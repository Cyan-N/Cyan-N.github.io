<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cecilia.cool</id>
    <title>慕青の迷途 • Posts by &#34;八股文&#34; tag</title>
    <link href="https://cecilia.cool" />
    <updated>2023-02-27T09:09:36.000Z</updated>
    <category term="tools" />
    <category term="云计算" />
    <category term="八股文" />
    <category term="shell" />
    <category term="轻小说" />
    <category term="网络协议与工具" />
    <category term="数据结构与算法" />
    <category term="Docker" />
    <category term="Spring全家桶" />
    <category term="uni-app" />
    <category term="日志框架" />
    <category term="Mybatis" />
    <category term="MySQL" />
    <category term="Redis" />
    <category term="JVM" />
    <category term="Java基础" />
    <category term="Concurrency" />
    <category term="Java8" />
    <category term="设计模式" />
    <category term="Web" />
    <category term="网络编程" />
    <entry>
        <id>https://cecilia.cool/2023/02/27/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
        <title>计算机网络</title>
        <link rel="alternate" href="https://cecilia.cool/2023/02/27/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
        <content type="html">&lt;p&gt;本文积累了作者在准备面试时学习的&lt;strong&gt;计算机网络&lt;/strong&gt;的知识与问题，作为科班出身，408 这些科目的重要性不必多说，能直接检验出你作为科班选手的水准。&lt;/p&gt;
&lt;p&gt;本 tag 的文章的问题都是本人先学习后，凭记忆写下的，相当于二次复习（复盘）了，这样有助于加深印象。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1. 键入网址后依次发生了什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考链接：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvSTZCTHdiSXBmR0VKbnhqRGNQWGMxQQ==&#34;&gt;https://mp.weixin.qq.com/s/I6BLwbIpfGEJnxjDcPXc1A&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器解析 URL 生成 Http 请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;发送 Http 请求前，会将域名解析为 IP 地址&lt;/strong&gt;，会先查询浏览器缓存、系统缓存、本机 &lt;code&gt;hosts&lt;/code&gt;  文件，如果没有，就会发送请求到本地域名服务器，通过本地域名服务器分别访问根域名服务器、顶级域名服务器、权威域名服务器，最终拿到域名映射的 IP 地址，并且缓存起来。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;建立 TCP 连接，三次握手&lt;/strong&gt;。三次握手是为了双方确定对方具有发送和接收数据的能力，所以两次握手不行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;增加 TCP 头部&lt;/strong&gt;。如果 Http 数据太长，超过了 MSS（网络层数据大小），就需要将其切分再每个加上 TCP 头部。TCP 头部包含了源端口，目的端口，校验和，序号等信息，最后交给 IP 模块处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加上 IP 头部&lt;/strong&gt;。IP 头部包含了源地址和目的地址，如果主机有多个网卡，会根据路由表规则来选择网卡，其实就是目的地址与网卡的掩码做&lt;strong&gt;与运算&lt;/strong&gt;从而来选择，如果都不匹配，就会走默认网卡 0.0.0.0。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加上 MAC 头部&lt;/strong&gt;。通过 ARP 协议来获取目的地址的 MAC 地址，如果 ARP 缓存有，就直接用，如果没有，就在以太网中广播目的地址从而得到响应拿到对应的 MAC 地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将给网卡，将包转为电信号，通过网线发送出去&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;交换机拿到包，通过 MAC 表将数据从对应端口发送出去&lt;/strong&gt;，如果表中没有对应映射，就对局域网所有主机发送。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;路由器拿到包并根据 IP 地址进行转发&lt;/strong&gt;。MAC 头部作用就是将包送到路由器，然后 MAC 头部就会被丢弃。路由器根据路由表决定下一跳（下一跳的 IP）。通过 ARP 协议拿到下一跳的 MAC 地址，重新发送。整体传输过程只有 MAC 地址在不断变化，因为包需要不断在以太网中传输。&lt;/li&gt;
&lt;li&gt;服务器收到请求，回复 ACK 和 Http 响应。浏览器得到响应，再请求 html 中的 js，css 资源。浏览器再解析渲染，呈现网页。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;2. 谈谈 http 协议&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考链接：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvQUsxUGI5cngwcTVIZjhkcTZITk9odw==&#34;&gt;https://mp.weixin.qq.com/s/AK1Pb9rx0q5Hf8dq6HNOhw&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;http 协议是超文本传输协议，一开始用于传输 html、css、js 等资源文件，后来也可以传输图片、视频、音频等。http1.0 是无状态的，每个 http 请求都必须重新建立 TCP 连接，这导致开销较大。http1.1 通过 &lt;code&gt;Cookie&lt;/code&gt;  来管理状态，同时实现了持久化连接。&lt;/p&gt;
&lt;p&gt;http 请求由：请求行、消息头、数据组成。请求行包括请求方法、&lt;strong&gt;URI&lt;/strong&gt;、协议版本。&lt;/p&gt;
&lt;p&gt;请求方法包括 GET（表单）、POST（实体）、DELETE（删除文件）、PUT（文件）、TRACE 等组成。&lt;/p&gt;
&lt;p&gt;状态码含义分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1xx：表示请求正在处理&lt;/li&gt;
&lt;li&gt;2xx：表示请求成功处理&lt;/li&gt;
&lt;li&gt;3xx：表示重定向&lt;/li&gt;
&lt;li&gt;4xx：表示客户端错误，请求不合法&lt;/li&gt;
&lt;li&gt;5xx：表示服务器错误，不能处理合法请求&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;3. 谈谈 https 协议&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考链接：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvMjFKYVh3ZGZTakl0ajVTZ093aGFwZw==&#34;&gt;https://mp.weixin.qq.com/s/21JaXwdfSjItj5SgOwhapg&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;数据传输使用的仍然是 http 协议，只不过使用了 SSL 对数据进行了加密，保证了数据传输的安全。&lt;/p&gt;
&lt;p&gt;其过程为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端发送 https 请求，服务端响应&lt;strong&gt; CA 证书和公钥&lt;/strong&gt;。（需要注意，是&lt;strong&gt;证书里面附带了公钥&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;客户端校验 CA 证书合法性，生成随机密钥 key，并使用&lt;strong&gt;公钥&lt;/strong&gt;对 key 加密，再发送给服务端。&lt;/li&gt;
&lt;li&gt;服务端收到后，使用私钥对可 key 解密，拿到真正的 key，双方之后的数据传输就用该 key 进行&lt;strong&gt;对称加密传输&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述过程，如果没有 CA 证书，那么中间人攻击可以这样：在第一步将公钥换成自己的公钥 1，这样在第二步对客户端产生的 key 使用自己的私钥 1 解密从而拿到 key。最后再将 key 使用最开始服务端发送的公钥进行加密发送给服务端，这样 MITM（中间人攻击）照样可以完成。&lt;/p&gt;
&lt;p&gt;所以需要第三方的公信认证，CA 机构有一对公钥 / 私钥，公钥是对外界公开的，而私钥必须严格保密。当服务端将&lt;strong&gt; CA 证书 + 服务端公钥&lt;/strong&gt;发送给客户端时， 会先将证书的数据（包括服务端公钥）进行哈希，得到哈希值&lt;strong&gt; H&lt;/strong&gt;，再用私钥将 H 加密，最后客户端（浏览器）拿到证书后，会使用系统 / 浏览器内置的 CA 公钥对 H 进行解密得到 H，再自己通过证书指定的哈希算法对数据进行哈希得到&lt;strong&gt; H&#39;&lt;/strong&gt;，比较&lt;strong&gt; H==H&#39;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;私钥和公钥可以互相加密解密，非不是私钥只能解密。上述过程，假设有中间人换了证书中的服务端公钥，也会因为不知道私钥而无法加密哈希值导致客户端会检测出来。所以 CA 机构应该严格保密私钥，如果泄露，就会失去公信力。&lt;/p&gt;
&lt;p&gt;如果整个 https 通信全部用非对称加密确实可以，双方各拿一对公钥 / 私钥，然后交换公钥进行通信。至于为什么本质还是要使用对称加密，是因为非对称加密太耗时间了，仅用于传输 key 即可。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;4. 用过 ping 吗，说说原理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考链接：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvM0tGMEl4THVtOEVPdGNGMFpOSWlQQQ==&#34;&gt;https://mp.weixin.qq.com/s/3KF0IxLum8EOtcF0ZNIiPA&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ping&lt;/code&gt;  实现原理依托于 &lt;code&gt;ICMP&lt;/code&gt;  协议。该协议是互联网控制报文协议，用于报告网络错误、传送报文运输情况等。 &lt;code&gt;ICMP&lt;/code&gt;  报文被封装到 &lt;code&gt;IP&lt;/code&gt;  数据包里面。ping 使用的两种 &lt;code&gt;ICMP&lt;/code&gt;  数据包是&lt;strong&gt;回送请求&lt;/strong&gt;和&lt;strong&gt;回送响应&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;假设主机 A 对主机 B 进行了 ping 操作，那么主机 A 会封装 ** &lt;code&gt;ICMP&lt;/code&gt;  回送请求 **，此时会记录请求产生的时间，并将其封装到 IP 数据包中，再加上 MAC 头部，最后发送出去。没有缓存目的 MAC 地址，先通过 ARP 协议获取。&lt;/p&gt;
&lt;p&gt;主机 B 收到报文后，逐步拆除 MAC 和 IP 头部，经过地址检验后，将有用的信息提取交给 ICMP 协议，再发送 ** &lt;code&gt;ICMP&lt;/code&gt;  回送响应 **。主机 A 收到回送响应后，用当前时间减去 &lt;code&gt;ICMP&lt;/code&gt;  数据包发送时间，就可以得到 &lt;code&gt;RTT&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;同时， &lt;code&gt;ICMP&lt;/code&gt;  还维护了一个 &lt;code&gt;TTL&lt;/code&gt; ，每次数据包经过一个路由器，就会 - 1，直到为 0 被丢弃，TTL 就可以检测出两个主机之间经过多少跳。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tracert&lt;/code&gt;  也是借助 &lt;code&gt;ICMP&lt;/code&gt;  协议实现的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;5. 聊聊 TCP 三次握手和四次挥手&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考链接：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvclgzQV9GQTE5bjRwSTlIaWNJRXNYZw==&#34;&gt;https://mp.weixin.qq.com/s/rX3A_FA19n4pI9HicIEsXg&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;TCP&lt;strong&gt; 三次握手&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;确认双方都有发送和接收数据的能力。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;防止旧连接覆盖新连接。客户端知道自己此时应该建立哪个连接，但是网络传输过程复杂，很可能旧的连接 SYN 比新的 SYN 后到，到底建立哪个连接服务端是不知道的，所以必须有第三次握手，让客户端确认到底建立哪个连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;防止浪费资源。两次握手中，服务端不知道自己的 &lt;code&gt;ACK+SYN&lt;/code&gt;  是否被客户端收到，这会导致重复发送 &lt;code&gt;SYN+ACK&lt;/code&gt; ，建立很多个无用的连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同步初始化序列号。同步序列号能够防止接收端接收的数据乱序。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总的来说，第三次握手是必要的，&lt;strong&gt;必须由客户端确认建立连接的各种状态信息的正确性&lt;/strong&gt;。值得一提的是，第三次握手，发送方可以顺带发送数据。&lt;/p&gt;
&lt;p&gt;TCP&lt;strong&gt; 四次挥手&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;重点：主动放弃连接的一方会进入 &lt;code&gt;Time_Wait&lt;/code&gt;  状态，在 Linux 中，会等待 2MSL（60 秒）。&lt;/p&gt;
&lt;p&gt;四次挥手的过程为（假设客户端主动断开连接）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端发送 &lt;code&gt;Fin&lt;/code&gt;  表示自己断开连接，不再发送数据，但是可以接收数据，进入 &lt;code&gt;FIN_WAIT_1&lt;/code&gt;  状态。&lt;/li&gt;
&lt;li&gt;服务端收到 &lt;code&gt;Fin&lt;/code&gt; ，发送 &lt;code&gt;ACK&lt;/code&gt; ，表示自己收到断开请求，需要处理剩下的数据，进入 &lt;code&gt;CLOSED_WAIT&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;服务端处理完数据，发送 &lt;code&gt;Fin&lt;/code&gt; ，进入 &lt;code&gt;LAST_ACK&lt;/code&gt;  状态。&lt;/li&gt;
&lt;li&gt;客户端收到 &lt;code&gt;Fin&lt;/code&gt; ，发送 &lt;code&gt;ACK&lt;/code&gt; ，进入 &lt;code&gt;TIME_WAIT&lt;/code&gt;  状态，等待 &lt;code&gt;2MSL&lt;/code&gt; ，最后进入 &lt;code&gt;CLOSED&lt;/code&gt;  状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;正是因为服务端需要处理剩下数据，所以是四次挥手，同样，如果省去最后一次挥手，那么服务端就会一直处于 &lt;code&gt;LAST_ACK&lt;/code&gt;  状态，当客户端想建立新的连接，发送 &lt;code&gt;SYN&lt;/code&gt; ，服务端就会回复 &lt;code&gt;RST&lt;/code&gt; ，建立连接的过程会终止。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;6. 为什么四次挥手中要有 &lt;code&gt;TIME_WAIT&lt;/code&gt;  状态以及为什么要等 2MSL？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考链接：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvclgzQV9GQTE5bjRwSTlIaWNJRXNYZw==&#34;&gt;https://mp.weixin.qq.com/s/rX3A_FA19n4pI9HicIEsXg&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们这里默认主动断开连接的是客户端。首先，主动断开连接的那一方才会进入 &lt;code&gt;TIME_WAIT&lt;/code&gt; ，这个时间是 2MSL，在 Linux 中为 60s，而且这个时间是固定的，也就是在内核代码中写死了，无法修改。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TIME_WAIT&lt;/code&gt;  的出现能够保证被动断开连接方（服务端）可以正常的关闭，从 &lt;code&gt;LAST_ACK&lt;/code&gt;  进入 &lt;code&gt;CLOSED&lt;/code&gt;  状态。&lt;/p&gt;
&lt;p&gt;MSL 是数据包在网络传输中存活的最长时间， &lt;code&gt;TIME_WAIT&lt;/code&gt;  设置为 2MSL，比较合理的解释为：如果服务端没有没有 ACK，超时重传 &lt;code&gt;FIN&lt;/code&gt;  后再接收 &lt;code&gt;ACK&lt;/code&gt;  的时间在 2MSL 之内。&lt;strong&gt;当客户端重新接收到 &lt;code&gt;FIN&lt;/code&gt;  时，会重置 2MSL 时间&lt;/strong&gt;。同时网络连接中的旧数据包在 2MSL 中能够被清理干净，如果客户端当前端口重新建立连接，不会有旧的数据传到当前端口，造成数据混乱。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TIME_WAIT&lt;/code&gt;  出现的原因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保证服务端正常关闭&lt;/li&gt;
&lt;li&gt;防止旧的四元组数据包影响下一次连接传输。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正因为主动断开会进入 &lt;code&gt;TIME_WAIT&lt;/code&gt; ，此时既会白白占用端口，又会无法传输数据，经历时间还非常长，对于服务端来说是很大的负担，所以这个烂摊子尽量交给对方，尽量让对方断开连接。&lt;/p&gt;
&lt;p&gt;解决 &lt;code&gt;TIME_WAIT&lt;/code&gt;  方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;tcp_rw_reuse&lt;/code&gt; + &lt;code&gt;tcp_timestamp&lt;/code&gt; ：这样可以使得处于 &lt;code&gt;TIME_WAIT&lt;/code&gt;  套接字复用，因为开启了时间戳，新的连接不会接收时间戳过期的数据。&lt;/li&gt;
&lt;li&gt;其他方法不推荐使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;7. 知道 SYN 攻击吗，说说你知道的防御手段&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考链接：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9pbmZvLnN1cHBvcnQuaHVhd2VpLmNvbS9pbmZvLWZpbmRlci9lbmN5Y2xvcGVkaWEvemgvU1lOK0Zsb29kLmh0bWw=&#34;&gt;https://info.support.huawei.com/info-finder/encyclopedia/zh/SYN+Flood.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;SYN 攻击是 DDos 攻击的一种，通过程序不断发送 SYN 迅速占满服务端的 SYN 队列，使其崩溃的攻击手段。&lt;/p&gt;
&lt;p&gt;防御手段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首包丢弃：大多数 SYN 攻击都是变源的，这使得在 SYN Flood 攻击中，每个 SYN 都是首包，Anti-DDos 系统可以丢弃收到的 SYN 首包，如果对方客户端是正常的，那么基于 TCP 超时机制，一定会重传，此时 SYN 就不是首包了，可以对其进行源认证。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;源认证：Anti-DDos 系统部署在网络入口，先代替服务端发送 SYN+ACK，如果收到了客户端的 ACK，就将其 IP 加入白名单，之后一段时间都不会代替服务端对该 IP 的 SYN 进行拦截。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;源认证必须配合首包丢弃使用，不然性能瓶颈也只是从服务器转移到了 Anti-DDos 系统中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;8.TCP 的半连接队列和全连接队列了解吗？如果队列满了怎么办？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考链接：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvdFJYbHExaEVycUtRTE1NTGN4b1h2Zw==&#34;&gt;https://mp.weixin.qq.com/s/tRXlq1hErqKQLMMLcxoXvg&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;半连接队列是指 SYN 队列，服务端收到 SYN 请求，就会将其加入到 SYN 队列；全连接队列是指 Accept 队列，当服务端收到客户端的 &lt;code&gt;ACK&lt;/code&gt;  就会将 SYN 队列对应节点放到 Accept 队列中。当队列满了，Linux 默认的操作是拒绝再接收 ACK。因为队列装不下了，但是有个问题就是，客户端发送了 ACK 就会进入 &lt;code&gt;ESTABLISHED&lt;/code&gt;  状态，但是实际上服务端却没有接收。&lt;/p&gt;
&lt;p&gt;Linux 中变量 &lt;code&gt;tcp_abort_on_overflow&lt;/code&gt;  为 0，就是丢掉客户端发送的数据，为 1 就会发送一个 &lt;code&gt;reset&lt;/code&gt;  包给客户端。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以全连接队列满了，一般解决方法就是扩大队列长度，Accept 队列长度由两个变量决定，结果式为 &lt;code&gt;len = min(backlog, somaxconn)&lt;/code&gt; 。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;半连接队列长度 &lt;code&gt;max_qlen_log&lt;/code&gt;  取决于全连接队列长度 &lt;code&gt;len&lt;/code&gt; 、变量 &lt;code&gt;max_syn_backlog&lt;/code&gt; ： &lt;code&gt;max_qlen_log = 2 * min(len, max_syn_backlog)&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;半连接队列一般不会满，当队列中剩余长度达到某个特定值时（和 &lt;code&gt;max_syn_backlog&lt;/code&gt;  有关，但是不同 Linux 版本计算方法可能不同），就不会再接收 &lt;code&gt;SYN&lt;/code&gt;  了。其实当全连接队列满了，不论半连接队列如何，都不会再接收 &lt;code&gt;SYN&lt;/code&gt;  了。&lt;/p&gt;
&lt;p&gt;半连接队列满了（假设遇到了 &lt;code&gt;SYN&lt;/code&gt;  攻击），策略有三个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增大半连接队列长度，也就是增大那三个参数。&lt;/li&gt;
&lt;li&gt;打开 &lt;code&gt;syncookies&lt;/code&gt; ，将该变量设置为 1 即可（0-- 关闭，1-- 队列满了打开 &lt;code&gt;syncookies&lt;/code&gt; ，2-- 直接打开 &lt;code&gt;syncookies&lt;/code&gt; ）。开启该功能后，不会再丢弃 &lt;code&gt;SYN&lt;/code&gt;  包，而是服务器根据当前状态计算出一个值，放在 &lt;code&gt;SYN+ACK&lt;/code&gt;  中发出，当客户端返回 &lt;code&gt;ACK&lt;/code&gt;  报文时，取出该值校验合法性，建立连接。&lt;/li&gt;
&lt;li&gt;减少 &lt;code&gt;SYN+ACK&lt;/code&gt;  重发次数，使得处于 &lt;code&gt;SYN_REVC&lt;/code&gt;  状态的连接尽快断开。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;9. 谈谈 TCP 相关的参数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考链接：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MveXRWN1JaU3lGWHl2UFdfbEtodjhodw==&#34;&gt;https://mp.weixin.qq.com/s/ytV7RZSyFXyvPW_lKhv8hw&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里讲的 TCP 参数与 TCP 三次握手和四次挥手优化有关。&lt;/p&gt;
&lt;p&gt;三次握手优化角度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端（发送方）：客户端行为有发送 &lt;code&gt;SYN&lt;/code&gt;  和 &lt;code&gt;ACK&lt;/code&gt; ，以及重发 &lt;code&gt;SYN&lt;/code&gt;  和 &lt;code&gt;ACK&lt;/code&gt; 。
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tcp_syn_retries&lt;/code&gt;  参数：控制重传 &lt;code&gt;SYN&lt;/code&gt;  次数，每次超时时间为上次 2 倍，初始为 1s。&lt;strong&gt;超过次数就会断开连接&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务端（接收方）：服务端行为较复杂，涉及到半连接队列和全连接队列的大小以及拒绝策略
&lt;ul&gt;
&lt;li&gt;重发 &lt;code&gt;FIN+ACK&lt;/code&gt;  次数：由 &lt;code&gt;tcp_synack_retires&lt;/code&gt;  决定&lt;/li&gt;
&lt;li&gt;半连接队列：大小由 &lt;code&gt;tcp_max_syn&lt;/code&gt; 、 &lt;code&gt;backlog&lt;/code&gt; 、 &lt;code&gt;somaxconn&lt;/code&gt;  共同决定。可以通过增大这三个参数来增大半连接队列。同时 &lt;code&gt;syncookies&lt;/code&gt;  参数控制当半连接队列满了时，生成状态值校验来避免放到半连接队列中。&lt;/li&gt;
&lt;li&gt;全连接队列：大小由 &lt;code&gt;backlog&lt;/code&gt;  和 &lt;code&gt;somaxconn&lt;/code&gt;  共同决定。拒绝策略由 &lt;code&gt;tcp_abort_on_overflow&lt;/code&gt;  决定，0 表示丢弃 &lt;code&gt;ACK&lt;/code&gt; ，不让其进入全连接队列，一般用这个，还可以解决短暂的突发网络繁忙。1 表示发送 &lt;code&gt;RST&lt;/code&gt;  包使其断开连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;绕过三次握手：Linux 内核 3.1 版本后，出现了 &lt;code&gt;Fast Open&lt;/code&gt;  机制，通过 &lt;code&gt;Cookie&lt;/code&gt;  来绕过后面的三次握手。第一次正常三次握手，但是服务端可以在第二次握手时创建 &lt;code&gt;Cookie&lt;/code&gt;  并发送给客户端。之后就可以重用该 &lt;code&gt;TCP&lt;/code&gt;  连接，而不需要重复建立 TCP 连接。因为后续数据发送可以携带 &lt;code&gt;Cookie&lt;/code&gt; ，服务端只需要验证 &lt;code&gt;Cookie&lt;/code&gt;  即可。这种的缺点就是，如果重发，还需要重发 &lt;code&gt;Cookie&lt;/code&gt; 。该机制使用 &lt;code&gt;tcp_fastopn&lt;/code&gt; ：
&lt;ul&gt;
&lt;li&gt;0 ——  &lt;code&gt;close&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;1 ——  &lt;code&gt;Client&lt;/code&gt;  打开&lt;/li&gt;
&lt;li&gt;2 ——  &lt;code&gt;Server&lt;/code&gt;  打开&lt;/li&gt;
&lt;li&gt;3 —— 双方都打开&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;四次挥手优化角度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主动断开方：会进入 &lt;code&gt;TIME_WAIT&lt;/code&gt;  状态，接收发送 &lt;code&gt;FIN&lt;/code&gt;  和 &lt;code&gt;ACK&lt;/code&gt; 。
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tcp_max_orphan&lt;/code&gt;  参数：调用 &lt;code&gt;close&lt;/code&gt;  函数后，连接就变成了&lt;strong&gt;孤儿连接&lt;/strong&gt;，该参数限制了最大孤儿连接数量，超过直接发送 &lt;code&gt;RST&lt;/code&gt;  包断开连接。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FIN_WAIT1&lt;/code&gt;  状态优化： &lt;code&gt;tcp_orphan_retries&lt;/code&gt;  参数 —— 表示处于 &lt;code&gt;FIN_WAIT1&lt;/code&gt;  状态的 &lt;code&gt;FIN&lt;/code&gt;  重传次数，超过直接关掉连接。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FIN_WAIT2&lt;/code&gt;  状态优化： &lt;code&gt;tcp_fin_timeout&lt;/code&gt;  参数：表示孤儿连接等待 &lt;code&gt;FIN&lt;/code&gt;  的最长时间，默认 60s。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TIME_WAIT&lt;/code&gt;  状态优化：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tcp_max_tw_buckets&lt;/code&gt;  参数：如果处于 &lt;code&gt;TIME_WAIT&lt;/code&gt;  连接超过该参数，之后的连接不再进入该状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tcp_tw_reuse&lt;/code&gt;  参数：开启后可以复用处于 &lt;code&gt;TIME_WAIT&lt;/code&gt;  状态的连接，需要配合时间戳使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;被动断开方：
&lt;ul&gt;
&lt;li&gt;还是借助 &lt;code&gt;tcp_orphan_retires&lt;/code&gt;  参数限定 &lt;code&gt;FIN&lt;/code&gt;  重传次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;小结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三次握手参数： &lt;code&gt;tcp_syn_retries&lt;/code&gt; 、 &lt;code&gt;somaxconn&lt;/code&gt; 、 &lt;code&gt;backlog&lt;/code&gt; 、 &lt;code&gt;tcp_max_syn&lt;/code&gt; 、 &lt;code&gt;syncookies&lt;/code&gt; 、 &lt;code&gt;tcp_abort_on_overflow&lt;/code&gt; 、 &lt;code&gt;tcp_fastopn&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;四次挥手参数： &lt;code&gt;tcp_max_orphan&lt;/code&gt; 、 &lt;code&gt;tcp_orphan_retries&lt;/code&gt; 、 &lt;code&gt;tcp_fin_timeout&lt;/code&gt; 、 &lt;code&gt;tcp_max_tw_buckets&lt;/code&gt; 、 &lt;code&gt;tcp_tw_reuse&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;10. 聊聊 TCP 的可靠传输机制，比如重传、拥塞、流量控制等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;重传机制&lt;/strong&gt;： 接收方回复 ACK 用于提醒发送方应该发那个数据包，当出现数据包丢失，接收方需要重传，分为超时重传和快速重传&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;超时重传：接收方拿不到 3 这个数据包，就不发 3 的 ACK，发送方等待 3 这个 ACK 超时，再重传，一种是只重传 3（节省带宽，慢），另一种是 3，4，5（快，浪费带宽）等都重传。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;快速重传：发送方连续三次接收到同一个 ACK，则重传对应的数据报。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实重传都面临一个选择：只重传这一个还是重传后边所有数据报。这就引出&lt;strong&gt; SACK&lt;/strong&gt; 机制，接收方回复 SACK，SACK 会汇报收到的数据碎片，这个协议需要两边都支持。但是 SACK 并不能替代 ACK，&lt;strong&gt;接收方有权把已经报给发送端 SACK 里的数据给丢了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SACK&lt;/strong&gt; 有一个严重的问题，Linux 代码中，使用一个 &lt;code&gt;sk_buff&lt;/code&gt;  的数据结构，简称 &lt;code&gt;SBK&lt;/code&gt; ，用于存储&lt;strong&gt;发送、接收&lt;/strong&gt;队列等，还有一个结构体为 &lt;code&gt;skb_cb&lt;/code&gt;  用于控制缓存，记录各种&lt;strong&gt; TCP packet&lt;/strong&gt; 的各种信息，如小报文的数量 &lt;code&gt;tcp_gso_segs&lt;/code&gt; ，无符号两字节，最多表示 64K，SKB 会将小报文段分片累积成大报文段再发送，但是内部最多维护 17 个分片队列，每个队列最大 32KB，如果有恶意攻击者将 &lt;code&gt;mss&lt;/code&gt;  设置为 8，则每个小报文段大小为 8B。&lt;strong&gt;SACK&lt;/strong&gt; 机制会将许多 &lt;code&gt;SKB&lt;/code&gt;  合并填满一个 &lt;code&gt;SKB&lt;/code&gt; ，那么就可能出现： &lt;code&gt;17 * 32 * 1024 / 8 &amp;gt; 64K&lt;/code&gt;  导致 &lt;code&gt;tcp_gso_segs&lt;/code&gt;  溢出，进入 &lt;code&gt;BUG_ON&lt;/code&gt;  函数使得服务器拒绝远程连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;滑动窗口&lt;/strong&gt;：发送方和接收方都有窗口，接收方的滑动窗口可以使发送方根据接收方的接收能力来发送数据。确认机制为&lt;strong&gt;累计确认 / 累计应答&lt;/strong&gt;，假设收到序列号为 100 的 ACK，说明 100 以前的数据都收到了。&lt;/p&gt;
&lt;p&gt;如果接收方的窗口为 0 了，也会将发送方的窗口设为 0，此时不再发送数据，直到接收方窗口恢复，此时发送一个通知消息给发送方，并等待数据。如果这个通知消息因为网络拥塞丢失了，就会导致：接收方一直等待数据，发送方一直等待通知的死锁状况。所以一旦发送方窗口被置为 0，就会每隔一段时间发送探测报文，询问接收方窗口大小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Silly Window Syndrome&lt;/strong&gt; 是一种现象，会对小的 window size 做出响应，为了避免对小的 window size 做出响应，直到有足够大的 window size 再响应，如果窗口太小，发送出去的数据甚至没有 &lt;code&gt;MSS&lt;/code&gt;  高，就会先累积再发送。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;拥塞处理&lt;/strong&gt;：名词： &lt;code&gt;ssthresh&lt;/code&gt;  是慢启动阈值， &lt;code&gt;cwnd&lt;/code&gt;  为拥塞窗口大小。&lt;/p&gt;
&lt;p&gt;三个状态，分别是慢启动，拥塞避免和快速恢复。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;慢启动&lt;/strong&gt;： &lt;code&gt;cwnd&lt;/code&gt; （拥塞窗口）一开始为 &lt;code&gt;1MSS&lt;/code&gt; ，每收到 1 个 &lt;code&gt;ACK&lt;/code&gt;  就 &lt;code&gt;+1&lt;/code&gt; ，如果&lt;strong&gt;超时&lt;/strong&gt;， &lt;code&gt;ssthresh=cwnd/2&lt;/code&gt; ，并且 &lt;code&gt;cwnd=1&lt;/code&gt;  重新慢启动。如果之后 &lt;code&gt;cwnd &amp;gt;=  ssthresh&lt;/code&gt;  就进入&lt;strong&gt;拥塞避免&lt;/strong&gt;。如果触发快速重传，就进入&lt;strong&gt;快速恢复&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拥塞避免&lt;/strong&gt;：每一个 &lt;code&gt;RTT&lt;/code&gt;  就 &lt;code&gt;cwnd++&lt;/code&gt; ，如果超时，设置 &lt;code&gt;ssthresh=cwnd/2, cwnd = 1&lt;/code&gt; ，进入慢启动。如果触发快速重传，进入&lt;strong&gt;快速恢复&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;快速恢复&lt;/strong&gt;：如果超时，同样操作，进入慢启动；每次收到一个冗余 &lt;code&gt;ACK&lt;/code&gt; ， &lt;code&gt;cwnd++&lt;/code&gt; ，如果收到新 &lt;code&gt;ACK&lt;/code&gt; ，进入&lt;strong&gt;拥塞避免&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进入&lt;strong&gt;快速恢复&lt;/strong&gt;之前，设置参数为 &lt;code&gt;ssthresh=cwnd/2, cwnd = ssthresh + 3&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里的 &lt;code&gt;RTT&lt;/code&gt;  是指一个窗口的数据全部发送出去，又全部收到 &lt;code&gt;ACK&lt;/code&gt;  的时间，而不是某一个报文的往返时间&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;11.DNS 劫持和 DNS 污染&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;DNS 劫持&lt;/strong&gt;：劫持了 DNS 服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原 IP 地址转入到修改后的指定 IP。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DNS 污染&lt;/strong&gt;：通过对 UDP 端口 53 上的 DNS 查询进行入侵检测，一经发现与关键词相匹配的请求则立即伪装成目标域名的解析服务器（NS，Name Server）给查询者返回虚假结果。很难靠个人设置解决，使用 VPN 是一个方法&lt;/p&gt;
</content>
        <category term="八股文" />
        <updated>2023-02-27T09:09:36.000Z</updated>
    </entry>
</feed>
