<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.7.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.7.0" type="image/png" sizes="32x32"><meta name="description" content="简介       BIO是阻塞的，如果没有多线程，BIO就需要一直占用CPU，而NIO则是非阻塞IO，NIO在获取连接或者请求时，即使没有取得连接和数据，也不会阻塞程序。NIO的服务器实现模式为一个线程可以处理多个请求。 I&#x2F;O 与 NIO 最重要的区别是数据打包和传输的方式，I&#x2F;O 以流的方式处理数据，而 NIO 以块的方式处理数据。 面向流的 I&#x2F;O 一">
<meta property="og:type" content="article">
<meta property="og:title" content="网络编程(3)--NIO基础详解">
<meta property="og:url" content="https://cecilia.cool/2022/09/01/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(3)-NIO%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="慕青的日记">
<meta property="og:description" content="简介       BIO是阻塞的，如果没有多线程，BIO就需要一直占用CPU，而NIO则是非阻塞IO，NIO在获取连接或者请求时，即使没有取得连接和数据，也不会阻塞程序。NIO的服务器实现模式为一个线程可以处理多个请求。 I&#x2F;O 与 NIO 最重要的区别是数据打包和传输的方式，I&#x2F;O 以流的方式处理数据，而 NIO 以块的方式处理数据。 面向流的 I&#x2F;O 一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/09/06/a30745dcd72b9009.jpg">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/09/06/2c96523c4e767ff8.jpg">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/09/01/77fb2a16735a25dc.jpg">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/09/01/6df58dfb355cd5fd.jpg">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/09/01/fc7668224747f135.jpg">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/09/01/e41dc8148e004937.jpg">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/09/01/34a021e1ad767087.jpg">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/09/01/c631fb000c1a9630.jpg">
<meta property="article:published_time" content="2022-09-01T03:13:56.000Z">
<meta property="article:modified_time" content="2022-09-06T17:05:00.844Z">
<meta property="article:author" content="Cyan">
<meta property="article:tag" content="网络编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s3.bmp.ovh/imgs/2022/09/06/a30745dcd72b9009.jpg"><title>网络编程(3)--NIO基础详解 | 慕青的日记</title><link ref="canonical" href="https://cecilia.cool/2022/09/01/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(3)-NIO%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.7.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">慕青的日记</div><div class="header-banner-info__subtitle">Cyan</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">网络编程(3)--NIO基础详解</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-01</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-07</span></span></div></header><div class="post-body">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h1>
      <p><code>BIO</code>是阻塞的，如果没有多线程，<code>BIO</code>就需要一直占用<code>CPU</code>，而<code>NIO</code>则是非阻塞<code>IO</code>，<code>NIO</code>在获取连接或者请求时，即使没有取得连接和数据，也不会阻塞程序。NIO的服务器实现模式为一个线程可以处理多个请求。</p>
<p><code>I/O</code> 与 <code>NIO</code> 最重要的区别是数据打包和传输的方式，<code>I/O</code> 以流的方式处理数据，而 <code>NIO </code>以块的方式处理数据。</p>
<p>面向流的 <code>I/O</code> 一次处理一个字节数据: 一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 <code>I/O</code> 通常相当慢。</p>

        <h1 id="相关知识"   >
          <a href="#相关知识" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h1>
      
        <h2 id="通道"   >
          <a href="#通道" class="heading-link"><i class="fas fa-link"></i></a><a href="#通道" class="headerlink" title="通道"></a>通道</h2>
      <p>通道（<code>Channel</code>接口）是对流的模拟，既可以用来进行读操作，又可以用来进行写操作。</p>
<p>通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 <code>InputStream</code> 或者 <code>OutputStream</code> 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。</p>
<p><code>NIO</code>中常用的<code>Channel</code>有：</p>
<ul>
<li><p>FileChannel: 从文件中读写数据；</p>
</li>
<li><p>DatagramChannel: 通过 UDP 读写网络中数据；</p>
</li>
<li><p>SocketChannel: 通过 TCP 读写网络中数据；</p>
</li>
<li><p>ServerSocketChannel: 可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</p>
</li>
</ul>
<p>我们先看一下<code>Channel</code>内部代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Channel</span> <span class="keyword">extends</span> <span class="title class_">Closeable</span> &#123;</span><br><span class="line">    <span class="comment">//通道是否处于开启状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOpen</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为通道开启也需要关闭，所以实现了Closeable接口，所以这个方法懂的都懂</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><img src="https://s3.bmp.ovh/imgs/2022/09/06/a30745dcd72b9009.jpg" alt="通道接口结构"></p>
<p>最后整合为<code>ByteChannel</code>接口</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ByteChannel</span> <span class="keyword">extends</span> <span class="title class_">ReadableByteChannel</span>, WritableByteChannel&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>我们对比一下不使用通道和使用通道</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用通道</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// 将System.in作为输入流</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> System.in;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = in.read(data)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;data = &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(data,<span class="number">0</span>,1en));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用通道</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    <span class="type">ReadableByteChannel</span> <span class="variable">readChannel</span> <span class="operator">=</span> Channels.newChannel(Syetem.in);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 将通道中的数据写到缓冲区，缓冲区最多一次装10个</span></span><br><span class="line">        readChannel.read(buffer);</span><br><span class="line">        </span><br><span class="line">        buffer.flip();<span class="comment">// 翻转缓冲区</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(),<span class="number">0</span>,buffer.remaining()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="FileChannel"   >
          <a href="#FileChannel" class="heading-link"><i class="fas fa-link"></i></a><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h4>
      <p>通道一个重要的特点就是能够双向传输数据。但是<code>FileInputStream</code>得到的通道只能输入，<code>FileOutputStream</code>得到的通道只能输出。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>();</span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> in.getChannel();</span><br></pre></td></tr></table></div></figure>

<p>我们可以通过<code>RandomAccessFile</code>创建通道</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      通过RandomAccessFile进行创建，注意后面的mode有几种：</span></span><br><span class="line"><span class="comment">      r        以只读的方式使用</span></span><br><span class="line"><span class="comment">      rw   读操作和写操作都可以</span></span><br><span class="line"><span class="comment">      rws  每当进行写操作，同步的刷新到磁盘，刷新内容和元数据</span></span><br><span class="line"><span class="comment">      rwd  每当进行写操作，同步的刷新到磁盘，刷新内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//这里设定为支持读写，这样创建的通道才能具有这些功能</span></span><br><span class="line">    <span class="keyword">try</span>(<span class="type">RandomAccessFile</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);  </span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> f.getChannel())&#123;   <span class="comment">//通过RandomAccessFile创建一个通道</span></span><br><span class="line">        channel.write(ByteBuffer.wrap(<span class="string">&quot;伞兵二号马飞飞准备就绪！&quot;</span>.getBytes()));</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//注意读取也是从现在的位置开始</span></span><br><span class="line">        System.out.println(<span class="string">&quot;写操作完成之后文件访问位置：&quot;</span>+channel.position());  </span><br><span class="line">        channel.position(<span class="number">0</span>);  <span class="comment">//需要将位置变回到最前面，这样下面才能从文件的最开始进行读取</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">        channel.read(buffer);</span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>除了基本的读写操作，也可以对文件进行截断：<code>channel.truncate(20)</code>。就只会保留前20个字节</p>
</blockquote>
<p>示例：文件拷贝</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在缓冲区也有文件复制的案例，但是此处我们直接使用写好的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">       <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.txt&quot;</span>)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">inChannel</span> <span class="operator">=</span> in.getChannel();</span><br><span class="line">        inChannel.transfer(<span class="number">0</span>,inChannel.size(),out.getChannel());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 也可以反向操作</span></span><br><span class="line">        out.getChannel().transfer(inChannel,<span class="number">0</span>,inChannel.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="文件锁FileLock"   >
          <a href="#文件锁FileLock" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件锁FileLock" class="headerlink" title="文件锁FileLock"></a>文件锁FileLock</h4>
      <p>我们可以创建一个跨进程文件锁来防止多个进程之间的文件争抢操作（注意这里是进程，不是线程）FileLock是文件锁，它能保证同一时间只有一个进程（程序）能够修改它，或者都只可以读，这样就解决了多进程间的同步文件，保证了安全性。但是需要注意的是，它进程级别的，不是线程级别的，他可以解决多个进程并发访问同一个文件的问题，但是它不适用于控制同一个进程中多个线程对一个文件的访问。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">Channel</span> <span class="operator">=</span> f.getChannel();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上锁：对0~6个字节上锁，false表示独占锁，其他进程连读都不可以</span></span><br><span class="line">    <span class="type">FileLock</span> <span class="variable">lock</span> <span class="operator">=</span> channel.getLock(<span class="number">0</span>,<span class="number">6</span>,<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以：channel.getLock(0,channel.size(),false);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    lock.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>为了快速讲完这部分内容，笔者简化了一些细节</p>
<blockquote>
<p>独占锁如果出现了交叉部分，也会被阻塞（人之常情嘛）。共享锁就是将参数设置为true。还有一个<code>trylock</code>的方法，它会尝试去获得锁，如果失败就返回<code>null</code>（这让我想起<code>AQS</code>里面的<code>tryAccquire</code>方法）。</p>
</blockquote>

        <h2 id="缓冲区"   >
          <a href="#缓冲区" class="heading-link"><i class="fas fa-link"></i></a><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2>
      <p>发送给通道的所有数据都必须首先放到缓冲区中，从通道读取的任何数据都要先读到缓冲区。不会直接对通道进行读写数据，而是要先经过缓冲区。</p>
<p>缓冲区实质上是一个<strong>数组</strong>，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读&#x2F;写进程。</p>
<p>缓冲区状态变量：</p>
<ul>
<li><code>capacity</code>: 最大容量；</li>
<li><code>position</code>: 当前已经读写的字节数；</li>
<li><code>limit</code>: 还可以读写的字节数。</li>
</ul>
<p>常见的缓冲区有（都是<code>Buffer</code>抽象类的子类）：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
</ul>

        <h3 id="相关方法"   >
          <a href="#相关方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h3>
      
        <h4 id="获取对象"   >
          <a href="#获取对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#获取对象" class="headerlink" title="获取对象"></a>获取对象</h4>
      <p>这里以<code>IntBuffer</code>为例，我们想要获得一个<code>IntBuffer</code>的实例化对象，需要调用<code>allocate</code>方法或者<code>wrap</code>方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.申请容量为10的int缓冲区</span></span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">buffer1</span> <span class="operator">=</span> IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.将现有数组直接转换为缓冲区</span></span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> IntBuffer,wrap(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 看一下内部两个方法的相关实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IntBuffer <span class="title function_">allocate</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeapIntBuffer</span>(capacity, capacity);   </span><br><span class="line">    <span class="comment">// 这里也能说明HeapIntBuffer是IntBuffer子类</span></span><br><span class="line">  	<span class="comment">//HeapIntBuffer是在堆内存中存放数据，本质上就数组，一会我们可以在深入看一下</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IntBuffer <span class="title function_">wrap</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> wrap(array, <span class="number">0</span>, array.length);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IntBuffer <span class="title function_">wrap</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> offset, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">//创建了一个新的HeapIntBuffer对象，并且给了初始数组以及截取的起始位置和长度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeapIntBuffer</span>(array, offset, length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException x) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这里涉及到一个新的类，我们先看一下总体的类结构</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/06/2c96523c4e767ff8.jpg" alt="类结构"></p>
<p>我们看一下两个类的构造方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IntBuffer构造方法</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span>[] hb;                  <span class="comment">// 只有在堆缓冲区实现时才会使用</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> offset;</span><br><span class="line"><span class="type">boolean</span> isReadOnly;                 <span class="comment">// 只有在堆缓冲区实现时才会使用</span></span><br><span class="line"></span><br><span class="line">IntBuffer(<span class="type">int</span> mark, <span class="type">int</span> pos, <span class="type">int</span> lim, <span class="type">int</span> cap, <span class="type">int</span>[] hb, <span class="type">int</span> offset)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">super</span>(mark, pos, lim, cap);  <span class="comment">//调用Buffer类的构造方法</span></span><br><span class="line">    <span class="built_in">this</span>.hb = hb;    <span class="comment">//hb就是真正我们要存放数据的数组，堆缓冲区底层其实就是这么一个数组</span></span><br><span class="line">    <span class="built_in">this</span>.offset = offset;   <span class="comment">//起始偏移位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HeapIntBuffer构造方法</span></span><br><span class="line">HeapIntBuffer(<span class="type">int</span>[] buf, <span class="type">int</span> off, <span class="type">int</span> len) &#123; </span><br><span class="line">    <span class="built_in">super</span>(-<span class="number">1</span>, off, off + len, buf.length, buf, <span class="number">0</span>);  </span><br><span class="line">  	<span class="comment">//mark是标记，off是当前起始下标位置，off+len是最大下标位置，</span></span><br><span class="line">    <span class="comment">//buf.length是底层维护的数组真正长度，buf就是数组，最后一个0是起始偏移位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="写操作"   >
          <a href="#写操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h4>
      <p><code>Buffer</code>中所有的<code>put</code>函数。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> IntBuffer <span class="title function_">put</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定位置插入数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> IntBuffer <span class="title function_">put</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> i)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接将src全部插入缓冲区，但是不能超过缓冲区大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> IntBuffer <span class="title function_">put</span><span class="params">(<span class="type">int</span>[] src)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接存放数组中的内容，同上，但是可以指定存放一段范围</span></span><br><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">put</span><span class="params">(<span class="type">int</span>[] src, <span class="type">int</span> offset, <span class="type">int</span> length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接存放另一个缓冲区中的内容</span></span><br><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">put</span><span class="params">(IntBuffer src)</span>; </span><br></pre></td></tr></table></div></figure>

<p>我们看做简单的<code>put</code>源码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">put</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    hb[ix(nextPutIndex())] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将i的值加上我们之前设定的offset偏移量值，但是默认是0（非0的情况后面会介绍）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">ix</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i + offset;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nextPutIndex</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> position;    <span class="comment">//获取Buffer类中的position位置（一开始也是0）</span></span><br><span class="line">    <span class="keyword">if</span> (p &gt;= limit)    <span class="comment">//位置肯定不能超过底层数组最大长度，否则越界</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BufferOverflowException</span>();</span><br><span class="line">    position = p + <span class="number">1</span>;   <span class="comment">//获取之后会使得Buffer类中的position+1</span></span><br><span class="line">    <span class="keyword">return</span> p;   <span class="comment">//返回当前的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>如果将<code>offset</code>看为0，那么整个函数就是在数组<code>hb</code>的<code>position</code>位置加入元素</p>
<p>示例：快速复制文件</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fastCopy</span><span class="params">(String src, String dist)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获得源文件的输入字节流 */</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取输入字节流的文件通道 */</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fcin</span> <span class="operator">=</span> fin.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取目标文件的输出字节流 */</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dist);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取输出字节流的通道 */</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fcout</span> <span class="operator">=</span> fout.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为缓冲区分配 1024 个字节 */</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从输入通道中读取数据到缓冲区中 */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> fcin.read(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* read() 返回 -1 表示 EOF */</span></span><br><span class="line">        <span class="keyword">if</span> (r == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 切换读写 */</span></span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 把缓冲区的内容写入输出文件中 */</span></span><br><span class="line">        fcout.write(buffer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 清空缓冲区 */</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>我们可以看一下整个<code>buffer</code>的状态变化，此处我们假设大小为8字节</p>
<p>①新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit &#x3D; capacity &#x3D; 8。capacity 变量不会改变，下面的讨论会忽略它。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/01/77fb2a16735a25dc.jpg" alt="buffer变化1"></p>
<p>② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 移动设置为 5，limit 保持不变。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/01/6df58dfb355cd5fd.jpg" alt="buffer变化2"></p>
<p>③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/01/fc7668224747f135.jpg" alt="buffer变化3"></p>
<p>④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/01/e41dc8148e004937.jpg" alt="buffer变化4"></p>
<p>⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/01/34a021e1ad767087.jpg" alt="buffer变化5"></p>
<blockquote>
<p>为什么缓冲区在写之后读需要使用<code>flip</code>函数呢？我们从图中看出<code>flip</code>之后会将Position置为0。从读到写不需要翻转（如果是覆盖写的话）</p>
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">flip</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//修改limit值，当前写到哪里，下次读的最终位置就是这里</span></span><br><span class="line">    limit = position;    </span><br><span class="line">    position = <span class="number">0</span>;    <span class="comment">//position归零</span></span><br><span class="line">    mark = -<span class="number">1</span>;    <span class="comment">//标记还原为-1，但是现在我们还没用到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>我们通过<code>put</code>方法来深入理解一下<code>flip</code>。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">put</span><span class="params">(IntBuffer src)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(src == <span class="built_in">this</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span>(isReadOnly())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReadOnlyBufferException</span>();</span><br><span class="line">    <span class="comment">// 非常重要，在这里就是确定src的元素个数</span></span><br><span class="line">    <span class="comment">// 你现在是读src，你应该将src转换为读状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> src.remaining();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(n &gt; remaining())</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BufferOverflowException</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        put(src.get());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p><code>remaining()</code>在读缓冲区时的结果期望是缓冲区数据个数，在写缓冲区时的结果期望是缓冲区的剩余容量。</p>
</blockquote>
<p>为什么我要强调期望呢？因为如果不恰当使用<code>flip</code>，得到的结果就不是期望值。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">remaining</span><span class="params">()</span> &#123;  <span class="comment">//计算并获取当前缓冲区的剩余空间</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rem</span> <span class="operator">=</span> limit - position;   <span class="comment">//最大容量减去当前位置，就是剩余空间</span></span><br><span class="line">    <span class="keyword">return</span> rem &gt; <span class="number">0</span> ? rem : <span class="number">0</span>;  <span class="comment">//没容量就返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>如果是写缓冲区，<code>limit-position</code>就是剩余容量；使用<code>flip</code>之后，<code>limit-position</code>就是缓冲区包含的数据个数。所以，<code>flip</code>的本质就是通过改变<code>limit</code>和<code>position</code>的值来改变二者之差的含义。·</p>

        <h4 id="读操作"   >
          <a href="#读操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h4>
      <p>为什么我们需要翻转操作，因为我们读写数据都是依托于<code>position</code>定位的。写入&#x2F;读取（<code>get()</code>方法）都会使<code>position</code>加一。如果超出范围抛出异常。</p>
<p>当然也可以用<code>get(i)</code>来指定读取第<code>i</code>个元素。</p>
<p>看一下有哪些重载的<code>get</code>方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;<span class="comment">// 只有这个方法不会改变position</span></span><br><span class="line"><span class="keyword">public</span> IntBuffer <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span>[] dst)</span>;<span class="comment">// 实际是调用下面那个方法</span></span><br><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">get</span><span class="params">(<span class="type">int</span>[] dst,<span class="type">int</span> offset,<span class="type">int</span> length)</span>;</span><br></pre></td></tr></table></div></figure>

<p>我们也可以使用<code>array()</code>方法直接返回<code>hb</code>数组。但是这直接将<code>hb</code>底层数组暴露在外面，所有修改都会生效在缓冲区。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span>[] array() &#123;</span><br><span class="line">    <span class="keyword">if</span> (hb == <span class="literal">null</span>)   <span class="comment">//为空那说明底层不是数组实现的，肯定就没法转换了</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    <span class="keyword">if</span> (isReadOnly)   <span class="comment">//只读也是不让直接取出的，因为一旦取出去岂不是就能被修改了</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReadOnlyBufferException</span>();</span><br><span class="line">    <span class="keyword">return</span> hb;   <span class="comment">//直接返回hb</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>最后，缓冲区还有一个<code>mark</code>操作，类似原理在缓冲流已经讲过了，此处不加赘述。当然缓冲区还有其他一些操作，这里笔者觉得不宜写太多，建议就是遇到了不懂就去浏览器搜。</p>
<p>只读缓冲区：<code>HeapIntBufferR</code>是<code>HeapIntBuffer</code>的子类，初始化为</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> IntBuffer.wrap(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line"><span class="type">IntBuffer</span> <span class="variable">readBuffer</span> <span class="operator">=</span> buffer.asReadOnlyBuffer();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">asReadOnlyBuffer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//注意这里并不是直接创建了HeapIntBuffer，而是HeapIntBufferR，并且直接复制的hb数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeapIntBufferR</span>(hb,    </span><br><span class="line">                                 <span class="built_in">this</span>.markValue(),</span><br><span class="line">                                 <span class="built_in">this</span>.position(),</span><br><span class="line">                                 <span class="built_in">this</span>.limit(),</span><br><span class="line">                                 <span class="built_in">this</span>.capacity(),</span><br><span class="line">                                 offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="选择器"   >
          <a href="#选择器" class="heading-link"><i class="fas fa-link"></i></a><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2>
      <p>这个其实就是<strong>Unix IO模型</strong>讲到的多路复用，<code>NIO</code>实现了<code>IO</code>多路复用中的Reactor模型，一个线程使用一个选择器Selector通过轮询的方式去监听多个通道<code>Channel</code>上的事件，从而让一个线程就可以处理多个事件。</p>
<p>通过配置监听的通道Channel为非阻塞，那么当Channel上的IO事件未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它Channel，找到IO事件已经到达的Channel执行。</p>
<blockquote>
<p>只有套接字Channel才能配置非阻塞，而FileChannel不能（FileChannel配置非阻塞也没有意义）。</p>
</blockquote>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/01/c631fb000c1a9630.jpg" alt="选择器"></p>

        <h3 id="创建选择器"   >
          <a href="#创建选择器" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建选择器" class="headerlink" title="创建选择器"></a>创建选择器</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br></pre></td></tr></table></div></figure>


        <h3 id="通道注册到选择器"   >
          <a href="#通道注册到选择器" class="heading-link"><i class="fas fa-link"></i></a><a href="#通道注册到选择器" class="headerlink" title="通道注册到选择器"></a>通道注册到选择器</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ssChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">ssChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">ssChannel.register(selector,SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></div></figure>

<p>通道配置必须为非阻塞模式，最后一行代码需要指定注册的具体事件</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在SelectionKey中定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_READ</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_WRITE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_CONNECT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_ACCEPT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></div></figure>


        <h3 id="监听事件"   >
          <a href="#监听事件" class="heading-link"><i class="fas fa-link"></i></a><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> selector.select();</span><br></pre></td></tr></table></div></figure>

<p>使用 <code>select()</code> 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。</p>

        <h3 id="获取到达的事件"   >
          <a href="#获取到达的事件" class="heading-link"><i class="fas fa-link"></i></a><a href="#获取到达的事件" class="headerlink" title="获取到达的事件"></a>获取到达的事件</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; leys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="事件循环"   >
          <a href="#事件循环" class="heading-link"><i class="fas fa-link"></i></a><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3>
      <p>一次<code>select()</code>调用不能处理所有事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> selector.select();</span><br><span class="line">    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line">    <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        keyIterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="套接字-NIO-实例"   >
          <a href="#套接字-NIO-实例" class="heading-link"><i class="fas fa-link"></i></a><a href="#套接字-NIO-实例" class="headerlink" title="套接字 NIO 实例"></a>套接字 NIO 实例</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建选择器</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将通道注册到选择器上（设置非阻塞）</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        ssChannel.register(selector,SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> ssChannel.socket();</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">        serverSocket.bind(address);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">ssChannel1</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 雾浮起为每个新连接创建一个SocketChannel</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sChannel</span> <span class="operator">=</span> ssChannel1.accept();</span><br><span class="line">                    sChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 该连接主要用于从客户端读取数据</span></span><br><span class="line">                    sChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable()) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    System.out.println(readDataFromSocketChannel(sChannel));</span><br><span class="line">                    sChannel.close();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">readDataFromSocketChannel</span><span class="params">(SocketChannel sChannel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sChannel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span>(n == -<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> buffer.limit();</span><br><span class="line">            <span class="type">char</span>[] dst = <span class="keyword">new</span> <span class="title class_">char</span>[limit];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; limit;i++) &#123;</span><br><span class="line">                dst[i] = (<span class="type">char</span>)buffer.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            data.append(dst);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>客户端</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        out.write(s.getBytes());</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="参考文章"   >
          <a href="#参考文章" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/io/java-io-nio.html" >https://pdai.tech/md/java/io/java-io-nio.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>语雀（青空の霞光）：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javase/kl68ty#e4f52ebc" >https://www.yuque.com/qingkongxiaguang/javase/kl68ty#e4f52ebc</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-nio/index.html" >Java NIO Tutorial  (opens new window)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://tech.meituan.com/nio.html" >Java NIO 浅析  (opens new window)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" >IBM: NIO 入门  (opens new window)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>Eckel B, 埃克尔, 昊鹏, 等. Java 编程思想 [M]. 机械工业出版社, 2002.</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" >IBM: NIO 入门  (opens new window)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html" >IBM: 深入分析 Java I&#x2F;O 的工作机制  (opens new window)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/index.htm" >IBM: 深入分析 Java 中的中文编码问题  (opens new window)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html" >IBM: Java 序列化的高级认识  (opens new window)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://blog.csdn.net/shimiso/article/details/24990499" >NIO 与传统 IO 的区别  (opens new window)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://stg-tud.github.io/sedc/Lecture/ws13-14/5.3-Decorator.html#mode=document" >Decorator Design Pattern  (opens new window)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://labojava.blogspot.com/2012/12/socket-multicast.html" >Socket Multicast</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://juejin.cn/post/6974191624331100174" >https://juejin.cn/post/6974191624331100174</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://cecilia.cool">Cyan</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://cecilia.cool/2022/09/01/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(3)-NIO%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/">https://cecilia.cool/2022/09/01/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(3)-NIO%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh_tw" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://cecilia.cool/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2022/09/02/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(4)-NIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E8%AF%A6%E8%A7%A3/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">网络编程(4)--IO多路复用详解</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2022/08/31/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(2)-BIO%E8%AF%A6%E8%A7%A3/"><span class="paginator-prev__text">网络编程(2)--BIO详解</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">
          简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text">
          相关知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E9%81%93"><span class="toc-number">2.1.</span> <span class="toc-text">
          通道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FileChannel"><span class="toc-number">2.1.0.1.</span> <span class="toc-text">
          FileChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%94%81FileLock"><span class="toc-number">2.1.0.2.</span> <span class="toc-text">
          文件锁FileLock</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">2.2.</span> <span class="toc-text">
          缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.1.</span> <span class="toc-text">
          相关方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">
          获取对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">
          写操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">
          读操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">2.3.</span> <span class="toc-text">
          选择器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">2.3.1.</span> <span class="toc-text">
          创建选择器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E6%B3%A8%E5%86%8C%E5%88%B0%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">2.3.2.</span> <span class="toc-text">
          通道注册到选择器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.3.3.</span> <span class="toc-text">
          监听事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%88%B0%E8%BE%BE%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.3.4.</span> <span class="toc-text">
          获取到达的事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.3.5.</span> <span class="toc-text">
          事件循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97-NIO-%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.4.</span> <span class="toc-text">
          套接字 NIO 实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">3.</span> <span class="toc-text">
          参考文章</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/logo.png" alt="avatar"></div><p class="sidebar-ov-author__text">You have lots more to work on</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">70</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">2</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">11</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh_tw" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Cyan</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.2.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.7.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.7.0"></script><script src="/js/stun-boot.js?v=2.7.0"></script><script src="/js/scroll.js?v=2.7.0"></script><script src="/js/header.js?v=2.7.0"></script><script src="/js/sidebar.js?v=2.7.0"></script></body></html>