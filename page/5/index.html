<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.7.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.7.0" type="image/png" sizes="32x32"><meta name="description" content="我始终勇往直前，百折不回...">
<meta property="og:type" content="website">
<meta property="og:title" content="慕青的日记">
<meta property="og:url" content="https://cecilia.cool/page/5/index.html">
<meta property="og:site_name" content="慕青的日记">
<meta property="og:description" content="我始终勇往直前，百折不回...">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Cyan">
<meta name="twitter:card" content="summary"><title>慕青的日记 | Cyan</title><link ref="canonical" href="https://cecilia.cool/page/5/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.7.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">慕青的日记</div><div class="header-banner-info__subtitle">Cyan</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/08/05/Shell/gawk%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/">gawk程序基础</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-08-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-08-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h1>
      <p><code>gawk</code>程序是<code>Unix</code>中原始<code>gawk</code>程序的<code>GNU</code>版本，让流编辑迈上了一个新的台阶，其作用为：</p>
<ul>
<li>定义变量保存数据。</li>
<li>使用算数和字符串操作符处理数据。</li>
<li>使用结构化编程概念来为数据处理增加处理逻辑。</li>
<li>通过提取数据文件中的数据元素，将其重新排列或格式化，生成格式化报告</li>
</ul>
<p>格式：<code>gawk options program file</code>。</p>
<p><code>gawk</code>强大之处在于程序脚本，可以写脚本来读取文本行的数据，处理并显示数据，创建任何类型的输出报告。</p>
<p>如果你没有下载<code>gwak</code>，执行命令：<code>sudo apt install gawk</code>。</p>

        <h1 id="从命令行读取脚本程序"   >
          <a href="#从命令行读取脚本程序" class="heading-link"><i class="fas fa-link"></i></a><a href="#从命令行读取脚本程序" class="headerlink" title="从命令行读取脚本程序"></a>从命令行读取脚本程序</h1>
      <p><code>gawk</code>程序脚本用一对花括号定义<code>&#123;&#125;</code>,必须将脚本命令放在花括号中：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gawk &#x27;&#123;print &quot;Hello World&quot;&#125;&#x27;</span><br></pre></td></tr></table></div></figure>

<p><code>print</code>命令会将文本打印到<code>STDOUT</code>中，由于没有在命令行中指定文件，所以输入默认是接收<code>STDIN</code>。由于该命令固定显示<code>Hello World</code>，所以不论输入什么，都只会显示这个。希望结束程序，必须表明数据流已经结束，<code>ctrl+d</code>会产生一个<code>EOF</code>字符，能够终止<code>gawk</code>。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gawk &#x27;&#123;print &quot;Hello world&quot;&#125;&#x27; testfile   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用文件作为输入</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">由于gawk命令行假定脚本是个单个文本字符串，所以要使用<span class="string">&#x27;&#x27;</span></span></span><br></pre></td></tr></table></div></figure>

<p>如果要使用多命令，还是使用分号</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;this is rich&quot; | gawk &#x27;&#123;$4=&quot;Mike&quot;;print $0&#125;&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以分行</span></span><br><span class="line">    gawk &#x27;&#123;</span><br><span class="line"><span class="meta prompt_"> &gt; </span><span class="language-bash"><span class="variable">$3</span>=<span class="string">&#x27;123&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"> &gt; </span><span class="language-bash"><span class="built_in">print</span> <span class="variable">$0</span></span></span><br><span class="line"><span class="meta prompt_"> &gt; </span><span class="language-bash">&#125;<span class="string">&#x27;</span></span></span><br></pre></td></tr></table></div></figure>

<p>这个与<code>sed</code>的多命令相似，两者的格式区别在于，<code>sed</code>的命令直接使用<code>&#39;&#39;</code>，<code>gawk</code>使用<code>&#39;&#123;&#125;&#39;</code>，如果将命令放在文件中，两者是相同的，都是使用<code>-f</code>参数，文件名为了避免混淆，也会以.<code>gawk</code>后缀命名。在<code>gawk</code>命令文件中，可以定义变量，同时，使用时不需要<code>$</code>。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">text=&#x27;213&#x27;</span><br><span class="line">print text</span><br></pre></td></tr></table></div></figure>




        <h1 id="数据字段变量"   >
          <a href="#数据字段变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据字段变量" class="headerlink" title="数据字段变量"></a>数据字段变量</h1>
      <p><code>gawk</code>会给一行中每个数据元素分配一个变量（默认数据分隔符是空格）<code>$0</code>–整行数据    <code>$n</code>–第<code>n</code>个数据</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gawk -F: &#x27;&#123;print $1&#125;&#x27; data      </span><br></pre></td></tr></table></div></figure>

<p>打印data每行第一个数据，<code>-F</code>指定分隔符，以<code>:</code>为分隔符。</p>

        <h1 id="程序脚本的运行"   >
          <a href="#程序脚本的运行" class="heading-link"><i class="fas fa-link"></i></a><a href="#程序脚本的运行" class="headerlink" title="程序脚本的运行"></a>程序脚本的运行</h1>
      <p><code>gawk</code>允许指定程序脚本<strong>何时运行</strong>，默认情况下，<code>gawk</code>会从输入读取一行脚本，然后针对该行数据运行程序脚本，但是，有时需要在处理数据前运行脚本，有时在之后处理脚本。</p>
<ul>
<li><code>BEGIN</code>关键字：会强制<code>gawk</code>在读取数据前执行<code>BEIGIN</code>关键字后指定的程序脚本</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ gawk &#x27;BEGIN &#123;print &quot;hello&quot;&#125;&#x27;</span><br><span class="line">hello</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为没有其他处理数据的命令，直接退出</span></span><br></pre></td></tr></table></div></figure>

<p><code>print</code>显示完文本后会快速退出，不等待任何数据，如果想使用正常的程序脚本中处理数据，必须使用另一个脚本区域来定义程序：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ gawk &#x27;BEGIN &#123;print &quot;hello&quot;&#125;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&#123;<span class="built_in">print</span> <span class="variable">$1</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">&#x27; data</span></span></span><br><span class="line">hello</span><br><span class="line">cat</span><br><span class="line">cat</span><br><span class="line">cat</span><br><span class="line">cat</span><br><span class="line">cat</span><br></pre></td></tr></table></div></figure>

<ul>
<li><code>END</code>关键字：会在读取数据(是所有数据)处理完之后，执行<code>END</code>后面的程序脚本</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ gawk &#x27;BEGIN &#123;print &quot;The data file content:&quot;&#125;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&#123;<span class="built_in">print</span> <span class="variable">$1</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">END &#123;<span class="built_in">print</span> <span class="string">&quot;END of file&quot;</span>&#125;<span class="string">&#x27; data</span></span></span><br><span class="line">The data file content:</span><br><span class="line">cat</span><br><span class="line">cat</span><br><span class="line">cat</span><br><span class="line">cat</span><br><span class="line">cat</span><br><span class="line">END of file</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/08/04/Shell/sed%E7%BC%96%E8%BE%91%E5%99%A8%E5%9F%BA%E7%A1%80/">sed编辑器基础</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-08-04</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-08-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h1>
      <p><code>sed</code>编辑器被称作<strong>流编辑器</strong>(<code>stream editor</code>)，流编辑器会在编辑器处理数据之前基于预先提供的一组<strong>数据规则</strong>来编辑数据流。根据命令来处理数据，这些命令要么从命令行输入，要么存储在一个命令文本文件中。</p>
<p><code>sed</code>编辑器处理事务：</p>
<ol>
<li>一次从输入中读取一行数据。</li>
<li>根据提供的编辑器命令匹配数据。</li>
<li>按照命令修改流中的数据。</li>
<li>将新的数据输出到<code>STDOUT</code>。</li>
</ol>
<p><code>sed</code>将所有命令与一行数据匹配完毕后，读取下一行数据并重复该过程，处理完所有数据，终止。</p>

        <h1 id="基本格式"   >
          <a href="#基本格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h1>
      <p>格式：<code>sed options script file</code>。</p>
<p>为了更好理解，举个例子。</p>
<p>先创建一个数据文件<code>data</code>，其中包含**6行’cat’**。然后我们希望将’cat’替换为’dog’。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ sed &#x27;s/cat/dog/&#x27; data</span><br><span class="line">dog</span><br><span class="line">dog</span><br><span class="line">dog</span><br><span class="line">dog</span><br><span class="line">dog</span><br><span class="line">dog</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">‘s/cat/dog/’是后者替换前者</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此次命令没有使用选项，scirpt就是<span class="string">&#x27;s/cat/dog&#x27;</span> file就是data</span></span><br></pre></td></tr></table></div></figure>

<p><code>sed</code>命令非常快。处理一行显示一行，但是<code>sed</code>并不会修改文件原始数据，只是将结果传给<code>STDOUT</code>而已，当然，也可以重定向。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/cat/big cat/&#x27; data &gt; result</span><br></pre></td></tr></table></div></figure>

<p><code>sed</code>可以执行多个命令，使用<code>-e</code>选项，多个命令分号隔开，并且分号紧靠上一个命令</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sed -e &#x27;s/brown/green/; s/dog/cat/&#x27; data</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者是这样，shell一旦发现封尾的单引号，就会执行命令</span></span><br><span class="line">sed -e &#x27;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">s/brown/green</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">s/fox/cat</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">&#x27; data</span></span></span><br></pre></td></tr></table></div></figure>

<p>如果要执行的命令太多，可以放在文件中，使用<code>-f</code>选项，该选项会在处理输入时，将文件中指定的命令添加到已有的命令中。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sed -f script.sed data</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为避免混淆，一般将sed的命令文件后缀写为.sed</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例子</span></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat command.sed</span><br><span class="line">s/cat/dog/</span><br><span class="line">s/Jack/Mark/</span><br><span class="line"></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat data</span><br><span class="line">cat Jack</span><br><span class="line">cat Jack</span><br><span class="line">cat Jack</span><br><span class="line">cat Jack</span><br><span class="line">cat Jack</span><br><span class="line"></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ sed -f command.sed data</span><br><span class="line">dog Mark</span><br><span class="line">dog Mark</span><br><span class="line">dog Mark</span><br><span class="line">dog Mark</span><br><span class="line">dog Mark</span><br></pre></td></tr></table></div></figure>

<p>关于<code>s</code>替换命令，还有其他选项</p>
<ul>
<li><code>sed &#39;s/cat/dog/&#39; data</code>只会替换每行第一处<code>cat</code>。如果想在第<code>n</code>处替换，<code>s/cat/dog/n&#39;</code>。</li>
<li><code>g</code>选项，所有匹配到的标记都会被替换。</li>
<li><code>p</code>选项，文本原先行内容替换后要打印出来：<code>sed -n &#39;s/cat/dog/p&#39; data</code>,一般和<code>-n</code>配合使用，<code>-n</code>禁止<code>sed</code>输出，配合<code>p</code>使用，就只会打印含有标记的文本。</li>
<li><code>w file</code>,将替换的结果写到文件中：<code>sed &#39;s/cat/dog/w aim.txt&#39; data</code>。</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ sed &#x27;s/cat/dog/w test_data&#x27; data</span><br><span class="line">dog Jack</span><br><span class="line">dog Jack</span><br><span class="line">dog Jack</span><br><span class="line">dog Jack</span><br><span class="line">dog Jack</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat test_data</span><br><span class="line">dog Jack</span><br><span class="line">dog Jack</span><br><span class="line">dog Jack</span><br><span class="line">dog Jack</span><br><span class="line">dog Jack</span><br></pre></td></tr></table></div></figure>

<p>有时候，<code>/</code>使用起来比较麻烦，可以使用<code>!</code>来代替：<code>s!cat!dog!</code>。</p>

        <h1 id="使用地址"   >
          <a href="#使用地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用地址" class="headerlink" title="使用地址"></a>使用地址</h1>
      <p>可以指定命令对某些特定的行数进行处理，<code>sed</code>编辑器的行寻址有两种形式：</p>
<ul>
<li>数字表示行区间</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.对单行指定修改</span></span><br><span class="line">sed &#x27;2s/cat/dog/&#x27; data</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.对行区间进行执行修改</span></span><br><span class="line">sed &#x27;2,5s/cat/dog&#x27; data # 2~5行被修改</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.美元符号$</span></span><br><span class="line">sed &#x27;2,$s/cat/dog/&#x27; data   # 对2行及以下的数据执行命令</span><br></pre></td></tr></table></div></figure>

<ul>
<li>文本模式来过滤出行，<code>/pattern/command</code>。比如修改用户<code>cyan</code>的默认<code>shell</code>。匹配模式十分类似<code>grep</code>，固定文本作用有限，最常用的是使用正则表达式。 匹配模式十分类似grep，固定文本作用有限，最常用的是使用正则表达式。</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep cyan /etc/passwd</span></span><br><span class="line">cyan:x:1000:1000:cyan,,,:/home/cyan:/bin/bash</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sed <span class="string">&#x27;/cyan/s/bash/csh/&#x27;</span> /etc/psswd</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>当有多条命令时候。</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">address &#123; #多条命令时，需要用&#123;&#125;来限定作用域</span><br><span class="line">        command1</span><br><span class="line">        command2</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例</span></span><br><span class="line">sed &#x27;2&#123;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">commands</span>    </span><br><span class="line">&#125;&#x27; data.txt</span><br></pre></td></tr></table></div></figure>




        <h1 id="删除与修改"   >
          <a href="#删除与修改" class="heading-link"><i class="fas fa-link"></i></a><a href="#删除与修改" class="headerlink" title="删除与修改"></a>删除与修改</h1>
      <p><code>sed</code>可以替换，也可以删除，使用<code>d</code>命令：<code>sed &#39;3d&#39; data</code>，和行寻址一起使用发挥最大作用。输出到STDOUT的结果是删除指定行之后的剩余文本。</p>
<p>如果我希望删除某个区间的文本（使用文本匹配）</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cat data</span><br><span class="line">num start</span><br><span class="line">num 2</span><br><span class="line">num 3</span><br><span class="line">num end</span><br><span class="line">num 4</span><br><span class="line">num start again</span><br><span class="line">kk</span><br><span class="line">nn</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行命令：sed <span class="string">&#x27;/start/,/end/d&#x27;</span> data</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果 num 4</span> </span><br></pre></td></tr></table></div></figure>

<p>一开始遇到<code>start</code>，打开删除模式，持续删除，直到遇到<code>end</code>，关闭删除模式(没遇到就一直删除）。再次遇到<code>start</code>时(<code>num start again</code>)，打开删除模式，并持续删除。</p>
<p><code>sed</code>编辑器是不会修改原始文件的，修改的只是从<code>sed</code>编辑器的输出中消失了。</p>
<p>至于修改行的内容，之前的<code>s</code>命令需要匹配，而<code>c</code>命令是直接修改整行内容，<code>c--change</code>。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;1c\this is changed line&#x27; data.txt</span><br><span class="line">sed &#x27;/num 1/c\this is changed line&#x27; data.txt</span><br><span class="line">sed &#x27;2,3c\this is changed line&#x27; data.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">c命令之后用的是反斜杠\,并且没有封尾，也就是line后没有\</span></span><br><span class="line"><span class="language-bash"><span class="comment"># 第三个使用区间修改行，并不是将区间的每一行都修改为指定行，而是用该指定行替换数据流中区间的所有文本</span></span></span><br></pre></td></tr></table></div></figure>




        <h1 id="插入和附加文本"   >
          <a href="#插入和附加文本" class="heading-link"><i class="fas fa-link"></i></a><a href="#插入和附加文本" class="headerlink" title="插入和附加文本"></a>插入和附加文本</h1>
      <p>插入<code>insert--i</code>:会在指定行<strong>前</strong>增加一个行，<code>echo &quot;test line 2&quot; | sed &#39;i\test line 1&#39;</code>。<br>附加<code>append--a</code>:会在指定行<strong>后</strong>增加一个行，<code>echo &quot;test line 2&quot; | sed &#39;a\test line 1&#39;</code>。</p>
<p>如果想要附加到行尾，只需要使用美元符号：<code>sed &#39;$a\new line&#39; data</code>。<strong>个人觉得美元符号是数据流最后一行的意思</strong>。<br>要插入（附加）多行数据，需要在每行之间使用<code>\</code>：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;1i\</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">line 1\</span></span><br><span class="line"><span class="language-bash">&gt; line 2</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">&#x27; data</span></span></span><br></pre></td></tr></table></div></figure>




        <h1 id="转换命令"   >
          <a href="#转换命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#转换命令" class="headerlink" title="转换命令"></a>转换命令</h1>
      <p><code>y</code>命令是唯一可以处理单个字符的<code>sed</code>编辑器命令  <code>[address]y/inchars/outchars/</code>。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;y/123/789/&#x27; data</span><br></pre></td></tr></table></div></figure>

<p><code>inchars</code>的第一个字符会被映射为<code>outchars</code>的第一个字符，以此类推，直到处理完指定字符。其中，如果两者长度不一样，会报错。<br>转换命令是全局命令，无法限定只转换在特定地方出现的字符(以行为单位)，也就是<strong>一行所有的字符都要被转换</strong>。</p>

        <h1 id="打印命令"   >
          <a href="#打印命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#打印命令" class="headerlink" title="打印命令"></a>打印命令</h1>
      <p>之前使用<code>s</code>替换命令时，配合<code>-n</code>和<code>p</code>选项，打印出修改的行，还有些命令也能打印数据流信息。</p>
<p><code>=</code>命令打印<strong>行号</strong>，<strong>行号由数据流中的换行符来决定</strong>，每出现一个换行符，sed编辑器就认为一行结束了。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;=&#x27; data</span><br></pre></td></tr></table></div></figure>

<p><code>l</code>命令可以打印出数据流中的文本和不可打印的ASCII字符(一般是标准C风格或八进制)，<code>l</code>就是<code>list</code>。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;l&#x27; data</span><br></pre></td></tr></table></div></figure>




        <h1 id="处理文件"   >
          <a href="#处理文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#处理文件" class="headerlink" title="处理文件"></a>处理文件</h1>
      <ul>
<li>写入文件：<code>[address]w filename</code>。</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;1,2w aim.txt&#x27; data</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在aim.txt追加</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>读取文件：<code>[address]r filename</code>。 允许将一个独立文件中的数据插入到数据流中，插入到指定行后。</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;3r sources.txt&#x27; data</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/08/04/Shell/%E5%87%BD%E6%95%B0/">函数</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-08-04</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-08-04</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="创建函数"   >
          <a href="#创建函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h1>
      <p>格式</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式1</span></span><br><span class="line">function name &#123;</span><br><span class="line">	commands</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式2,更推荐使用</span></span><br><span class="line">name() &#123;</span><br><span class="line">	commands</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用时只需要使用函数名即可--name</span></span><br></pre></td></tr></table></div></figure>

<p>默认情况下，函数退出状态码是函数中最后一条命令返回的退出状态码，函数执行结束后，可以用标准变量<code>$?</code>来确定函数退出状态码。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">return</span>语句</span></span><br><span class="line">fun() &#123;</span><br><span class="line">	read -p &quot;please input the value:&quot; value</span><br><span class="line">    return $value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>退出状态码在<code>0~255</code>，否则就会返回错误值</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">fun() &#123;</span><br><span class="line">    var=&#x27;abc&#x27; # 会报错：line 5: return: abc: numeric argument required</span><br><span class="line">    return $var</span><br><span class="line">&#125;</span><br><span class="line">fun</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果中间有其他命令，$?就会被置0</span></span><br><span class="line">echo $?</span><br></pre></td></tr></table></div></figure>

<p>当然，如果希望从函数那得到一个任意对象，就像强类型语言那样<code>return</code>语句返回值可以用变量接收</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun() &#123;</span><br><span class="line">value=10</span><br><span class="line">echo $[$value*2]</span><br><span class="line">&#125;</span><br><span class="line">reslut=`fun` #或者是$(fun)</span><br></pre></td></tr></table></div></figure>

<p>如此可以获得任何类型的函数输出，并将其保存在变量中。</p>

        <h1 id="函数中使用变量"   >
          <a href="#函数中使用变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数中使用变量" class="headerlink" title="函数中使用变量"></a>函数中使用变量</h1>
      <p><strong>传参：</strong></p>
<ul>
<li><code>bash shell</code> 会将函数当成一个小型脚本来对待，也就是说，可以传递参数，如同脚本一样。</li>
<li>如同脚本一样，对于传入参数，依旧是使用<code>$0,$1...</code>，<code>$#</code>是传入参数数量。<code>value=$(fun 10 15)</code>,参数直接写在后面即可。</li>
<li>由于函数使用特殊参数环境变量作为自己的参数值，因此他无法直接获取脚本在命令行获取的参数值。</li>
</ul>
<p><strong>处理变量：</strong></p>
<p>比较麻烦的就是变量的作用域。默认情况下，<strong>定义的变量都是全局变量</strong>，函数外定义的变量，函数内部也可以正常使用。函数内定义的变量函数外也可以使用。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">fun() &#123;</span><br><span class="line">    var=10</span><br><span class="line">    return $var</span><br><span class="line">&#125;</span><br><span class="line">fun</span><br><span class="line">echo $var</span><br></pre></td></tr></table></div></figure>
<p>函数内部使用的任何变量都可以被声明成局部变量，只需要加上<code>local</code>关键字即可。</p>
<p><code>local temp=$[$value + 2]</code>,在函数内使用<code>temp</code>，不会影响主体脚本的<code>temp</code>的值。</p>

        <h1 id="数组"   >
          <a href="#数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#数组" class="headerlink" title="数组"></a>数组</h1>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr=(one two three)</span><br></pre></td></tr></table></div></figure>

<p>直接<code>$arr</code>只会显示<code>one</code>，使用格式为：<code>$&#123;arr[1]&#125;</code>,一次性全部显示，就是<code>$&#123;arr[*]&#125;</code>。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">fun() &#123;</span><br><span class="line">    local arr=(1,2,3,4)</span><br><span class="line">    for i in $&#123;arr[*]&#125;</span><br><span class="line">    do</span><br><span class="line">        echo -n $i</span><br><span class="line">   done</span><br><span class="line">   echo</span><br><span class="line">&#125;</span><br><span class="line">fun</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">结果：1,2,3,4</span></span><br></pre></td></tr></table></div></figure>




        <h1 id="创建库"   >
          <a href="#创建库" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建库" class="headerlink" title="创建库"></a>创建库</h1>
      <p>总有一些方法，我在很多脚本文件中都会使用，为了避免每个脚本文件都写一次，<code>bash shell</code>允许创建函数库文件，然后在多个脚本中引用。</p>
<p>我们在运行一个脚本文件时，当前的<code>shell</code>会创建一个新的<code>shell</code>运行</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat testfile</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">while var=10</span><br><span class="line">do</span><br><span class="line">        var=10</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ ./testfile &amp;</span><br><span class="line">[1] 89708</span><br><span class="line"></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ ps --forest</span><br><span class="line">    PID TTY          TIME CMD</span><br><span class="line">  88948 pts/1    00:00:00 bash</span><br><span class="line">  89708 pts/1    00:00:08  \_ testfile</span><br><span class="line">  89710 pts/1    00:00:00  \_ ps</span><br></pre></td></tr></table></div></figure>

<p><code>shell</code>函数仅仅在定义它的<code>shell</code>会内有效，所以如果在<code>shell</code>命令行界面的提示符下运行库函数脚本，<code>shell</code>会创建一个新的<code>shell</code>运行。这个<code>shell</code>会重新定义库函数，当其他脚本想用时，是不能的。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">./funs_file</span><br><span class="line">..</span><br></pre></td></tr></table></div></figure>

<p>哪怕在<code>test</code>中运行<code>funs_file</code>库文件，这些库函数，也只能在运行库文件的<code>shell</code>里面才会生效。</p>

        <h2 id="source命令"   >
          <a href="#source命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#source命令" class="headerlink" title="source命令"></a>source命令</h2>
      <p>该命令会在当前<code>shell</code>上下文执行命令，而不是创建一个新的<code>shell</code>，并且<code>source</code>命令有个快捷别名–点操作符. <code>./fun_file</code>。</p>
<p>编写一个脚本</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat testfile</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">var=10</span><br></pre></td></tr></table></div></figure>

<p>如果不使用<code>source</code>命令，那么<code>var</code>对于当前<code>shell</code>是不可见的</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ ./testfile</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ echo $var</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>使用之后</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ . ./testfile</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ echo $var</span><br><span class="line">10</span><br></pre></td></tr></table></div></figure>




        <h1 id="终端使用函数"   >
          <a href="#终端使用函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#终端使用函数" class="headerlink" title="终端使用函数"></a>终端使用函数</h1>
      <p>格式</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式1，分号结尾</span></span><br><span class="line">fun()&#123;echo &quot;ok&quot;;read value;&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式2</span></span><br><span class="line">  fun() &#123;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;adc&quot;</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&#125;</span></span><br></pre></td></tr></table></div></figure>

<p>在<code>.bashrc</code>文件定义函数：函数定义放在一个特殊的位置，每次启动新<code>shell</code>都会由<code>shell</code>重新在<code>.bashrc</code>中定义的函数，甚至可以在自己写的脚本中直接使用。</p>
<p>关于<code>.bashrc</code>，就是个启动文件，<code>shell</code>启动时会执行一下。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/08/04/Shell/%E6%8E%A7%E5%88%B6%E8%84%9A%E6%9C%AC/">控制脚本</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-08-04</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-08-04</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="信号"   >
          <a href="#信号" class="heading-link"><i class="fas fa-link"></i></a><a href="#信号" class="headerlink" title="信号"></a>信号</h1>
      <p><code>Linux</code>利用信号与运行在系统中的进程进行通信，常见的<code>Linux</code>系统信号：</p>
<ul>
<li>1–<code>SIGHUP</code>–挂起进程</li>
<li>2–<code>SIGINT</code>–终止进程</li>
<li>3–<code>SIGQUIT</code>–停止进程</li>
<li>9–<code>SIGLIKILL</code>–无条件终止进程</li>
<li>15–<code>SIHTERM</code>–尽可能终止进程</li>
<li>17–<code>SIGSTOP</code>–无条件停止进程，但不是终止</li>
<li>18–<code>SIGTSTP</code>–停止或暂停进程，但不是终止</li>
<li>19–<code>SIGCONT</code>–继续运行停止的进程</li>
</ul>
<p><code>crtl+c</code>会生成<code>SIGINT</code>信号，停止<code>shell</code>当前运行的所有进程。<br><code>ctrl+z</code>会生成<code>SIGTSTP</code>信号，停止<code>shell</code>中运行的任何进程。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~$ sleep 1000</span><br><span class="line">^Z</span><br><span class="line">[1]+  Stopped                 sleep 1000</span><br><span class="line">cyan@cyan-virtual-machine:~$ ps -l</span><br><span class="line">F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">0 S  1000   30447   30445  0  80   0 -  3559 do_wai pts/0    00:00:00 bash</span><br><span class="line">0 T  1000   33293   30447  0  80   0 -  2789 do_sig pts/0    00:00:00 sleep</span><br><span class="line">0 R  1000   33294   30447  0  80   0 -  3623 -      pts/0    00:00:00 ps</span><br></pre></td></tr></table></div></figure>

<p><code>S</code>列中，<code>T</code>标志就是进程被暂停。使用<code>ps</code>获得希望杀死的进程的<code>PID</code>，使用<code>kill -9 PID</code>。</p>

        <h2 id="trap命令"   >
          <a href="#trap命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#trap命令" class="headerlink" title="trap命令"></a>trap命令</h2>
      <p><code>trap</code>命令：允许指定<code>shell</code>脚本监看并从<code>shell</code>中拦截的<code>Linux</code>信号。如果脚本收到了<code>trap</code>命令中列出的信号，该信号不再由<code>shell</code>处理。而是本地处理。</p>
<p>其使用格式为：<code>trap commands signals</code>。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">trap &quot;echo &#x27;I have trapped ctrl-c&#x27;&quot; SIGINT</span><br><span class="line">sleep 1000</span><br></pre></td></tr></table></div></figure>

<p>在睡眠期间使用<code>ctrl+c</code>就会打印这句话。</p>
<p>在很多程序中，想要实现程序正常运行结束或者外部发送信号退出，都会打印<code>Goodby...</code>，可以加上这句话</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trap &quot;echo &#x27;Goodby...&#x27;&quot; Exit</span><br></pre></td></tr></table></div></figure>

<p><code>trap</code>可以修改或是移除，其重点就是<strong>先到先占位</strong>，比如第一行设置了<code>trap</code>指令，在第20行修改或移除了该信号，那么第一行<code>trap</code>的只会在1~19行生效。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除,单（双）短横线都可以</span></span><br><span class="line">trap --SIGINT</span><br></pre></td></tr></table></div></figure>




        <h1 id="后台模式"   >
          <a href="#后台模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#后台模式" class="headerlink" title="后台模式"></a>后台模式</h1>
      <p>最开始就提到过，在运行脚本时加上<code>&amp;</code>，就能将进程置入后台。后台模式中，进程不会和终端会话上的<code>STDIN</code>，<code>STDOUT</code>，<code>STDERR</code>关联 。</p>

        <h1 id="最后"   >
          <a href="#最后" class="heading-link"><i class="fas fa-link"></i></a><a href="#最后" class="headerlink" title="最后"></a>最后</h1>
      <p><code>shell</code>脚本的基本编程到此为止，之后我们会进入高级<code>shell</code>脚本编程，其中会涉及到函数，著名的流编辑器<code>sed</code>和<code>gawk</code>，以及正则表达式四个主要部分。然后就可以结束此次<code>Linux</code>与<code>shell</code>编程的学习了。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/08/03/Shell/%E5%91%88%E7%8E%B0%E6%95%B0%E6%8D%AE/">呈现数据</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-08-03</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-08-03</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h1>
      <p>之前关于标准输入，输出重定向的文章，我提到开始接触流，并且在文中讲解时使用也是以流来具体化重定向的作用，但是讲解的非常不严谨。本文相当于对重定向深入讲解，甚至可以自定义重定向。</p>

        <h1 id="标准文件描述符"   >
          <a href="#标准文件描述符" class="heading-link"><i class="fas fa-link"></i></a><a href="#标准文件描述符" class="headerlink" title="标准文件描述符"></a>标准文件描述符</h1>
      <p><code>Linux</code>系统将每个对象当作文件处理（有句话就是一切皆文件），包括输入和输出，用文件描述符<strong>标识</strong>每个文件对象。文件描述符是一个<strong>非负整数</strong>，可以唯一表示会话中打开的文件。出于特殊目的，<code>bash shell</code>在每个进程，只保留了3个文件标识符(0,1,2)</p>
<ul>
<li><code>STDIN</code>–标准输<strong>入</strong>。对于终端界面，<strong>标准输入是键盘</strong>。<code>shell</code>从<code>STDIN</code>对应的键盘获得输入。使用输入重定向符号<code>&lt;</code>，<code>Linux</code>会使用重定向指定的文件来替换标准文件描述符，会读取文件并提取数据，如同是在键盘上键入的。</li>
<li><code>STDOUT</code>–标准输<strong>出</strong>。同标准输入类似，shell所有输出都会被定向到标准输出中，也就是显示器。</li>
<li><code>STDERR</code>–错误消息对于错误消息，<strong>也是重定向到显示器的</strong>，但是错误消息和一般标准输出是分开的。比如：<code>ls -l badfile &gt; test</code>，如果没有<code>badfile</code>就会报错，但是错误信息并没有给<code>test</code>。</li>
</ul>
<p>我们之前知道如何重定向标准输入和标准输出，现在讲解如何重定向错误信息。</p>
<ul>
<li>只重定向错误：将<code>STDERR</code>文件描述符的值<code>(2)</code>紧紧放在重定向符号前，<code>ls -al badfile 2&gt; test</code>。但是这种方法，如果该命令的输出既包含错误信息，也包含标准输出，那么标准输出还是会输出到屏幕中。</li>
<li>重定向错误和数据：我们肯定不希望重定向的数据和错误信息在同一文件中（难道你希望错误日志里面还给你保存几句莫名其妙的打印语句吗），所以必须使用两个重定向符号，需要在符号面前放上各自文件描述符值：<code>ls -al test test2 test3 badtest 2&gt; testSTDERR 1&gt; testSTDOUT</code>（其中<code>test*</code>文件都存在，<code>badtest</code>不存在）。   当然，也可以将数据和错误重定向到同一文件： <code>ll n_File bad_File new_File &amp;&gt; STD_ALL</code>。<code>bash shell</code>自动赋予了错误消息更高的优先级，方便集中浏览错误信息，也就是说，<code>ll A B C</code>中<code>B</code>文件不存在，那么输出时会优先输出关于<code>B</code>的错误信息。</li>
</ul>

        <h1 id="脚本中的标准重定向输出和输入"   >
          <a href="#脚本中的标准重定向输出和输入" class="heading-link"><i class="fas fa-link"></i></a><a href="#脚本中的标准重定向输出和输入" class="headerlink" title="脚本中的标准重定向输出和输入"></a>脚本中的标准重定向输出和输入</h1>
      <p>对于三个标准文件描述符，一定要记住，使用<code>exec</code>命令时数字放在箭头左边。当数字出现在右边，要用<code>&amp;</code>符号。</p>

        <h2 id="临时重定向"   >
          <a href="#临时重定向" class="heading-link"><i class="fas fa-link"></i></a><a href="#临时重定向" class="headerlink" title="临时重定向"></a>临时重定向</h2>
      <p>在脚本中生成错误消息，可以将单独的一行输出重定向到<code>STDERR</code>，不同的是，在脚本中，格式为<code>&gt;&amp;2</code>。<code>echo &quot;This is error&quot; &gt;&amp;2</code>，这样，该行就会指向<code>STDERR</code>的位置，也就类似于终端上的错误信息一样。</p>
<p>这种操作可以用于检测脚本运行时传入的选型或者参数是否正确，如果不正确就可以通过<code>&gt;&amp;2</code>来生成错误信息。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;This is error&quot; &gt;&amp;2</span><br><span class="line">echo &quot;This is normal&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行脚本，并将脚本的错误信息重定向到result1文件中</span></span><br><span class="line">./test 2&gt; result1</span><br><span class="line">This is normal</span><br><span class="line"></span><br><span class="line">cat result1</span><br><span class="line">This is an error</span><br></pre></td></tr></table></div></figure>




        <h2 id="永久重定向"   >
          <a href="#永久重定向" class="heading-link"><i class="fas fa-link"></i></a><a href="#永久重定向" class="headerlink" title="永久重定向"></a>永久重定向</h2>
      <p>上面的临时重定向，比如我一个脚本有很多行生成错误信息并需要重定向，而每一行都是用<code>&gt;&amp;2</code>太麻烦了，那么就可以使用<code>exec</code>命令来进行永久重定向。</p>
<p><code>exec</code>命令告诉<code>shell</code>在脚本中执行期间重定向某个特定文件描述符。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">exec 1&gt; STD_output_file</span><br><span class="line">....</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">那么脚本中该命令之下的所有标准输出都重定向到了STD_output_file中</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同理，改变标准输入，这对于从待处理文件中读取数据有很大帮助</span></span><br><span class="line">exec 0&lt; STD_input_file</span><br></pre></td></tr></table></div></figure>



        <h1 id="自定义重定向"   >
          <a href="#自定义重定向" class="heading-link"><i class="fas fa-link"></i></a><a href="#自定义重定向" class="headerlink" title="自定义重定向"></a>自定义重定向</h1>
      <p><code>Linux</code>系统本来每个进程都有<strong>9个</strong>文件描述符，3个标准，剩下6个都可以用于自定义，<strong>这6个可以任意作为输入还是输出</strong>。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exec 6&gt; testout</span><br><span class="line">echo &quot;This is a data&quot;&gt;&amp;6</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果使用&gt;&gt;就是追加模式</span></span><br></pre></td></tr></table></div></figure>

<p>如果你想恢复一个被重定向的文件描述符</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exec 3&gt;&amp;1   #3指向1</span><br><span class="line">exec 1&gt;testout</span><br><span class="line">.....</span><br><span class="line">exec 1&gt;&amp;3</span><br></pre></td></tr></table></div></figure>

<p>创建<strong>读写</strong>文件描述符</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec 4&lt;&gt; testfile</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入输出时，文件指针是共享的。同时注意&gt;&gt;的追加模式与该特性的使用</span></span><br></pre></td></tr></table></div></figure>

<p>关闭文件描述符时，一般创建了新的输入输出文件描述符，脚本退出时，<code>shell</code>就会自动关闭它们。手动关闭：<code>exec 3&gt;&amp;-</code>。一旦关闭，就不能在写入&#x2F;读取数据，否则就会报错。</p>

        <h1 id="lsof命令"   >
          <a href="#lsof命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#lsof命令" class="headerlink" title="lsof命令"></a>lsof命令</h1>
      <p>网上给的知识有些凌乱，甚至有些错误，所以我会总结几篇文章，最后给一下参考。</p>
<p><code>lsof--list open files</code>，列出当前系统已经打开的所有文件，一般<code>lsof</code>命令位于<code>/usr/bin/losf</code>或者是<code>/usr/sbin/lsof</code>。因为终端运行时，会有很多文件被打开使用，如果直接使用<code>lsof</code>会出现很多结果，我们在使用时一定要灵活使用相关的选项来控制输出。</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-a</td>
<td align="center">对给的选项进行<strong>与</strong>运算</td>
</tr>
<tr>
<td align="center">-p<pid></td>
<td align="center">列出指定进程号所打开的文件</td>
</tr>
<tr>
<td align="center">-d&lt;文件号&gt;</td>
<td align="center">列出占用该文件号的文件</td>
</tr>
<tr>
<td align="center">+d&lt;目录&gt;</td>
<td align="center">列出目录下被打开的文件</td>
</tr>
<tr>
<td align="center">-c&lt;进程名&gt;</td>
<td align="center">列出指定进程所打开的文件</td>
</tr>
</tbody></table></div>
<p>根据上面的部分选项，我们使用一下该命令</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">lsof -a -p $$ -d 0,1,2</span><br><span class="line">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">bash    29075 cyan    0u   CHR  136,0      0t0    3 /dev/pts/0</span><br><span class="line">bash    29075 cyan    1u   CHR  136,0      0t0    3 /dev/pts/0</span><br><span class="line">bash    29075 cyan    2u   CHR  136,0      0t0    3 /dev/pts/0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">变量$$表示当前shell的pid</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">COMMAND:正在运行的命令名的前9个字符</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">FD:文件描述符号以及访问类型(r--读，w--写，u--读写)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">TYPE:文件的类型(CHR--字符型，BLK--块型，DIR--目录，REG--常规文件)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">NAME：文件描述符所使用的文件的完整路径名</span></span><br></pre></td></tr></table></div></figure>

<p>现在编写一个简单的脚本<code>test</code>，本文主要是讲解文件描述符。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">exec 4&gt; four_data</span><br><span class="line"></span><br><span class="line">while [ $var -eq 10] #死循环</span><br><span class="line">do</span><br><span class="line">	var=10</span><br><span class="line">done</span><br></pre></td></tr></table></div></figure>

<p>使用<code>&amp;</code>将该脚本置入后台运行：<code>./test&amp;</code></p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ ./test&amp;</span><br><span class="line">[1] 88214</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ ps</span><br><span class="line">    PID TTY          TIME CMD</span><br><span class="line">  88084 pts/3    00:00:00 bash</span><br><span class="line">  88214 pts/3    00:00:19 test</span><br><span class="line">  88218 pts/3    00:00:00 ps</span><br></pre></td></tr></table></div></figure>

<p>再使用<code>lsof</code>来查看使用了哪些文件描述符</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ lsof -a -p 88214 -d 4</span><br><span class="line">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF   NODE NAME</span><br><span class="line">test    88214 cyan    4w   REG    8,5        0 935362 /home/cyan/Templates/four_data</span><br></pre></td></tr></table></div></figure>

<p><code>-p 88214</code>是寻找进程为<code>pid=88214</code>的进程打开的文件，<code>-d 4</code>找到使用<code>4</code>文件描述符的文件，<code>-a</code>对<code>-p 88214</code> 和<code>-d 4</code>进行与运算。</p>
<p>所以，你也可以尝试以下命令</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsof -p pid</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看这个进程的文件到底占用了哪些描述符</span></span><br></pre></td></tr></table></div></figure>

<p>完成案例讲解，将<code>test</code>的进程杀死</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ kill 88214</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ ps</span><br><span class="line">    PID TTY          TIME CMD</span><br><span class="line">  88084 pts/3    00:00:00 bash</span><br><span class="line">  88243 pts/3    00:00:00 ps</span><br><span class="line">[1]+  Terminated              ./test</span><br></pre></td></tr></table></div></figure>

<p><code>lsof</code>命令很强大，这里我们只是用来查看文件描述符，如果你想要深入了解，可以参考以下文章</p>
<blockquote>
<p>Linux 查看端口占用情况：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/linux-check-port-usage.html" >https://www.runoob.com/w3cnote/linux-check-port-usage.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>lsof命令详解：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/klausage/p/14995042.html" >https://www.cnblogs.com/klausage/p/14995042.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> （其实并不是很详细）</p>
<p>lsof入门：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.qieseo.com/162896.html" >https://www.qieseo.com/162896.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>

        <h1 id="阻止命令输出"   >
          <a href="#阻止命令输出" class="heading-link"><i class="fas fa-link"></i></a><a href="#阻止命令输出" class="headerlink" title="阻止命令输出"></a>阻止命令输出</h1>
      <p><code>Linux</code>有一个文件叫<code>null(/dev/null)</code>，<code>shell</code>输出到<code>null</code>文件的任何数据都不会被保存，全部都被丢掉。所以，不希望后台输出错误信息时，<code>shell</code>发送电子邮件给进程属主的话，就将<code>STDERR</code>重定向到<code>null</code>。<code>null</code>文件可以快速清除现有文件中的数据而不需要删除文件再重新创建<code>cat /dev/null &gt; testfile</code>，类似于清空日志文件。哦，其实我个人更喜欢<code>echo &quot;&quot; &gt; testfile</code>。</p>

        <h1 id="创建临时文件"   >
          <a href="#创建临时文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建临时文件" class="headerlink" title="创建临时文件"></a>创建临时文件</h1>
      <p><code>/tmp</code>目录是<code>Linux</code>用来存放不永久保留的文件，大部分<code>Linux</code>发行版配置了系统在启动时自动删除<code>/tmp</code>目录的所有文件。任何用户账户都有权限在<code>/tmp</code>读写。<br>单独<code>mktemp</code>命令可以在<code>/tmp</code>目录中创建一个唯一的临时文件。<code>shell</code>会创建该文件，但不是使用默认的<code>umask</code>，会将文件读和写权限分给属主，并将你设为属主。但是其他人没法访问(root除外)。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ mktemp</span><br><span class="line">/tmp/tmp.thPVXNPVJp</span><br></pre></td></tr></table></div></figure>

<p>也可以自定义文件名，但是会在当前目录下创建该文件</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mktemp</span>会用6个字符替换6个X，保证文件名唯一</span></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ mktemp test.XXXXXX</span><br><span class="line">test.k5CvV0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在脚本中，一般将创建的文件名保存在变量中</span></span><br><span class="line">filename=$(mktemp test.XXXXXX)</span><br></pre></td></tr></table></div></figure>

<p>还可以使用选项</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在/tmp下创建，返回全路径名</span></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ mktemp -t test.XXXXXX</span><br><span class="line">/tmp/test.LRNlpY</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d选项创建临时目录</span></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ mktemp -d dir.XXXXXX</span><br><span class="line">dir.Adr0Q6</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ mktemp -d -t dir.XXXXXX</span><br><span class="line">/tmp/dir.H9rIut</span><br></pre></td></tr></table></div></figure>




        <h1 id="记录消息"   >
          <a href="#记录消息" class="heading-link"><i class="fas fa-link"></i></a><a href="#记录消息" class="headerlink" title="记录消息"></a>记录消息</h1>
      <p><code>tee</code>命令：<br>    相当于管道的<code>T</code>型接头，将从<code>STDIN</code>过来的数据同时发送到<code>STDOUT</code>和<code>tee</code>命令行所指定的文件名：<code>tee testfile</code>。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$  date | tee testfile</span><br><span class="line">2022年 08月 03日 星期三 15:51:57 CST</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat testfile</span><br><span class="line">2022年 08月 03日 星期三 15:51:57 CST</span><br></pre></td></tr></table></div></figure>

<p><code>tee</code>每次都会覆盖文件内容，<code>-a</code>选型是追加模式：<code>who | tee -a testfile</code>。</p>

        <h1 id="实例"   >
          <a href="#实例" class="heading-link"><i class="fas fa-link"></i></a><a href="#实例" class="headerlink" title="实例"></a>实例</h1>
      <p>下面脚本涉及<code>sql</code>语句，如果你不会，可以跳过。该脚本主要是从.csv文件中读取数据快速生成<code>sql</code>执行文件。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件名create_sql_file</span></span><br><span class="line"></span><br><span class="line">outfile=&#x27;members.sql&#x27; # 要输出的文件</span><br><span class="line">IFS=&#x27;,&#x27; # 重新定义分隔符</span><br><span class="line">while read lname fname address city state zip</span><br><span class="line">do</span><br><span class="line">    cat &gt;&gt; $outfile &lt;&lt; EOF</span><br><span class="line">INSERT INTO members (lname,fname,address,city,state,zip) VALUES</span><br><span class="line">(&#x27;$lname&#x27;,&#x27;$fname&#x27;,&#x27;$address&#x27;,&#x27;$city&#x27;,&#x27;$state&#x27;,&#x27;$zip&#x27;)</span><br><span class="line">EOF</span><br><span class="line">done &lt; $&#123;1&#125; # read的标准输入重定向到$&#123;1&#125;文件。</span><br></pre></td></tr></table></div></figure>

<p>直接使用<code>cat &lt;&lt; file</code>可以追加数据到文件中，然后使用<code>ctrl+d</code>结束。也可以使用<code>&lt;&lt; 结束符</code>，通过输入结束符来结束输入。</p>
<p>我们写一个<code>mebers.csv</code>数据</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat members.csv</span><br><span class="line">Cyan,Jack,US,qiqo,iasui,iwah</span><br><span class="line">Mike,Smith,Japen,isaui,uwif,ianas</span><br></pre></td></tr></table></div></figure>

<p>然后运行脚本生成<code>sql</code>文件。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ ./create_sql_file members.csv</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat members.sql</span><br><span class="line">INSERT INTO members (lname,fname,address,city,state,zip) VALUES</span><br><span class="line">(&#x27;Cyan&#x27;,&#x27;Jack&#x27;,&#x27;US&#x27;,&#x27;qiqo&#x27;,&#x27;iasui&#x27;,&#x27;iwah&#x27;)</span><br><span class="line">INSERT INTO members (lname,fname,address,city,state,zip) VALUES</span><br><span class="line">(&#x27;Mike&#x27;,&#x27;Smith&#x27;,&#x27;Japen&#x27;,&#x27;isaui&#x27;,&#x27;uwif&#x27;,&#x27;ianas&#x27;)</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/08/02/Shell/%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/">处理用户输入</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-08-02</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-08-04</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h1>
      <p>我们之前只是讲了脚本如何输出，也就是<code>echo</code>，本文会讲解脚本如何处理用户的输入。同时我们会涉及到另外一些变量的讲解。</p>

        <h1 id="位置参数"   >
          <a href="#位置参数" class="heading-link"><i class="fas fa-link"></i></a><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h1>
      <p>我们之前使用过许多命令，他们有些可以接收若干个参数，这其实是通过位置参数来实现的。</p>
<p><code>$0</code>是程序名，<code>$1~$9</code>是第<code>1~9</code>个参数，超过9时，就要使用<code>$&#123;&#125;</code>，比如<code>$&#123;10&#125;</code>，这样，就允许在运行时加入任意个参数。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat tmp.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/bin/bash</span></span><br><span class="line">echo $0</span><br><span class="line">echo $1</span><br><span class="line">echo $2</span><br><span class="line"></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ ./tmp.txt var1 var2</span><br><span class="line">./tmp.txt</span><br><span class="line">var1</span><br><span class="line">var2</span><br></pre></td></tr></table></div></figure>

<p><code>$0</code>是命令行输入的程序名，以绝对(相对)路径运行，<code>$0</code>就是绝对(相对)路径。该特性会对脚本造成不同程度的影响，所以可以使用<code>basename</code>命令，只会返回不包含路径的脚本名：<code>name=$(basename $0)</code>       ​<code>$()</code>是命令替换。<br>注：</p>
<ul>
<li>在位置参数使用时，有可能并没有输入这个参数，所以在使用前需要测试参数：<code>if [ -n &quot;$1&quot; ]</code>  测试变量是否存在,<strong>必须要加引号</strong>。</li>
<li><code>$#</code>是含有脚本运行时携带的命令行参数个数，<code>$@</code>包含所有参数，当作同一字符串多个独立单词，<code>$*</code>是同一字符串，所有参数看作一个单词。</li>
<li>位置变量中，想要将数字使用变量代替(比如<code>$1</code>)：<code>$(!var)</code>其中var值为1,<code>$&#123;!#&#125;</code>表示最后一个参数，<code>$&#123;&#125;</code>中不能使用<code>$</code>而是使用<code>!</code>代替。</li>
</ul>
<p>这几个参数的使用和上述例子差不多，此处不再赘述。</p>

        <h1 id="移动变量"   >
          <a href="#移动变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#移动变量" class="headerlink" title="移动变量"></a>移动变量</h1>
      <p><code>shift</code>命令会默认将所有位置参数都向左移动一位，也就是<code>$1</code>的值变成了<code>$2</code>。<code>$0</code>的值始终不会变。使用shift是遍历位置参数的一个好方法</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">demonstrating the <span class="built_in">shift</span> <span class="built_in">command</span></span> </span><br><span class="line">echo </span><br><span class="line">count=1 </span><br><span class="line">while [ -n &quot;$1&quot; ] </span><br><span class="line">do </span><br><span class="line"> echo &quot;Parameter #$count = $1&quot; </span><br><span class="line"> count=$[ $count + 1 ] </span><br><span class="line"> shift </span><br><span class="line">done </span><br></pre></td></tr></table></div></figure>

<p>也可以给shift传递一个参数，指明参数移动的距离。</p>

        <h1 id="getopt命令"   >
          <a href="#getopt命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#getopt命令" class="headerlink" title="getopt命令"></a>getopt命令</h1>
      <p>说实话，这部分当时书上讲得挺让我难受的，痛苦.jpg。</p>
<p><code>getopt</code>命令可以接受一系列任意形式的<strong>命令行选项和参数</strong>，并将它们转换成适当的格式。说白了，该函数就是用来<strong>解析</strong>命令行选项参数的。</p>
<p>使用：<code>getopt optstring parameters</code>。</p>
<p><code>optstring</code>定义了命令可以接受的命令行有效的<strong>选项字母</strong>（要分析的参数），在每个需要参数值的选项字母后面加一个冒号，其参数紧跟在选项后面或者隔一个空格；如果选项字母后面加了2个冒号，则参数和选项之间不能有空格。<code>getopt</code>会基于定义的<code>optstring</code>解析提供的参数。</p>
<p><code>paramters</code>是实际的参数列表。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举个例子</span></span><br><span class="line">cyan@cyan-virtual-machine:~$ getopt ab:cd -a -b test1 -cd test2 test3</span><br><span class="line"> -a -b test1 -c -d -- test2 test3</span><br></pre></td></tr></table></div></figure>

<p>上面例子可以看到，<code>optstring</code>是<code>ab:cd</code>，规定了命令可以接受的有效的选项<code>a,b,c,d</code>。<code>b</code>的后面有冒号，所以<code>-b</code>选项后面必须跟一个参数，例子中是<code>test1</code>。<code>-a -b test1 -cd test2 test3</code>是<code>parameters</code>，里面出现的选项不能是<code>optstring</code>之外的选项。</p>
<p>注意，它会自动将<code>-cd</code>选项分为两个单独的选项，并<strong>插入双破折号</strong>来分隔行中的额外参数。</p>
<p>为了帮你更好理解这个命令，我们会写一个脚本，但是在这之前，我希望你能知道<code>set</code>命令。该命令会将位置参数设置为固定的值</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat new_File</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo $1 $2 $3</span><br><span class="line">set -- 参数1 参数2 参数3</span><br><span class="line">echo $1 $2 $3</span><br><span class="line"></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ ./new_File para1 para2 para3</span><br><span class="line">para1 para2 para3</span><br><span class="line">参数1 参数2 参数3</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>现在写一个脚本</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">set</span> -- 会将命令行参数替换成<span class="built_in">set</span>命令的命令行值，挺重要的</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-q可以去掉报错信息，<span class="variable">$@</span>是得到脚本后面跟着的参数（字符串形式,同一个字符串多个单词）</span></span><br><span class="line">set -- $(getopt -q ab:cd &quot;$@&quot;)</span><br><span class="line"></span><br><span class="line">while [ -n $1 ]</span><br><span class="line">do</span><br><span class="line">    case &quot;$1&quot; in </span><br><span class="line">    -a) echo &quot;Found the -a option&quot; ;;</span><br><span class="line">    -b) param=&quot;$2&quot;</span><br><span class="line">        echo &quot;Found the -b option,with parameter value $param&quot;</span><br><span class="line">        shift ;;</span><br><span class="line">    -c) echo &quot;Found the -c option&quot; ;;</span><br><span class="line">    --) shift</span><br><span class="line">        break ;;</span><br><span class="line">    *) echo &quot;$1 is not an option&quot; ;;</span><br><span class="line">    esac</span><br><span class="line">    shift</span><br><span class="line">done</span><br></pre></td></tr></table></div></figure>

<p>所以，我们平时使用的命令的选项+参数，其原理差不多就是这样的（当然不排除更复杂的）。(⊙﹏⊙)，我觉得加上这个脚本例子，你应该很明白<code>getopt</code>到底是干什么的了吧。</p>

        <h1 id="getopts命令"   >
          <a href="#getopts命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#getopts命令" class="headerlink" title="getopts命令"></a>getopts命令</h1>
      <p>没错，我当时也很难受，费工夫理解<code>getopt</code>之后，又来一个。</p>
<p>该命令内建于<code>bash shell</code>，比<code>getopt</code>多了一些扩展功能。使用格式为：<code>getopts optstring variable</code><br><strong>每次只处理命令行一个参数</strong>，处理完所有参数后，就会退出并返回一个大于0的退出码。</p>
<ol>
<li>如果要想<code>getiopt -q</code>那样去掉错误信息，需要在<code>optstring</code>前加上一个冒号。</li>
<li><code>getopts</code>命令会将当前参数（选项）保存在命令行中定义的<code>variable</code>中</li>
<li><code>getopts</code>命令会用到两个环境变量。选项如果需要一个参数值，<code>OPTARG</code>环境变量就会保存这个值。<code>OPTIND</code>环境变量保存参数列表中<code>getopts</code>正在处理的参数位置。</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;OPTIND的值为:$OPTIND&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据第2点，当前选项会被保存在opt中</span></span><br><span class="line">while getopts :ab:c opt</span><br><span class="line">do</span><br><span class="line">    case &quot;$opt&quot; in</span><br><span class="line">    # 我写的是a而不是-a</span><br><span class="line">        a) echo &quot;Found the -a option&quot; ;;</span><br><span class="line">        b) echo &quot;Found the -b option,with value $OPTARG&quot; ;; # 选项后的参数值</span><br><span class="line">        c) echo &quot;Found the -c option&quot; ;;</span><br><span class="line">        *) echo &quot;Unkown option:$opt&quot;;;</span><br><span class="line">    esac</span><br><span class="line">    echo &quot;OPTIND的值为:$OPTIND&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></div></figure>

<p>如果我给的真实的参数列表为：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ ./tmp.txt -a -btest1 -c test2 test3</span><br></pre></td></tr></table></div></figure>

<p>得到的结果就是</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OPTIND的值为:1</span><br><span class="line">Found the -a option</span><br><span class="line">OPTIND的值为:2</span><br><span class="line">Found the -b option,with value test1</span><br><span class="line">OPTIND的值为:3</span><br><span class="line">Found the -c option</span><br><span class="line">OPTIND的值为:4</span><br></pre></td></tr></table></div></figure>

<p>从该脚本中，我们看到了<code>getopts</code>如何根据两个系统变量进行参数控制的。我们不妨将脚本内容改一下</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;OPTIND的值为:$OPTIND&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据第2点，当前选项会被保存在opt中</span></span><br><span class="line">while getopts :ab:c opt</span><br><span class="line">do</span><br><span class="line"><span class="meta prompt_">   # </span><span class="language-bash"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$opt</span>&quot;</span> <span class="keyword">in</span></span></span><br><span class="line">    #    a) echo &quot;Found the -a option&quot; ;;</span><br><span class="line">    #    b) echo &quot;Found the -b option,with value $OPTARG&quot; ;; # 选项后的参数值</span><br><span class="line">    #    c) echo &quot;Found the -c option&quot; ;;</span><br><span class="line">    #   *) echo &quot;Unkown option:$opt&quot;;;</span><br><span class="line">    #esac</span><br><span class="line">    echo $opt</span><br><span class="line">    echo &quot;OPTIND的值为:$OPTIND&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></div></figure>

<p>参数列表不变</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ ./tmp.txt -a -btest1 -c test2 test3</span><br><span class="line">OPTIND的值为:1</span><br><span class="line">a</span><br><span class="line">OPTIND的值为:2</span><br><span class="line">b</span><br><span class="line">OPTIND的值为:3</span><br><span class="line">c</span><br><span class="line">OPTIND的值为:4</span><br></pre></td></tr></table></div></figure>

<p>在<code>opt=c</code>之后还进行了一次循环，此时opt应该是到了其他参数（<code>test2,test3</code>）那里，但是不会存储相应的值，<code>opt</code>只存储选项的值。</p>

        <h1 id="read命令"   >
          <a href="#read命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#read命令" class="headerlink" title="read命令"></a>read命令</h1>
      <p><code>read</code>命令用于获取用户输入：</p>
<ul>
<li><code>read name</code>输入的数据就会保存在<code>name</code>中。</li>
<li><code>read -p &quot;Please enter your age:&quot; age</code>， <code>-p</code>参数允许指定输入提示语句。</li>
<li><code>read -p &quot;Please enter your name:&quot; firstname lastname</code>可以指定多个变量，如果输入大于变量个数，就会将剩下的输入全部保存在最后一个变量中。</li>
<li>不指定保存变量时，会将输入保存在环境变量<code>REPLY</code>中。</li>
<li><code>read -t 5 age</code>设置超时选项，如果规定时间没有完成输入，就会继续执行,单位是秒。</li>
<li><code>read -n1 -p &quot;Please enter [Y/N] to continue:&quot; ans</code>，可以通过<code>-n</code>对输入长度进行限制,数字可以与选项<code>-n</code>一起使用。给的例子中并且只要按下单个字符后，不需要按回车就会继续执行。</li>
<li><code>read -s -p &quot;Please enter the password:&quot; passwd</code>，<code>-s</code>会让输入时数据隐藏。</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从文件中读取，每次调用<span class="built_in">read</span>命令就会读取一行文本，当文件没有内容时，<span class="built_in">read</span>就会退出并返回非0退出状态码</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件数据传给<span class="built_in">read</span>，最常见的就是使用<span class="built_in">cat</span>，将结果通过管道直接传给含有<span class="built_in">read</span>命令的<span class="keyword">while</span>命令</span></span><br><span class="line"></span><br><span class="line">count=1</span><br><span class="line">cat data.txt | while read line</span><br><span class="line">do</span><br><span class="line">    echo &quot;Line $count:$line&quot;</span><br><span class="line">    count=$[$count + 1]</span><br><span class="line">done</span><br><span class="line">echo &quot;Finished proceessign the file&quot;</span><br></pre></td></tr></table></div></figure>




        <h1 id="最后"   >
          <a href="#最后" class="heading-link"><i class="fas fa-link"></i></a><a href="#最后" class="headerlink" title="最后"></a>最后</h1>
      <p>请多加练习。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/08/01/Shell/%E6%9E%84%E5%BB%BA%E5%9F%BA%E6%9C%AC%E8%84%9A%E6%9C%AC(2)/">构建基本脚本(2)</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-08-01</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-08-04</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="数学运算"   >
          <a href="#数学运算" class="heading-link"><i class="fas fa-link"></i></a><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h1>
      <p>在脚本中进行数学运算有很多种方式，你可以从下面选几种喜欢的</p>
<ul>
<li><code>exper</code>命令，支持基本的（逻辑、比较）运算符，对于有歧义的符号(如<code>*</code>)，需要用<code>\*</code>，<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-expr.html" >传送门</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">expr</span> 表达式</span></span><br><span class="line">expr length “this is a test”	#计算字串长度</span><br><span class="line">expr 14 % 9		#整数运算</span><br><span class="line">expr 2 \* 10	#注意。参数和符号之间必须要有空格</span><br></pre></td></tr></table></div></figure>

<ul>
<li><code>$[表达式]</code>，更加方便，符号不会出现歧义，但是只能整数运算。</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var1=$[1+5]</span><br></pre></td></tr></table></div></figure>

<ul>
<li><code>bc</code>计算器，实际上是一种编程语言，<code>-q</code>可以不显示<code>bash</code>计算器冗长的欢迎信息。浮点运算是由内建变量<code>scale</code>控制的，必须将这个值设置为计算结果希望保留的小数位数<code>scale</code>默认是0。</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~$ bc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">欢迎信息</span></span><br><span class="line">bc 1.07.1</span><br><span class="line">Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006, 2008, 2012-2017 Free Software Foundation, Inc.</span><br><span class="line">This is free software with ABSOLUTELY NO WARRANTY.</span><br><span class="line">For details type `warranty&#x27;.</span><br><span class="line">1+3</span><br><span class="line">4</span><br><span class="line">319+42</span><br><span class="line">361</span><br><span class="line"></span><br><span class="line">cyan@cyan-virtual-machine:~$ bc -q</span><br><span class="line">21/3</span><br><span class="line">7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">内建变量不能在外面修改</span></span><br><span class="line">cyan@cyan-virtual-machine:~$ echo $scale</span><br><span class="line"></span><br><span class="line">cyan@cyan-virtual-machine:~$ bc -q</span><br><span class="line">scale=3 #进入bc修改内建变量</span><br><span class="line">21/3</span><br><span class="line">7.000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">还有一种修改内建变量的方法，常用于脚本中，格式为<span class="built_in">echo</span> <span class="string">&quot;options;expression&quot;</span> | bc</span></span><br><span class="line">cyan@cyan-virtual-machine:~$ echo &#x27;21/4&#x27; | bc</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">cyan@cyan-virtual-machine:~$ echo &#x27;scale=4;21/4&#x27; | bc</span><br><span class="line">5.2500</span><br></pre></td></tr></table></div></figure>

<p>可见，通过管道，<code>bc</code>计算器还是挺好用的。再看一个输入重定向的例子</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~$ cat math.dat</span><br><span class="line">scale=4</span><br><span class="line">var1=1</span><br><span class="line">var2=29</span><br><span class="line">var3=5</span><br><span class="line">var1/var3+var2</span><br><span class="line"></span><br><span class="line">cyan@cyan-virtual-machine:~$ result=$(bc &lt; math.dat)</span><br><span class="line">cyan@cyan-virtual-machine:~$ echo $result</span><br><span class="line">29.2000</span><br></pre></td></tr></table></div></figure>

<p>有一点你可以看到，我们在<code>bc</code>中使用变量没有加<code>$</code>符号。最后，你也可以试试<strong>内联输入重定向</strong>，我想，应该没什么问题吧？</p>

        <h1 id="结构化语句"   >
          <a href="#结构化语句" class="heading-link"><i class="fas fa-link"></i></a><a href="#结构化语句" class="headerlink" title="结构化语句"></a>结构化语句</h1>
      <p>该部分我就直接给格式了，你记住了就会使用。</p>

        <h2 id="选择语句"   >
          <a href="#选择语句" class="heading-link"><i class="fas fa-link"></i></a><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h2>
      <p>我们如何对<code>if</code>中的条件进行判断？</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition1      #(退出状态码是0)   </span><br><span class="line">then</span><br><span class="line">    commands_1</span><br><span class="line">elif condition2</span><br><span class="line">then</span><br><span class="line">    commands_2</span><br><span class="line">else</span><br><span class="line">    commands_3</span><br><span class="line">fi</span><br></pre></td></tr></table></div></figure>

<p><code>condition</code>可以是一个命令的正确执行，也可以是字符串比较，数值比较，文件比较。</p>
<p>判断<code>condition</code>的命令为<code>test condtion</code>或者<code>[ condition ](必须有空格)</code>。同样的，如果有多个<code>condition</code>可以使用<code>&amp;&amp; , ||</code>。</p>
<p>举个例子</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat tmp.txt</span><br><span class="line">var=100</span><br><span class="line">if [ $var -ge 10 ] &amp;&amp; [ $var -le 190 ]</span><br><span class="line">then</span><br><span class="line">    echo &#x27;执行if语句块&#x27;</span><br><span class="line">else</span><br><span class="line">    echo &#x27;执行else语句块&#x27;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ ./tmp.txt</span><br><span class="line">执行if语句块</span><br></pre></td></tr></table></div></figure>

<p>再次声明，使用<code>[]</code>要加<strong>空格</strong>。</p>

        <h2 id="比较方式"   >
          <a href="#比较方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#比较方式" class="headerlink" title="比较方式"></a>比较方式</h2>
      <p><strong>数值比较</strong>：<code>n1 -eq n2</code></p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">符号选项</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-eq</td>
<td align="center">equals(&#x3D;&#x3D;)</td>
</tr>
<tr>
<td align="center">-gt</td>
<td align="center">greater than(&gt;)</td>
</tr>
<tr>
<td align="center">-ge</td>
<td align="center">greater equals(&gt;&#x3D;)</td>
</tr>
<tr>
<td align="center">-lt</td>
<td align="center">less than(&lt;)</td>
</tr>
<tr>
<td align="center">-le</td>
<td align="center">less equals(&lt;&#x3D;)</td>
</tr>
<tr>
<td align="center">-ne</td>
<td align="center">not equals(!&#x3D;)</td>
</tr>
</tbody></table></div>
<p><code>if [ $val -gt 5]</code> ，注意，bash shell只能使用整数。</p>
<p><strong>字符串比较</strong>：</p>
<p>直接使用<code>=,!=,\&gt;,\&lt;</code>(大于小于，必须使用转义，否则就会被认为是重定向)。 在比较测试中，<strong>大写字母&lt;小写字母**，如<code>a&gt;z&gt;A</code>。而<code>sort</code>命令恰好相反，<code>sort</code>使用的是系统本地化语言设置中定义的排序顺序。对于英语，</strong>本地化设置指定在排序顺序中，小写字母出现在大写字母前**。</p>
<p> <code>-n</code>和<code>-z</code>可以检查一个变量是否含有数据(未被定义的变量默认长度为0)</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if[ -n $val ]	#如果val长度不为0，就执行then</span><br><span class="line">if[ -z $val ]	#如果val长度为0，就执行then，z--zero</span><br></pre></td></tr></table></div></figure>

<p><strong>文件比较</strong>：</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">符号选项</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-d file</td>
<td align="center">检查file是否存在并是一个目录(directory)</td>
</tr>
<tr>
<td align="center">-e file</td>
<td align="center">检查file是否存在(exits)</td>
</tr>
<tr>
<td align="center">-f file</td>
<td align="center">检查file是否存在并是否是一个文件</td>
</tr>
<tr>
<td align="center">-r file</td>
<td align="center">检查file是否存在并是否可读</td>
</tr>
<tr>
<td align="center">-s file</td>
<td align="center">检查file是否存在并是否非空</td>
</tr>
<tr>
<td align="center">-w file</td>
<td align="center">检查file是否存在并是否可写</td>
</tr>
<tr>
<td align="center">-x file</td>
<td align="center">检查file是否存在并是否可执行</td>
</tr>
<tr>
<td align="center">-G file</td>
<td align="center">检查file是否存在并且默认组与当前用户相同</td>
</tr>
<tr>
<td align="center">-O file</td>
<td align="center">检查file是否存在并是否并属当前用户所有</td>
</tr>
<tr>
<td align="center">file1 -nt file2</td>
<td align="center">检查file1是否比file2新</td>
</tr>
<tr>
<td align="center">file1 -ot file2</td>
<td align="center">检查file1是否比file2旧</td>
</tr>
</tbody></table></div>

        <h3 id="case语句"   >
          <a href="#case语句" class="heading-link"><i class="fas fa-link"></i></a><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h3>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">case variable in                            </span><br><span class="line">pattern1 | pattern2)    commands1;;        </span><br><span class="line">pattern3)   commands2;;                         </span><br><span class="line">*) defalut commands3;;                      </span><br><span class="line">esac                                       </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例子</span></span><br><span class="line">case $USER in</span><br><span class="line">Bob | Mike)</span><br><span class="line">	echo &quot;Number one&quot;;;</span><br><span class="line">Cyan)</span><br><span class="line">     echo &quot;Cyan&quot;;;</span><br><span class="line">*)</span><br><span class="line">	 echo &quot;Have not found&quot;;;</span><br><span class="line">esac                                 </span><br></pre></td></tr></table></div></figure>




        <h2 id="循环语句"   >
          <a href="#循环语句" class="heading-link"><i class="fas fa-link"></i></a><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2>
      
        <h3 id="for循环"   >
          <a href="#for循环" class="heading-link"><i class="fas fa-link"></i></a><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for var in list         </span><br><span class="line">do</span><br><span class="line">    commands                </span><br><span class="line">done                    </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">例子</span></span><br><span class="line">for test in Alabama Alaska Arizona Arkansas California</span><br><span class="line">do</span><br><span class="line">	echo The state is $test</span><br><span class="line">done</span><br></pre></td></tr></table></div></figure>

<ul>
<li><p><code>$test</code>变量在剩余的<code>shell</code>脚本一直有效并且保持着最后一个变量的值(当然是可以修改的)</p>
</li>
<li><p><code>list</code>中单个元素出现了单引号，空格等，要么在这个单独变量外部直接再使用一对引号，要么直接使用<code>\</code>转义字符</p>
</li>
<li><p><code>list</code>的获取，也可以用<strong>命令的输出+命令替换</strong>：<code>for var in $(cat file)</code>，甚至是<code>/home/cyan/test/*</code>路径。当然，如果变量是文件名，要考虑文件名可能出现空格，那么在使用时就要使用引号：<code>&quot;$file&quot;</code>。</p>
</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">模拟<span class="built_in">ls</span>指令，打印指定目录下的所有文件（当然这里目录固定为home/cyan）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果想像<span class="built_in">ls</span> 路径那样传参数，需要用到之后的知识</span></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat tmp.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/bin/bash</span></span><br><span class="line">for file_name in /home/cyan/*</span><br><span class="line">do</span><br><span class="line">        echo $file_name</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ ./tmp.txt</span><br><span class="line">/home/cyan/Desktop</span><br><span class="line">/home/cyan/Documents</span><br><span class="line">/home/cyan/Downloads</span><br><span class="line">/home/cyan/Files</span><br><span class="line">/home/cyan/Music</span><br><span class="line">/home/cyan/OSIntroduction</span><br><span class="line">/home/cyan/Pictures</span><br><span class="line">/home/cyan/Public</span><br><span class="line">/home/cyan/shtool-2.0.8</span><br><span class="line">/home/cyan/shtool-2.0.8.tar.gz</span><br><span class="line">/home/cyan/snap</span><br><span class="line">/home/cyan/Templates</span><br><span class="line">/home/cyan/Videos</span><br><span class="line">/home/cyan/vmware-tools-distrib</span><br></pre></td></tr></table></div></figure>

<ul>
<li>在<code>list</code>中，各个元素之间的分隔符是由<code>IFS</code>–内部字段分隔符决定的，一般会将<strong>空格，制表符，换行符</strong>作为默认字段分隔符如果想要更改分隔符，就必须在<code>shell</code>脚本<code>for</code>循环前面更改<code>IFS</code>。</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat data</span><br><span class="line">jack bob cyan mike</span><br><span class="line">mary smith</span><br><span class="line"></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat tmp.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/bin/bash</span></span><br><span class="line">for name in `cat data`</span><br><span class="line">do</span><br><span class="line">        echo $name</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">得到的结果</span></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ ./tmp.txt</span><br><span class="line">jack</span><br><span class="line">bob</span><br><span class="line">cyan</span><br><span class="line">mike</span><br><span class="line">mary</span><br><span class="line">smith</span><br></pre></td></tr></table></div></figure>

<p>这是因为<code>IFS</code>默认的是空格，制表符，换行符。在遇到第一个空格时，就已经分隔了。如果想要只以换行符为分隔符</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat tmp.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/bin/bash</span></span><br><span class="line">oldIFS=$IFS</span><br><span class="line">IFS=$&#x27;\n&#x27;</span><br><span class="line"></span><br><span class="line">for file_name in `cat data`</span><br><span class="line">do</span><br><span class="line">        echo $file_name</span><br><span class="line">done</span><br><span class="line">IFS=$oldIFS</span><br><span class="line"></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ ./tmp.txt</span><br><span class="line">jack bob cyan mike</span><br><span class="line">mary smith</span><br></pre></td></tr></table></div></figure>

<p>C语言风格的for循环</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (( i=1;i &lt;= 20;i++ )) # i=$(expr $i+1)  i=$[$i + 1]   i=$(echo &quot;scale=0;$i + 1&quot; | bc)</span><br><span class="line">do</span><br><span class="line">    commands</span><br><span class="line">done</span><br></pre></td></tr></table></div></figure>


        <h3 id="while循环"   >
          <a href="#while循环" class="heading-link"><i class="fas fa-link"></i></a><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">while test conitions</span><br><span class="line">do</span><br><span class="line">    commands</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">test</span>的替代物[]需要两边空格，而<span class="built_in">expr</span>的替代物$[]不需要两边空格</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">while</span>命令允许执行多个测试命令，但是只有最后一个测试命令的退出状态码会被用于决定什么时候结束循环</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  比如：<span class="keyword">while</span> [<span class="variable">$var1</span> -ge 0]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">              <span class="built_in">echo</span> <span class="variable">$var1</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  就是一个死循环</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意，每个测试命令单独一行</span>                </span><br></pre></td></tr></table></div></figure>


        <h3 id="until命令"   >
          <a href="#until命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#until命令" class="headerlink" title="until命令"></a>until命令</h3>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">until test commands</span><br><span class="line">do</span><br><span class="line">    commands</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">until语句，只有测试条件的退出码非0，才会执行循环中列出的命令。</span></span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/08/01/Shell/%E6%9E%84%E5%BB%BA%E5%9F%BA%E6%9C%AC%E8%84%9A%E6%9C%AC(1)/">构建基本脚本(1)</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-08-01</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-08-01</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h1>
      <p>之前在<code>shell</code>快速入门中已经讲了如何构建一个脚本，我们回顾一下：</p>
<ul>
<li>第一行要指定shell类型<code>#!/bin/bash</code>。</li>
<li>完成基本的脚本构建后，增加执行权限<code>chmod u+x 文件名(u是属主)</code>。</li>
<li>要取消<code>echo</code>的换行，就要使用<code>-n</code>参数<code>echo -n &quot;abcd&quot;</code>。</li>
<li>使用美元符号<code>$</code>来引用变量，如果想单纯使用这个符号，要加上转义符<code>\$</code>。</li>
<li>在脚本中自行设置变量时，&#x3D;之间不能有空格，不然shell会认为是命令而不是变量<code>var=100</code>。</li>
</ul>
<p>本文会接着介绍其他与脚本编程相关的知识。</p>

        <h1 id="命令替换"   >
          <a href="#命令替换" class="heading-link"><i class="fas fa-link"></i></a><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h1>
      <p><code>shell</code>脚本最有用的特性之一就是可以<strong>从命令输出中提取信息</strong>，请<code>get</code>关键词，<strong>命令输出</strong>和<strong>提取信息</strong>。</p>
<p>该特性有两种实现方式：</p>
<ul>
<li>使用反引号（就是<code>Tab</code>键上面那个）</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">date</span>命令可以得到当前时间cyan@cyan-virtual-machine:~/Templates$ <span class="built_in">cat</span> new_File</span></span><br><span class="line">214391248</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat new_File</span><br><span class="line">214391248</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ echo `date` &gt; new_File</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat new_File</span><br><span class="line">2022年 08月 01日 星期一 10:42:33 CST</span><br><span class="line">cyan@cyan-virtual-machine:~$ var=`date`</span><br><span class="line">cyan@cyan-virtual-machine:~$ echo $var</span><br><span class="line">2022年 08月 01日 星期一 10:21:55 CST</span><br></pre></td></tr></table></div></figure>

<ul>
<li>使用<code>$()</code>，有些<code>shell</code>不支持这种</li>
</ul>
<p>	</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~$ var=$(date)</span><br><span class="line">cyan@cyan-virtual-machine:~$ echo $var</span><br><span class="line">2022年 08月 01日 星期一 10:23:19 CST</span><br></pre></td></tr></table></div></figure>

<p>命令替换会创建一个子<code>shell</code>来运行对应命令，子<code>shell</code>是由运行脚本的<code>shell</code>创建的一个独立的子<code>shell</code>。因此，该子<code>shell</code>所执行的命令是无法使用脚本中所创建的变量的。在命令行提示符下使用路径.&#x2F;来运行命令，也会创建子<code>shell</code></p>
<p>关于<code>date</code>命令，你如果希望得到自己希望的格式化结果</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~$ date +%y-%m-%d\ %H:%M:%S</span><br><span class="line">22-08-01 10:25:33</span><br></pre></td></tr></table></div></figure>




        <h1 id="重定向"   >
          <a href="#重定向" class="heading-link"><i class="fas fa-link"></i></a><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1>
      <p>从这里开始，你就算接触流这个东西了，输入流输出流，<strong>重定向就是对流的方向重新定义</strong>（你现在可以这么理解）。</p>

        <h2 id="标准输出重定向"   >
          <a href="#标准输出重定向" class="heading-link"><i class="fas fa-link"></i></a><a href="#标准输出重定向" class="headerlink" title="标准输出重定向"></a>标准输出重定向</h2>
      <p>举一个例子，<code>echo</code>将数据打印到屏幕上（标准输出流），那么我们可以对<code>echo</code>的流的方向重新<strong>指向</strong></p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat new_File</span><br><span class="line">214391248</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat new_File</span><br><span class="line">214391248</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ echo `date` &gt; new_File</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat new_File</span><br><span class="line">2022年 08月 01日 星期一 10:42:33 CST</span><br></pre></td></tr></table></div></figure>

<p>从上面代码可以看到，<code>echo</code>通过<code>&gt;</code>符号，将输出重定向到<code>new_File</code>这个文件里面了。并且<strong>先清空文件原本内容</strong>。</p>
<p><code>command &gt;&gt; outputfile</code>  是追加模式。</p>

        <h2 id="标准输入重定向"   >
          <a href="#标准输入重定向" class="heading-link"><i class="fas fa-link"></i></a><a href="#标准输入重定向" class="headerlink" title="标准输入重定向"></a>标准输入重定向</h2>
      <p>将文件内容重定向到命令：<code>command &lt; inputfile</code></p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">wc</span>命令可以对数据文本进行计数：文本行数  文本字数  文本字节数</span></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ wc &lt; new_File</span><br><span class="line"> 1  6 43</span><br></pre></td></tr></table></div></figure>

<p>这里有个需要注意的地方就是，<code>&lt;</code>是改变标准输出（屏幕），<code>&gt;</code>是改变标准输入（键盘）。<strong>重定向不是代替参数，而是改变标准输入输出</strong>。</p>
<p>比如以下命令就不行</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &lt; new_File</span><br></pre></td></tr></table></div></figure>

<p><code>echo</code>的使用格式是<code>echo 参数</code>，重定向不能替代参数。</p>
<p><code>wc</code>后面接收的可以是标准输入</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ wc</span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">      2       2      12 # 使用ctrl+d结束命令并统计</span><br></pre></td></tr></table></div></figure>




        <h2 id="内联重定向"   >
          <a href="#内联重定向" class="heading-link"><i class="fas fa-link"></i></a><a href="#内联重定向" class="headerlink" title="内联重定向"></a>内联重定向</h2>
      <blockquote>
<p>可以参考：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38156104/article/details/110375889" >https://blog.csdn.net/qq_38156104/article/details/110375889</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>替换文件为文本，数据流向命令：<code>command &lt;&lt; 特殊字符</code></p>
<p>数据的开始和结束文本标记要一致。本质就是将开始符和结束符之间的数据传给命令</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ wc &lt;&lt;EOF</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">123</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">4142</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">EOF</span></span><br><span class="line">2 2 9</span><br></pre></td></tr></table></div></figure>




        <h1 id="管道"   >
          <a href="#管道" class="heading-link"><i class="fas fa-link"></i></a><a href="#管道" class="headerlink" title="管道"></a>管道</h1>
      <p>一个命令的<strong>标准输出</strong>作为另一个命令的标准输入</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa &gt; rpm.list</span><br><span class="line">sort &lt; rpm.list</span><br></pre></td></tr></table></div></figure>

<p><code>rpm</code>命令通过<code>RedHat</code>包管理系统(<code>RPM</code>)对系统上安装的软件包进行管理。配合<code>-qa</code>选项使用时，会生成已安装包的列表，尽管不会排序。(虽然我在终端执行上面两个命令没啥反应)</p>
<p>重定向在命令之间数据传输比较繁琐，使用管道 <code>|</code> 解决。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command | command</span><br></pre></td></tr></table></div></figure>

<p>为了更好了解管道，我写了一个<code>c</code>程序，文件为<code>test.c</code>。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>,<span class="title">end</span>;</span></span><br><span class="line">        <span class="type">int</span> fd = open(<span class="string">&quot;./tmp&quot;</span>,O_RDONLY);</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> bf[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">                gettimeofday(&amp;start,<span class="literal">NULL</span>);</span><br><span class="line">                read(fd,bf,<span class="number">10</span>);</span><br><span class="line">                gettimeofday(&amp;end,<span class="literal">NULL</span>);</span><br><span class="line">                <span class="comment">//printf(&quot;%s&quot;,bf);</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,end.tv_usec - start.tv_usec);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>在<code>linux</code>中可以用<code>cat</code>查看，如果在后面接上<code>sort</code>命令</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat test.c | sort</span><br></pre></td></tr></table></div></figure>

<p>其输出结果为</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="type">char</span> bf[<span class="number">10</span>];</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">for</span>(i;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">                gettimeofday(&amp;end,<span class="literal">NULL</span>);</span><br><span class="line">                gettimeofday(&amp;start,<span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">        <span class="type">int</span> fd = open(<span class="string">&quot;./tmp&quot;</span>,O_RDONLY);</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">                <span class="title function_">printf</span><span class="params">(<span class="string">&quot;%d&quot;</span>,end.tv_usec - start.tv_usec)</span>;</span><br><span class="line">                <span class="comment">//printf(&quot;%s&quot;,bf);</span></span><br><span class="line">                read(fd,bf,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>,<span class="title">end</span>;</span></span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/07/31/Shell/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/">Linux文件权限</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-07-31</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-07-31</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="Linux安全性"   >
          <a href="#Linux安全性" class="heading-link"><i class="fas fa-link"></i></a><a href="#Linux安全性" class="headerlink" title="Linux安全性"></a>Linux安全性</h1>
      <p><code>Linux</code>安全系统核心是用户账户，用户账户通过创建用户时分配的用户<code>ID(UID)</code>来跟踪。<code>/etc/password</code>文件将用户的登录名匹配到对应的<code>UID</code>的值<br><code>root</code>账户是<code>Linux</code>管理员，固定分配给的<code>UID</code>是0。<code>Linux</code>会为各种各样的功能创建不同的用户账户，这些账户不是真正的用户，而是系统账户，是系统上运行各种服务进程访问资源用的特殊账户。所有运行在后台的服务都需要用一个系统用户账户登录到Linux系统上！！<strong>在意识到安全问题之前</strong>，许多服务都用<code>root</code>登陆，如果其中一个服务被攻陷，<code>root</code>权限就会被入侵。</p>
<p><code>/etc/shadow</code>文件，该文件记录各个账户之间密码记录。该文件只有<code>root</code>才有权限操作，所以如果我们不是<code>root</code>用户登录，就需要使用<code>sudo</code>命令。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~$ sudo cat /etc/shadow</span><br><span class="line">[sudo] password for cyan:</span><br><span class="line">root:!:18999:0:99999:7:::</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其他信息就不展示了</span></span><br></pre></td></tr></table></div></figure>

<p>每一行就是一个用户，分为九个字段，分别是:<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/sherlockmj/article/details/106786520" >参考文章传送门</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>
<ul>
<li>与<code>/etc/passwd</code>文件中对应的登录名。</li>
<li><strong>加密后</strong>的密码，也就是说，你不能直接看到这个密码。</li>
<li>自上次修改密码后过去的天数，上面的<code>root</code>是18999，就是从1970.1.1不断累加得到的时间，可以使用命令 <code>date -d &quot;1970-01-01 18999 days&quot;</code>查看具体时间。</li>
<li>最小修改时间间隔，该字段规定了从第 3 字段（最后一次修改密码的日期）起，<strong>多长时间之内不能修改密码</strong>。如果是 0，则密码可以随时修改；如果是 10，则代表密码修改后 10 <strong>天</strong>之内不能再次修改密码。</li>
<li>密码有效期，默认值为 99999，也就是273年。</li>
<li>密码需要变更前的警告天数，当账户密码有效期快到时，系统会发出警告信息给此账户，提醒用户 “再过 n 天你的密码就要过期了，请尽快重新设置你的密码！”。</li>
<li>密码过期后的宽限天数，过期后，在宽限天数内还是可以登录。</li>
<li>账号失效时间，该字段通常被使用在具有收费服务的系统中。</li>
<li>最后一个，保留，还没有使用。</li>
</ul>

        <h1 id="添加新用户"   >
          <a href="#添加新用户" class="heading-link"><i class="fas fa-link"></i></a><a href="#添加新用户" class="headerlink" title="添加新用户"></a>添加新用户</h1>
      <p>使用<code>useradd</code>命令，可以一次性创建新用户账户及设置用户<code>HOME</code>目录结构。<code>useradd</code>命令使用系统默认值以及命令行参数设置用户账户。</p>
<p>系统默认值被设置在<code>/etc/default/useradd</code>，可以使用<code>useradd -D</code>检查默认值</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~$ useradd -D</span><br><span class="line">GROUP=100		# 新用户被添加到GID=100的公共组</span><br><span class="line">HOME=/home		# 新的home目录位于/home/loginname</span><br><span class="line">INACTIVE=-1		# 密码过期后不会被禁用</span><br><span class="line">EXPIRE=			# 未设置过期日期</span><br><span class="line">SHELL=/bin/sh</span><br><span class="line">SKEL=/etc/skel	# 将/etc/skel目录下内容复制到用户的home下</span><br><span class="line">CREATE_MAIL_SPOOL=no	# 是否为该用户在mail目录下创建一个接受邮件的文件</span><br></pre></td></tr></table></div></figure>

<p>上述的系统默认值是可以更改的，在<code>useradd</code>时，加入参数进行更改</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-b  default_home    # 更改默认的创建用户HOME目录的位置</span><br><span class="line">-e  expirtion_date  # 更改默认的新账户的过期日期</span><br><span class="line">-f  inactive        # 更改默认的新用户从密码过期到账户被禁用的天数</span><br><span class="line">-g  group           # 更改默认的组名称或GID</span><br><span class="line">-s  shell           # 更改默认登录shell</span><br></pre></td></tr></table></div></figure>




        <h1 id="删除用户"   >
          <a href="#删除用户" class="heading-link"><i class="fas fa-link"></i></a><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h1>
      <p><code>userdel</code>命令，默认情况下只会删除<code>/etc/passwd</code>文件中的用户信息，而不会删除系统中属于该账户的任何文件，<code>userdel -r</code>会删除用户的HOME目录以及邮件目录。</p>

        <h1 id="修改用户"   >
          <a href="#修改用户" class="heading-link"><i class="fas fa-link"></i></a><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h1>
      <p><code>usermod,chsh,chfn,chage</code>这几个指令要用到再自己百度，平时用不到，隔不了多久就会忘记。</p>

        <h1 id="Linux组"   >
          <a href="#Linux组" class="heading-link"><i class="fas fa-link"></i></a><a href="#Linux组" class="headerlink" title="Linux组"></a>Linux组</h1>
      <p>linux通过将具有相同特性的用户划归为一个组，可以大大简化用户的管理，方便用户之间文件的共享。任何一个用户都至少属于一个组，这个组称为初始组，可以同时属于多个附加组。用户不仅拥有初始组的权限，还拥有附加组的权限。</p>
<p>在<code>/etc/group</code>文件中，包含系统上用到的每个组的信息，4个字段：<strong>组名:组密码:GID:属于该组的用户列表</strong></p>
<p>用户列表中某些组没有列出用户，并不代表没有成员，只是加入了成员，不会出现在该文件中。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建组</span></span><br><span class="line">groupadd 组名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后期将成员加入到指定组</span></span><br><span class="line">usermod -G 组名 成员名</span><br></pre></td></tr></table></div></figure>




        <h1 id="文件权限"   >
          <a href="#文件权限" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h1>
      <p>在本系列第一篇文章中，为了运行一个新建脚本，需要使用<code>chmod u+x 文件名</code>。查看一个文件，我们可以使用<code>ll</code></p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ ll</span><br><span class="line">total 16</span><br><span class="line">drwxr-xr-x  2 cyan cyan 4096 7月  30 19:09 ./</span><br><span class="line">drwxr-xr-x 21 cyan cyan 4096 7月  30 19:09 ../</span><br><span class="line">-rw-rw-r--  1 cyan cyan    0 7月  28 15:50 new_File</span><br><span class="line">-rwxrw-r--  1 cyan cyan   49 7月  30 19:09 test*</span><br><span class="line">-rwxrw-r--  1 cyan cyan   31 7月  29 16:18 test_1.sh*</span><br></pre></td></tr></table></div></figure>

<p>得到的结果中，第一位有些是<code>d</code>，有些是<code>-</code>。第一个代表了文件(-)&#x2F;目录(d)&#x2F;链接(l)&#x2F;字符型设备(c)&#x2F;块设备(b)&#x2F;网络设备(n)。</p>
<p>后面一共是9位，每3位为一个部分（分别表示rwx），这<strong>三个部分</strong>依次属于<strong>文件属主（创建文件的用户）</strong>，<strong>属组成员</strong>，<strong>其他用户</strong>权限。</p>
<p>目录或者文件一开始创建时，会授予默认权限，默认权限与<code>umask</code>值有关。三个用户权限（<strong>三个部分</strong>）各自占用一个八进制位（0-7），一个部分的权限从<code>&#39;---&#39;</code>到<code>&#39;rwx&#39;</code>在八进制位中表示为<code>0-7</code>，如<code>rw-</code>就是6。三个部分合在一个，就是<code>000-777</code>，也就是<code>---------到rwxrwxrwx</code>。</p>
<p><code>umask</code>命令用于<strong>设置</strong>创建文件或是目录的<strong>默认权限</strong>，我们先在终端输入<code>umask</code>命令</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ umask</span><br><span class="line">0002</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">你的终端可能会输出0022，我好像是在环境文件做过持久化更改（有点记不清了）</span></span><br></pre></td></tr></table></div></figure>

<p>第一位是一个关于特殊权限的位，可以暂时不管。后面三个与默认权限有关。</p>
<p>对于文件而言，默认的最大权限就是<code>666</code>，也就是<code>rw-rw-rw-</code>，目录的默认最大权限是<code>777</code>。如果你学过计算机网络，你会知道<strong>掩码</strong>这个东西。这里就是，最大默认权限<strong>减去</strong>掩码就会得到文件（目录）创建时赋予的权限。</p>
<p>比如我的掩码<code>umask=0002</code>，那么创建文件时，<code>666-002=664</code>，得到的权限就是<code>rw-rw-r--</code></p>
<p>验证一下</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ touch tmp.txt</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ ll tmp.txt</span><br><span class="line">-rw-rw-r-- 1 cyan cyan 0 7月  31 21:30 tmp.txt</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ umask</span><br><span class="line">0002</span><br></pre></td></tr></table></div></figure>

<p>这里有一篇<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.51cto.com/u_15127673/2803517" >文章</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>参考。</p>

        <h1 id="更改权限"   >
          <a href="#更改权限" class="heading-link"><i class="fas fa-link"></i></a><a href="#更改权限" class="headerlink" title="更改权限"></a>更改权限</h1>
      <p>通过<code>chmod</code>命令，可以修改文件的权限</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">chmod</span> 3位八进制权限码 文件名</span></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ chmod 777 tmp.txt</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ ll tmp.txt</span><br><span class="line">-rwxrwxrwx 1 cyan cyan 0 7月  31 21:30 tmp.txt*</span><br></pre></td></tr></table></div></figure>

<p>如果你只是想改变某一部分（属主，组内用户，其他用户）的权限，可以使用</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x 文件名 # 属主增加执行权限</span><br><span class="line">chmod g-rx 文件名 # 组内用户减少</span><br><span class="line">chmod o=rwx 文件名 # 其他用户的权限为rwx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例</span></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ chmod g-rx tmp.txt</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ ll tmp.txt</span><br><span class="line">-rwx-w-rwx 1 cyan cyan 0 7月  31 21:30 tmp.txt*</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">说明</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">u:表示用户(属主)  g:表示组  o:表示其他  a:表示所有</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">+:增加  -:减少  =:赋值</span></span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/07/31/Database/MySQL/B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/">B+树索引的使用</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-07-31</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-07-31</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h1>
      <p>本文主要讲解索引的具体工作原理以及代价，如何正确的建立索引才能使查询变快。在阅读本文前，请一定保证对之前更新的内容（B+树索引）理解明白。</p>
<p>现在我们先创建一个表，之后方便举例</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">create table single_table (</span><br><span class="line">    id int not null auto_increment</span><br><span class="line">    key1 varchar(100),</span><br><span class="line">    key2 int</span><br><span class="line">    key3 varchar(100),</span><br><span class="line">    key_part1 varchar(100),</span><br><span class="line">    key_part2 varchar(100),</span><br><span class="line">    key_part3 varchar(100),</span><br><span class="line">    common_field varchar(100),</span><br><span class="line">    primary key(id),</span><br><span class="line">    key idx_key1(key1),</span><br><span class="line">    unique key uk_key2(key2),</span><br><span class="line">    key idx_key3(key3),</span><br><span class="line">    key idx_key_part(key_part1,key_part2,key_part3)</span><br><span class="line">) engine=InnoDB character set=utf8; </span><br></pre></td></tr></table></div></figure>




        <h1 id="简化B-树示意图"   >
          <a href="#简化B-树示意图" class="heading-link"><i class="fas fa-link"></i></a><a href="#简化B-树示意图" class="headerlink" title="简化B+树示意图"></a>简化B+树示意图</h1>
      <p>我们知道，B+树的非叶子节点是目录项，它是为了定位下一层节点，直到在叶子节点找到对应的记录。其查询算法的本质还是在每个页中使用<strong>二分查找</strong>找到下一层对应的页。那么我们不如将B+树直接简化，只剩下叶子节点。</p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/4/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/icons/logo.png" alt="avatar"></div><p class="sidebar-ov-author__text">You have lots more to work on</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">61</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">2</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">9</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh_tw" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Cyan</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.2.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.7.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.7.0"></script><script src="/js/stun-boot.js?v=2.7.0"></script><script src="/js/scroll.js?v=2.7.0"></script><script src="/js/header.js?v=2.7.0"></script><script src="/js/sidebar.js?v=2.7.0"></script><script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},t.src!==i&&(n.src=i)}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body></html>