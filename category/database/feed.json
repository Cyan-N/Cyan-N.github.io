{
    "version": "https://jsonfeed.org/version/1",
    "title": "慕青の迷途 • All posts by \"database\" category",
    "description": "时雨病重症患者！！！",
    "home_page_url": "https://cecilia.cool",
    "items": [
        {
            "id": "https://cecilia.cool/2022/07/28/Database/MySQL/B-%E6%A0%91%E7%B4%A2%E5%BC%95/",
            "url": "https://cecilia.cool/2022/07/28/Database/MySQL/B-%E6%A0%91%E7%B4%A2%E5%BC%95/",
            "title": "B+树索引",
            "date_published": "2022-07-28T01:42:18.000Z",
            "content_html": "<h1 id=\"简介\"><a class=\"anchor\" href=\"#简介\">#</a> 简介</h1>\n<p>我们使用 sql 语句查询某条记录时</p>\n<pre><code class=\"language-mysql\">select * from 表名 where 列名 = xxx;\n</code></pre>\n<p><code>where</code>  后面跟着的是查询条件，我们之前学的，页中的记录是根据主键排序的（如果没有主键，就根据不能为 NULL 的唯一的数据排序，如果这样的属性也没有，就按照 <code>row_id</code>  排序）。</p>\n<p>那么在没有创建索引的情况下，如果我们的查询条件是根据主键查询，那么在页中就可以通过二分查找快速获取数据，但是如果 <code>where</code>  后面跟着的是一个非主键属性，那么在页中就只能从 <code>Infimum</code>  到 <code>Supremum</code>  一条一条的<strong>顺序查找</strong>，<strong>一下子就慢很多</strong>。</p>\n<p>所以我们必须找到一种高效的搜索方法 —— 索引。</p>\n<h1 id=\"索引\"><a class=\"anchor\" href=\"#索引\">#</a> 索引</h1>\n<p>先建一个表，后面方便演示例子。</p>\n<pre><code class=\"language-mysql\">create table index_demo (\n    c1 int,\n    c2 int,\n    c3 char(1)，\n    primary key (c1)\n) row_format = COMPACT;\n</code></pre>\n<p>我们知道，一个页默认只有 16KB，存储的记录是有限的，所以一个表往往需要很多个页，<strong>页之间的记录也必须保持顺序</strong>，也就是说，<strong>页 A 的记录主键值必须大于上一个页的记录主键值，小于下一页的记录的主键值</strong>（当然，这里面不包含 <code>Infimum</code>  和 <code>Supremum</code> ）。</p>\n<p>前文讲页结构时， <code>File Header</code>  中对于页号的规定使得<strong>数据页之间连成双向链表</strong>，我们期望为快速定位记录所在的数据页而建立一个别的目录，该目录实现：</p>\n<ul>\n<li>下一个数据页的记录的主键 &gt; 上一个数据页记录的主键。</li>\n</ul>\n<p>为了实现这个状态，存在<strong>页分裂</strong>的机制。假设上一个页已经满了，最后一条记录主键是 100，现在又加入一条记录，主键为 90。那么新加入的这条记录就会放到该页末尾，主键为 100 的记录会被分到新的一个页。</p>\n<ul>\n<li>给所有页建立一个<strong>目录项</strong></li>\n</ul>\n<p>此处是关于页的目录其实对于页的查找也是二分（就是根据页目录，之前的槽 <code>Slot</code>  是关于记录的 <code>Page Directory</code> ）。<strong>每个页对应一个目录项</strong>，每个<strong>目录项</strong>包括两部分：<strong>页的最小主键值</strong> +<strong> 页号</strong> <code>page_no</code> 。插入记录时，根据主键值，在所有<strong>目录项</strong>下进行二分查找，找到合适的页后，根据页中的 <code>Page Directory</code>  进行二分查找，然后页分裂（如果有的话）。最重要的就是，这个目录就叫 ——<strong> 索引</strong>。</p>\n<h2 id=\"简单的索引方案\"><a class=\"anchor\" href=\"#简单的索引方案\">#</a> 简单的索引方案</h2>\n<p>为了实现通过<strong>目录项</strong>来进行二分查找，我们也要<strong>管理目录项</strong>，使其在增删改查时保持有序，所以也把它们放在页中进行管理，这种记录就是<strong>目录项记录</strong> <code>record_type = 1</code> （你还记得 <code>record_type</code>  为 0，2，3 时是什么意思吗）, 该记录也就只有主键值和页号，<strong>当然头信息也是存在的</strong>，因为只有主键值（如果不是变长字段或变长字符集），所以没有变长字段长度列表，也没有 NULL 列表。</p>\n<p>不断累积，目录项页也存在目录项，这样的目录项又被放进新的目录项页（只不过在上一层），不断向上递归，形成 B + 树。</p>\n<p>说了那么多，不看图总是懵逼的。</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/07/28/f4fdab5241230111.png\" alt=\"image-20220728104845461\" /></p>\n<p>这个图画的我难受。。。。</p>\n<p>上图为了简略，一个记录的内容我只画了： <code>record_type</code> + <code>next_record</code> + <code>c1</code> + <code>c2</code> + <code>c3</code> 。</p>\n<p>从图中可以看出，我们真正的记录是放在 B + 树中的叶子节点，存放目录项记录的都是内节点。</p>\n<p><code>Page Header</code>  里面有个属性就是 <code>PAGE_LEVEL</code>  表示该页在 B + 树中的层级。其实我们谈索引，什么对某个属性 A 创建索引，其实就是创建以 A 排序的 B + 树（当然，这么说不准确，B + 树内容不同，但是你可以这么理解）。我们一开始创建表，指定 <code>c1</code>  为主键，那么我们插入记录时， <code>InnoDB</code>  就会维护上图的 B + 树，使其有序。如果我们创建关于 <code>c2</code>  的索引，我们就会得到一个关于 <code>c2</code>  排序的 B + 树。</p>\n<blockquote>\n<p>索引的 B + 树和真正的主键的 B + 树有什么不同，之后讲到回表你就懂了</p>\n</blockquote>\n<h2 id=\"索引种类\"><a class=\"anchor\" href=\"#索引种类\">#</a> 索引种类</h2>\n<p><strong>聚簇索引</strong>：在 InnoDB 中，聚簇索引就是数据的存储方式，所有记录都存在叶子节点，“索引即数据，数据即索引”</p>\n<p>二级索引：聚簇索引只有在搜索条件为主键时才能发挥作用，如果以其他列为搜索条件，就要创建关于他们的索引（B + 树）才行，这就是二级索引。假设对 <code>c2</code>  创建索引，该二级索引 B + 树的叶子节点的记录存储的就是<strong> c2 + 主键值</strong>。当我们在二级索引中找到对应的 <code>c2</code> ，我们就可以拿到对应的主键值，然后<strong>再去聚簇索引中找到真正完整的数据，这就是回表</strong>。二级索引之所以不存储完整的记录，<strong>那肯定是为了节省空间啊</strong>。</p>\n<p>联合索引：其本质就是二级索引，因为有时我们会这么查询</p>\n<pre><code class=\"language-mysql\">select * from index_demo where c2 = 1 and c3 = '1';\n</code></pre>\n<p>所以我们此时就要创建关于 <code>c2,c3</code>  的联合索引。</p>\n<p>一个索引的根页面，一旦被创建，其页号就不会改变。一开始是没有数据的，每当存在数据插入，都是在这个根节点下插入</p>\n<h1 id=\"sql语句\"><a class=\"anchor\" href=\"#sql语句\">#</a> sql 语句</h1>\n<pre><code class=\"language-mysql\"># key和index是同义词，随便指定一个即可\ncreate table 表名 (\n    各个列信息\n    (key|index) 索引名 (要指定的列)\n)\n\nalter table 表名 add (key|index) 索引名 (要指定的列)\n\n# 删除索引\nalter table drop (index|key) 索引名\n</code></pre>\n",
            "tags": [
                "MySQL"
            ]
        },
        {
            "id": "https://cecilia.cool/2022/07/26/Database/MySQL/InnoDB%E9%A1%B5%E7%BB%93%E6%9E%84/",
            "url": "https://cecilia.cool/2022/07/26/Database/MySQL/InnoDB%E9%A1%B5%E7%BB%93%E6%9E%84/",
            "title": "InnoDB页结构",
            "date_published": "2022-07-26T02:49:58.000Z",
            "content_html": "<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>之前说过，页是 InnoDB<strong> 管理磁盘空间</strong>的基本单位，一个页的大小基本上是 16KB。MySQL 规定一页至少存两条记录。我们从客户端写入表中的记录会被存在页中，其实还有一种记录，它存在于 B + 树的非叶子节点的页中，其头信息中的 <code>record_type=1</code> 。</p>\n<p>目前你只需理解，页中存储的记录要么是我们从客户端写入的真实的记录 <code>record_type=0</code> 。这样的页称为<strong>索引页</strong>；另一个是 B + 树非叶子节点的目录项记录 <code>record_type=1</code> 。</p>\n<h2 id=\"页结构\"><a class=\"anchor\" href=\"#页结构\">#</a> 页结构</h2>\n<p>本节内容主要是就要了解页的大致结构和其存储记录的方式，下图为一个页的基本结构。</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/07/26/55c753f812c612e5.png\" alt=\"image-20220726110822415\" /></p>\n<p>之后我们会对其中的结构一 一讲解。但是直接给出很多概念会让你失去阅读兴趣，所以我们先看一下记录怎么在页中存储。</p>\n<h2 id=\"记录在页中的存储\"><a class=\"anchor\" href=\"#记录在页中的存储\">#</a> 记录在页中的存储</h2>\n<p>请看上图的 <code>User Records</code>  和 <code>Free Space</code> ，我们的记录就存放在 <code>User Records</code> ，如果 <code>User Records</code>  的空间不够了，就向 <code>Free Space</code>  去申请空间。所以一个页刚开始创建的时候，是没有 <code>User Records</code>  的。当 <code>Free Space</code>  全部被 <code>User Record</code>  代替时，该页就满了。恭喜，页结构七个概念你已经懂了两个。</p>\n<p>我们的记录在 <code>User Record</code>  里面是一条一条摆放进去的，但是我现在要提一下一条记录里的<strong>头信息</strong>（你不会已经忘了什么是头信息了吧，不会吧，不会吧）。</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/07/26/81205e50ebf500f5.png\" alt=\"image-20220725112044762\" /></p>\n<p><code>record_type</code>  可以是，0-- 普通记录，1--B + 树非叶子节点的目录项记录，2--Infimum，3--supremum。请看页结构图，红色区域就是 <code>Infimum,supremum</code> ，也就是说，每个页固定都有这两条记录，他们代表所有记录中的最小记录（链表头节点）以及所有记录中的最大记录（链表尾节点），** 尽管它们没有主键值，但它们就是最小和最大。** 这两条记录没有实际内容，但这是规定！这样每次查询记录时，都能从一个固定的起点查询。</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/07/26/986c7070b2da0836.png\" alt=\"image-20220726131306378\" /></p>\n<p><code>User Record</code>  里面的记录排列紧密，一条紧接另一条。这个其实就是堆， <code>heap_no</code>  就是该记录在堆中的相对位置。比如我顺序写入了 a,b,c 三条记录，它们的 <code>heap_no</code>  就是 2，3，4。至于 0 和 1，它们是 <code>Infimum,supremum</code>  的 <code>heap_no</code>  值。其实从图就可以看出， <code>Infimum,supremum</code>  在 <code>User_record</code>  上面。</p>\n<h3 id=\"next_record的计算\"><a class=\"anchor\" href=\"#next_record的计算\">#</a> next_record 的计算</h3>\n<p>很好，进入到了喜闻乐见的计算环节，我会尽量让你懂的。</p>\n<p><code>next_record</code>  不就是指向下一条记录嘛，那它指向下一条记录的那个部位呢？我们知道，头信息右边是默认添加数据（就是 row_id,trx_id,roll_pointer)，接着是真实信息。</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/07/26/e4c3645b69edae43.png\" alt=\"image-20220726115106879\" /></p>\n<p><code>next_record</code>  指向的是下一条记录的真实信息，其实存储的是一个以字节为单位的偏移量。比如第四条记录的 <code>next_record=-111</code> , 就是指从第四条记录的真实数据的地址开始，上前找 111 个字节就是下一条记录的真实数据的地址。</p>\n<p>所以，页中的记录因为 <code>next_record</code>  而形成了链表，在插入新的记录时，InnoDB 始终维护链表中节点的从小到大的顺序（维护顺序当然是为了二分查找）。</p>\n<p>为了让读者感受一下 <code>next_record</code>  的计算过程，我们创建一个表玩一下</p>\n<pre><code class=\"language-mysql\">create table test_next_record (\n\tc1 int,\n    c2 int,\n    c3 varchar(10000),\n    primary key (c1)\n) character set acsii,row_format=COMPACT；\n#使用 ascii字符集，一个字符用一个字节表示 \n\n#插入一条数据\ninsert into test_next_record values(1,100,'aaaa');\n</code></pre>\n<p>那么在页中实际是这个样子的</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/07/26/71735b9e7f52f0b7.png\" alt=\"image-20220726130854616\" /></p>\n<p><code>Infimum</code>  中的 41 是如何计算的： <code>Infimum</code> 8 字节 <code>+Supremum</code>  整条记录 13 字节 + 变长字段 1 字节 + NULL 值列表 1 字节 + 头信息 5 字节 + <code>trx_id</code> 6 字节 + <code>roll_pointer</code> 7 字节 = 41 字节。</p>\n<p><code>next_record</code>  指向真实信息和头信息中间，这个位置刚刚好，向左是 NULL 值列表（逆序存放）和变长字段长度列表（逆序存放），向右是真实信息。逆序可以使得记录中靠前的字段和它们对应的字段长度列表在内存中靠得更近，可能会<strong>提高缓存命中率</strong>。</p>\n<h2 id=\"file-header\"><a class=\"anchor\" href=\"#file-header\">#</a> File Header</h2>\n<p>校验和：对于一个很长的字符串，通过算法计算出比较短的值代表这个长字符串，这个值就是校验和。</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>FIL_PAGE_SPACE_OR_CHKSUM</td>\n<td>(4Byte) 空间或校验和，MySQL 版本低于 4.0.14 时，该属性表示本页面所在的<strong>表空间 ID</strong>；之后的版本表示页的<strong>校验和</strong></td>\n</tr>\n<tr>\n<td>FIL_PAGE_OFFSET</td>\n<td><strong>页号</strong>，对于页号的分配，并不是连续的，也就是说<strong>使用的页在磁盘上可能并不挨着（当然是尽可能挨着）</strong></td>\n</tr>\n<tr>\n<td>FIL_PAGE_PREV</td>\n<td>上页的页号</td>\n</tr>\n<tr>\n<td>FIL_PAGE_NEXT</td>\n<td>下页的页号（形成双向链表）</td>\n</tr>\n<tr>\n<td>FIL_PAGE_TYPE</td>\n<td><strong>页的类型</strong></td>\n</tr>\n<tr>\n<td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>\n<td>页属于哪个表空间</td>\n</tr>\n<tr>\n<td>FIL_PAGE_LSN</td>\n<td>页面被最后修改时对应的 LSN（Log Sequence Number，日志序列号）</td>\n</tr>\n</tbody>\n</table>\n<p>表格中内容看起来比较多，但是梳理一下就很清晰。</p>\n<p>首先，MySQL 具有良好的健壮性，比如内存中的页<strong>正在</strong>被刷新到磁盘中，但是此时突然断电了，导致刷新时只刷了一部分。我们就需要使用校验和来判断一个页是否被完整的刷新到磁盘中，这个在 <code>File Trailer</code>  部分会讲解到。</p>\n<p>其实，B + 树的节点就是页，页与页之间形成一个多叉树的同时，同一层的节点又形成双向链表。</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/07/26/d5d6dec569020c94.png\" alt=\"image-20220726112224302\" /></p>\n<p>这样，我们就记住了中间三个属性。最后的 <code>FIL_PAGE_TYPE</code>  表示页的类型，肯定啊，MySQL 这么大，肯定不可能只有 1 种页。</p>\n<h2 id=\"page-directory\"><a class=\"anchor\" href=\"#page-directory\">#</a> Page Directory</h2>\n<p>现在记录通过 <code>next_record</code>  连成了一个有序单向链表，对链表使用二分查找过程大致如下：</p>\n<ul>\n<li>将记录分为若干组，每个组最大的那个记录，其 <code>n_owned</code>  表示该组记录数。</li>\n<li>将每组最大记录的地址偏移量拿出来，按顺序排列在 <code>Page Dierctory</code>  中。</li>\n<li>这些偏移量被称为槽 -- <code>slot</code> ，每个槽位 2 字节， <code>Page Dierctory</code>  就是由若干个槽组成。</li>\n<li>你可以把一个个顺序排列的槽看作一个数组，槽对应的记录越小，就越接近 <code>File Trailer</code> 。</li>\n</ul>\n<p>关键的问题是怎么分组，机制为：</p>\n<ul>\n<li>对于 <code>Infimum</code>  记录所在的分组，只能有一条记录。即最靠近 <code>File Trailer</code>  的槽始终是 <code>Infimum</code> 。</li>\n<li>对于 <code>supermum</code>  记录所在的分组，可以有 1~8 条记录。</li>\n<li>其余组只能有 4~8 条记录，如果组中记录大于 8 条，会 4,5 分为两组，并生成一个新的 <code>slot</code> 。</li>\n<li>每次插入一条记录，该记录都会从页目录中寻找对应记录的主键值比待插入记录主键值大且差值最小的 <code>slot</code> （然后找到前一个槽 A，A 对应的记录开始遍历插入即可）</li>\n</ul>\n<p>配合这种机制，哪怕记录插入表中，记录在每个槽中也会保持有序，并且每个组中记录的主键逐渐紧凑。</p>\n<p>下图省略了记录之间的连接：</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/07/27/350085bbd3bc62f9.png\" alt=\"image-20220727133511829\" /></p>\n<p>上图相当于是： <code>slot_0=Infimum</code> ， <code>slot_1=4</code> ， <code>slot_2=Supremum</code> 。假设要查询记录 7，就相当于在数组 <code>[Min,4,Max]</code>  里面进行二分查找，最后找到 4，记录 4 的下一条记录就是槽 2 的组的记录，就相当于遍历槽 2 的组，直到找到目标记录。</p>\n<h2 id=\"page-header\"><a class=\"anchor\" href=\"#page-header\">#</a> Page Header</h2>\n<p>总共 56 字节，该结构是存储数据页中记录的状态信息，比如页中的记录数， <code>Free Space</code>  的偏移量，页目录有多少个槽等。下图只是部分结构，没有写完，记不住问题也不大，但是看到这里，下面的部分属性你肯定很熟悉。</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>长度</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>PAGE_HEAP_TOP</td>\n<td>2Byte</td>\n<td>还未使用的空间的最小地址，向后走就是 Free Space</td>\n</tr>\n<tr>\n<td>PAGE_N_HEAP</td>\n<td>2Byte</td>\n<td>第 1 位表示是否为紧凑型记录，剩余的 15 位表示本页的堆中的记录（包括 Infimumu,supermum 和已删除记录）</td>\n</tr>\n<tr>\n<td>PAGE_FREE</td>\n<td>2Byte</td>\n<td>垃圾链表头节点对应记录在页面中的偏移量</td>\n</tr>\n<tr>\n<td>PAGE_GARBAGE</td>\n<td>2Byte</td>\n<td>已删除记录占用的字节数</td>\n</tr>\n<tr>\n<td>PAGE_DIRECTION</td>\n<td>2Byte</td>\n<td>记录插入的方向，向后是 right</td>\n</tr>\n<tr>\n<td>PAGE_N_DIRECTION</td>\n<td>2Byte</td>\n<td>记录连续插入同一个方向的记录条数，当插入方向不同时，马上重置刷新</td>\n</tr>\n<tr>\n<td>PAGE_N_RECS</td>\n<td>2Byte</td>\n<td>该页用户记录的数量（不包括 Infimumu,supermum 和已删除记录）</td>\n</tr>\n<tr>\n<td>PAGE_MAX_TRX_ID</td>\n<td>8Byte</td>\n<td>修改当前页的最大事务 id，该值仅在二级索引页面中定义</td>\n</tr>\n<tr>\n<td>PAGE_LEVEL</td>\n<td>2Byte</td>\n<td>2Byte, 该页在 B + 树中的层级</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"file-trailer\"><a class=\"anchor\" href=\"#file-trailer\">#</a> File Trailer</h1>\n<p>在 <code>File Header</code>  提到过校验和。如果页从内存刷新到磁盘中断电了，导致之刷新了一部分到磁盘中该怎么办？ <code>File Trailer</code>  就是为了<strong>检验</strong>一个页是否刷新完整（至于如何恢复，那就的学到日志那才知道了）</p>\n<p>该部分由 8 个字节组成：</p>\n<ul>\n<li>前四个字节代表页的校验和，该部分与 <code>File Header</code>  的校验和相对应。 <strong>每次</strong>页在内存中发生<strong>修改</strong>时，在刷新前就要把校验和算出来。以页 A（假设校验和为 1）刚从磁盘读到内存为例，修改之后校验和为 2，那么此时磁盘中的页 A 和内存中的页 A 校验和不一样。刷新到磁盘时， <code>File Header</code>  的磁盘先被刷新到磁盘中，如果断电导致 <code>File Trailer</code>  的校验和没有刷新进去，那么磁盘中的 <code>File Header</code>  与 <code>File  trailer</code>  的校验和就不一样。</li>\n<li>后四个字节是页面最后被修改时对应的 LSN 的后 4 个字节，与 <code>File Header</code>  相对应，也是检验页完整性。</li>\n</ul>\n<h1 id=\"引用\"><a class=\"anchor\" href=\"#引用\">#</a> 引用</h1>\n<blockquote>\n<p>本文总结于《从根上理解 MySQL》第五章 p72-p89，作者：小孩子 4919。对于有能力或者兴趣的读者，鄙人强烈推荐这本书，如果您能够通过正规渠道购买，支持作者，支持正版，支持每一颗热爱技术的心，我将感激不尽。</p>\n</blockquote>\n",
            "tags": [
                "MySQL"
            ]
        },
        {
            "id": "https://cecilia.cool/2022/07/25/Database/MySQL/InnoDB%E8%A1%8C%E6%A0%BC%E5%BC%8F%E5%AD%98%E5%82%A8%E8%AE%B0%E5%BD%95/",
            "url": "https://cecilia.cool/2022/07/25/Database/MySQL/InnoDB%E8%A1%8C%E6%A0%BC%E5%BC%8F%E5%AD%98%E5%82%A8%E8%AE%B0%E5%BD%95/",
            "title": "InnoDB行格式存储记录",
            "date_published": "2022-07-25T02:11:43.000Z",
            "content_html": "<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>MySQL 服务器中负责对表中数据进行读取和写入工作的部分是<strong>存储引擎</strong>，而服务器支持不同类型的存储引擎，如 InnoDB，MyISAM，MEMORY 等。<strong>真实数据在不同存储引擎的存放格式可能不同</strong>。因为 InnoDB 现在是 MySQL 默认的存储引擎，所以会介绍其相关特性。</p>\n<p>在 MySQL 中，表中的一行数据被称为一条记录，记录保存在页中，页组成 B + 树，通过二分查找迅速找到记录。如果你还看不太懂，也没太大关系，这句话只是想告诉你 InnoDB 存储数据的本质。</p>\n<h1 id=\"innodb页\"><a class=\"anchor\" href=\"#innodb页\">#</a> InnoDB 页</h1>\n<p>数据库会频繁发生数据的读取和写入，这就像操作系统的文件系统一样，会发生大量的与磁盘的交互。但是从磁盘中直接读写数据非常慢，也就是说数据库不可能每次读写数据都直接和磁盘交互，所以就将数据分为若干个页，<strong>以页作为磁盘与内存之间交互的基本单位</strong>，其实页的本质也就是一个固定大小的内存。</p>\n<p>InnoDB 中的页大小一般是 16KB，也就是说，一次从磁盘中读取的数据最少是 16KB，每次将内存中的数据刷新到磁盘中最少也是 16KB。</p>\n<pre><code class=\"language-mysql\">mysql&gt; show variables like 'innodb_page_size';\n+------------------+-------+\n| Variable_name    | Value |\n+------------------+-------+\n| innodb_page_size | 16384 |\n+------------------+-------+\n1 row in set, 1 warning (0.00 sec)\n# 16 * 1024 = 16384\n#该系统变量不能在服务器运行时修改。\n</code></pre>\n<h1 id=\"innodb行格式\"><a class=\"anchor\" href=\"#innodb行格式\">#</a> InnoDB 行格式</h1>\n<p><strong>一条记录的存放格式被称为为行格式或者记录格式</strong>，InnoDB 目前有四种行格式： <code>COMPACT</code> ， <code>REDUNDANT</code> ， <code>DYNAMIC</code> ， <code>COMPRESSED</code> 。</p>\n<pre><code class=\"language-mysql\"># 指定行格式\ncreate table 表名 (列信息) row_format=行格式名\nalter table 表名 row_format=行格式\n</code></pre>\n<h2 id=\"compact行格式\"><a class=\"anchor\" href=\"#compact行格式\">#</a> COMPACT 行格式</h2>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/07/25/49b544009f43872c.png\" alt=\"image-20220725103902849\" /></p>\n<h3 id=\"变长字段长度列表\"><a class=\"anchor\" href=\"#变长字段长度列表\">#</a> 变长字段长度列表</h3>\n<p>我们先创建一个表，用于之后的示例讲解</p>\n<pre><code class=\"language-mysql\">create table record_format_demo (\n\tt1 varchar(10),\n    t2 varchar(256),\n    t3 varchar(20) not null\n) character set = ascii row_format = COMPACT;\n</code></pre>\n<p>变长字段指的就是 varchar (10) 这种，不能预先确定存储的数据的大小。在 InnoDB 读取数据时，如果是一个确定大小的数据，那么就能根据其大小确定偏移量从而读取出正确的数据，但是变长数据是不确定的，所以就需要保存这个变长字段（不为 NULL）的长度，来告诉 InnoDB 这个数据的大小。</p>\n<p>所以变长字段占用的存储空间分为两部分：</p>\n<ul>\n<li>真正的数据内容</li>\n<li>该数据占用的字节数</li>\n</ul>\n<p>在 COMPACT 行格式中，所有变长字段的真实数据占用字节数都存放在记录的开头位置 (十六进制，各字段长度之间没有空格)，从而形成一个变长字段长度列表。各字段占用<strong>字节数</strong>按列的顺序逆序存放，是逆序存放！</p>\n<p>有时用于表示长度的数据，需要占据不止一个字节。比如某一变长字段占字节 <code>n=700</code> , 那么就需要用到多个字节来表示 <code>n</code> ，<strong>因为一个字节哪怕加上符号位也表示不了 n</strong>。关于使用几个字节，InnoDB 有属于自己的规则，此处引入 <code>W，M，L</code>  三个符号：</p>\n<ul>\n<li>\n<p>W：假设某个<strong>字符集</strong>中最多需要 <code>W</code>  字节表示一个字符 (也就是 <code>show charset;</code>  中的 <code>MaxLen</code>  列)</p>\n</li>\n<li>\n<p>M：对于变长类型 <code>VARCHAR(M)</code>  来说，这种类型表示能存储最多<strong> M 个字符</strong> (是字符，不是字节)，所以该类型最多能存储 <code>M*W</code>  个字节</p>\n</li>\n<li>\n<p>L：该变长字段<strong>实际存储</strong>的字符数占用的字节数是 L</p>\n</li>\n</ul>\n<p>InnoDB 在读取记录变长字段长度列表时，<strong>会先查看表结构</strong>，如果某个字段允许存储最大字节数 <code>M*W&lt;=255</code> ，就认为只是用 1 字节表示真实数据占用的字节数。</p>\n<p>如果 <code>M*W &gt; 255</code> :</p>\n<ul>\n<li>若 <code>L &lt;= 127</code>  使用 1 字节</li>\n<li>若 <code>L &gt; 127</code>   使用 2 字节</li>\n</ul>\n<blockquote>\n<p>255 是 1 个字节（无符号整型）能表示的最大数，即 8 位全为 1，2^8-1=255。</p>\n<p>127 是 1 个字节（有符号整型）能表示的最大数，即最高位 0，其他 7 位为 1，2^7-1=127</p>\n</blockquote>\n<p>该规则主要就是用于区分长度列表中，当 <code>M*W &gt; 255</code>  时，一个字节到底是一个单独的字段长度 **（L &lt;= 127）<strong>，还是半个字段长度</strong>（L &gt; 127)**。设计者使用该字节的第一个二进制位作为标志位：如果该字节的第一个位是 0，该字节就是一个单独的字段长度，这也就是 0~127 的第一位都是 0。如果第一位为 1，那么该字节就是半个字段长度。</p>\n<blockquote>\n<p>其实可以设定，只要 M*W &gt; 255 就使用两个字节存储变长字段长度。之所以分的这么细，是想要节省空间，设计者的良苦用心可见一斑</p>\n</blockquote>\n<p>如果某个字段占用字节特别多，InnoDB 可能会把该字段的值的一部分数据存放到<strong>溢出页</strong>中，变长度列表只记录留在本页中的数据长度，<br />\n所以<strong> 2 字节表示变长字段长度是完全足够的</strong>。同时，长度列表只有在<strong>有必要存在时</strong>，才会存在（存在不为 NULL 的变长字段）</p>\n<p>对于 <code>CHAR(M)</code>  而言，如果使用的<strong>字符集</strong>是变长编码字符集，那么该属性也会被加入到变长列表中，并且长度为 <code>M*W</code>  (该字符集的 MaxLen=W)。</p>\n<h3 id=\"null值列表\"><a class=\"anchor\" href=\"#null值列表\">#</a> NULL 值列表</h3>\n<p>COMPACT 把一条记录的值为 NULL 的统一管理起来，存储到 NULL 列表中。处理过程：</p>\n<ul>\n<li>统计表中允许储存 NULL 的列有哪些 (比如主键和 NOT NULL 会被排除)</li>\n<li>如果表中所有列都不能存储 NULL，那么 NULL 值列表也就不存在。否则将每个允许存储 NULL 的列对应一个二进制位，位按照列的顺序<strong>逆序</strong>排列，位值为 1 时，代表该列的值为 NULL</li>\n<li>MySQL 规定 NULL 列表必须用整数个字节的位表示，不足高位补 0</li>\n</ul>\n<blockquote>\n<p>为什么是逆序之后会提到，先不要着急。</p>\n</blockquote>\n<h3 id=\"记录头信息\"><a class=\"anchor\" href=\"#记录头信息\">#</a> 记录头信息</h3>\n<p>记录头信息由固定的 5 个字节（40bit）组成，用于描述记录的一些信息</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/07/25/75ddfe7a3d59a65d.png\" alt=\"image-20220725112044762\" /></p>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t各二进制位的详细信息</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">预留位 1</td>\n<td style=\"text-align:center\">没有使用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">预留位 2</td>\n<td style=\"text-align:center\">没有使用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">deleted_flag</td>\n<td style=\"text-align:center\">标记该记录是否被删除</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">min_rec_flag</td>\n<td style=\"text-align:center\">B + 树的每层非叶子节点中最小目录项记录会添加该标记</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">n_owned</td>\n<td style=\"text-align:center\">页面中记录会被分为多个组，每个组最大的那个记录作为 “大哥”，“大哥 “的该标志位会记录组中记录条数</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">heap_no</td>\n<td style=\"text-align:center\">当前记录在页面堆中的相对位置，记录紧密排列的结构称为堆，前面的记录该值小，后面的值更大</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">record_type</td>\n<td style=\"text-align:center\">当前记录类型，0-- 普通记录，1--B + 树非叶子节点的目录项记录，2--Infimum，3--supremum</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">next_record</td>\n<td style=\"text-align:center\">表示下一条记录的相对位置</td>\n</tr>\n</tbody>\n</table>\n<p>这么多，看不懂无所谓，现在记不住无所谓。</p>\n<p>解释：</p>\n<ul>\n<li>deleted_flag 中，0 表示没有删除，1 表示已经删除。尽管一条记录被标志为删除，但是并不会马上从表中移除，<strong>这是避免移除后要重新排列其他记录，造成性能损耗</strong>。所以这些被标志删除的记录，会组成一个垃圾链表，这些空间又被称为可重用空间，如我新插入的记录，垃圾链表中某一个节点（记录）放得下，就会将新纪录覆盖的那条被标志为删除的记录。</li>\n<li>next_record 向我们表明记录会被排列成链表，链表是个好东西。</li>\n<li>record_type 表示记录的四种类型，在目前知晓的查询算法中，二分查找已非常优秀的，所以在 MySQL 中大量使用了二分查找。那么就涉及到记录之间的大小比较，一般是通过键值比较大小。规定 <code>record_type=2</code>  的记录是所有记录中最小的， <code>record_type=3</code>  的记录是所有记录中最大的。这两个记录实际不存储任何真实数据，但是它们分别是记录链表中的起点和终点，非常重要。 <code>record_type=1</code>  暂时不需要知道。之后会讲解</li>\n</ul>\n<h3 id=\"记录的真实数据\"><a class=\"anchor\" href=\"#记录的真实数据\">#</a> 记录的真实数据</h3>\n<p>我需要提醒一下，标题中的记录都是名词，不是动词。</p>\n<p>对于表来说，记录的真实数据除了我们自己设定的数据（比如 <code>name='cyan'</code>  之类的），MySQL 还会为每个记录默认地添加一些列 (也称为<strong>隐藏列</strong>)。</p>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\tMySQL 为每个记录默认添加的列</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">列名</th>\n<th style=\"text-align:center\">是否必需</th>\n<th style=\"text-align:center\">占用空间</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">row_id</td>\n<td style=\"text-align:center\">非必需</td>\n<td style=\"text-align:center\">6 字节</td>\n<td style=\"text-align:center\">行 ID，唯一标识一条记录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">trx_id</td>\n<td style=\"text-align:center\">必需</td>\n<td style=\"text-align:center\">6 字节</td>\n<td style=\"text-align:center\">事务 ID</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">roll_pointer</td>\n<td style=\"text-align:center\">必需</td>\n<td style=\"text-align:center\">7 字节</td>\n<td style=\"text-align:center\">回滚指针，形成版本链</td>\n</tr>\n</tbody>\n</table>\n<p>其实上述列名都是大写！并且这三列数据位于额外信息和真实数据中间</p>\n<p>解释：</p>\n<ul>\n<li>row_id 是唯一表示一条记录。如果在创建表时没有指定主键或者没有<strong>不能为 NULL 的唯一属性</strong>，反正就是，没有一个属性能够唯一表示一条记录，那么 row_id 就会被添加。</li>\n<li>trx_id 与事务有关，暂时不需要了解</li>\n<li>roll_pointer 是回滚指针，为了方便大家理解，这里不那么准确的讲，MySQL 支持回滚操作，也就是说我们改动一条记录后，如果想要回滚到上一个版本，就需要保存上一个版本的数据，那么 roll_pointer 就是指向上一个版本（改动前）的内存。</li>\n</ul>\n<h1 id=\"引用\"><a class=\"anchor\" href=\"#引用\">#</a> 引用</h1>\n<blockquote>\n<p>本文总结于《从根上理解 MySQL》第四章 p55-p63，作者：小孩子 4919。对于有能力或者兴趣的读者，鄙人强烈推荐这本书，如果您能够通过正规渠道购买，支持作者，支持正版，支持每一颗热爱技术的心，我将感激不尽。</p>\n</blockquote>\n",
            "tags": [
                "MySQL"
            ]
        }
    ]
}