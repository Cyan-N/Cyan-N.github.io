<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.7.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.7.0" type="image/png" sizes="32x32"><meta name="description" content="通信协议设计       在TCP网络编程中，发送方和接收方的数据包格式都是二进制，发送方将对象转化成二进制流发送给接收方，接收方获得二进制数据后需要知道如何解析成对象。 一个完备的网络协议需要具备以下基本要素                     魔数       作用是防止任何人随便向服务器端口发送数据。服务端在接收到数据时会解析出前几个固定字节的魔数">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty框架(5)--Http协议通信">
<meta property="og:url" content="https://cecilia.cool/2022/09/15/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty%E6%A1%86%E6%9E%B6(5)-Http%E5%8D%8F%E8%AE%AE%E9%80%9A%E4%BF%A1/index.html">
<meta property="og:site_name" content="慕青的日记">
<meta property="og:description" content="通信协议设计       在TCP网络编程中，发送方和接收方的数据包格式都是二进制，发送方将对象转化成二进制流发送给接收方，接收方获得二进制数据后需要知道如何解析成对象。 一个完备的网络协议需要具备以下基本要素                     魔数       作用是防止任何人随便向服务器端口发送数据。服务端在接收到数据时会解析出前几个固定字节的魔数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/09/15/baca09d46ab8eb8c.jpg">
<meta property="article:published_time" content="2022-09-15T03:07:20.000Z">
<meta property="article:modified_time" content="2022-09-15T09:25:31.808Z">
<meta property="article:author" content="Cyan">
<meta property="article:tag" content="网络编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s3.bmp.ovh/imgs/2022/09/15/baca09d46ab8eb8c.jpg"><title>Netty框架(5)--Http协议通信 | 慕青的日记</title><link ref="canonical" href="https://cecilia.cool/2022/09/15/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty%E6%A1%86%E6%9E%B6(5)-Http%E5%8D%8F%E8%AE%AE%E9%80%9A%E4%BF%A1/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.7.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">慕青的日记</div><div class="header-banner-info__subtitle">Cyan</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">Netty框架(5)--Http协议通信</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-15</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-15</span></span></div></header><div class="post-body">
        <h1 id="通信协议设计"   >
          <a href="#通信协议设计" class="heading-link"><i class="fas fa-link"></i></a><a href="#通信协议设计" class="headerlink" title="通信协议设计"></a>通信协议设计</h1>
      <p>在TCP网络编程中，发送方和接收方的数据包格式都是二进制，发送方将对象转化成二进制流发送给接收方，接收方获得<strong>二进制数据</strong>后需要知道如何解析成对象。</p>
<p>一个完备的网络协议需要具备以下基本要素</p>

        <h2 id="魔数"   >
          <a href="#魔数" class="heading-link"><i class="fas fa-link"></i></a><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2>
      <p>作用是防止任何人随便向服务器端口发送数据。服务端在接收到数据时会解析出前几个固定字节的魔数做对比，如果和约定的魔数不匹配，就会认为是非法数据。</p>
<p>魔数的思想在压缩算法，Java Class文件就有魔数<code>0XCAFFBABE</code>，调侃为咖啡宝贝，在加载Class文件时就会首先验证魔数的正确性。</p>

        <h2 id="序列化算法"   >
          <a href="#序列化算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#序列化算法" class="headerlink" title="序列化算法"></a>序列化算法</h2>
      <p>序列化算法表示数据发送方应该用何种方法将请求的对象转化为二进制，以及如何将二进制转化为对象等，如JSON，Hessian，Java自带序列化等。</p>
<blockquote>
<p>可以从Http协议中看出，完整的网络协议还需要长度域字段，请求数据，状态，保留字段，报文类型，协议版本号等。</p>
</blockquote>
<figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> 魔数 <span class="number">2</span>byte <span class="operator">|</span> 协议版本号 <span class="number">1</span>byte <span class="operator">|</span> 序列化算法 <span class="number">1</span>byte <span class="operator">|</span> 报文类型 <span class="number">1</span>byte  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> 状态 <span class="number">1</span>byte <span class="operator">|</span>        保留字段 <span class="number">4</span>byte     <span class="operator">|</span>      数据长度 <span class="number">4</span>byte     <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>                   数据内容 （长度不定）                          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------------------------+</span></span><br></pre></td></tr></table></div></figure>




        <h1 id="实现Http协议通信"   >
          <a href="#实现Http协议通信" class="heading-link"><i class="fas fa-link"></i></a><a href="#实现Http协议通信" class="headerlink" title="实现Http协议通信"></a>实现Http协议通信</h1>
      <p>需要使用到我们上一篇讲到的解码器和编码器</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">HttpRequestDecoder</span>())   <span class="comment">//Http请求解码器</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="comment">//看看是个啥类型</span></span><br><span class="line">                System.out.println(<span class="string">&quot;收到客户端的数据：&quot;</span>+msg.getClass());  </span><br><span class="line">                </span><br><span class="line">              	<span class="comment">//收到浏览器请求后，我们需要给一个响应回去</span></span><br><span class="line">                <span class="comment">//HTTP版本为1.1，状态码就OK（200）即可</span></span><br><span class="line">                <span class="type">FullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">                    <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1, </span><br><span class="line">                                            HttpResponseStatus.OK);  </span><br><span class="line">              	<span class="comment">//直接向响应内容中写入数据</span></span><br><span class="line">                response.content().writeCharSequence(<span class="string">&quot;Hello World!&quot;</span>,</span><br><span class="line">                                                     StandardCharsets.UTF_8);</span><br><span class="line">                ctx.channel().writeAndFlush(response);   <span class="comment">//发送响应</span></span><br><span class="line">                ctx.channel().close();   <span class="comment">//HTTP请求是一次性的，所以记得关闭</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">HttpResponseEncoder</span>());   <span class="comment">//响应记得也要编码后发送哦</span></span><br></pre></td></tr></table></div></figure>

<p>用浏览器访问一下</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/15/baca09d46ab8eb8c.jpg"></p>
<p>控制台打印的类型为：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class.io.netty.handler.codec.http.DefaultHttpRequest</span><br><span class="line">class.io.neety.handler.codec.http.LastHttpContent$<span class="number">1</span></span><br><span class="line">class.io.netty.handler.codec.http.DefaultHttpRequest</span><br><span class="line">class.io.neety.handler.codec.http.LastHttpContent$<span class="number">1</span></span><br></pre></td></tr></table></div></figure>

<p>可以看到一次请求是一个<code>DefaultHttpRequest</code>+<code>LastHttpContent$1</code>，这里有两组是因为浏览器请求了一个地址后紧接着又请求了网站的favicon图标。</p>
<p>如果不希望一次请求被拆分为两个，可以在<code>HttpRequestDecoder</code>后面加上聚合器</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将内容聚合为一个FullHttpRequest，参数是最大内容长度</span></span><br><span class="line">.addLast(<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(Integer.MAX_VALUE))</span><br></pre></td></tr></table></div></figure>

<p>我们再改一下channelRead里的内容</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">FullHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> (FullHttpRequest) msg;</span><br><span class="line">    System.out.println(<span class="string">&quot;浏览器请求路径：&quot;</span>+request.uri());  <span class="comment">//直接获取请求相关信息</span></span><br><span class="line">    <span class="type">FullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1,</span><br><span class="line">                                                            HttpResponseStatus.OK);</span><br><span class="line">    response.content().writeCharSequence(<span class="string">&quot;Hello World!&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">    ctx.channel().writeAndFlush(response);</span><br><span class="line">    ctx.channel().close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浏览器总共发送了两次请求</span></span><br><span class="line"><span class="comment">// 浏览器请求路径：/</span></span><br><span class="line"><span class="comment">// 浏览器请求路径：/favicon.ico</span></span><br></pre></td></tr></table></div></figure>

<p>如果我们是请求服务器网页资源，需要自定义一个解析器（本质就是通过请求路径拿到相关资源）</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageResolver</span> &#123;</span><br><span class="line">		<span class="comment">//直接单例模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">PageResolver</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageResolver</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">PageResolver</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PageResolver <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//请求路径给进来，接着我们需要将页面拿到，然后转换成响应数据包发回去</span></span><br><span class="line">    <span class="keyword">public</span> FullHttpResponse <span class="title function_">resolveResource</span><span class="params">(String path)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.startsWith(<span class="string">&quot;/&quot;</span>))  &#123;  <span class="comment">//判断一下是不是正常的路径请求</span></span><br><span class="line">            </span><br><span class="line">             <span class="comment">//如果是直接请求根路径，那就默认返回index页面，否则就该返回什么路径的文件就返回什么</span></span><br><span class="line">            path = path.equals(<span class="string">&quot;/&quot;</span>) ? <span class="string">&quot;index.html&quot;</span> : path.substring(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span>(<span class="type">InputStream</span> <span class="variable">stream</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader()</span><br><span class="line">                .getResourceAsStream(path)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(stream != <span class="literal">null</span>) &#123;   <span class="comment">//拿到文件输入流之后，才可以返回页面</span></span><br><span class="line">                    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[stream.available()];</span><br><span class="line">                    stream.read(bytes);</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.packet(HttpResponseStatus.OK, bytes);  </span><br><span class="line">                    <span class="comment">//数据先读出来，然后交给下面的方法打包</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//其他情况一律返回404</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.packet(HttpResponseStatus.NOT_FOUND,</span><br><span class="line">                           <span class="string">&quot;404 Not Found!&quot;</span>.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//包装成FullHttpResponse，把状态码和数据写进去</span></span><br><span class="line">    <span class="keyword">private</span> FullHttpResponse <span class="title function_">packet</span><span class="params">(HttpResponseStatus status, <span class="type">byte</span>[] data)</span>&#123;</span><br><span class="line">        <span class="type">FullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1, status);</span><br><span class="line">        response.content().writeBytes(data);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>在<code>channelRead</code>方法中使用该类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">FullHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> (FullHttpRequest) msg;</span><br><span class="line">    <span class="comment">//请求进来了直接走解析</span></span><br><span class="line">    <span class="type">PageResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> PageResolver.getInstance();</span><br><span class="line">    ctx.channel().writeAndFlush(resolver.resolveResource(request.uri()));</span><br><span class="line">    ctx.channel().close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="其他内置Handler"   >
          <a href="#其他内置Handler" class="heading-link"><i class="fas fa-link"></i></a><a href="#其他内置Handler" class="headerlink" title="其他内置Handler"></a>其他内置Handler</h1>
      <p>Netty内置了其他很有用的Handler，比如日志打印</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">HttpRequestDecoder</span>())</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(Integer.MAX_VALUE))</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))  </span><br><span class="line">    	<span class="comment">//添加一个日志Handler，在请求到来时会自动打印相关日志</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></div></figure>

<p>每次请求的内容和详细信息都会在日志中出现，包括详细的数据包解析过程，请求头信息都是完整地打印在控制台上的。</p>
<p>还可以使用Handler对IP地址进行过滤，比如我们不希望某些IP地址连接我们的服务器：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">HttpRequestDecoder</span>())</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(Integer.MAX_VALUE))</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">RuleBasedIpFilter</span>(<span class="keyword">new</span> <span class="title class_">IpFilterRule</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(InetSocketAddress inetSocketAddress)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> !inetSocketAddress.getHostName().equals(<span class="string">&quot;127.0.0.1&quot;</span>);  </span><br><span class="line">              	<span class="comment">//进行匹配，返回false表示匹配失败</span></span><br><span class="line">              	<span class="comment">//如果匹配失败，那么会根据下面的类型决定该干什么，</span></span><br><span class="line">                <span class="comment">//比如这里判断是不是本地访问的，如果是那就拒绝</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> IpFilterRuleType <span class="title function_">ruleType</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> IpFilterRuleType.REJECT;   </span><br><span class="line">                <span class="comment">//类型，REJECT表示拒绝连接，ACCEPT表示允许连接</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;))</span><br></pre></td></tr></table></div></figure>

<p><code>IdleStateHandler</code>可以对空闲的连接进行处理（idle–闲置的）</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>())</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>))  <span class="comment">//侦测连接空闲状态</span></span><br><span class="line">        <span class="comment">//第一个参数表示连接多少秒没有读操作时触发事件，第二个是写操作，</span></span><br><span class="line">    	<span class="comment">//第三个是读写操作都算，0表示禁用</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//事件需要在ChannelInboundHandlerAdapter中进行监听处理</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;收到客户端数据：&quot;</span>+msg);</span><br><span class="line">                ctx.channel().writeAndFlush(<span class="string">&quot;已收到！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="comment">//这个方法原来是在这个时候用的</span></span><br><span class="line">                <span class="keyword">if</span>(evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">                    <span class="type">IdleStateEvent</span> <span class="variable">event</span> <span class="operator">=</span> (IdleStateEvent) evt;</span><br><span class="line">                    <span class="keyword">if</span>(event.state() == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;长时间没有写操作&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(event.state() == IdleState.READER_IDLE) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;长时间没有读操作&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br></pre></td></tr></table></div></figure>




        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%20RPC%20%E5%AE%9E%E8%B7%B5-%E5%AE%8C/07%20%20%E6%8E%A5%E5%A4%B4%E6%9A%97%E8%AF%AD%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%20Netty%20%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE%E9%80%9A%E4%BF%A1%EF%BC%9F.md" >利用Netty实现自定义协议通信</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>
<p>语雀·青空の霞光：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javase/ibx6ug#37653588" >https://www.yuque.com/qingkongxiaguang/javase/ibx6ug#37653588</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://cecilia.cool">Cyan</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://cecilia.cool/2022/09/15/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty%E6%A1%86%E6%9E%B6(5)-Http%E5%8D%8F%E8%AE%AE%E9%80%9A%E4%BF%A1/">https://cecilia.cool/2022/09/15/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty%E6%A1%86%E6%9E%B6(5)-Http%E5%8D%8F%E8%AE%AE%E9%80%9A%E4%BF%A1/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh_tw" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://cecilia.cool/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2022/09/19/%E4%BA%91%E8%AE%A1%E7%AE%97/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">云计算作业</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2022/09/14/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty%E6%A1%86%E6%9E%B6(4)-%E7%BC%96%E7%A0%81%E5%99%A8%E4%B8%8E%E8%A7%A3%E7%A0%81%E5%99%A8/"><span class="paginator-prev__text">Netty(4)--编码器与解码器</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.</span> <span class="toc-text">
          通信协议设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AD%94%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">
          魔数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">
          序列化算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Http%E5%8D%8F%E8%AE%AE%E9%80%9A%E4%BF%A1"><span class="toc-number">2.</span> <span class="toc-text">
          实现Http协议通信</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%86%85%E7%BD%AEHandler"><span class="toc-number">3.</span> <span class="toc-text">
          其他内置Handler</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">4.</span> <span class="toc-text">
          参考</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/logo.png" alt="avatar"></div><p class="sidebar-ov-author__text">You have lots more to work on</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">82</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">2</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">14</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh_tw" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Cyan</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.2.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.7.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.7.0"></script><script src="/js/stun-boot.js?v=2.7.0"></script><script src="/js/scroll.js?v=2.7.0"></script><script src="/js/header.js?v=2.7.0"></script><script src="/js/sidebar.js?v=2.7.0"></script></body></html>