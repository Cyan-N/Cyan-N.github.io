{
    "version": "https://jsonfeed.org/version/1",
    "title": "慕青の迷途 • All posts by \"docker\" tag",
    "description": "时雨病重症患者",
    "home_page_url": "https://cecilia.cool",
    "items": [
        {
            "id": "https://cecilia.cool/2022/09/28/Docker/Docker(7)-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/",
            "url": "https://cecilia.cool/2022/09/28/Docker/Docker(7)-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/",
            "title": "Docker(7)--资源管理",
            "date_published": "2022-09-28T08:16:58.000Z",
            "content_html": "<h1 id=\"容器控制操作\"><a class=\"anchor\" href=\"#容器控制操作\">#</a> 容器控制操作</h1>\n<blockquote>\n<p>补充一些 Docker 的命令，对于这种单纯的命令查看，建议直接看菜鸟教程。</p>\n</blockquote>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 进入容器，退出：ctrl+P，ctrl+Q；终止容器运行的程序：ctrl+C</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">docker</span> attach 容器ID/名称</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 执行命令，这里执行的是 bash，并开启一个可输入终端</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">docker</span> <span class=\"token builtin class-name\">exec</span> <span class=\"token parameter variable\">-it</span> 容器ID/名称 <span class=\"token function\">bash</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># （假设容器可以执行 java），就相当于让容器执行 java -version</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">docker</span> <span class=\"token builtin class-name\">exec</span> 容器ID/名称 <span class=\"token function\">java</span> <span class=\"token parameter variable\">-version</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\"># 允许容器处理善后再停止运行</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token function\">docker</span> <span class=\"token function\">kill</span> 容器ID/名称</pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\"># 直接强制停止容器</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token function\">docker</span> stop 容器ID/名称</pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token comment\"># 启动容器（一般是容器被 stop 之后）</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token function\">docker</span> start 容器ID/名称</pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token comment\"># 重启容器</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token function\">docker</span> restart 容器ID/名称</pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token comment\"># 暂停容器 (unpause-- 取消暂停)</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token function\">docker</span> pause 容器ID/名称</pre></td></tr></table></figure><h1 id=\"物理资源管理\"><a class=\"anchor\" href=\"#物理资源管理\">#</a> 物理资源管理</h1>\n<ul>\n<li>内存分配：</li>\n</ul>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-it</span> <span class=\"token parameter variable\">-m</span> 50M --memory-swap<span class=\"token operator\">=</span>100M nagocoler/springboot-test:1.0</pre></td></tr></table></figure><p><code>-m</code>  对容器的物理内存的限制， <code>--memory-swap</code>  对内存和交换分区总和的限制。默认都是 - 1，即没有任何限制。如果仅指定 <code>-m</code> ，那么交换内存的限制也为 <code>-m</code>  指定的参数。</p>\n<ul>\n<li>CPU 进行限额：</li>\n</ul>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># </span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-c</span> <span class=\"token number\">1024</span> ubuntu</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-c</span> <span class=\"token number\">512</span> ubuntu</pre></td></tr></table></figure><p>对 CPU 的分配只有多容器才生效，默认是 1024，如果 CPU 不紧张，依然可以使用全部 CPU 资源。</p>\n<blockquote>\n<p>通过 Ubuntu 命令： <code>sudo apt install stress</code>  在容器中下载压力测试工具来看一下进程分配权重对进程获得 CPU 资源的影响。</p>\n</blockquote>\n<p>还可以限制容器使用 CPU：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-it</span> --cpuset-cpus<span class=\"token operator\">=</span><span class=\"token number\">1</span> ubuntu</pre></td></tr></table></figure><blockquote>\n<p>选项后面的值不是 CPU 的数量，而是 CPU 的 “编号”，即这个容器只用 1 这个 CPU，所以指定两个 CPU 时也可以这样： <code>docker run -it --cpuset-cpus=0,1 ubuntu</code> 。</p>\n</blockquote>\n<p>命令 <code>--cpus</code>  来限制使用 CPU 资源数（个数）： <code>docker run -it --cpus=1 ubuntu</code> 。</p>\n<h1 id=\"容器监控\"><a class=\"anchor\" href=\"#容器监控\">#</a> 容器监控</h1>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> stats</pre></td></tr></table></figure><p>可以实时对容器的各项状态进行监控，包括内存使用、CPU 占用、网络 I/O、磁盘 I/O 等信息。</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/09/28/2e4f267ce01df490.jpg\" alt=\"\" /></p>\n<p><code>top</code>  命令可以查看容器进程：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> <span class=\"token function\">top</span> 容器ID/名称</pre></td></tr></table></figure><p>对于容器监管，也有页面版本的，官方<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLnBvcnRhaW5lci5pby9zdGFydC9pbnN0YWxsL3NlcnZlci9kb2NrZXIvbGludXg=\">下载教程</span>，此处不过多讲解。</p>\n<h1 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h1>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueXVxdWUuY29tL3Fpbmdrb25neGlhZ3Vhbmcvendoa3BpL2txNnJsZw==\">https://www.yuque.com/qingkongxiaguang/zwhkpi/kq6rlg</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVub29iLmNvbS9kb2NrZXIvZG9ja2VyLXN0YXJ0LXN0b3AtcmVzdGFydC1jb21tYW5kLmh0bWw=\">https://www.runoob.com/docker/docker-start-stop-restart-command.html</span></p>\n</blockquote>\n",
            "tags": [
                "Docker"
            ]
        },
        {
            "id": "https://cecilia.cool/2022/09/27/Docker/Docker(6)-%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%AE%A1%E7%90%86/",
            "url": "https://cecilia.cool/2022/09/27/Docker/Docker(6)-%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%AE%A1%E7%90%86/",
            "title": "Docker(6)--数据卷管理",
            "date_published": "2022-09-27T08:46:08.000Z",
            "content_html": "<h1 id=\"数据卷\"><a class=\"anchor\" href=\"#数据卷\">#</a> 数据卷</h1>\n<blockquote>\n<p>基于分层机制，在容器中操作的文件都是在最顶层进行，这也导致容器的销毁会导致数据丢失。通过数据卷可以实现数据共享和持久化。</p>\n</blockquote>\n<h2 id=\"文件挂载\"><a class=\"anchor\" href=\"#文件挂载\">#</a> 文件挂载</h2>\n<p>Linux 根目录以外的文件想要被访问，就需要将其关联到根目录下的某个目录实现，这种关联就叫挂载，目录就是挂载点，解除关联就是卸载。</p>\n<blockquote>\n<p>最直接的就是读取 U 盘的文件，如果没有挂载操作，就只能在图形化界面使用 U 盘，在命令行找不到的。</p>\n</blockquote>\n<p>进行挂载时建议重新创建一个文件夹，如果使用了系统文件夹（etc 之类的），挂载操作会使得原有目录中文件被隐藏，可能会导致系统崩溃。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">mount</span> 设备号 挂载点目录</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">umount</span> 挂载点目录</pre></td></tr></table></figure><h2 id=\"容器持久化\"><a class=\"anchor\" href=\"#容器持久化\">#</a> 容器持久化</h2>\n<blockquote>\n<p>我们可以让容器将文件保存到宿主主机上，这样就算容器销毁，文件也会在宿主主机上保留，下次创建容器时，依然可以从宿主主机上读取到对应的文件。</p>\n</blockquote>\n<p>在宿主机创建需要挂载到容器的目录：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">mkdir</span> <span class=\"token builtin class-name\">test</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># 随便创建点文件表示有内容</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">vim</span> test/hello.txt</pre></td></tr></table></figure><p>将 test 目录挂载到容器的某个目录上</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-it</span> <span class=\"token parameter variable\">-v</span> ~test:/root/test ubuntu</pre></td></tr></table></figure><p>此时在容器中就可以访问宿主主机的文件，对挂载目录的文件进行编辑，就相当于编辑宿主主机的数据。在容器中创建文件，宿主主机也会创建相应文件。</p>\n<blockquote>\n<p>在容器中删除文件，不会影响主机的文件。</p>\n</blockquote>\n<p>可以部署 Nginx，在宿主主机上保存前端页面，然后将这个前端页面目录挂载到 Nignx 容器上，这样 Nginx 镜像有升级，容器需要删除重新创建也不会影响前端页面。</p>\n<p>我们这里使用的前端模板是<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ib290c3RyYXBtYWRlLmNvbS8=\"> Arsha</span>（如何将文件传到 linux 上待会讲）。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-it</span> <span class=\"token parameter variable\">-v</span> /win_data/Arsha:/usr/share/nginx/html/ <span class=\"token parameter variable\">-p</span> <span class=\"token number\">80</span>:80 <span class=\"token parameter variable\">-d</span> nginx</pre></td></tr></table></figure><p>将解压出来的目录挂载到 Nginx 的默认站点目录 <code>/usr/share/nginx/html/</code> ，因为挂在后位于顶层，会替代镜像原有的文件。</p>\n<p>进入容器将 Nginx 服务启动：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>systemctl start nginx</pre></td></tr></table></figure><blockquote>\n<p>在 windos 浏览器中输入 <code>IP:80</code> ，即可访问 nginx 服务，如果访问超时，可能是 linux80 端口被其他进程占用，最简单的就是重启一下 linux，再启动 nginx。</p>\n</blockquote>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/09/28/72cd9dda6c186381.jpg\" alt=\"\" /></p>\n<p>如果在挂载时没有指定宿主主机的目录，Docker 就会自动创建一个新的文件夹，并且会将容器中对应路径下的内容拷贝到这个自动创建的目录中，最后挂在到容器中，这种就是由 Docker 管理的数据卷了。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-it</span> <span class=\"token parameter variable\">-v</span> /root/abc ubuntu</pre></td></tr></table></figure><p>要查看 Docker 将文件放在了宿主机哪个位置</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> inspect 容器名字/ID</pre></td></tr></table></figure><p>主要是看 Mount 这个部分</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/09/28/efea66dac14a3326.jpg\" alt=\"\" /></p>\n<p>Docker 支持从宿主主机复制文件到容器中（或者容器复制文件到宿主主机）</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> <span class=\"token function\">cp</span> 主机文件 容器名/ID:文件夹路径</pre></td></tr></table></figure><h3 id=\"win文件传输到linux\"><a class=\"anchor\" href=\"#win文件传输到linux\">#</a> win 文件传输到 Linux</h3>\n<blockquote>\n<p>如果 linux 装在虚拟机上，虚拟机安装了 VMwareTools 后，一般可以实现文件直接从 win 拖动到虚拟机系统里面，但是有时候抽风又不能拖动。也可以将文件放到 U 盘里面，然后 U 盘挂载到 Linux 上，再将文件移动到 Linux 其他文件夹里面使用。（无语的是我这 U 盘挂载也出了问题）</p>\n</blockquote>\n<p>这里讲通过 pscp，命令行传输文件。</p>\n<ul>\n<li>在 Linux 中设置好 root 的密码： <code>sudo passwd</code> 。在根目录下创建 <code>win_data</code>  文件夹（名字其实随便）</li>\n<li>修改 <code>sshd_config</code>  文件，参考这篇文章：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veHVsaWFuZ3hpbmcvcC83NDI4NzM3Lmh0bWw=\">https://www.cnblogs.com/xuliangxing/p/7428737.html</span></li>\n<li>在 windos 下载好需要的文件</li>\n</ul>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/09/28/29425736a49aebd9.jpg\" alt=\"\" /></p>\n<ul>\n<li>下载 pscp：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY2hpYXJrLmdyZWVuZW5kLm9yZy51ay9+c2d0YXRoYW0vcHV0dHkvbGF0ZXN0Lmh0bWw=\">https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html</span></li>\n<li>将 <code>pscp.exe</code>  放在 C:\\Windows\\System32 文件夹下</li>\n</ul>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/09/28/0879d6517d9f457d.jpg\" alt=\"\" /></p>\n<ul>\n<li>在 C:Windows\\System32 下打开命令行，输入：</li>\n</ul>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">scp</span> 下载文件路径 root@IP:/win_data</pre></td></tr></table></figure><p>输入密码后就可以传输了，这里必须要使用 root，使用一般用户的话，权限不够会拒绝访问。</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/09/28/6d1d04a4f34aac95.jpg\" alt=\"\" /></p>\n<ul>\n<li>最后在 <code>/win_data</code>  目录里解压压缩包就可以使将其挂载到 nginx 上了</li>\n</ul>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">unzip</span> Arsha.zip</pre></td></tr></table></figure><h2 id=\"容器数据共享\"><a class=\"anchor\" href=\"#容器数据共享\">#</a> 容器数据共享</h2>\n<blockquote>\n<p>容器与容器之间的数据共享</p>\n</blockquote>\n<p>一般思路是在宿主主机上创建公告目录，让需要共享的容器挂载到这个公共目录。也可以创建一个容器专门用于存放数据，即数据卷容器。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-it</span> <span class=\"token parameter variable\">-v</span> ~/test:/root/test <span class=\"token parameter variable\">--name</span><span class=\"token operator\">=</span>data_test ubuntu</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-it</span> --volumes-from data_test ubuntu</pre></td></tr></table></figure><p>使用 <code>--volumes-from</code>  指定另一个容器，数据卷容器挂载的内容，在当前容器也存在，就算数据卷容器被删除，也不会影响这边，本质上还是让两个容器挂载了同样的目录实现数据共享。</p>\n<p>还可以将数据完全放到容器中，通过构建一个容器将打包好的数据分享给其他容器</p>\n<pre><code class=\"language-Dockerfile\">FROM ubuntu\nADD data.tar.gz /usr/share/nginx/html\nVOLUME /usr/share/nginx/html\n</code></pre>\n<p>指令 ADD，它跟 COPY 命令类似，也可以复制文件到容器中，但是它可以自动对压缩文件进行解压，这里只需要将压缩好的文件填入即可，后面的 VOLUME 指令就像我们使用 <code>-v</code>  参数一样，会创建一个挂载点在容器中</p>\n<p>然后构建</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> build <span class=\"token parameter variable\">-t</span> 镜像名 <span class=\"token builtin class-name\">.</span></pre></td></tr></table></figure><p>通过这个镜像创建按出来的容器，我们就可以使用了（假设容器名是 ubuntu_test）</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-p</span> <span class=\"token number\">80</span>:80 --volumes-from<span class=\"token operator\">=</span>ubuntu_test <span class=\"token parameter variable\">-d</span> nginx</pre></td></tr></table></figure><h1 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h1>\n<blockquote>\n<p>Linux 文件挂载：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9oYWljb2Rlci5uZXQvbGludXgvbGludXgtZmlsZS1tb3VudC5odG1s\">https://haicoder.net/linux/linux-file-mount.html</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmJzbWF4LmNvbS9BL2dWZG5PS1A4elcv\">https://www.bbsmax.com/A/gVdnOKP8zW/</span></p>\n<p>修改 sshd_config 文件：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veHVsaWFuZ3hpbmcvcC83NDI4NzM3Lmh0bWw=\">https://www.cnblogs.com/xuliangxing/p/7428737.html</span></p>\n<p>前端模板：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ib290c3RyYXBtYWRlLmNvbS8=\">https://bootstrapmade.com/</span></p>\n</blockquote>\n",
            "tags": [
                "Docker"
            ]
        },
        {
            "id": "https://cecilia.cool/2022/09/24/Docker/Docker(5)-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/",
            "url": "https://cecilia.cool/2022/09/24/Docker/Docker(5)-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/",
            "title": "Docker(5)--网络配置",
            "date_published": "2022-09-24T04:28:58.000Z",
            "content_html": "<h1 id=\"docker默认网桥\"><a class=\"anchor\" href=\"#docker默认网桥\">#</a> Docker 默认网桥</h1>\n<p>安装 Docker 服务会默认创建一个 docker0 网桥，它在内核层连通了其他的物理或虚拟网卡，这就<strong>将所有容器和本地主机都放到同一个物理网络</strong>。</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/09/26/6cd3d7a5835ed737.jpg\" alt=\"\" /></p>\n<p>容器有三种网络类型，分别是 <code>bridge</code> , <code>host</code> , <code>none</code> ，创建容器时默认是 <code>bridge</code> 。我们可以使用命令查看</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> network <span class=\"token function\">ls</span></pre></td></tr></table></figure><p>先创建一个容器再来讲解</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-it</span> ubuntu</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">apt</span> update</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">apt</span> <span class=\"token function\">install</span> net-tools iputils-ping <span class=\"token function\">curl</span></pre></td></tr></table></figure><p><img data-src=\"https://s3.bmp.ovh/imgs/2022/09/26/30f79fa9a2b0bfe5.jpg\" alt=\"\" /></p>\n<p>可以看到这个容器的 <code>IP</code>  是 <code>172.17.0.3</code> 。该 ubuntu 容器启动时没有指定网络类型，默认就是 <code>bridge</code> ，我们看一下 <code>bridge</code>  的网络</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>cyan@w2d:~$ <span class=\"token function\">docker</span> network inspect bridge</pre></td></tr></table></figure><p>看关键部分</p>\n<figure class=\"highlight json\"><figcaption data-lang=\"JSON\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token property\">\"Config\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token property\">\"Subnet\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"172.17.0.0/16\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token property\">\"Gateway\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"172.17.0.1\"</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">]</span></pre></td></tr></table></figure><blockquote>\n<p>我的终端倒是没有显示 Gateway 网关，这个其实就是 docker0 的 IP，我们创建的容器默认就是通过 docker0 桥接宿主机的网络。</p>\n</blockquote>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/09/26/726c5b32968c34d6.jpg\" alt=\"\" /></p>\n<h2 id=\"创建容器\"><a class=\"anchor\" href=\"#创建容器\">#</a> 创建容器</h2>\n<p>Docker 在创建一个容器的时候，会执行如下操作：</p>\n<ul>\n<li>\n<p>创建一对虚拟接口 / 网卡，也就是 veth pair，分别放到本地主机和新容器中；</p>\n</li>\n<li>\n<p>本地主机一端桥接到默认的 docker0 或指定网桥上，并具有一个唯一的名字，如 vethxxxxx；</p>\n</li>\n<li>\n<p>容器一端放到新容器中，并修改名字作为 eth0，这个网卡 / 接口只在容器的名字空间可见；</p>\n</li>\n<li>\n<p>从网桥可用地址段中（也就是与该 bridge 对应的 network）获取一个空闲地址分配给容器的 eth0，并配置默认路由到桥接网卡 vethxxxx。</p>\n</li>\n</ul>\n<blockquote>\n<p>如果不指定 --network，创建的容器默认都会挂到 docker0 上，使用本地主机上 docker0 接口的 IP 作为所有容器的默认网关</p>\n</blockquote>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/09/26/324896ddff4fdafc.jpg\" alt=\"\" /></p>\n<h1 id=\"网络类型\"><a class=\"anchor\" href=\"#网络类型\">#</a> 网络类型</h1>\n<h2 id=\"默认网络类型\"><a class=\"anchor\" href=\"#默认网络类型\">#</a> 默认网络类型</h2>\n<p>之前使用 <code>docker network ls</code>  查看三种网络类型，有 <code>bridge</code> ， <code>host</code> ， <code>none</code> 。，使用 <code>--network</code>  可以指定网络</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-it</span> <span class=\"token parameter variable\">--network</span><span class=\"token operator\">=</span>none ubuntu</pre></td></tr></table></figure><ul>\n<li><strong>none 网络</strong>：只有一个本地环回网络，通过 <code>ifconfig</code>  查看，只有一个本地环回 <code>lo</code>  网络设备：</li>\n</ul>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/09/26/ba906a10862142e3.jpg\" alt=\"\" /></p>\n<p>在这种网络模式下，容器无法连接到互联网：比如， <code>ping</code>  不通，纯纯单机运行。</p>\n<ul>\n<li><strong>bridger 网络</strong>：容器默认使用的网络类型，上文我们已经讲了，此处不再赘述。</li>\n<li><strong>host 网络</strong>：当容器连接到此网络，会共享宿主主机的网络，网络配置是完全一样。</li>\n</ul>\n<h2 id=\"自定义网络类型\"><a class=\"anchor\" href=\"#自定义网络类型\">#</a> 自定义网络类型</h2>\n<p>Docker 默认提供三种网络驱动： <code>bridge</code> 、 <code>overlay</code> 、 <code>macvlan</code> ，不同的驱动对应着不同的网络设备驱动，实现的功能也不一样，比如 bridge 类型的，其实就和我们前面介绍的桥接网络是一样的。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> network create <span class=\"token parameter variable\">--driver</span> bridge <span class=\"token builtin class-name\">test</span></pre></td></tr></table></figure><p>这就是本文最开始的 <code>ifconfig</code>  多显示了一个网络设备，不同网络之间的通信是相互隔离的，无法进行通信，比如我们有一个在默认网络类型的 ubuntu 容器，有一个在 test 网络下的 ubuntu 容器，后者的网关是 <code>172.18.0.1</code> ，容器 IP 为 <code>172.18.0.2</code> ，在前者中想要执行命令：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">ping</span> <span class=\"token number\">172.18</span>.0.2</pre></td></tr></table></figure><p>会失败，想要实现通信，需要将前者连接到另一个容器所属的网络下：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> network connect test<span class=\"token punctuation\">(</span>网络类型<span class=\"token punctuation\">)</span> 容器ID/名称</pre></td></tr></table></figure><p>此时容器就可以互相通信。Docker 的 DNS 服务器可以不需要指定容器 IP，比如有两个可以互相通信的容器，在启动时分别用 <code>--name</code>  指定名称，通信时就可以使用名称而不是 IP（就像有一个 DNS 一样将名字解析成 IP）</p>\n<p>两个容器也可以共享一个网络设备，即两个容器共同使用一个 IP 地址，只需要在创建时指定：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-it</span> <span class=\"token parameter variable\">--name</span><span class=\"token operator\">=</span>test02 <span class=\"token parameter variable\">--network</span><span class=\"token operator\">=</span>container:test02 ubuntu</pre></td></tr></table></figure><p>两个容器的 IP 地址和网卡的 Mac 地址是完全一样的，它们的网络现在是共享状态，此时在容器中访问，localhost，既是自己也是别人。</p>\n<p>可以在容器 1 中，安装 Nginx，然后再容器 2 中访问：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">apt</span> <span class=\"token function\">install</span> <span class=\"token parameter variable\">-y</span> systemctl nginx</pre></td></tr><tr><td data-num=\"2\"></td><td><pre> systemctl start nginx</pre></td></tr></table></figure><p>访问到另一个容器中的 Nginx 服务器。</p>\n<blockquote>\n<p>另外两种类型的网络用于多主机通信，多主机通信会使用物理交换机，不同主机的网卡连接到同一台交换机，就相当于各自网桥在同一物理网络了。</p>\n</blockquote>\n<h2 id=\"容器外部网络\"><a class=\"anchor\" href=\"#容器外部网络\">#</a> 容器外部网络</h2>\n<p>在默认的三种的网络下，只有共享模式和桥接模式可以连接到外网，共享模式实际上就是直接使用宿主主机的网络设备连接到互联网，这里主要来看一下桥接模式。</p>\n<blockquote>\n<p>桥接模式容器发送数据包时，关键部分就是 NAT (Netwirk Address Translation)，将地址进行转换，再利用宿主主机的 IP 地址发送数据包出去。</p>\n</blockquote>\n<p>比如我们要访问互联网上的某个资源，要和服务器进行通信，那么就需要将数据包发送出去，同时服务器也要将数据包发送回来，我们可以知道服务器的 IP 地址，也可以直接去连接，因为服务器的 IP 地址是暴露在互联网上的，但是我们的局域网就不一样了，它仅仅局限在我们的家里，比如我们连接了家里的路由器，可以得到一个 IP 地址，但是你会发现，这个 IP 公网是无法直接访问到我们的，因为这个 IP 地址仅仅是一个局域网的 IP 地址，俗称内网 IP。</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/09/27/dab39643f8e2041e.jpg\" alt=\"\" /></p>\n<p>这里就借助了 NAT 在帮助我们与互联网上的服务器进行通信，通过 NAT，可以实现将局域网的 IP 地址，映射为对应的公网 IP 地址，而 NAT 设备一端连接外网，另一端连接内网的所有设备，当我们想要与外网进行通信时，就可以将数据包发送给 NAT 设备，由它来将数据包的源地址映射为它在外网上的地址，这样服务器就能够发现它了，能够直接与它建立通信。当服务器发送数据回来时，也是直接交给 NAT 设备，然后再根据地址映射，转发给对应的内网设备（当然由于公网 IP 地址有限，所以一般采用 IP + 端口结合使用的形式 ANPT）。</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/09/27/e05a018b5df6da55.jpg\" alt=\"\" /></p>\n<p>用百度查出来的 IP 和在命令行使用 <code>ipconfig(windows)</code>  查出来的不一样，前者是 NAT 设备的公网地址。</p>\n<p>Docker 中，内网数据包想要发送到互联网上的流程为：</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/09/27/e4ebfbc4ba947097.jpg\" alt=\"\" /></p>\n<p>单纯依靠 NAT，只有主动与外界联系时，外界才知道我们。但是如果容器中部署了一些服务，需要外界主动连接容器的服务，就需要使用端口映射配置。</p>\n<blockquote>\n<p>外界连接，只知道 linux 的 IP 而不知道容器的 IP，就需要通过端口映射访问。端口映射可以将容器需要对外提供服务的端口映射到宿主主机的端口上，这样，当外部访问到宿主主机的对应端口时，就会直接转发给容器内映射的端口了。</p>\n</blockquote>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 先部署一个 nginx 服务</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">-p</span> <span class=\"token number\">80</span>:80 nginx</pre></td></tr></table></figure><p><code>-p</code>  参数是进行端口映射配置，规则为 <code>宿主端口:容器端口</code> ，其实关于端口映射之前的文章已经讲过了。</p>\n<p>然后在浏览器中输入： <code>Linux IP:80</code>  即可访问 nignx 服务。</p>\n<h1 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h1>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wZGFpLnRlY2gvbWQvZGV2b3BzL2RvY2tlci9kb2NrZXItMDctbmV0d29yay5odG1s\">https://pdai.tech/md/devops/docker/docker-07-network.html</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueXVxdWUuY29tL3Fpbmdrb25neGlhZ3Vhbmcvendoa3BpL2txNnJsZyM2N2ZiOTdlYQ==\">https://www.yuque.com/qingkongxiaguang/zwhkpi/kq6rlg#67fb97ea</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaXQxMzUyLmNvbS8yMDUyODkyLmh0bWw=\">https://www.it1352.com/2052892.html</span></p>\n</blockquote>\n",
            "tags": [
                "Docker"
            ]
        },
        {
            "id": "https://cecilia.cool/2022/09/24/Docker/Docker(4)-webapp%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/",
            "url": "https://cecilia.cool/2022/09/24/Docker/Docker(4)-webapp%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/",
            "title": "Docker(4)--webapp应用实例",
            "date_published": "2022-09-24T03:34:17.000Z",
            "content_html": "<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>本文通过 web 应用展示主机如何与 wen 容器之间通信，为后续讲解网络提供基础。</p>\n<h1 id=\"web的运行与访问\"><a class=\"anchor\" href=\"#web的运行与访问\">#</a> web 的运行与访问</h1>\n<h2 id=\"运行\"><a class=\"anchor\" href=\"#运行\">#</a> 运行</h2>\n<blockquote>\n<p>找到一个 webapp 镜像即可。</p>\n</blockquote>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> pull training/webapp</pre></td></tr></table></figure><p>下载完成后查看</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> images <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> webapp</pre></td></tr></table></figure><blockquote>\n<p>我们需要跑一下这个 webapp 里面的 app.py 文件，其实就是 hello world</p>\n</blockquote>\n<p>启动 webapp</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">-P</span> training/webapp python app.py</pre></td></tr></table></figure><blockquote>\n<p><code>-d</code> ：让容器在后台运行</p>\n<p><code>-P</code> ：将容器内部使用的网络端口映射到主机上</p>\n</blockquote>\n<p>查看一下</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>cyan@w2d:~$ <span class=\"token function\">docker</span> <span class=\"token function\">ps</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>CONTAINER ID          PORTS                                   </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>e7a994ce697c     <span class=\"token number\">0.0</span>.0.0:49153-<span class=\"token operator\">></span><span class=\"token number\">5000</span>/tcp, :::49153-<span class=\"token operator\">></span><span class=\"token number\">5000</span>/tcp</pre></td></tr></table></figure><p>这里因为界面显示不够，我就只保留了 ID 和端口号的相关信息。</p>\n<h2 id=\"访问\"><a class=\"anchor\" href=\"#访问\">#</a> 访问</h2>\n<p>上文端口号的解读是：Docker 开放 5000 端口（Python Flask 默认端口）映射到主机端口 49153.</p>\n<p>所以我们可以从 49153 这个端口来访问这个界面</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">netstat</span> <span class=\"token parameter variable\">-nltp</span> <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> <span class=\"token number\">49153</span></pre></td></tr></table></figure><blockquote>\n<p><code>netstat</code>  命令用于显示网络状态</p>\n</blockquote>\n<p>在命令行：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">curl</span> localhost:49153</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># 或者在浏览器上访问，ip 是虚拟机 - Ubuntu 的 ip</span></pre></td></tr></table></figure><p><img data-src=\"https://s3.bmp.ovh/imgs/2022/09/24/1d9b4aa085083f9e.jpg\" alt=\"\" /></p>\n<p>容器映射到主机的端口是随机的，但是可以用 - P 选项来指定端口</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">-P</span> <span class=\"token number\">5001</span>:500 training/webapp python app.py</pre></td></tr></table></figure><blockquote>\n<p>如果浏览器访问不上，把镜像删了重新下载试试，反正是可以的</p>\n</blockquote>\n<h1 id=\"其他功能\"><a class=\"anchor\" href=\"#其他功能\">#</a> 其他功能</h1>\n<blockquote>\n<p>反正都是命令，快速过一下</p>\n</blockquote>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 查看容器 (映射) 端口</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">docker</span> port ID</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 查看日志</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">docker</span> logs ID</pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># 查看容器进程</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">docker</span> <span class=\"token function\">top</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\"># 检查应用底层信息，返回 JSON 文件记录</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\"># 容器配置和状态信息</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token function\">docker</span> inspect ID</pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token comment\"># 停止应用容器</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token function\">docker</span> stop ID</pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token comment\"># 重启容器</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token function\">docker</span> restart/start ID</pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token comment\"># 移除容器，-f 就是强制删除，一般容器删除需要 </span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token function\">docker</span> <span class=\"token function\">rm</span> ID</pre></td></tr></table></figure><h2 id=\"容器互联\"><a class=\"anchor\" href=\"#容器互联\">#</a> 容器互联</h2>\n<blockquote>\n<p>删除所有不再使用的容器： <code>docker container prune</code> 。</p>\n</blockquote>\n<p>创建数据库容器：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">--name</span> db training/postgres</pre></td></tr></table></figure><p>db 容器与 web 容器建立互联关系</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">-P</span> <span class=\"token number\">5001</span>:5000 <span class=\"token parameter variable\">--name</span> web <span class=\"token parameter variable\">--link</span> db:db training/webapp python app.py</pre></td></tr></table></figure><p><code>--link</code>  参数格式为  <code>--link name:alias</code> ，其中 name 是要链接的容器的名称，alias 是这个连接的别名。</p>\n<p>容器之间的连接信息的查看有两种方式：</p>\n<ul>\n<li>查看环境变量：</li>\n</ul>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># webapp 已经运行起来了，假设其名字为 web</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">docker</span> <span class=\"token builtin class-name\">exec</span> <span class=\"token parameter variable\">-it</span> web /bin/bash</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># ====>，这里假设 ID 是 1cbc9aeba2a8</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>root@1cbc9aeba2a8:/opt/webapp<span class=\"token comment\"># env</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token assign-left variable\">DB_NAME</span><span class=\"token operator\">=</span>/web/db</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token assign-left variable\">DB_PORT_5432_TCP_ADDR</span><span class=\"token operator\">=</span><span class=\"token number\">172.17</span>.0.2</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token assign-left variable\">DB_PORT</span><span class=\"token operator\">=</span>tcp://172.17.0.2:5432</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token assign-left variable\">DB_PORT_5432_TCP</span><span class=\"token operator\">=</span>tcp://172.17.0.2:5432</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token assign-left variable\"><span class=\"token environment constant\">PWD</span></span><span class=\"token operator\">=</span>/opt/webapp</pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token assign-left variable\">DB_PORT_5432_TCP_PORT</span><span class=\"token operator\">=</span><span class=\"token number\">5432</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token assign-left variable\"><span class=\"token environment constant\">SHLVL</span></span><span class=\"token operator\">=</span><span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token assign-left variable\"><span class=\"token environment constant\">HOME</span></span><span class=\"token operator\">=</span>/root</pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token assign-left variable\">DB_PORT_5432_TCP_PROTO</span><span class=\"token operator\">=</span>tcp</pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token assign-left variable\">DB_ENV_PG_VERSION</span><span class=\"token operator\">=</span><span class=\"token number\">9.3</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token assign-left variable\">_</span><span class=\"token operator\">=</span>/usr/bin/env</pre></td></tr></table></figure><blockquote>\n<p>DB_ 开头的环境变量是供 web 容器连接 db 容器使用，前缀采用大写的连接别名。<strong>只有在建立连接之后才会有，没有建立连接是没有这几个变量的</strong>。</p>\n</blockquote>\n<ul>\n<li>hosts 文件</li>\n</ul>\n<p>除了环境变量，Docker 还添加 host 信息到父容器的  <code>/etc/hosts</code>  的文件。下面是父容器 web 的 hosts 文件</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>root@1cbc9aeba2a8:/opt/webapp<span class=\"token comment\"># cat /etc/hosts</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">127.0</span>.0.1       localhost</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>::1     localhost ip6-localhost ip6-loopback</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>fe00::0 ip6-localnet</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>ff00::0 ip6-mcastprefix</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>ff02::1 ip6-allnodes</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>ff02::2 ip6-allrouters</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token number\">172.17</span>.0.2      db d992e3c761e0</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token number\">172.17</span>.0.3      1cbc9aeba2a8</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>root@1cbc9aeba2a8:/opt/webapp<span class=\"token comment\">#</span></pre></td></tr></table></figure><p>这里有 2 个 hosts:</p>\n<ul>\n<li>第一个， <code>172.17.0.2 db d992e3c761e0</code>  表示 db 容器的 ip, ID 和 Name</li>\n<li>第二个， <code>172.17.0.3 1cbc9aeba2a8</code>  表示 web 容器的 ip, ID</li>\n</ul>\n<h1 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h1>\n<blockquote>\n<p>netstat 命令：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVub29iLmNvbS9saW51eC9saW51eC1jb21tLW5ldHN0YXQuaHRtbD9pdmtfc2E9MTAyNDMyMHU=\">https://www.runoob.com/linux/linux-comm-netstat.html?ivk_sa=1024320u</span></p>\n<p>Java 全栈知识体系：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9wZGFpLnRlY2gvbWQvZGV2b3BzL2RvY2tlci9kb2NrZXItMDMtYmFzaWMtd2ViLWFwcC5odG1s\">https://pdai.tech/md/devops/docker/docker-03-basic-web-app.html</span></p>\n</blockquote>\n",
            "tags": [
                "Docker"
            ]
        },
        {
            "id": "https://cecilia.cool/2022/09/22/Docker/Docker(3)-%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E4%B8%8E%E5%8F%91%E5%B8%83/",
            "url": "https://cecilia.cool/2022/09/22/Docker/Docker(3)-%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E4%B8%8E%E5%8F%91%E5%B8%83/",
            "title": "Docker(3)--镜像构建与发布",
            "date_published": "2022-09-22T02:46:18.000Z",
            "content_html": "<h1 id=\"构建镜像\"><a class=\"anchor\" href=\"#构建镜像\">#</a> 构建镜像</h1>\n<p>有些冷门的软件不在远程仓库里，此时就需要手动安装。我们以 Ubuntu 的 base 镜像中安装 Java 环境，并将其打包成新的镜像（这个新的镜像就是一个包含 Java 环境的 Ubuntu 系统镜像）。</p>\n<p>拉取启动 Ubuntu：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> pull ubuntu</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-it</span> ubuntu</pre></td></tr></table></figure><p>更新 apt（因为只有 base 镜像）</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">apt</span> update</pre></td></tr></table></figure><blockquote>\n<p>这一步我之前换不换源都会出错，反正就是更新失败，后来折腾了两三天，都没什么效果。最后把 wifi 换成热点就更新成功了。所以你如果更新失败，可以试着检查一下网络问题。</p>\n<p>也不用怀疑版本问题，本人用 Ubuntu 15 和 Ubuntu22 都更新成功过。</p>\n</blockquote>\n<p>安装 <code>jdk</code> ：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">apt</span> <span class=\"token function\">install</span> openjdk-8-jdk</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># 如果 apt 更新失败，后面的也会失败</span></pre></td></tr></table></figure><p>退出容器，将其构建为新的镜像，使用 commit 将容器保存为新的镜像：</p>\n<figure class=\"highlight dockerfile\"><figcaption data-lang=\"Docker\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker commit 容器名称/ID 新的镜像名称</pre></td></tr></table></figure><p>此时再使用 <code>docker images</code>  就可以看到新构建的镜像了。</p>\n<blockquote>\n<p>但是这种构建方式 Docker 官方并不推荐。普通用户可以使用 Dockerfile 构建上述镜像</p>\n</blockquote>\n<p>创建名为 <code>Dockerfile</code>  的文件：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">touch</span> Dockerfile</pre></td></tr></table></figure><p>我们需要在 <code>Dockerfile</code>  文件内部编写指令来告诉 Docker 需要构建镜像的相关信息</p>\n<figure class=\"highlight dockerfile\"><figcaption data-lang=\"Docker\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> &lt;基础镜像></span></pre></td></tr></table></figure><p><code>FROM</code>  指令选择当前镜像的基础镜像（必须以该指令开始）。如果不需要任何基础镜像，使用 <code>scratch</code>  表示从零开始基础构建。</p>\n<p>在容器中运行命令安装 Java 环境</p>\n<figure class=\"highlight dockerfile\"><figcaption data-lang=\"Docker\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token instruction\"><span class=\"token keyword\">RUN</span> apt update</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token instruction\"><span class=\"token keyword\">RUN</span> apt install -y openjdk-8-jdk</span></pre></td></tr></table></figure><p>构建：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> build <span class=\"token parameter variable\">-t</span> <span class=\"token operator\">&lt;</span>镜像名称<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span>构建目录<span class=\"token operator\">></span></pre></td></tr></table></figure><p>执行后，Docker 会在构建目录中寻找 Dockerfile 文件，然后开始依次执行 Dockerfile 中的指令：</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/09/23/97bff6ac9d64700f.jpg\" alt=\"\" /></p>\n<p>每一个指令都会在镜像上创建一个新的层， <code>-t</code>  指定要创建的目标镜像名， <code>.</code>  是 Dockerfile 所在目录。</p>\n<h1 id=\"发布镜像\"><a class=\"anchor\" href=\"#发布镜像\">#</a> 发布镜像</h1>\n<p>我们可以将镜像上传到：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9yZXBvc2l0b3JpZXM=\">https://hub.docker.com/repositories</span></p>\n<p>先在 hub.docker.com 上创建公共的镜像仓库，再将本地镜像上传，上传前可以将镜像名称修改规范：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> tag ubuntu-java-file:latest 用户名/仓库名称:版本</pre></td></tr></table></figure><p>然后本地上传：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> push nagocoler/ubuntu-java:1.0</pre></td></tr></table></figure><blockquote>\n<p>这里参考的青空の霞光的用户名 nagocoler 和仓库名 ubuntu-java</p>\n</blockquote>\n<p>公共仓库是可以被搜索和下载的，搜索使用 <code>search</code>  命令即可：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> search nagocoler/ubuntu-java</pre></td></tr></table></figure><p>再使用 pull 命令下载：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> pull nagocoler/ubuntu-java:1.0</pre></td></tr></table></figure><h1 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h1>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueXVxdWUuY29tL3Fpbmdrb25neGlhZ3Vhbmcvendoa3BpL2txNnJsZw==\">https://www.yuque.com/qingkongxiaguang/zwhkpi/kq6rlg</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wZGFpLnRlY2gvbWQvZGV2b3BzL2RvY2tlci9kb2NrZXItMDMtYmFzaWMyLmh0bWw=\">https://pdai.tech/md/devops/docker/docker-03-basic2.html</span></p>\n</blockquote>\n",
            "tags": [
                "Docker"
            ]
        },
        {
            "id": "https://cecilia.cool/2022/09/21/Docker/Docker(2)-%E9%95%9C%E5%83%8F%E5%9F%BA%E7%A1%80/",
            "url": "https://cecilia.cool/2022/09/21/Docker/Docker(2)-%E9%95%9C%E5%83%8F%E5%9F%BA%E7%A1%80/",
            "title": "Docker(2)--镜像基础",
            "date_published": "2022-09-21T11:56:42.000Z",
            "content_html": "<h1 id=\"hello-world\"><a class=\"anchor\" href=\"#hello-world\">#</a> hello-world</h1>\n<p>要使用那些容器，首先需要拉取镜像到本地仓库，然后再运行</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 拉取 hello-world</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">docker</span> pull hello-world:latest</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 查看本地仓库的镜像</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">docker</span> images</pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># 在容器中运行 hello-world 实例</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token punctuation\">(</span>--name<span class=\"token operator\">=</span>XXX<span class=\"token punctuation\">)</span> hello-world</pre></td></tr></table></figure><blockquote>\n<p>拉取指定版本的镜像： <code>docker pull 名称:版本</code> ，默认是最新版本。run 命令 hi 自动给容器分配名称，也可以使用唯一名称指定。</p>\n</blockquote>\n<p>如果没有调整 docker 的镜像源，那么 docker 就是从<span class=\"exturl\" data-url=\"aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS8=\"> Docker Hub</span> 拉取的镜像到本地仓库。也可直接使用 <code>run</code>  来运行实例，如果本地仓库没有这个实例，那么就会从远端拉取镜像到仓库中。</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/09/21/6378a12818c5974f.jpg\" alt=\"\" /></p>\n<blockquote>\n<p><code>docker images</code>  的结果有一列是 ID，如果希望删除一个镜像： <code>docker rmi -f  &lt;ID&gt;</code> 。</p>\n</blockquote>\n<p>Docker 允许在容器内运行应用程序： <code>docker run</code> 。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run centos:latest /bin/echo <span class=\"token string\">\"Hello world\"</span></pre></td></tr></table></figure><p>如果本地仓库没有 centos 的镜像，那么就会先拉取 centos 镜像。看一下参数的含义：</p>\n<ul>\n<li>\n<p><code>docker</code> : Docker 的二进制执行文件。</p>\n</li>\n<li>\n<p><code>run</code> : 与前面的 docker 组合来运行一个容器。</p>\n</li>\n<li>\n<p><code>ubuntu:latest</code>  指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。</p>\n</li>\n<li>\n<p><code>/bin/echo &quot;Hello world&quot;</code> : 在启动的容器里执行的命令</p>\n</li>\n</ul>\n<blockquote>\n<p>吐槽：我这拉取 centos 镜像文件好慢。。。</p>\n</blockquote>\n<p>如果我们只是想创建容器而不是去运行</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> create hello-world</pre></td></tr></table></figure><p>如果想要查看<strong>所有容器</strong>（不论是否运行）</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># linux 的 ps 是查看进程</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># 不加 - a 就只能查看运行的容器</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">docker</span> <span class=\"token function\">ps</span> <span class=\"token parameter variable\">-a</span></pre></td></tr></table></figure><p><img data-src=\"https://s3.bmp.ovh/imgs/2022/09/21/7bcf577b1cbd289f.jpg\" alt=\"\" /></p>\n<p>想要停止或者删除容器，就需要使用 ID 或者 NAMES 来指定容器，关于容器的相关操作：</p>\n<ul>\n<li>\n<p>删除容器： <code>docker rm &lt;容器名/ID&gt;</code> 。</p>\n</li>\n<li>\n<p>停止容器： <code>docker stop &lt;XXX&gt;</code> 。</p>\n</li>\n<li>\n<p>运行停止的容器： <code>docker start &lt;XXX&gt;</code> 。因为有些容器是执行完后马上停止，而不是像服务器那样阻塞从而一直保持运行状态。</p>\n</li>\n<li>\n<p>重启容器： <code>docker restart &lt;XXX&gt;</code> 。</p>\n</li>\n<li>\n<p>停止后自动删除： <code>docker run --rm &lt;XXX&gt;</code> 。</p>\n</li>\n</ul>\n<p>在指定 ID 时，可以不用将 ID 完整打出来，只要前面一部分能够<strong>唯一标识</strong>该容器即可。</p>\n<blockquote>\n<p>该部分通过 hello-world 的例子讲解了一些命令和容器操作</p>\n</blockquote>\n<h1 id=\"镜像结构\"><a class=\"anchor\" href=\"#镜像结构\">#</a> 镜像结构</h1>\n<p>先回顾一下镜像，容器与仓库的关系，这是官网的图：</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/09/21/8ef2d678187a6499.jpg\" alt=\"\" /></p>\n<p>可以看到，容器的建立（实例化）依赖于镜像，项目打包需要一个基本的操作系统环境，这样才能在操作系统中安装依赖，这种基本的系统镜像，叫做<strong> base 镜像</strong>。一般 base 镜像就是各个 Linux 操作系统的发行版。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 如果你执行过上面的 centos 的 hello world</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># 就不需要再执行该语句</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">docker</span> pull centos</pre></td></tr></table></figure><p>这就是 centos 的 base 镜像，<strong>base 镜像省去了内核</strong>，内存很小。<img data-src=\"https://s3.bmp.ovh/imgs/2022/09/21/2ccdcf9b038c620c.png\" alt=\"\" /></p>\n<h2 id=\"base镜像机制\"><a class=\"anchor\" href=\"#base镜像机制\">#</a> base 镜像机制</h2>\n<p><strong>Linux 操作系统</strong>有内核空间和用户空间组成，这里需要了解两个文件系统：</p>\n<ul>\n<li>bootfs 包含 BootLoader 和 Linux 内核，在内核启动后，bootfs 会自动卸载。</li>\n<li>rootfs 包含系统常见目录结构，包括 <code>/dev</code> ， <code>/bin</code>  等以及一些基本的文件和命令。</li>\n</ul>\n<p><strong>base 镜像底层会直接使用宿主主机的内核</strong>，而 rootfs 可以在不同容器中运行多种不同的版本，所以实际上 base 镜像只包含 CentOS 的 rootfs。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># uname 查看内核版本</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">uname</span> <span class=\"token parameter variable\">-r</span></pre></td></tr></table></figure><p>因此，Docker 能够同时模拟多种 Linux 操作系统环境。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 启动 base 镜像</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-it</span> centos</pre></td></tr></table></figure><p>参数 <code>-it</code>  进行启动，其中 <code>-i</code>  表示在容器上打开一个标准输入（STDIN）接口， <code>-t</code>  表示分配一个伪 tty 设备，可以支持终端登录（理解为伪终端），一般这两个是一起使用，否则 base 容器启动后就自动停止了。</p>\n<blockquote>\n<p>两个合起来的意思就是会弹出一个可以标准输入的终端提示符。</p>\n</blockquote>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/09/21/e0ad3e663ad0fd3e.jpg\" alt=\"\" /></p>\n<p>使用 <code>exit</code>  退出后（<strong>CTRL+D 也可以</strong>），容器也会停止，再次启动时，<strong>需要加上 <code>-i</code>  参数才能输入进行交互，否则就是后台运行</strong>。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> start <span class=\"token parameter variable\">-i</span> <span class=\"token operator\">&lt;</span>容器ID<span class=\"token operator\">></span></pre></td></tr></table></figure><h2 id=\"安装镜像\"><a class=\"anchor\" href=\"#安装镜像\">#</a> 安装镜像</h2>\n<p>前面提到为什么需要一个基本的操作系统，基于 base 镜像，我们可以在这基础上安装各种软件，使用分层结构，每安装一个软件，就在 base 镜像上叠加上去。</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/09/21/2600c8683f6fa6f4.jpg\" alt=\"\" /></p>\n<p>** 所有的镜像会叠起来组成一个统一的文件系统，如果不同层中存在相同位置的文件，那么上层的会覆盖掉下层的文件，最终我们看到的是一个叠加之后的文件系统。** 当需要修改容器中的文件时，实际上并不会对镜像进行直接修改，而是在最顶上的容器层（最上面一般称为容器层，下面都是镜像层）进行修改。</p>\n<p>各个操作如下：</p>\n<ul>\n<li>\n<p>文件读取：要读取一个文件，Docker 会<strong>最上层往下</strong>依次寻找，找到后则打开文件。</p>\n</li>\n<li>\n<p>文件创建和修改：创建新文件会直接添加到容器层中，修改文件会从上往下依次寻找各个镜像中的文件，如果找到，则将其复制到容器层，再进行修改。</p>\n</li>\n<li>\n<p>删除文件：删除文件也会从上往下依次寻找各个镜像中的文件，一旦找到，并不会直接删除镜像中的文件，而是在容器层标记这个删除操作。</p>\n</li>\n</ul>\n<h1 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h1>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wZGFpLnRlY2gvbWQvZGV2b3BzL2RvY2tlci9kb2NrZXItMDItYmFzaWMuaHRtbA==\">https://pdai.tech/md/devops/docker/docker-02-basic.html</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueXVxdWUuY29tL3Fpbmdrb25neGlhZ3Vhbmcvendoa3BpL2txNnJsZyNhMzI3ZGRmMg==\">https://www.yuque.com/qingkongxiaguang/zwhkpi/kq6rlg#a327ddf2</span></p>\n</blockquote>\n",
            "tags": [
                "Docker"
            ]
        },
        {
            "id": "https://cecilia.cool/2022/09/20/Docker/Docker(1)-%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8/",
            "url": "https://cecilia.cool/2022/09/20/Docker/Docker(1)-%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8/",
            "title": "Docker(1)--容器技术入门",
            "date_published": "2022-09-20T03:56:30.000Z",
            "content_html": "<h1 id=\"虚拟化技术\"><a class=\"anchor\" href=\"#虚拟化技术\">#</a> 虚拟化技术</h1>\n<p>Virtualization 是一种资源管理技术，将计算机各种实体资源（服务器，内存，网络）予以抽象，打破实体结构间不可切割的障碍，使用户可以更好的方式利用资源。从而实现在同一主机上运行多个系统或应用。</p>\n<p>软件虚拟化技术是利用软件技术，在现有的物理平台上实现对物理平台访问的截获和模拟。有些软件虚拟化技术需要依赖硬件支持，比如：VMware，KVM。</p>\n<p>Docker 就是软件虚拟化，软件虚拟化分为好几类，Docker 实际是操作系统层虚拟化。<strong>操作系统级虚拟化也被称为容器化</strong>，它允许多个相互隔离的用户空间实例存在，这些用户空间实例也被<strong>容器</strong>。</p>\n<blockquote>\n<p>普通的进程可以看到计算机所有资源而容器只能看到分配给该容器的资源</p>\n</blockquote>\n<p>实现操作系统虚拟化需要用到<strong> Namespace</strong> 及<strong> cgroups</strong> 技术。</p>\n<p>因为不是主要讲解虚拟化技术的底层实现，所以详细可以看这篇文章：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9teS5vc2NoaW5hLm5ldC9rZWx2aW54dXB0L2Jsb2cvMTYwMjk5MA==\">操作系统级虚拟化概述</span>。</p>\n<h2 id=\"docker虚拟化\"><a class=\"anchor\" href=\"#docker虚拟化\">#</a> Docker 虚拟化</h2>\n<p>Docker 是一个开源的应用容器引擎，它让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到安装了任何 Linux 发行版本的机器上。Docker 是直接运行在宿主操作系统之上的一个容器（操作系统级别的虚拟化），<strong>所有容器用的都是宿主操作系统的内核</strong>。</p>\n<p>Docker 能快速搭建开发环境，并且每个容器相互隔离：我们只需要将这些环境打包成镜像，到需要在服务器上部署时，可以直接下载镜像实现一键部署。</p>\n<h2 id=\"docker与虚拟机区别\"><a class=\"anchor\" href=\"#docker与虚拟机区别\">#</a> Docker 与虚拟机区别</h2>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/09/20/204f57e058964113.jpg\" alt=\"\" /></p>\n<p><strong>虚拟机</strong></p>\n<ul>\n<li>基础设施（Infrastructure）：个人电脑，服务器，云主机。</li>\n<li>主操作系统（Host Operating System）：基础设施上运行的 MacOS，Windows 或者某个 Linux 发行版。</li>\n<li>虚拟机管理系统（Hypervisor）：利用 Hypervisor，可以在主操作系统之上运行多个不同的从操作系统。类型 1 的 Hypervisor 有支持 MacOS 的 HyperKit，支持 Windows 的 Hyper-V 以及支持 Linux 的 KVM。类型 2 的 Hypervisor 有 VirtualBox 和 VMWare。</li>\n<li><strong>操作系统（Guest Operating System）</strong>：假设你需要运行 3 个相互隔离的应用，则需要使用 Hypervisor 启动 3 个从操作系统，也就是 3 个虚拟机。这些虚拟机都非常大，也许有 700MB，这就意味着它们将占用 2.1GB 的磁盘空间。更糟糕的是，它们还会消耗很多 CPU 和内存。</li>\n<li>各种依赖：每一个从操作系统都需要安装许多依赖。如果你的的应用需要连接 PostgreSQL 的话，则需要安装 libpq-dev；如果你使用 Ruby 的话，应该需要安装 gems；如果使用其他编程语言，比如 Python 或者 Node.js，都会需要安装对应的依赖库。</li>\n</ul>\n<p><strong>Docker 容器</strong></p>\n<ul>\n<li>主操作系统（Host Operating System）：所有主流的 Linux 发行版都可以运行 Docker。对于 MacOS 和 Windows，也有一些办法 &quot;运行&quot;Docker。</li>\n<li>Docker 守护进程（Docker Daemon）：Docker 守护进程取代了 Hypervisor，它是运行在操作系统之上的后台进程，<strong>负责管理 Docker 容器</strong>。</li>\n<li>各种依赖。对于 Docker，<strong>应用的所有依赖都打包在 Docker 镜像中，Docker 容器是基于 Docker 镜像创建的</strong>。</li>\n<li>应用。应用的源代码与它的依赖都打包在 Docker 镜像中，不同的应用需要不同的 Docker 镜像。不同的应用运行在不同的 Docker 容器中，它们是相互隔离的。</li>\n</ul>\n<blockquote>\n<p>Docker 守护进程可以直接与主操作系统进行通信，为各个 Docker 容器分配资源；它还可以将容器与主操作系统隔离，并将各个容器互相隔离。</p>\n</blockquote>\n<h1 id=\"docker架构\"><a class=\"anchor\" href=\"#docker架构\">#</a> Docker 架构</h1>\n<p>Docker 是 C/S 架构，通过远程 API 来管理和创建容器。</p>\n<p>客户端：客户端通过命令行或者其他工具使用 Docker SDK 和 Docker 守护进程通信。</p>\n<p>主机：物理或虚拟机器，用于执行 Docker 守护进程和容器。</p>\n<p>其他的基本概念：</p>\n<ul>\n<li>\n<p><strong>镜像（Image）</strong>：Docker 镜像（Image），就相当于是一个 root 文件系统。</p>\n</li>\n<li>\n<p><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>\n</li>\n<li>\n<p><strong>仓库（Repository）</strong>：仓库可看着一个代码控制中心，用来保存镜像。</p>\n</li>\n</ul>\n<h1 id=\"docker安装\"><a class=\"anchor\" href=\"#docker安装\">#</a> Docker 安装</h1>\n<blockquote>\n<p>我使用的系统是 Ubuntu 20.04.3 版本</p>\n</blockquote>\n<p>先安装一些工具</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> ca-certificates <span class=\"token function\">curl</span> gnupg lsb-release</pre></td></tr></table></figure><p>再安装官方的 GPG key：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">mkdir</span> <span class=\"token parameter variable\">-p</span> /etc/apt/keyrings</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">curl</span> <span class=\"token parameter variable\">-fsSL</span> https://download.docker.com/linux/ubuntu/gpg <span class=\"token operator\">|</span> <span class=\"token function\">sudo</span> gpg <span class=\"token parameter variable\">--dearmor</span> <span class=\"token parameter variable\">-o</span> /etc/apt/keyrings/docker.gpg</pre></td></tr></table></figure><p>将 Docker 的库添加到 apt 资源列表中：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"deb [arch=<span class=\"token variable\"><span class=\"token variable\">$(</span>dpkg --print-architecture<span class=\"token variable\">)</span></span> signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu <span class=\"token variable\"><span class=\"token variable\">$(</span>lsb_release <span class=\"token parameter variable\">-cs</span><span class=\"token variable\">)</span></span> stable\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">sudo</span> <span class=\"token function\">tee</span> /etc/apt/sources.list.d/docker.list <span class=\"token operator\">></span> /dev/null</pre></td></tr></table></figure><p>更新 apt：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> update</pre></td></tr></table></figure><p>安装 Docker CE 版本</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> docker-ce</pre></td></tr></table></figure><p>等待安装后，查看 Docker 版本</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> <span class=\"token parameter variable\">--version</span></pre></td></tr></table></figure><p>但是我们使用了 sudo 命令（因为当前用户使用权限可能不足），所以需要将当前用户加入到 Docker 组里面</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">usermod</span> <span class=\"token parameter variable\">-aG</span> <span class=\"token function\">docker</span> <span class=\"token operator\">&lt;</span>用户名<span class=\"token operator\">></span></pre></td></tr></table></figure><p>退出 ssh 终端，重新连接即可生效。</p>\n<p>我们可以先看一下 Docker 这个组</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 这里把提示符部分也写出来是为了展示一下我的用户名</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>cyan@cyan-virtual-machine:~$ <span class=\"token function\">cat</span> /etc/group</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 最后一排：docker:x:998:cyan</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\"># 我已经执行过 usermod 命令了，所以 docker 组有 cyan 这个用户</span></pre></td></tr></table></figure><p>关于详细的 Linux 组的知识，你可以参考这篇文章：<a href=\"https://cecilia.cool/2022/07/31/Shell/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/\">Linux 文件权限</a>。</p>\n<blockquote>\n<p>如果加入组后权限依然不够，执行： <code>newgrp docker</code> 。newgrp 命令是登入群组。</p>\n</blockquote>\n<p>前文提到 Docker 架构（C/S），现在部署 Nginx 服务器</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">-p</span> <span class=\"token number\">80</span>:80 nginx</pre></td></tr></table></figure><p>会从镜像仓库里面下载对应的镜像，下载完成后就在后台运行了</p>\n<blockquote>\n<p>在浏览器的 url 中输入虚拟机 IP，就能看到 Nginx 启动了</p>\n</blockquote>\n<p>该命令流程：</p>\n<ol>\n<li>Docker 客户端将操作发送给服务端，告诉服务端我们要运行 nginx 这个镜像。</li>\n<li>Docker 服务端先看看本地有没有这个镜像，发现没有。</li>\n<li>接着只能从公共仓库 Docker Hub 去查找下载镜像了。</li>\n<li>下载完成，镜像成功保存到本地。</li>\n<li>Docker<strong> 服务端加载 Nginx 镜像</strong>，启动容器开始正常运行。</li>\n</ol>\n<h1 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h1>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wZGFpLnRlY2gvbWQvZGV2b3BzL2RvY2tlci9kb2NrZXItMDEtZG9ja2VyLXZtLmh0bWw=\">https://pdai.tech/md/devops/docker/docker-01-docker-vm.html</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueXVxdWUuY29tL3Fpbmdrb25neGlhZ3Vhbmcvendoa3BpL2txNnJsZw==\">https://www.yuque.com/qingkongxiaguang/zwhkpi/kq6rlg</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9teS5vc2NoaW5hLm5ldC9rZWx2aW54dXB0L2Jsb2cvMTYwMjk5MA==\">https://my.oschina.net/kelvinxupt/blog/1602990</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vamllLWZhbmcvcC8xMDI3OTYyOS5odG1s\">https://www.cnblogs.com/jie-fang/p/10279629.html</span></p>\n</blockquote>\n",
            "tags": [
                "Docker"
            ]
        }
    ]
}