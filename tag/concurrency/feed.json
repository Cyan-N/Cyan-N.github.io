{
    "version": "https://jsonfeed.org/version/1",
    "title": "慕青の迷途 • All posts by \"concurrency\" tag",
    "description": "时雨病重症患者",
    "home_page_url": "https://cecilia.cool",
    "items": [
        {
            "id": "https://cecilia.cool/2022/12/28/Java/Concurrency/Java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6B(%E5%85%B3%E9%94%AE%E5%AD%97)/",
            "url": "https://cecilia.cool/2022/12/28/Java/Concurrency/Java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6B(%E5%85%B3%E9%94%AE%E5%AD%97)/",
            "title": "Java并发机制B(关键字)",
            "date_published": "2022-12-28T10:16:37.000Z",
            "content_html": "<h2 id=\"volatile关键字\"><a class=\"anchor\" href=\"#volatile关键字\">#</a> volatile 关键字</h2>\n<p>CPU 并不是和内存直接交互，而是和 <code>cache</code>  高速缓存交互，当需要访问一个内存地址时，如果这个地址之前被读到 <code>cache</code>  中，就直接从 <code>cache</code>  中拿，这叫做<strong>缓存命中</strong>。同时，如果想要修改一个数据，而这个数据被读到了 <code>cache</code>  中，处理器则会将这个操作数写回到缓存中，而不是内存中，这叫做<strong>写命中</strong>。</p>\n<p>这也导致，在多处理器中，多个线程各自运行在自己的处理器上，对共享变量各自都在 <code>cache</code>  中有一份副本，某一线程对该变量修改后是写回缓存中，而不是马上写回内存，即使写回内存，其他线程也不会读取新的值（因为自己的 <code>cache</code>  中始终处于缓存命中状态，除非该部分被其他内存地址覆盖）。</p>\n<p><code>volatile</code>  的作用有两个，假设被该关键词修饰的变量为 <code>count</code> ：</p>\n<ol>\n<li><code>count</code>  被某一个线程修改后，会立即写入内存中。</li>\n<li>这个写回操作会使其他 CPU 的 <code>cache</code>  缓存了该内存地址的数据无效。</li>\n</ol>\n<h3 id=\"实现原理\"><a class=\"anchor\" href=\"#实现原理\">#</a> 实现原理</h3>\n<p>被 <code>volatile</code>  修饰的变量在进行写操作时，JVM 会向处理器发送一条 <code>lock</code>  前缀指令，该指令就会让变量所在的缓存行的数据写回到系统内存中。</p>\n<p>在多处理器下，为了保证各个处理器的缓存是一致的，会实现<strong>缓存一致协议（MESI）</strong>：每个处理器通过嗅探总线上传播的数据来检查自己缓存的值是否过期，从而设置自己缓存中的对应的数据为无效状态。</p>\n<p>早期的 <code>lock</code>  前缀会使处理器执行当前指令时产生一个 <code>LOCK#</code> 信号，会对<strong>总线进行锁定</strong>，其他 CPU 对内存的读写请求会被阻塞，直到锁释放，但是开销比较大。后来加锁操作变成了<strong>高速缓存锁</strong>。缓存锁不是指给某一行缓存上锁，而是说<strong>某个 CPU 对缓存数据进行更改时，会通知缓存了该数据的其他 CPU 抛弃缓存的数据或者从内存重新读取。</strong></p>\n<h3 id=\"缓存一致性\"><a class=\"anchor\" href=\"#缓存一致性\">#</a> 缓存一致性</h3>\n<p>缓存是分段的，一个段对应一块存储空间，称之为<strong>缓存行</strong>，是 CPU 缓存中可分配的最小存储单元，通常是 64 字节， LOCK# 因为锁总线效率太低，因此使用了多组缓存。 为了使其行为看起来如同一组缓存那样。因而设计了 缓存一致性协议。 缓存一致性协议有多种，但是日常处理的大多数计算机设备都属于 &quot; <strong>嗅探</strong> &quot; 协议。 <strong>所有内存的传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线。</strong> 缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁 (同一个指令周期中，只有一个 CPU 缓存可以读写内存)。 CPU 缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。 当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。 只要某个处理器写内存，其它处理器马上知道这块内存在它们的缓存段中已经失效。</p>\n<p>之前也提到过， <code>volatile</code>  不能保证并发安全，多个线程对共享变量进行自增的例子：线程 1 刚刚将 a 的值更新为 100，这时线程 2 可能也已经执行到更新 a 的值这条指令了，<strong>已经刹不住车了</strong>，所以依然会将 a 的值再更新为一次 100。</p>\n<h3 id=\"优化\"><a class=\"anchor\" href=\"#优化\">#</a> 优化</h3>\n<p>在 Java7 中并发包下新增了一个队列集合类 <code>LinkedTransferQueue</code> ，Doug lea 设计这个队列的节点时，用一个类将节点包装起来，再通过加入一些无用的引用 <code>reference</code>  来将包装类扩充到 64 字节大小，下面是我修改后，意思相近的代码：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 队列代码</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Reference</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">QNode</span><span class=\"token punctuation\">></span></span> head<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Reference</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">QNode</span><span class=\"token punctuation\">></span></span> tail<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Reference</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token class-name\">V</span> value<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token class-name\">Object</span> p0<span class=\"token punctuation\">,</span>p1<span class=\"token punctuation\">,</span>p2<span class=\"token punctuation\">,</span>p3<span class=\"token punctuation\">,</span>p4<span class=\"token punctuation\">,</span>p5<span class=\"token punctuation\">,</span>p6<span class=\"token punctuation\">,</span>p7<span class=\"token punctuation\">,</span>p8<span class=\"token punctuation\">,</span>p9<span class=\"token punctuation\">,</span>pa<span class=\"token punctuation\">,</span>pb<span class=\"token punctuation\">,</span>pc<span class=\"token punctuation\">,</span>pd<span class=\"token punctuation\">,</span>pe<span class=\"token punctuation\">;</span><span class=\"token comment\">// 15 个引用，一个引用占 4 字节</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>加入队列中的是 <code>Reference</code> ，这是一个很神奇的事，它将共享变量扩充到了 64 字节。因为在英特尔酷睿 i7 等处理器，缓存行是 64 字节，如果头节点和尾节点加起来都不足 <code>64byte</code> ，那么他们可能会被分配到一个缓存行，当需要入队（修改尾节点）时，就会锁定整个缓存行，导致其他处理器的对应缓存行失效，本来应该只失效尾节点数据，但是此时头节点和尾节点在同一行中，导致头节点也失效。</p>\n<p>将节点大小扩充到 64 字节后，避免了头节点和尾节点在同一缓存行中。</p>\n<h2 id=\"synchronized关键字\"><a class=\"anchor\" href=\"#synchronized关键字\">#</a> synchronized 关键字</h2>\n<p><code>synchronized</code>  是对一个 Java 对象上锁，底层原理是对一个 Java 对象的头部信息进行修改从而记录这个锁对象是否被获取，被哪个线程获取，锁类型（偏向，轻量，重量锁）等信息，因为 Java 对象中有一个很特别的 <code>Class</code>  对象，这也就导致了对象锁和类锁两种区别。</p>\n<h3 id=\"对象锁\"><a class=\"anchor\" href=\"#对象锁\">#</a> 对象锁</h3>\n<p>包括方法锁和同步代码块，因为 <code>synchronized</code>  可以修饰方法，所以有了方法锁的定义，可以理解为整个方法都包含在了同步代码块中。</p>\n<p>对于对象锁，作用范围仅在于某个实例对象</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">lombok<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Data</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token class-name\">Solution</span> test <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>            <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>test<span class=\"token operator\">::</span><span class=\"token function\">func</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>test<span class=\"token punctuation\">.</span><span class=\"token function\">getCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token annotation punctuation\">@Data</span>\t<span class=\"token comment\">// 使用了 lombok 框架</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">void</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>上述代码是方法锁的例子，如果要将其改为同步代码块，只需要将 <code>func</code>  方法改为：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">synchronized</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>通过引用 <code>this</code>  对象来实现同步代码块的上锁。</p>\n<h3 id=\"类锁\"><a class=\"anchor\" href=\"#类锁\">#</a> 类锁</h3>\n<p>类锁作用域整个类，方法锁用于静态方法，同步・代码块的锁对象为 <code>xxx.class</code> 。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>            <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>                <span class=\"token keyword\">new</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Solution</span><span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">void</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token comment\">// 实例化对象不能调用静态方法，所以需要通过另一个方法间接使用</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>            <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>同步代码块此处不再演示，本质上就是获得 <code>Solution</code>  类的 <code>Class</code>  对象锁。</p>\n<p>对象锁和类锁的本质是没有什么区别的，都是将一个 Java 对象作为锁，线程去获取。我并不推荐这样的理解：</p>\n<blockquote>\n<p>对象锁作用于指定的对象，类锁作用域所有对象。</p>\n</blockquote>\n<p>读者需要理解的是，<strong> <code>synchronized</code>  到底需要拿到什么样的锁</strong>。因为 <code>Class</code>  对象全局唯一，所以所有同一个类的实例化对象调用类锁修饰的静态方法 / 同步代码块，都需要去竞争同一个 <code>Class</code>  对象，自然就导致类锁作用于所有实例化对象。</p>\n<h3 id=\"原理分析\"><a class=\"anchor\" href=\"#原理分析\">#</a> 原理分析</h3>\n<p>使用 <code>synchronized</code> ，会在底层字节码文件中产生 <code>Monitorenter</code>  和 <code>Monitorexit</code>  两个指令，对让对象在执行，使其锁计数器<strong>加 1 / 减 1</strong>，<strong>一个对象在同一时间只与一个 <code>monitor</code> （锁）相关联，而一个 monitor 在同一时间只能被一个线程获得</strong>。</p>\n<p>线程尝试获取这个 <code>Monitor</code>  锁时， <code>monitorenter</code>  指令会发生 3 种情况：</p>\n<ul>\n<li>计数器为 0，线程获取锁并将其 + 1，别的线程只能等待释放。</li>\n<li>该线程已经有了锁的所有权，重入锁，计数器加 1。</li>\n<li>等待其他线程释放锁（进入阻塞队列），线程状态变为 <code>BLOCKED</code> 。</li>\n</ul>\n<p>而 <code>monitorexit</code>  指令则是将计数器 - 1，如果之前是重入了，就不需要释放锁，如果计数器变为 0，释放锁。</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2023/01/01/c60358e73ac37169.jpg\" alt=\"\" /></p>\n<blockquote>\n<p><strong>可重入</strong>一定需要保证单个线程执行时重新进入同一个子程序仍然是安全的。</p>\n</blockquote>\n<h3 id=\"锁的优化\"><a class=\"anchor\" href=\"#锁的优化\">#</a> 锁的优化</h3>\n<p>这种优化是基于一种假设：大部分同步代码一般都处于无锁竞争状态，即单线程执行环境。之前的 <code>monitorenter</code>  和 <code>monitorexit</code>  指令需要依赖底层操作系统的 <code>Mutex Lock</code>  实现，该命令需要将当前线程挂起并从<strong>用户态切换到内核态</strong>，切换的代价非常贵。基于之前优化假设，如果锁一般处于单线程获取锁的情况，也就是大部分时间都<strong>只有同一个线程反复拿到这个锁，释放锁，再次拿锁</strong>。那么每次重新拿锁就会导致状态切换，开销很大。</p>\n<p>所以之后出现了偏向锁，轻量锁来优化 <code>synchronized</code>  的性能。</p>\n<p>还有几个其他的概念：</p>\n<ul>\n<li>锁粗化：减少不必要的紧连在一起的 unlock，lock 操作，将多个连续的锁扩展成一个范围更大的锁。</li>\n<li>锁消除：通过运行时 JIT 编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护，通过逃逸分析也可以在线程本的 Stack 上进行对象空间的分配 (同时还可以减少 Heap 上的垃圾收集开销)。</li>\n</ul>\n<p>在 jdk1.6 种， <code>synchronized</code>  同步锁一共有四种状态： <code>无锁</code> 、 <code>偏向锁</code> 、 <code>轻量级锁</code> 、 <code>重量级锁</code> ，它会随着竞争情况逐渐升级。锁可以升级但是<strong>不可以降级</strong>，目的是为了提供获取锁和释放锁的效率。</p>\n<blockquote>\n<p>锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁</p>\n</blockquote>\n<h4 id=\"自旋锁\"><a class=\"anchor\" href=\"#自旋锁\">#</a> 自旋锁</h4>\n<p>在操作系统篇也讲到过这个锁的出现，它通过不断地 <code>while</code>  循环 <code>CAS</code>  操作尝试获取锁。自旋锁是最简单的锁，其缺点就是会消耗整个 CPU 时间片，直到拿到了锁。</p>\n<p>有时这样的锁是不能接受的，但是 jdk 引入自旋锁，是因为有时共享数据的锁定状态只会持续很短时间，为了这段时间<strong>挂起，恢复阻塞线程</strong>并不值得，所以完全可以让没有获取到锁的线程在外面等待一会（自旋）。</p>\n<p>自旋锁适用于竞争线程很少的情况下，如果大量线程竞争同一个自旋锁，或者同步代码块执行时间非常长，是不能接受的。所以 JDK 定义自旋锁默认自旋次数为 10 次，还没拿到锁就得去挂起线程。</p>\n<blockquote>\n<p><code>-xx:PreBlockSpin</code>  参数可以修改自旋次数。</p>\n</blockquote>\n<p>在 JDK1.6 引入了<strong>自适应自旋锁</strong>，自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。</p>\n<h4 id=\"偏向锁\"><a class=\"anchor\" href=\"#偏向锁\">#</a> 偏向锁</h4>\n<p>了解整个 <code>synchronized</code>  的锁膨胀过程，需要了解 <code>HotSpot</code>  虚拟机种对象头的内存布局，对象头存在两部分：</p>\n<ul>\n<li><code>Mark Word</code> ：存储对象自身的运行时数据， <code>HashCode</code> 、 <code>GC Age</code> 、锁标记位、是否为偏向锁。</li>\n<li><code>Klass Point</code> ：存储的是指向方法区对象类型数据的指针，如果对象是数组的话，还会有一个额外的部分用于存储数据的长度。</li>\n</ul>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2023/01/01/e514dba9540d23bd.jpg\" alt=\"\" /></p>\n<p>在 jdk1.6 引入了偏向锁，当一个线程访问同步块并获取锁时，会在<strong>对象头</strong>和<strong>线程栈帧</strong>中的锁记录里存储锁偏向的线程 ID，以后该线程在进入和推出同步块时不需要进行 CAS 操作来加锁和解锁。只需要测试一下对象头的 <code>Mark Word</code>  里是否存储着指向当前线程的偏向锁。如果成功，表示线程已经获取到了锁。</p>\n<p>下面是《Java 并发编程的艺术》对偏向锁的解释：</p>\n<p>只有当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销需要等到 ** 全局安全点 (** 就是当前线程没有正在执行的字节码)。会首先暂停拥有偏向锁的线程，让你后检查持有偏向锁的线程是否活着。如果线程不处于活动状态，直接将对象头设置为无锁状态。如果线程活着，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁（升级为轻量锁）。</p>\n<h4 id=\"轻量锁\"><a class=\"anchor\" href=\"#轻量锁\">#</a> 轻量锁</h4>\n<p>在线程执行同步块之前，JVM 会先在当前线程的栈帧中创建一个名为锁记录 ( <code>Lock Record</code> ) 的空间，用于存储锁对象目前的 <code>Mark Word</code>  的拷贝 (JVM 会将对象头中的 <code>Mark Word</code>  拷贝到锁记录中，官方称为 <code>Displaced Mark Ward</code> )</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2023/01/01/e7b5db628ab90811.jpg\" alt=\"\" /></p>\n<p>上图还没有将拷贝存储到 <code>Lock Record</code>  空间。</p>\n<p>CAS 操作将 <code>Mark Word</code>  拷贝到所记录中，同时将 <code>Mark Word</code>  更新为指向 <code>Lock Record</code>  的指针，如果更新成功了，该线程就有了该对象的锁，并且对象的 <code>Mark Word</code>  最后两位更新为<strong> 00</strong>。</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2023/01/01/20cc5748bddc69b8.jpg\" alt=\"\" /></p>\n<p>如果这个更新操作失败，<strong>JVM 会检查当前的 <code>Mark Word</code>  中是否存在指向当前线程的栈帧的 <code>Lock Record</code>  的指针：</strong></p>\n<ul>\n<li>如果有，相当于锁重入，就会再创建一个 <code>Lock Record</code>  作为重入的计数</li>\n</ul>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2023/01/01/37198c41e0eea6e9.jpg\" alt=\"\" /></p>\n<ul>\n<li>没有，说明该锁被其他线程抢占，如果由两条以上的线程竞争同一个锁，就会直接膨胀为重量级锁。</li>\n</ul>\n<p>膨胀过程中，会为锁对象申请一个 <code>Monitor</code>  锁，让 <code>Mark Word</code>  指向 <code>Monitor</code>  地址。</p>\n<p>轻量锁<strong>解锁</strong>时，会使用 CAS 将 <code>Displaced Mark Word</code>  替换回到对象头中，如果成功，则没有发生竞争关系，如果失败，表示当前锁存在竞争关系，膨胀为重量级锁。</p>\n<p>下图来自《Java 并发编程的艺术》：</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2023/01/01/078b3563ac71c7b4.jpg\" alt=\"\" /></p>\n<p>从上图可以看到，线程 2 不断自旋获取锁，当自旋次数过长，导致线程 2 挂起不再自旋，此时线程 2 会修改对象头的 <code>Martk Word</code>  指向 <code>Monitor</code>  锁，并阻塞自己，所以线程 1 希望通过 <code>CAS</code>  替换释放锁时，就会失败，此时线程 1 会将指向重量级锁的指针设为空，将原有的锁释放并唤醒线程 2。</p>\n<p>上述对图的解释来自于：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hc2suY3Nkbi5uZXQvcXVlc3Rpb25zLzQ2NDYyMjc=\">https://ask.csdn.net/questions/4646227</span> 评论区中 2022-11-03 的 **k？？** 网友提出的，我也对自己的疑问也进行了提问。</p>\n<p>作者存疑：</p>\n<p>说实话，我是没搞懂为什么线程 1 在释放轻量锁时会将指针设为空，那还怎么找到 Monitor 对象？</p>\n<p>如果读者有什么高见，劳烦发邮箱：laurensvfevaa@gmail.com 十分感谢</p>\n<blockquote>\n<p>轻量锁的一个很大的特征就是其他线程会自旋等待一段时间，而重量锁会直接阻塞。</p>\n</blockquote>\n<h2 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h2>\n<blockquote>\n<p>《Java 并发编程的艺术》第二章</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wZGFpLnRlY2gvbWQvamF2YS90aHJlYWQvamF2YS10aHJlYWQteC1rZXktdm9sYXRpbGUuaHRtbA==\">https://pdai.tech/md/java/thread/java-thread-x-key-volatile.html</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wZGFpLnRlY2gvbWQvamF2YS90aHJlYWQvamF2YS10aHJlYWQteC1rZXktc3luY2hyb25pemVkLmh0bWw=\">https://pdai.tech/md/java/thread/java-thread-x-key-synchronized.html</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hc2suY3Nkbi5uZXQvcXVlc3Rpb25zLzQ2NDYyMjc=\">https://ask.csdn.net/questions/4646227</span></p>\n</blockquote>\n",
            "tags": [
                "Concurrency"
            ]
        },
        {
            "id": "https://cecilia.cool/2022/12/22/Java/Concurrency/Java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6A(%E7%BA%BF%E7%A8%8B)/",
            "url": "https://cecilia.cool/2022/12/22/Java/Concurrency/Java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6A(%E7%BA%BF%E7%A8%8B)/",
            "title": "Java并发机制A(线程)",
            "date_published": "2022-12-22T03:44:20.000Z",
            "content_html": "<h1 id=\"线程\"><a class=\"anchor\" href=\"#线程\">#</a> 线程</h1>\n<p>本篇讲解 Java 的线程基础。</p>\n<p>谈起线程的状态（生命周期），操作系统层面上和 Java 层面上是不同的：</p>\n<ul>\n<li>\n<p>操作系统：初始状态（NEW），可运行状态（READY），运行状态（RUNNING），等待（WAITING），终止状态（TERMINATED）。</p>\n</li>\n<li>\n<p>Java：新建（New），可运行（Runable），阻塞（Blocking），无限等待（Waiting），限时等待（Timed Waiting），死亡（Terminated）。</p>\n</li>\n</ul>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/12/22/db994fe0c48b9983.jpg\" alt=\"\" /></p>\n<blockquote>\n<p>在操作系统篇中，我们提到的拿不到锁休眠（阻塞），等待条件变量进入等待队列休眠，在操作系统层面都是 WAITING。</p>\n</blockquote>\n<p>注意：</p>\n<ul>\n<li>Java 没有 Running 状态，Runnable 就包括了 Running 和 Ready 以及部分 wait。</li>\n<li>阻塞和等待的区别在于，阻塞是被动的，线程拿不到锁就会阻塞，但是等待是主动的，通过调用 <code>sleep</code>  或 <code>wait</code>  实现。</li>\n</ul>\n<h2 id=\"传入任务\"><a class=\"anchor\" href=\"#传入任务\">#</a> 传入任务</h2>\n<p>首先要构建一个线程，在 <code>Thread</code>  中的 <code>init(..)</code>  方法，会将<strong>当前线程设置为父线程</strong>，新线程是由父线程进行空间分配，子线程继承了父线程是否为 <code>Daemon</code> ，优先级，可继承的 <code>ThreadLocal</code>  等。</p>\n<p>在创建线程对象时，可以传入 <code>Runnable</code>  或者 <code>Callable</code> ，或者继承 <code>Thread</code> ，重写 <code>run</code>  方法。但是实现接口比继承好得多。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello world\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h2 id=\"基础机制\"><a class=\"anchor\" href=\"#基础机制\">#</a> 基础机制</h2>\n<ul>\n<li>\n<p><strong>守护线程</strong>：当所有非守护线程结束后，程序也就会终止，同时杀死所有守护线程。使用 <code>setDaemon(true)</code>  将线程设置为守护线程。如果守护线程中有 <code>finally</code> ，并且在执行 <code>finally</code>  前所有的非守护线程都结束了，虚拟机就会停止，<strong>不会执行 <code>finally</code>  语句</strong>。</p>\n</li>\n<li>\n<p><code>sleep()</code> ：休眠当前线程，如果该线程持有锁，<strong>不会释放锁</strong>。</p>\n</li>\n<li>\n<p><code>yield()</code> ：如果当前线程已经完成生命周期最重要的部分，可以切换给其他线程执行。该方法只是给调度器一个建议。</p>\n</li>\n</ul>\n<h3 id=\"线程中断\"><a class=\"anchor\" href=\"#线程中断\">#</a> 线程中断</h3>\n<p><strong>中断</strong>理解为线程的一个<strong>标识位</strong>属性，表示一个运行的线程是否被其他线程进行了中断操作，打上中断标识不会立即中断线程，而是需要线程自己来处理这个中断标识。</p>\n<p>一个线程执行完毕会自动结束，如果运行过程中<strong>发生异常</strong>也会提前结束。有时在外部我们就是希望中断某一个线程，在 Java 中专门设计了一个 <code>InterruptedException</code>  来提前结束线程。</p>\n<p>如果线程处于阻塞，限期等待或者无限期等待，此时调用 <code>interrupt()</code>  就会触发异常从而结束线程。但是不能中断<strong> I/O 阻塞</strong>和 <code>synchronized</code>  锁阻塞。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">8000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Thread run\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>thread1<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>thread1<span class=\"token punctuation\">.</span><span class=\"token function\">interrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>当一个线程内部是一个循环，且没有执行 <code>sleep</code>  等会抛出中断异常的操作，而我们又希望在外部控制线程中断，可以使用 <code>interrupted()</code>  方法：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 这种设计限制还是比较大的</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">interrupted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token comment\">// ..</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>注意：</p>\n<ul>\n<li>\n<p><code>sleep()</code>  如果要抛出中断异常，会先清空中断标记，再抛出异常。</p>\n</li>\n<li>\n<p><code>interrupted</code>  会清空中断标记，而 <code>isInterrupted()</code>  不会。</p>\n</li>\n<li>\n<p>如果一个线程处于终结状态， <code>isInterrupted</code>  也返回 <code>false</code> 。</p>\n</li>\n</ul>\n<h3 id=\"线程通信\"><a class=\"anchor\" href=\"#线程通信\">#</a> 线程通信</h3>\n<ul>\n<li>使用 <code>volatile</code>  和 <code>synchronized</code>  两个关键字，前者保证共享变量的实时更新，保证了可见性，底层原理是总线嗅探机制；后者可以实现同步代码块，保证同一时间只能有一个线程处于同步代码块，保证线程对变量访问的可见性和排他性。</li>\n</ul>\n<blockquote>\n<p>需要注意的是，之前的例子，多个线程将 <code>count</code>  变量累加 10000，不能用 <code>volatile</code>  修饰 <code>count</code>  来保证线程安全。该关键字不保证线程安全。假设一下，在多 CPU 里面，已经有两个线程将要同时执行关于 <code>count</code>  的写入指令， <code>volatile</code>  对此是无法避免的。</p>\n</blockquote>\n<ul>\n<li>还有一种通信方式就是等待 / 通知机制：该部分类似于之前讲的条件变量那部分的内容，父线程等待子线程结果（<strong>Java 中也可以使用 <code>join</code>  方法</strong>）。\n<ul>\n<li><code>wait()</code> ：进入<strong>等待队列</strong>，线程放弃锁和时间片，满足某条件，才会被唤醒（ <code>notify/notifyAll</code> ）。在之前的操作系统篇提到，<strong> <code>wait</code>  应该在获得锁后才允许被调用</strong>。 <code>wait()</code>  还有两个重载函数，传入参数为等待时间。</li>\n<li><code>notify/notifyAll()</code> ：通知等待队列中的线程从 <code>wait</code>  返回，后者则是将队列中所有线程都唤醒。全部唤醒，还记得覆盖条件的概念吗？</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>其实所谓的唤醒，是将等待队列中的线程放到了同步队列中，因为线程调用了 <code>notify/notifyAll</code>  后还没有释放锁。</p>\n</blockquote>\n<ul>\n<li>管道输入 / 输出流：使用 <code>PipedOutputStream/PipedInputStream/PipedReader/PipedWriter</code>  类</li>\n</ul>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 管道输入输出主要用于线程之间的数据传输</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// 下面代码改编自《Java 并发编程的艺术》，书上用的是字符流，但是中文会出现乱码，所以我改成字节流了</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token class-name\">PipedOutputStream</span> out <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">PipedOutputStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token class-name\">PipedInputStream</span> in <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">PipedInputStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token comment\">// 输入输出流连接，不然会抛出 IOException</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        out<span class=\"token punctuation\">.</span><span class=\"token function\">connect</span><span class=\"token punctuation\">(</span>in<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token class-name\">Thread</span> printThread <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Print</span><span class=\"token punctuation\">(</span>in<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"PrintThread\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        printThread<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token keyword\">int</span> receive <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> buf <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        </pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>            <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>receive <span class=\"token operator\">=</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>in<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>                out<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">,</span><span class=\"token number\">0</span> <span class=\"token punctuation\">,</span>receive<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>            out<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Print</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token keyword\">private</span> <span class=\"token class-name\">PipedInputStream</span> in<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> buf <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        <span class=\"token keyword\">public</span> <span class=\"token class-name\">Print</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">PipedInputStream</span> in<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>in <span class=\"token operator\">=</span> in<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>            <span class=\"token keyword\">int</span> receive <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>                <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">!=</span> <span class=\"token punctuation\">(</span>receive <span class=\"token operator\">=</span> in<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>                    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> receive<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> ignored<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><ul>\n<li><code>ThreadLocal</code> ：该类到时候会详细讲解，此处简单介绍。它是线程变量，存储的是一个键值对，以 <code>ThreadLocal</code>  对象为键，存储指定的泛型值。每个线程都有一个 <code>ThreadLocalMap</code> ，存放的就是各种 <code>ThreadLocal-&gt;value</code>  对。</li>\n</ul>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ThreadLocalTest</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">ThreadLocal</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> threadLocal <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadLocal</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token comment\">// 创建第一个线程</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token class-name\">Thread</span> threadA <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>            threadLocal<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ThreadA：\"</span> <span class=\"token operator\">+</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"线程A本地变量中的值为：\"</span> <span class=\"token operator\">+</span> threadLocal<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"ThreadA\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        </pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token comment\">// 创建第二个线程</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token class-name\">Thread</span> threadB <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            threadLocal<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ThreadB：\"</span> <span class=\"token operator\">+</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"线程B本地变量中的值为：\"</span> <span class=\"token operator\">+</span> threadLocal<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"ThreadB\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        </pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token comment\">// 启动线程 A 和线程 B</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        threadA<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        threadB<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token comment\">// 每次的打印结果可能不一致</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token comment\">// 线程 B 本地变量中的值为：ThreadB：ThreadA</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token comment\">// 线程 A 本地变量中的值为：ThreadA：ThreadB</span></pre></td></tr></table></figure><blockquote>\n<p>如果你此时对 <code>ThreadLocal</code>  还不熟悉（很正常），之后会有一篇文章专门讲解这个，当然，看源码也是必不可缺的。</p>\n</blockquote>\n<h1 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h1>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wZGFpLnRlY2gvbWQvamF2YS90aHJlYWQvamF2YS10aHJlYWQteC10aHJlYWQtYmFzaWMuaHRtbA==\">https://pdai.tech/md/java/thread/java-thread-x-thread-basic.html</span></p>\n<p>《Java 并发编程的艺术》第四章</p>\n</blockquote>\n",
            "tags": [
                "Concurrency"
            ]
        },
        {
            "id": "https://cecilia.cool/2022/12/21/Java/Concurrency/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87C/",
            "url": "https://cecilia.cool/2022/12/21/Java/Concurrency/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87C/",
            "title": "操作系统篇C",
            "date_published": "2022-12-21T15:08:32.000Z",
            "content_html": "<h2 id=\"并发缺陷\"><a class=\"anchor\" href=\"#并发缺陷\">#</a> 并发缺陷</h2>\n<p>并发的缺陷主要分为死锁和非死锁缺陷。</p>\n<h3 id=\"非死锁缺陷\"><a class=\"anchor\" href=\"#非死锁缺陷\">#</a> 非死锁缺陷</h3>\n<p>《操作系统导论》中基于 Lu 及其同事的研究，讨论了<strong>违反原子性缺陷</strong>和<strong>错误顺序缺陷</strong>。</p>\n<ul>\n<li>违反原子性缺陷：</li>\n</ul>\n<p>mysql 中出现过的例子：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Thread <span class=\"token number\">1</span><span class=\"token operator\">::</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>thd<span class=\"token operator\">-></span>proc_info<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">//....</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token function\">fputs</span><span class=\"token punctuation\">(</span>thd<span class=\"token operator\">-></span>proc_info<span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>Thread <span class=\"token number\">2</span><span class=\"token operator\">::</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>thd<span class=\"token operator\">-></span>proc_info <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>如果线程 1 在 <code>fputs</code>  前发生中断，线程 2 将 <code>proc_info</code>  设为空，再执行线程 1 就会出现引用空指针。通过<strong>加锁</strong>就可以解决该问题。</p>\n<ul>\n<li>违反顺序缺陷：</li>\n</ul>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Thread <span class=\"token number\">1</span><span class=\"token operator\">::</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">// ...</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    mThread <span class=\"token operator\">=</span> <span class=\"token function\">PR_CreateThred</span><span class=\"token punctuation\">(</span>mMain<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>Thread <span class=\"token number\">2</span><span class=\"token operator\">::</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">mMain</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token comment\">// ...</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    mState <span class=\"token operator\">=</span> mThread<span class=\"token operator\">-></span>State<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>线程 2 默认了 <code>mState</code>  已经初始化了，如果线程 1 没有先执行，就会引用空指针。所以<strong>需要强制顺序</strong>，即引入条件变量。</p>\n<h3 id=\"死锁缺陷\"><a class=\"anchor\" href=\"#死锁缺陷\">#</a> 死锁缺陷</h3>\n<p>产生条件：</p>\n<ul>\n<li>互斥：线程对于需要的资源进行互斥的访问。</li>\n<li>持有并等待：线程持有资源，等待其他资源。</li>\n<li>非抢占：线程获取的资源不能被抢占。</li>\n<li>循环等待：线程之间存在一个环路，环路上每个线程都额外持有一个资源，而这 个资源又是下一个线程要申请的。</li>\n</ul>\n<p>总结一句话就是：死锁出现的条件就是两个线程各自持有某一资源的锁，然后再请求对方的资源。</p>\n<blockquote>\n<p>当然可能不只是两个线程，多个线程且请求形成环即可。</p>\n</blockquote>\n<p>要预防死锁，就需要避免出现死锁条件</p>\n<h4 id=\"循环等待\"><a class=\"anchor\" href=\"#循环等待\">#</a> 循环等待</h4>\n<p>如果整个系统中，对于锁获得的顺序总是相同的，那么就不会出现循环等待。比如总共有两个锁 <code>L1</code>  和 <code>L2</code> ，如果每次都先申请 L1 再申请 L2，就不会出现死锁问题。这叫做<strong>全序</strong>。</p>\n<p>全序很难做到，偏序可能更现实一点。也就是部分的锁的获取顺序是固定的。</p>\n<blockquote>\n<p>但是其实设计都很复杂，需要很仔细。</p>\n</blockquote>\n<p>当一个函数需要抢多个锁时，为了避免死锁问题而固定锁的顺序，有些人旋转根据锁的地址作为获取锁的顺序。</p>\n<h4 id=\"持有并等待\"><a class=\"anchor\" href=\"#持有并等待\">#</a> 持有并等待</h4>\n<p>通过原子抢锁避免，就是在线程抢锁的过程中不会被打断。其实相当于就是在最外部加上一个全局锁。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span>prevention<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span>L1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span>L2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">//....</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span>prevention<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"非抢占\"><a class=\"anchor\" href=\"#非抢占\">#</a> 非抢占</h4>\n<p>假设 AB 两个线程各自抢了 ab 锁，然后请求对方的锁，会造成死锁。死锁的原因之一就是 AB 都不会主动释放自己的锁。</p>\n<p>在很多语言的线程库中都会提供一个 <code>trylock()</code>  函数，它会尝试抢锁，如果失败，不会阻塞而是返回 - 1，所以为了避免死锁问题，可以让线程抢对方的锁失败后主动释放自己的锁让对方抢：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>top<span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span>L1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">trylock</span><span class=\"token punctuation\">(</span>L2<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span>L1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token keyword\">goto</span> top<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>但是也可能出现活锁，两个线程不断重复，都抢锁然后再释放锁，可以设置一个随机的等待时间，降低线程之间的相互干扰。</p>\n<blockquote>\n<p>关于 <code>trylock</code>  的使用，较为麻烦的就是 <code>goto top</code>  的实现，如果代码在中途中获取了某些资源，必须确保也能释放这些资源。</p>\n</blockquote>\n<h4 id=\"互斥\"><a class=\"anchor\" href=\"#互斥\">#</a> 互斥</h4>\n<p>使资源的访问不再互斥，更多的是使用硬件支持，从而设计出无等待的数据结构。比如使用 <code>CAS</code>  设计链表插入：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token class-name\">node_t</span> <span class=\"token operator\">*</span>n <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">node_t</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    n<span class=\"token operator\">-></span>val <span class=\"token operator\">=</span> val<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">do</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        n<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">CompareAndSet</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>head<span class=\"token punctuation\">,</span> n<span class=\"token operator\">-></span>next<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"基于事件的并发\"><a class=\"anchor\" href=\"#基于事件的并发\">#</a> 基于事件的并发</h2>\n<p>这部分属于进阶内容，怎么说呢，如果你了解网络编程，如果你了解过 Netty，那么这部分理解起来就很简单。但是本部分要讲的内容也不会很多。</p>\n<blockquote>\n<p>所以你听过 <code>select()</code>  和 <code>poll()</code>  这两个 API 吗？</p>\n</blockquote>\n<p>基于事件的服务器，最经典的设计就是写一个死循环，然后监听是否有事件，没有事件就会一直阻塞。 <code>select/poll</code>  就是用于支持检查是否有网络数据包到达。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token comment\">// ...</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token keyword\">int</span> rc <span class=\"token operator\">=</span> <span class=\"token function\">select</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token comment\">// ...</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>使用单个 CPU + 基于事件的应用程序就不会出现并发问题，因为一次只会处理一个事件（其实性能非常 <code>low</code> ，为了并发处理，也就有了 <code>Netty</code> ）。</p>\n<p>当某个事件需要程序发出阻塞的系统调用，如从磁盘读文件，再返回给客户端。这样就需要发送 <code>I/O</code>  请求，造成阻塞，整个系统处于闲置状态，所以基于事件的系统（单线程）必须遵守：不允许调用阻塞调用。</p>\n<p>许多现代操作系统都支持异步 I/O，当事件需要请求 I/O，异步 I/O 的接口使程序发送 I/O 请求，并且在 I/O 完成前将控制权立即返回给调用者，然后有其他接口轮询 I/O 是否完成。</p>\n<p>随着客户端数量连接上升，单线程的基于事件的并发是不可能满足需求的，到时候依然需要，不可避免地创建新的线程来处理：事件，I/O 请求等，详细知识可以参考网络编程标签。</p>\n<h2 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h2>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYWdlcy5jcy53aXNjLmVkdS9+cmVtemkvT1NURVAvQ2hpbmVzZS8zMi5wZGY=\">https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/32.pdf</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYWdlcy5jcy53aXNjLmVkdS9+cmVtemkvT1NURVAvQ2hpbmVzZS8zMy5wZGY=\">https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/33.pdf</span></p>\n</blockquote>\n",
            "tags": [
                "Concurrency"
            ]
        },
        {
            "id": "https://cecilia.cool/2022/12/21/Java/Concurrency/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87B/",
            "url": "https://cecilia.cool/2022/12/21/Java/Concurrency/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87B/",
            "title": "操作系统篇B",
            "date_published": "2022-12-21T02:58:42.000Z",
            "content_html": "<h2 id=\"条件变量\"><a class=\"anchor\" href=\"#条件变量\">#</a> 条件变量</h2>\n<p>线程有时需要检查某一条件（condition）满足后才能继续运行：<strong>子线程 join 父线程</strong>。这也就意味着父线程需要等待子线程运行完才能继续运行。</p>\n<ul>\n<li>设计一个共享变量：这样父线程就需要一直自旋来等待子线程运行结束，将共享变量改为父线程可用状态。这种设计缺点就是浪费时间，某些情况甚至是错误的。</li>\n<li>加入等待队列：其实整个设计思想和 A 篇中我们讲到设计锁的思想很相似，这里的条件变量就是”<strong> 锁</strong> “。当条件不满足时，线程就将自己加入队列，等待该条件。某个线程修改了条件状态，就唤醒一个或多个等待线程。</li>\n</ul>\n<p><strong>定义：条件变量是一个显示的队列，当某些执行状态（即条件）不满足时，线程就将自己加入队列，等待条件</strong>。</p>\n<p>关于条件变量的两种操作： <code>wait()</code>  和 <code>singal()</code> 。 <code>wait()</code>  职责是释放锁，并让调用线程休眠（原子地），当线程被唤醒时，<strong>需要重新竞争锁再返回调用者</strong>，<strong>这是为了避免线程陷入休眠时产生一些竞态条件</strong>； <code>signal()</code>  唤醒等待在某个条件变量上的睡眠线程。</p>\n<blockquote>\n<p><code>wait</code>  会释放锁，牢记，实际上，在 Java 语言中， <code>Object</code>  也有 <code>await()</code>  函数，该方法也会释放锁。</p>\n</blockquote>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> done <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">pthread_cond_wait</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">pthread_cond_t</span> <span class=\"token operator\">*</span>c<span class=\"token punctuation\">,</span> <span class=\"token class-name\">pthread_mutex_t</span> <span class=\"token operator\">*</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">pthread_cond_signal</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">pthread_cond_t</span> <span class=\"token operator\">*</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">thread_exit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 假设已经初始化了一个宏变量 m 作为锁</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    done <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token function\">pthread_cond_signal</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 假设已经初始化了一个宏变量 c 作为等待队列</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">child</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"child\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token function\">thread_exit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">thread_join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>done <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> </pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token function\">pthread_cond_wait</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>agrv<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"parent: begin\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    thread p<span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token function\">thread_create</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> child<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    <span class=\"token function\">thread_join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"parent: end\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>设想如果在发送信号和等待时都不加锁会发生什么问题？在操作系统 A 篇中讲过：<strong>改变锁的状态时一定要是线程安全的</strong>。这里保证互斥除了锁，还有条件变量，也就是信号。</p>\n<blockquote>\n<p>DIjkstra 最早在 “私有信号量” 提出等待条件这个思想，Hoare 在关于观察者的工作中，将这种类似的思想称为<strong>条件变量</strong>。</p>\n</blockquote>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">thr_exit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    done <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token function\">pthread_cond_signal</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">thr_join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>done <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token function\">pthread_cond_wait</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>设想，如果父线程调用 <code>thr_join()</code> ，检查到 <code>done==0</code> ，然后试图休眠，此时发生中断，然后子线程修改 <code>done=1</code> ，发出信号，此时子线程检查到没有等待线程。父线程再次运行，进入休眠，之后就会一直休眠，没有线程唤醒。</p>\n<p>发信号时总是持有锁，但也有一些情况可以不加锁，而这可能是你应该避免的。因此，为 了简单，请在调用  <code>signal</code>  时持有锁（<strong>hold the lock when calling signal</strong>）。同样的，在 <code>wait</code>  时也必须持有锁，这是 <code>wait</code>  语法强制要求的。因为  <code>wait</code>  调 用总是假设你调用它时已经持有锁、调用者睡眠之前会释放锁以及返回前重新持有锁。因此，这个提示 的一般化形式是正确的：调用  <code>signal</code>  和  <code>wait</code>  时要持有锁（<strong>hold the lock when calling signal or wait</strong>）。</p>\n<blockquote>\n<p>在操作系统 A 篇中我们最后给了一个设计锁的例子，结构体里面也有一个队列 <code>queue_t *q</code> ，该队列是竞争锁失败后，线程进入阻塞队列等待锁空闲。线程为了节省时间也会休眠。但是条件变量不同的是需要线程主动调用 <code>wait</code>  主动放弃锁的占用，进入等待队列从而休眠，需要等到一个指定条件发生才会被唤醒。</p>\n</blockquote>\n<h3 id=\"生产消费问题\"><a class=\"anchor\" href=\"#生产消费问题\">#</a> 生产 / 消费问题</h3>\n<p>这也是 Dijkstra 提出来的 —— 生产者消费者问题。我们回顾前面的代码，你也许认为将：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>done <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>改成：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>done <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>也是符合逻辑的。在父线程 / 子线程的案例中，这确实是合理的，但是在使用条件变量时，应该总是使用 <code>while</code> ，在生产者消费者问题中就能够体现出来。</p>\n<p>先看伪代码： <code>count==1</code>  表示缓冲区有数据可以被消费，消费之后就为 0。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">producer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> loops<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>            <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token function\">put</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">consumer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> loops<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token keyword\">int</span> tmp <span class=\"token operator\">=</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span>tmp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>上述代码使用的就是 <code>if</code>  语句，我们假设只有一个生产者。如果只有一个消费者，那么这段代码不会出现问题。但是当出现两个消费者时，就会导致错误。</p>\n<blockquote>\n<p>首先，这个问题肯定是当缓冲区没有数据，就不应该调用 <code>get</code>  的。</p>\n</blockquote>\n<p>设想 <code>C1</code> ， <code>C2</code>  两个消费者此时都 <code>wait</code> ，等待缓冲区加入数据。生产者产生数据后，唤醒了 <code>C1</code>  并拿到了锁， <code>C1</code>  开始执行 <code>int tmp = get();</code>  这段代码。然后继续唤醒等待队列中的线程。当然有可能唤醒 <code>C2</code>  线程并且拿到锁，那么 <code>C2</code>  此时也会执行 <code>get()</code>  函数，但是此时缓冲区并没有数据，<strong>缓冲区无法消费</strong>，就会断言触发，<strong>提示整个并发环境出现了问题</strong>。所以需要将 <code>if</code>  改成 <code>while</code> ，每次被唤醒都需要重新检查一下缓冲区是否还可以消费。</p>\n<blockquote>\n<p>其实导致我们需要循环检查缓冲区消费情况的本质原因是：消费者在休眠的时候 <code>count</code>  可能会减小。</p>\n</blockquote>\n<p>但是仅仅是将 <code>if</code>  改为 <code>while</code>  还是存在问题，主要原因是生产者和消费者都位于同一个休眠（等待，阻塞）队列（这是我自己总结的原因，先不用急着反驳）。</p>\n<p>设想这种情况： <code>P1</code>  作为生产者， <code>C1</code> ， <code>C2</code>  作为两个消费者. <code>C1</code> ， <code>C2</code>  因为缓冲区没有数据先休眠，进入队列。当 <code>P1</code>  向缓冲区放入数据，然后进入队列。此时 <code>C1</code>  被唤醒，消费了数据之后，需要唤醒一个队列中的线程。</p>\n<p>此时应该唤醒一个生产者，因为缓冲区没有数据了，但是不同的队列的管理方式不同，并不是所有队列都是 <code>FIFO</code> ，所以程序运行到后期你根本不知道下一个被唤醒的是生产者还是消费者。如果恰好此时 <code>C2</code>  被唤醒了，进入 <code>while</code>  循环发现缓冲区没有数据，于是继续 <code>wait</code>  休眠，进入队列。此时三个线程都休眠了，就不会再有线程来唤醒队列中的线程了，程序崩溃。</p>\n<p>所以只需要使用两个队列即可，标准的说法就是使用两个条件变量。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">cond_t</span> empty<span class=\"token punctuation\">,</span> fill<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// producer</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>empty<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 当缓冲区为空时，就需要从 empty 唤醒生产者</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>fill<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">// consumer</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>fill<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">int</span> tmp <span class=\"token operator\">=</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>empty<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"覆盖条件\"><a class=\"anchor\" href=\"#覆盖条件\">#</a> 覆盖条件</h3>\n<p>这其实就是 <code>signal_all()</code>  方法，将休眠的线程全部唤醒。有时这样的操作是有必要的，尽管他比较损耗性能。</p>\n<p>举个内存分配的问题，当 <code>allocate(int size)</code>  遇到了内存不足时，就会休眠等待，相应的，线程释放内存会发出信号说有更多内存空间，但是，代码中有一个问题就是，应该缓行哪个线程？</p>\n<p>极端的情况就是：共有 3 个线程，2 个都在休眠等待，最后一个线程释放了内存后，现在还有 50 的内存，线程 A 需要 100，线程 B 需要 10，但是不能够保证一定唤醒 B 线程，如果唤醒了 A 线程，那么所有线程都会进入休眠，所以有人的解决方案就是将所有线程都唤醒，这就是覆盖条件。</p>\n<blockquote>\n<p>其实单论这个问题的话，可以用优先队列来解决，当然我只是借这个问题引出覆盖条件的概念。</p>\n</blockquote>\n<h2 id=\"信号量\"><a class=\"anchor\" href=\"#信号量\">#</a> 信号量</h2>\n<p>信号量是有一个<strong>整数值</strong>的对象，可以用两个函数操作它。在 POSIX 标准中，是 <code>sem_wait()</code>  和 <code>sem_post()</code> 。当线程完成一次对信号量对象的等待（wait）时，计数值减一；当线程完成一次对信号量的释放（release）时，计数值加一。</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/12/21/e73efde1c65e3fc7.jpg\" alt=\"\" /></p>\n<h3 id=\"应用锁\"><a class=\"anchor\" href=\"#应用锁\">#</a> 应用：锁</h3>\n<p>最简单的例子就是使用信号量作为锁，那么同时间进入临界区只能有一个线程，假设最开始 A 线程进入临界区，此时需要调用 <code>wait()</code> ，将信号量减一，如果此时不允许其他线程进入，那么信号量此时至少为 0. 因为其他线程进入临界区之前也需要调用一下 <code>wait()</code> ，此时再判断信号量为负，不能进入临界区，进入休眠。因为锁只有两种状态，所以这种用法有时也叫做<strong>二值信号量</strong>。</p>\n<blockquote>\n<p>所以信号量作为锁，初始化的计数值应该为 1。 图中的 <code>signal</code>  相当于 <code>POSIX</code>  中的 <code>sme_post()</code> 。</p>\n</blockquote>\n<h3 id=\"应用条件变量\"><a class=\"anchor\" href=\"#应用条件变量\">#</a> 应用：条件变量</h3>\n<p>本文最开始讲解条件变量时的例子是父线程创建子线程，并等待子线程执行结束。用一个显示队列作为条件变量，使用 <code>wait/signal</code>  来保证线程安全。</p>\n<p>下面讲一下如何用信号量来实现这种效果。</p>\n<p>首先要理解一个点，信号量并不是什么很特别的东西，本质就是一个整数，只是说，操作系统存在调用，如 <code>sem_wait()</code>  和 <code>sem_signal()</code> 。重要的是它能够让线程停下来等待，放弃 CPU 资源进入休眠。</p>\n<p>父线程等待子线程的例子中，逻辑为：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">child</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"child\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token function\">sem_post</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">sem_init</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 0 表示同一进程所有线程都共享信号量，计数值初始化为 x</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"parent:begin\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token function\">thread_create</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> child<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 创建子线程并运行</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token function\">sem_wait</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"parent:end\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>使用信号量代替条件变量，计数值初始化为 0。</p>\n<blockquote>\n<p>需要思考父线程先执行 <code>sem_wait()</code>  和子线程先执行 <code>sem_post()</code>  两种情况。</p>\n</blockquote>\n<h3 id=\"应用实现信号量\"><a class=\"anchor\" href=\"#应用实现信号量\">#</a> 应用：实现信号量</h3>\n<p>该部分模拟实现一下 <code>sem_wait</code>  和 <code>sem_post</code> 。《操作系统导论》一书中将这个自定义信号量称为 <code>Zemaphore</code> ，我们延用一下。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">_Zem_t</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> val<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 计数值</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token class-name\">pthread_cond_t</span> cond<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 休眠 / 等待队列，肯定要有，不然你以为谁替你维护一个队列</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token class-name\">pthread_mutex_t</span> lock<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 锁</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">Zem_init</span><span class=\"token punctuation\">(</span>Zem_t <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    s<span class=\"token operator\">-></span>val <span class=\"token operator\">=</span> val<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token function\">Cond_init</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token operator\">-></span>cond<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 初始化阻塞队列</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token function\">Mutex_init</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token operator\">-></span>lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 初始化锁，</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">Zem_wait</span><span class=\"token punctuation\">(</span>Zem_t <span class=\"token operator\">*</span>s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token function\">Mutex_lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token operator\">-></span>lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">-></span>val <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 进入队列休眠 </span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token function\">Cond_wait</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token operator\">-></span>cond<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>s<span class=\"token operator\">-></span>lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    s<span class=\"token operator\">-></span>val<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token function\">Mutex_unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token operator\">-></span>lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">Zem_post</span><span class=\"token punctuation\">(</span>Zem_t <span class=\"token operator\">*</span>s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token function\">Mutex_lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token operator\">-></span>lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    s<span class=\"token operator\">-></span>val<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token function\">Cond_signal</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token operator\">-></span>cond<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token function\">Mutex_unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token operator\">-></span>lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>只用了一把锁、一个条件变量和一个状态的变量来记录信号量的值。是不是感觉信号量就是将锁和条件变量封装了一下。</p>\n<h2 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h2>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYWdlcy5jcy53aXNjLmVkdS9+cmVtemkvT1NURVAvQ2hpbmVzZS8zMC5wZGY=\">https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/30.pdf</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYWdlcy5jcy53aXNjLmVkdS9+cmVtemkvT1NURVAvQ2hpbmVzZS8zMS5wZGY=\">https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/31.pdf</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvemgtaGFucy8lRTQlQkYlQTElRTUlOEYlQjclRTklODclOEY=\">https://zh.m.wikipedia.org/zh-hans/ 信号量</span></p>\n</blockquote>\n",
            "tags": [
                "Concurrency"
            ]
        },
        {
            "id": "https://cecilia.cool/2022/12/20/Java/Concurrency/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87A/",
            "url": "https://cecilia.cool/2022/12/20/Java/Concurrency/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87A/",
            "title": "操作系统篇A",
            "date_published": "2022-12-20T13:49:24.000Z",
            "content_html": "<h2 id=\"并发介绍\"><a class=\"anchor\" href=\"#并发介绍\">#</a> 并发：介绍</h2>\n<p>经典观点：一个程序只有一个执行点（一个程序计数器，存放执行的指令），那么所有的执行都是顺序执行的。但是多线程（multi-threaded）程序有<strong>多个执行点</strong>，此处区别进程，多线程程序中，线程之间共享地址空间，能够访问到相同的数据。</p>\n<p>类比进程，当两个线程运行在一个处理器上，从运行 A 线程到运行 B 线程，一定会发生上下文切换（context switch），<strong>进程</strong>的状态保存到 PCB 中，<strong>线程</strong>的状态保存到 TCB（Thread Control Block）中。唯一与<strong>进程</strong>上下文切换不同的是，线程切换上下文，地址空间保持不变，也就是<strong>不需要切换当前使用的页表</strong>。</p>\n<p>在并发中最经典的程序问题就是多个线程累加同一个变量：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">static</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">int</span> counter <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">mythread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%s: begin\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">1e7</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    \tcounter <span class=\"token operator\">=</span> counter <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%s: done\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t<span class=\"token keyword\">return</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">int</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>argv<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token class-name\">pthread_t</span> p1<span class=\"token punctuation\">,</span> p2<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"main: begin (counter = %d)\\n\"</span><span class=\"token punctuation\">,</span> counter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token function\">Pthread_create</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>p1<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> mythread<span class=\"token punctuation\">,</span> <span class=\"token string\">\"A\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token function\">Pthread_create</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>p2<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> mythread<span class=\"token punctuation\">,</span> <span class=\"token string\">\"B\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token comment\">// join waits for the threads to finish</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token function\">Pthread_join</span><span class=\"token punctuation\">(</span>p1<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token function\">Pthread_join</span><span class=\"token punctuation\">(</span>p2<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"main: done with both (counter = %d)\\n\"</span><span class=\"token punctuation\">,</span> counter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>希望最终 <code>counter</code>  得到的结果是 20000000，但是往往结果不是对的，而且每次都不一样。关键的指令在于：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>mov <span class=\"token number\">0x8049a1c</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">%</span>eax</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>add $<span class=\"token number\">0x1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">%</span>eax</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>mov <span class=\"token operator\">%</span>eax<span class=\"token punctuation\">,</span> <span class=\"token number\">0x8049a1c</span></pre></td></tr></table></figure><p>变量  <code>counter</code>  位于地址  <code>0x8049a1c</code> 。在这 3 条指令中，先用 x86 的  <code>mov</code>  指令，从内存地址处取出值，放入  <code>eax</code> 。然后，给  <code>eax</code>  寄存器的值加 1（0x1）。最后， <code>eax</code>  的值被存回内存中相同的地址。</p>\n<p>这其实就是 c 代码中的 <code>counter = counter + 1</code> ，<strong>整个程序失败的点在于这行 c 代码不是原子执行</strong>。如果线程 A 在执行完 <code>add</code>  指令后中断，此时 <code>counter</code>  还是 50，A 线程的 <code>eax=51</code> ，轮到 B 执行完这三行指令，此时 <code>counter=51</code> ，再次轮到 A，就会将 51 再次存入 <code>counter</code> ，相当于 A 线程在本次循环中并没有使 <code>counter</code>  增加。</p>\n<p>由于<strong>执行这段代码的多个线程可能导致竞争状态</strong>，因此我们将<strong>此段代码称为临界区</strong> （critical section）。<strong>临界区是访问共享变量（或更一般地说，共享资源）的代码片段，一定不能由多个线程同时执行</strong>。</p>\n<p>我们真正想要的代码就是的<strong>互斥</strong>（mutual exclusion）。这个属性保证了如果一个线程在临界区内执行，其他线程将被阻止进入临界区。</p>\n<p>这些术语都是 <code>Dijkstra</code>  创造的，此处给出一些术语补充：</p>\n<ul>\n<li><strong>临界区</strong>（critical section）是访问共享<strong>资源</strong>的一段代码，资源通常是一个变量或数据结构。</li>\n<li><strong>竞态条件</strong>（race condition）出现在多个执行线程大致同时进入临界区时，它们都试图更新共享的数据结构，导致了令人惊讶的（也许是不希望的）结果。</li>\n<li><strong>不确定性</strong>（indeterminate）程序由一个或多个竞态条件组成，程序的输出因运行而异，具体取 决于哪些线程在何时运行。这导致结果不是确定的（deterministic），而我们通常期望计算机系统给出确 定的结果。</li>\n<li>为了避免这些问题，线程应该使用某种<strong>互斥</strong>（mutual exclusion）原语。这样做可以保证只有一 个线程进入临界区，从而避免出现竞态，并产生确定的程序输出。</li>\n</ul>\n<p>为了保证安全的访问临界区，有两种方法，要么对临界区的操作是原子操作，要么就是对临界区的操作上锁。将一系列动作原子化（atomic）背后的想法可以简单用一个短语表达：“全部或没有”。要么都发生了，要么都没有发生，不会出现中间状态。</p>\n<blockquote>\n<p>本部分最重要的部分就是对临界区和资源的理解，本质上来说，我们需要锁住的不是临界区，而是临界区访问的资源，有可能很多个不同的临界区都会访问同一个资源。</p>\n</blockquote>\n<h2 id=\"并发锁\"><a class=\"anchor\" href=\"#并发锁\">#</a> 并发：锁</h2>\n<p>锁的本质就是一个变量，现实生活中，锁的状态只有打开和关闭两种状态（别和我扯什么撬开状态），锁变量其实也就是表示锁的状态，最简单的就是 0 表示打开，1 表示关闭。复杂点的，我们也可以保存：<strong>持有锁的线程</strong>，请求获取锁的<strong>线程队列</strong>，但这些信息会隐藏起来，锁的使用者不会发现。</p>\n<p>在 c 语言中， <code>lock()</code>  和 <code>unlock()</code>  函数分别表示尝试获取锁和释放锁。在其他语言中，也有类似的方法。</p>\n<h3 id=\"评价锁\"><a class=\"anchor\" href=\"#评价锁\">#</a> 评价锁</h3>\n<p>我们需要一些标准来评判一把锁的实现效果：</p>\n<ul>\n<li><strong>互斥性</strong>：这是最基本的，阻止多个线程进入临界区。</li>\n<li><strong>公平性</strong>（ <code>fairness</code> ）：当锁可用时，是否每一个竞争线程有公平的机会抢到锁？这其实考验的是等待队列的设计，像 <code>AQS</code>  使用的就是先进先出。</li>\n<li><strong>性能</strong>：是使用锁之后增加的时间开销。考虑这个是非常必要的，因为有时真的只有一个线程在执行，但是它还是要执行上锁解锁的操作，当然，还有其他需要考虑的场景。</li>\n</ul>\n<h3 id=\"控制中断\"><a class=\"anchor\" href=\"#控制中断\">#</a> 控制中断</h3>\n<p>最早的互斥方案之一就是<strong>在临界区关闭中断</strong>，也就是说，此时线程 A 在临界区不会发生上下文切换。这个解决方案是为单处理器 系统开发的。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token function\">DisableInterrupts</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token function\">EnableInterrupts</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>控制中断是使用特殊的硬件指令，背后的实现是由硬件支持的， <code>CAS</code>  也是由硬件支持的。这种方法优点就是简单，但是缺点十分明显：</p>\n<ul>\n<li>\n<p>这种方法要求我们允许所有调用线程执行特权操作（打开 / 关闭中断），但是恶意程序一开始调用关闭中断就会一直霸占处理器。</p>\n</li>\n<li>\n<p>多处理器不适用。多个线程在多 CPU 上，每个线程都试图进入同一个临界区，关闭中断也没用。</p>\n</li>\n<li>\n<p>关闭中断导致中断丢失，可能会导致严重的系统问题。假如磁盘设备完成了读 取请求，但 CPU 错失了这一事实，那么，操作系统如何知道去唤醒等待读取的进程？</p>\n</li>\n<li>\n<p>效率低。与正常指令执行相比，现代 CPU 对于关闭和打 开中断的代码执行得较慢。</p>\n</li>\n</ul>\n<h3 id=\"原子交换\"><a class=\"anchor\" href=\"#原子交换\">#</a> 原子交换</h3>\n<p>如果<strong>不依赖硬件</strong>，我们可以这么实现一个锁：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">lock_t</span> <span class=\"token punctuation\">&#123;</span><span class=\"token keyword\">int</span> flag<span class=\"token punctuation\">;</span><span class=\"token punctuation\">&#125;</span> <span class=\"token class-name\">lock_t</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">lock_t</span> <span class=\"token operator\">*</span>mutex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    mutex<span class=\"token operator\">-></span>flag <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 0 表示没有上锁</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">lock_t</span> <span class=\"token operator\">*</span>mutex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>mutex<span class=\"token operator\">-></span>flag <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token comment\">// 什么都不做，空等待，这就叫做 spin-wait   自旋</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    mutex<span class=\"token operator\">-></span>flag <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">lock_t</span> <span class=\"token operator\">*</span>mutex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    mutex<span class=\"token operator\">-></span>flag <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>可以看到这种锁有一些问题：</p>\n<ul>\n<li>正确性：你可能会觉得上述代码完全没有问题的，但是如果 AB 两个线程都调用 <code>lock</code>  函数，假设 A 先调用，然后经过了 <code>while</code>  循环，此时发生中断，轮到 B，经过 while 循环，又发生中断，那么此时两个线程相当于都拿到了锁，因为他们之后都会执行 <code>mutex-&gt;flag = 1;</code>  的操作。导致问题的本质就是 —— 上<strong>锁的过程不是原子的</strong>。</li>\n<li>性能：可以看到，如果一个线程拿不到锁，就会一直自旋，直到它的时间片执行完或者拿到锁。自旋等待在等待其他线程释放锁的 时候会浪费时间。尤其是在单处理器上，一个等待线程等待的目标线程甚至无法运行（至 少在上下文切换之前）！</li>\n</ul>\n<p>为了解决这些问题，我们需要硬件的支持 —— 原子交换。它们基本上在不同的平台上做同样的事，通常称为<strong>测试并设置指令（test-and-set）</strong>。回顾上述代码，我们在 <code>lock()</code>  函数中的行为可以归为：测试 <code>flag</code> ，设置 <code>flag</code> 。</p>\n<p>这个指令的工作内容，我们用 c 代码演示一下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">TestAndSet</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>old_ptr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> new<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> old <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>old_ptr<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token operator\">*</span>old_ptr <span class=\"token operator\">=</span> new<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">return</span> old<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>只不过这个操作是<strong>原子进行</strong>的。它原子的实现了：给变量赋予新值并返回旧值。那我们的锁的实现代码就可以改为：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">lock_t</span> <span class=\"token operator\">*</span>mutex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">TestAndSet</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mutex<span class=\"token operator\">-></span>flag<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token punctuation\">;</span><span class=\"token comment\">// spin-wait</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>只有当旧值为 0 才算此次上锁成功。这样就是原子上锁了，尽管还是没有解决自旋浪费性能的问题。这样的锁就叫做自旋锁（spin lock）。</p>\n<p>自旋锁不提供公平性，在竞争状态下，自旋的线程甚至会永远自旋（回忆一下进程切换，如果不人为的设置一些 FIFO 什么的，有些进程会被饿死）。同时，自旋锁在单 CPU 下开销很大，在多 CPU 情况该性能不错。</p>\n<p>上文讲了测试并切换 <code>TAS</code> ，其实还有比较并切换 <code>CAS</code> ，c 语言伪代码为：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">compareAndSwap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>ptr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> expected<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> new<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> actual <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>ptr<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>actual <span class=\"token operator\">==</span> expected<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token operator\">*</span>ptr <span class=\"token operator\">=</span> new<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">return</span> actual<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>同样是返回旧值（你可以思考一下为什么返回的是旧值），总体思路就是，检测变量的旧值是否是期望值，如果是，就赋新值，返回旧值。如果用 <code>CAS</code>  实现上述自旋锁：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">lock_t</span> <span class=\"token operator\">*</span>mutex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">CompareAndSet</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mutex<span class=\"token operator\">-></span>flag <span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token punctuation\">;</span> <span class=\"token comment\">//spin-wait</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"解决自旋\"><a class=\"anchor\" href=\"#解决自旋\">#</a> 解决自旋</h3>\n<ul>\n<li><strong>让出时间片</strong>，即在要自旋的时候，放弃 CPU。</li>\n</ul>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">lock_t</span> <span class=\"token operator\">*</span>mutex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">CompareAndSet</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mutex<span class=\"token operator\">-></span>flag <span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token function\">yield</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们假定操作系统提供原语  <code>yield()</code> ，线程可以调用它主动放弃 CPU， 让其他线程运行。 <code>yield()</code>  系统调用能让线程由 <code>running</code>  变为 <code>readying</code> 。但是这个方法没有处理本质问题：频繁的上下文切换。线程饿死的情况也没解决。</p>\n<ul>\n<li><strong>使用队列：休眠代替自旋</strong></li>\n</ul>\n<p>前面一些方法的真正问题是存在太多的偶然性。因此，我们必须<strong>显式</strong>地施加某种控制，<strong>决定锁释放时，谁能抢到锁</strong>（这样才能保证公平的）。</p>\n<blockquote>\n<p><strong>处于休眠状态的线程永远不会分配到 CPU 资源</strong>，当等待的事件出现，休眠状态的线程才会转换到可运行的状态。</p>\n</blockquote>\n<p>在 c 语言中，Solaris 提供了两个调用： <code>park()/unpark(ThreadID)</code> 。前者能够让调用线程休眠，后者会唤醒 ThreadID 标识的线程。使用两个调用实现锁，可以让<strong>调用者在获取不到锁时休眠</strong>，在锁可用时被唤醒，看一下《操作系统导论》里面给的例子：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">lock_t</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> flag<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">int</span> guard<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token class-name\">queue_t</span> <span class=\"token operator\">*</span>q<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span> <span class=\"token class-name\">lock_t</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">lock_init</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">lock_t</span> <span class=\"token operator\">*</span>m<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    m<span class=\"token operator\">-></span>flag <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    m<span class=\"token operator\">-></span>guard <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token function\">queue_init</span><span class=\"token punctuation\">(</span>m<span class=\"token operator\">-></span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">lock_t</span> <span class=\"token operator\">*</span>m<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">TestAndSet</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>m<span class=\"token operator\">-></span>guard<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token punctuation\">;</span><span class=\"token comment\">// spin-wait</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>m<span class=\"token operator\">-></span>flag <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        m<span class=\"token operator\">-></span>flag <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 获得锁</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        m<span class=\"token operator\">-></span>guard <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token function\">queue_add</span><span class=\"token punctuation\">(</span>m<span class=\"token operator\">-></span>q<span class=\"token punctuation\">,</span> <span class=\"token function\">gettid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        m<span class=\"token operator\">-></span>guard <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token function\">park</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">lock_t</span> <span class=\"token operator\">*</span>m<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">TestAndSet</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>m<span class=\"token operator\">-></span>guard<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> </pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        <span class=\"token punctuation\">;</span><span class=\"token comment\">// spin-wait</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">queue_empty</span><span class=\"token punctuation\">(</span>m<span class=\"token operator\">-></span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> </pre></td></tr><tr><td data-num=\"32\"></td><td><pre>        m<span class=\"token operator\">-></span>flag <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 没有线程竞争锁</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    <span class=\"token keyword\">else</span> </pre></td></tr><tr><td data-num=\"34\"></td><td><pre>        <span class=\"token function\">unpark</span><span class=\"token punctuation\">(</span><span class=\"token function\">queue_remove</span><span class=\"token punctuation\">(</span>m<span class=\"token operator\">-></span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 从队首取出线程，不需要改变 flag</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>    m<span class=\"token operator\">-></span>guard <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>下面解释一下代码：</p>\n<ul>\n<li><code>flag</code> ：表示锁是否被占用，0 表示没有线程占用锁，1 表示有线程</li>\n<li><code>guard</code> ：注意，线程获取锁并不是一个原子过程（ <code>lock</code>  函数），但是我们应该让 <code>lock()/unlock()</code>  在某些代码保证并发安全。之前我们的做法：</li>\n</ul>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">lock_t</span> <span class=\"token operator\">*</span>mutex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">CompareAndSet</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mutex<span class=\"token operator\">-></span>flag <span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token punctuation\">;</span> <span class=\"token comment\">//spin-wait</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>确实能保证 <code>lock</code>  内部的并发安全，但是使用 <code>flag</code>  自旋的缺点上文也详述过。所以不能用<strong>锁的状态</strong>来自旋。此处使用 <code>guard</code>  来自旋。当 <code>guard=0</code>  时，表示没有线程正在改变锁的状态；当 <code>guard=1</code>  时，表示有线程正在改变锁的状态，此时不允许任何线程也跟着来修改锁的状态。</p>\n<blockquote>\n<p>锁的状态包括了 flag，queue。</p>\n</blockquote>\n<p>所以其他线程都会先围绕 <code>guard</code>  自旋一会。这个过程非常短，<strong>因为线程修改锁的状态花费的时间也非常短</strong>。</p>\n<ul>\n<li>释放锁时，如果队列里还有线程在等待，不需要改变 <code>flag</code> 。举个例子，假设临界区代码为：</li>\n</ul>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>my_lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 临界区</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>my_lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>假设只有 AB 两个线程，线程 A 在获取锁后，B 也获取锁，失败后 B 加入等待队列。当 A 执行到 <code>unlock()</code>  代码后，唤醒 B 线程，也许 B 不会立刻被分配时间片，但是此时 flag 仍然为 1，其他线程哪怕拿到时间片获取锁，也需要休眠进入队列。直到 B 分配到时间片，B 从哪里开始继续执行呢？</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">queue_add</span><span class=\"token punctuation\">(</span>m<span class=\"token operator\">-></span>q<span class=\"token punctuation\">,</span> <span class=\"token function\">gettid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>m<span class=\"token operator\">-></span>guard <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">park</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 从这里被唤醒，也就是 lock () 函数的结尾</span></pre></td></tr></table></figure><p>相当于在 <code>lock()</code>  结束， <code>count++;</code>  之前被唤醒。在临界区被唤醒，天生自带锁。</p>\n<h2 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h2>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8zZTc5YWUyNWJmYjY=\">https://www.jianshu.com/p/3e79ae25bfb6</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYWdlcy5jcy53aXNjLmVkdS9+cmVtemkvT1NURVAvQ2hpbmVzZS8yNi5wZGY=\">https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/26.pdf</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYWdlcy5jcy53aXNjLmVkdS9+cmVtemkvT1NURVAvQ2hpbmVzZS8yOC5wZGY=\">https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/28.pdf</span></p>\n</blockquote>\n",
            "tags": [
                "Concurrency"
            ]
        },
        {
            "id": "https://cecilia.cool/2022/12/20/Java/Concurrency/Concurrency%E6%A0%87%E7%AD%BE%E5%AF%BC%E8%AF%BB/",
            "url": "https://cecilia.cool/2022/12/20/Java/Concurrency/Concurrency%E6%A0%87%E7%AD%BE%E5%AF%BC%E8%AF%BB/",
            "title": "Concurrency标签导读",
            "date_published": "2022-12-20T13:41:42.000Z",
            "content_html": "<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>现在你看到的并发标签是我第二次重制版，第一次的并发系列文章比较散乱，当时也是处于初学阶段，心态不够沉稳，很多东西看不清晰就写了博客，所以这次打算好好改一下。</p>\n<p>个人观点：Java 并发需要分为两个部分学习，一部分为操作系统级别的并发知识，另一部分才是 <code>j.u.c</code>  包。考虑到整个体系的知识量过于庞大，所以本系列前几篇长篇文章，都会用于简述第一部分的内容，概述操作系统的并发和 Java 为了并发而做出的努力，如内存模型，类设计，并发关键字等。然后剩下的文章才是对 <code>j.u.c</code>  包中各个类的应用解释，该部分我们会阅读大量源码，有些类我们会着重讲解，像 <code>AQS</code>  这样的重点，还会分上下来讲解，当然，有些我们也会讲得很快，比如 <code>ConcurrentHashMap</code> ，就不必停留在实现细节上，而是了解它的实现逻辑上即可。</p>\n<h1 id=\"第一部分\"><a class=\"anchor\" href=\"#第一部分\">#</a> 第一部分</h1>\n<p>第一部分重点是讲解操作系统底层并发实现的机制以及 Java 的一些基本并发机制。</p>\n<h2 id=\"操作系统篇\"><a class=\"anchor\" href=\"#操作系统篇\">#</a> 操作系统篇</h2>\n<p>本部分主要讲解一个操作系统为了满足并发而做出的努力，如何设计一个锁，从自旋到主动释放 CPU 资源，是如何逐步优化的以及解决一些经典的并发问题。本系列主要参考《操作系统导论》的并发主题，本书已经有中文翻译版，如果不喜欢阅读实体书， <code>github</code>  上也有对应的中文 pdf：</p>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3JlbXppLWFycGFjaWR1c3NlYXUvb3N0ZXAtdHJhbnNsYXRpb25zL3RyZWUvbWFzdGVyL2NoaW5lc2U=\">https://github.com/remzi-arpacidusseau/ostep-translations/tree/master/chinese</span></p>\n</blockquote>\n<p>实在看不进去，你也可以看我的博客，总之，你需要花时间。</p>\n<h2 id=\"java并发机制篇\"><a class=\"anchor\" href=\"#java并发机制篇\">#</a> Java 并发机制篇</h2>\n<p>该部分不会过多涉及 <code>j.u.c</code>  包下面的类，而是会着重讲一下 Java 中的线程，并发关键字， <code>JMM</code> ，Java 中的锁， <code>ThreadLocal</code>  等重要知识。</p>\n<p>该部分主要参考了《Java 并发编程的艺术》，Java 全栈知识体系等。</p>\n",
            "tags": [
                "Concurrency"
            ]
        }
    ]
}