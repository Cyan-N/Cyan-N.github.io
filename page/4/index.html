<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><link rel="mask-icon" href="/images/logo.svg" color=""><link rel="manifest" href="/images/manifest.json"><meta name="msapplication-config" content="/images/browserconfig.xml"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="慕青の迷途" href="https://cecilia.cool/rss.xml"><link rel="alternate" type="application/atom+xml" title="慕青の迷途" href="https://cecilia.cool/atom.xml"><link rel="alternate" type="application/json" title="慕青の迷途" href="https://cecilia.cool/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://cecilia.cool/page/4/"><title>慕青の迷途 = 冲天香阵透长安，满城尽带黄金甲</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><a href="/" class="logo" rel="start"><h1 itemprop="name headline" class="title">慕青の迷途</h1></a><p class="meta" itemprop="description">= 冲天香阵透长安，满城尽带黄金甲 =</p></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">慕青の迷途</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipexw3o58j20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicis3attqj20zk0m8k7l.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclj9410cj20zk0m8h12.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipeu7txpzj20zk0m81kx.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipewr8iypj20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclwuom7cj20zk0m8dvn.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="index wrap"><div class="segments posts"><article class="item"><div class="cover"><a href="/2022/10/10/Java/JVM/JVM(4)-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" itemprop="url" title="JVM(4)--类加载器"><img data-src="https://tva1.sinaimg.cn/mw690/6833939bly1gicli9lfebj20zk0m84qp.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-10-10 10:58:09"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-10-10T10:58:09+08:00">2022-10-10</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>5.8k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>5 分钟</span></span></div><h3><a href="/2022/10/10/Java/JVM/JVM(4)-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" itemprop="url" title="JVM(4)--类加载器">JVM(4)--类加载器</a></h3><div class="excerpt">jvm 启动的时候，并不会一次性加载所有的 class 文件，而是根据需要去动态加载。ClassLoader 的具体作用就是将 class 文件加载到 jvm 虚拟机中去，程序就可以正确运行了。普通的 Java 开发者其实用到的不多，但对于某些框架开发者来说却非常常见。 # 使用 看了很多文章，个人觉得先把如何使用类加载器 -- ClassLoader 弄明白，再来讲解原理效果好得多。 class 字节码文件，需要使用类加载器加载字节码，即在 java 中所有类都会通过加载器加载才能运行。下文提到的类似 Bootstrap ClassLoader ， Extension...</div><a href="/2022/10/10/Java/JVM/JVM(4)-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" itemprop="url" title="JVM(4)--类加载器" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/10/09/Java/JVM/JVM(3)-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" itemprop="url" title="JVM(3)--类加载机制"><img data-src="https://tva1.sinaimg.cn/mw690/6833939bly1giciukx8a7j20zk0m8aio.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-10-09 12:39:46"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-10-09T12:39:46+08:00">2022-10-09</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>3.3k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>3 分钟</span></span></div><h3><a href="/2022/10/09/Java/JVM/JVM(3)-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" itemprop="url" title="JVM(3)--类加载机制">JVM(3)--类加载机制</a></h3><div class="excerpt"># 类的生命周期 加载 、 验证 、 准备 和 初始化 这四个阶段发生的顺序是确定的，而 解析 阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持 Java 语言的运行时绑定 (也成为动态绑定或晚期绑定)。 这些阶段知识按顺序开始，并不是按顺序结束，这些阶段往往互相交叉混合进行，再一个阶段执行过程中调用或激活另一个阶段。 # 类的加载 首先介绍几个概念： 方法区：JVM 实例内部，类型信息被存储在方法区的内存逻辑区中。类型信息是由类加载时从类文件中提取出来的。方法区又叫做静态区，被所有线程共享，方法区包含所有 class 和 static...</div><a href="/2022/10/09/Java/JVM/JVM(3)-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" itemprop="url" title="JVM(3)--类加载机制" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/10/08/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%AE%BF%E9%97%AE%E8%80%85/" itemprop="url" title="行为型--访问者"><img data-src="https://tva1.sinaimg.cn/mw690/6833939bly1giclwuom7cj20zk0m8dvn.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-10-08 13:02:44"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-10-08T13:02:44+08:00">2022-10-08</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>2k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>2 分钟</span></span></div><h3><a href="/2022/10/08/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%AE%BF%E9%97%AE%E8%80%85/" itemprop="url" title="行为型--访问者">行为型--访问者</a></h3><div class="excerpt"># 访问者 (Visitor) 当想要为对象的组合增加新的能力且封装并不重要时，就可以使用访问者模式。 现在需要知道的就是，被访问的类需要将自身引用传入访问者。讲起来比较空泛，所以先看代码。 # 实现 代码来自菜鸟教程。 定义表示元素的接口： public interface ComputerPart &amp;#123; // 接口定义的行为：元素提供一个方法供访问者进入 // 假设存在 ComputerPartVisitor 接口定义了访问者的 visit 行为 public void accept(ComputerPartVisitor...</div><a href="/2022/10/08/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%AE%BF%E9%97%AE%E8%80%85/" itemprop="url" title="行为型--访问者" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/10/08/Java/JVM/JVM(2)-%E5%AD%97%E8%8A%82%E7%A0%81%E5%A2%9E%E5%BC%BA/" itemprop="url" title="JVM(2)--字节码增强"><img data-src="https://tva1.sinaimg.cn/mw690/6833939bly1gicljgocqbj20zk0m8e81.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-10-08 12:56:20"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-10-08T12:56:20+08:00">2022-10-08</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>4.7k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>4 分钟</span></span></div><h3><a href="/2022/10/08/Java/JVM/JVM(2)-%E5%AD%97%E8%8A%82%E7%A0%81%E5%A2%9E%E5%BC%BA/" itemprop="url" title="JVM(2)--字节码增强">JVM(2)--字节码增强</a></h3><div class="excerpt"># JVM 基础 - 字节码增强 字节码增强技术就是一类对现有字节码进行修改或者动态生成全新字节码文件的技术。 # ASM ASM 可以直接生成 .class 字节码文件，也可以在类被加载入 JVM 之前动态修改类行为。ASM 框架是 JDK 内部自带的，最基本的就是通过 ClassWriter 对象编辑类的字节码文件。 public class Main &amp;#123; public static void main(String[] args) &amp;#123; ClassWriter writer = new...</div><a href="/2022/10/08/Java/JVM/JVM(2)-%E5%AD%97%E8%8A%82%E7%A0%81%E5%A2%9E%E5%BC%BA/" itemprop="url" title="JVM(2)--字节码增强" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/10/05/Java/JVM/JVM(1)-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" itemprop="url" title="JVM(1)--类文件结构"><img data-src="https://tva1.sinaimg.cn/mw690/6833939bly1gicivghyooj20zk0m8dir.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-10-05 23:29:47"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-10-05T23:29:47+08:00">2022-10-05</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>4.6k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>4 分钟</span></span></div><h3><a href="/2022/10/05/Java/JVM/JVM(1)-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" itemprop="url" title="JVM(1)--类文件结构">JVM(1)--类文件结构</a></h3><div class="excerpt"># 类文件结构 计算机是不能直接运行 java 代码的，必须要先运行 java 虚拟机，再由 java 虚拟机运行编译后的 java 代码。这个编译后的 java 代码，就是本文要介绍的 java 字节码。 Java 代码间接翻译成字节码，储存字节码的文件再交由运行于不同平台上的 JVM 虚拟机去读取执行，从而实现一次编写，到处运行的目的。 JVM 也不再只支持 Java，由此衍生出了许多基于 JVM 的编程语言，如 Groovy, Scala, Koltin 等等。 许多开发语言支持将源代码编译为 .class 字节码文件格式，以便交给 JVM 运行 #...</div><a href="/2022/10/05/Java/JVM/JVM(1)-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" itemprop="url" title="JVM(1)--类文件结构" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/10/04/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88(5)-WeakHashMap/" itemprop="url" title="Java集合(5)--WeakHashMap"><img data-src="https://tva1.sinaimg.cn/mw690/6833939bly1giclflwv2aj20zk0m84qp.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-10-04 17:46:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-10-04T17:46:00+08:00">2022-10-04</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>3.9k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>4 分钟</span></span></div><h3><a href="/2022/10/04/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88(5)-WeakHashMap/" itemprop="url" title="Java集合(5)--WeakHashMap">Java集合(5)--WeakHashMap</a></h3><div class="excerpt"># 引用类型 # 强引用 最普遍的引用，如果一个对象具有强引用，GC 绝不会回收。如果不使用，要弱化引用 Object o = new Object();o = null;// help GCpublic void test() &amp;#123; Object o = new Object();&amp;#125;/**test 方法内部有一个强引用，引用保存在栈中，new 的对象保存在堆中，当方法运行结束会退出方法栈，则引用内容的引用不存在，Object就会被回收。*/ 如果 o 是全局变量，需要在不用对象时赋值为 null。 #...</div><a href="/2022/10/04/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88(5)-WeakHashMap/" itemprop="url" title="Java集合(5)--WeakHashMap" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/10/03/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88(4)-TreeMap/" itemprop="url" title="Java集合(4)-TreeMap"><img data-src="https://tva1.sinaimg.cn/mw690/6833939bly1gipeyvx1d4j20zk0m8hdt.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-10-03 21:55:25"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-10-03T21:55:25+08:00">2022-10-03</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>2.1k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>2 分钟</span></span></div><h3><a href="/2022/10/03/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88(4)-TreeMap/" itemprop="url" title="Java集合(4)-TreeMap">Java集合(4)-TreeMap</a></h3><div class="excerpt"># 前言 首先， TreeMap 与哈希没有任何关系，其次，哈希和 Map 也不是一回事，请不要先入为主。Map 只是一个键值对的数据结构，哈希是将对象计算哈希码的一种算法。 TreeMap 只是通过红黑树将键值对存起来，一方面实现了二叉搜索树的排序性，另一方面维护了整棵树的平衡性，防止树退化为链表增大查询 / 插入的时间复杂度。 # 排序方式 TreeMap 对插入数据实现了排序，如果是自定义数据，要么该类实现 Comparable 接口，要么 TreeMap 在构造方法中传入 Comparator 接口。 # Comparable 以 Student 类来说明，继承 Comparable...</div><a href="/2022/10/03/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88(4)-TreeMap/" itemprop="url" title="Java集合(4)-TreeMap" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/10/02/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88(3)-LinkedHashMap/" itemprop="url" title="Java集合3-LinkedHashMap"><img data-src="https://tva1.sinaimg.cn/mw690/6833939bly1giclfw2t96j20zk0m8x6p.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-10-02 21:36:18"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-10-02T21:36:18+08:00">2022-10-02</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>1.7k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>2 分钟</span></span></div><h3><a href="/2022/10/02/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88(3)-LinkedHashMap/" itemprop="url" title="Java集合3-LinkedHashMap">Java集合3-LinkedHashMap</a></h3><div class="excerpt"># 简介 LinkedHashSet 也是用了适配器模式，对 LinkedHashMap 进行包装，所以本文主要分析 LinkedHashMap 。 从名字上可以看出容器是 Linked list 和 HashMap 的混合体，可以将 LinkedHashMap 看作采用 linked list 增强的 HashMap。 public class LinkedHashMap&amp;lt;K,V&gt; extends HashMap&amp;lt;K,V&gt; implements Map&amp;lt;K,V&gt;&amp;#123;...</div><a href="/2022/10/02/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88(3)-LinkedHashMap/" itemprop="url" title="Java集合3-LinkedHashMap" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/10/02/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88(2)-HashMap/" itemprop="url" title="Java集合(2)--HashMap"><img data-src="https://tva1.sinaimg.cn/mw690/6833939bly1giclfb3vzhj20zk0m8wny.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-10-02 15:59:51"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-10-02T15:59:51+08:00">2022-10-02</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>2.2k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>2 分钟</span></span></div><h3><a href="/2022/10/02/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88(2)-HashMap/" itemprop="url" title="Java集合(2)--HashMap">Java集合(2)--HashMap</a></h3><div class="excerpt"># 前言 关于这些集合的讲解，作者默认读者都知道该如何使用，所以不会从最基础的开始讲起，会直接跳过什么是映射关系，哈希值等概念的讲解。对于源码的解析也是最主要使用的那些方法。 # 一些概念 负载因子：集合容量都有上限，如果加入集合的数量超过一定允许值，集合就会扩容。负载因子就是衡量当前情况是否需要进行扩容的标准。 // 如果数据占用率达到 75%，就会扩容，扩容会重新计算哈希值static final float DEFAULT_LOAD_FACTOR = 0.75f; 红黑树：一种数据结构，在 HashMap 里面查询效率是...</div><a href="/2022/10/02/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88(2)-HashMap/" itemprop="url" title="Java集合(2)--HashMap" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/10/01/Java/%E5%B9%B6%E5%8F%91/Java%E5%85%B3%E9%94%AE%E5%AD%97-volatile/" itemprop="url" title="Java关键字volitale"><img data-src="https://tva1.sinaimg.cn/mw690/6833939bly1giclx29mstj20zk0m8hdt.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-10-01 15:20:23"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-10-01T15:20:23+08:00">2022-10-01</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>2.5k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>2 分钟</span></span></div><h3><a href="/2022/10/01/Java/%E5%B9%B6%E5%8F%91/Java%E5%85%B3%E9%94%AE%E5%AD%97-volatile/" itemprop="url" title="Java关键字volitale">Java关键字volitale</a></h3><div class="excerpt"># volatile 关键字 并发存在的问题主要是可见性，原子性，有序性。原子性可以通过 synchronized 实现同步，可见性，有序性通过 volatile 解决。 可见性：CPU 直接和内存交互太慢了，所以 CPU 直接和缓存交互。在多核 CPU 中，每个 CPU 各自有一个缓存，在 A 修改了某一变量时，可能来不及写入内存并让其他 CPU 读取，造成修改的不可见。 缓存一致性协议就是为了解决一致性问题。 volatile 可以保证可见性，当某一个线程修改了被 volatile 修饰的变量后，其他线程会马上更新这个变量。但是它依然不能解决原子性问题，就像那个最经典的多个线程 i++...</div><a href="/2022/10/01/Java/%E5%B9%B6%E5%8F%91/Java%E5%85%B3%E9%94%AE%E5%AD%97-volatile/" itemprop="url" title="Java关键字volitale" class="btn">more...</a></div></article></div></div><nav class="pagination"><div class="inner"><a class="extend prev" rel="prev" href="/page/3/"><i class="ic i-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/5/"><i class="ic i-angle-right" aria-label="下一页"></i></a></div></nav></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Cyan" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Cyan</p><div class="description" itemprop="description">时雨病重症患者！！！</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">105</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">2</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">20</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0N5YW4tTg==" title="https:&#x2F;&#x2F;github.com&#x2F;Cyan-N"><i class="ic i-github"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/page/3/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/page/5/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Cyan @ 慕青の迷途</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">373k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">5:39</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"page/4/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>