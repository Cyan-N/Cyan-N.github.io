<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.7.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.7.0" type="image/png" sizes="32x32"><meta name="description" content="我始终勇往直前，百折不回...">
<meta property="og:type" content="website">
<meta property="og:title" content="慕青的日记">
<meta property="og:url" content="https://cecilia.cool/index.html">
<meta property="og:site_name" content="慕青的日记">
<meta property="og:description" content="我始终勇往直前，百折不回...">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Cyan">
<meta name="twitter:card" content="summary"><title>慕青的日记 | Cyan</title><link ref="canonical" href="https://cecilia.cool/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.7.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">慕青的日记</div><div class="header-banner-info__subtitle">Cyan</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/03/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88(4)-TreeMap/">Java集合(4)-TreeMap</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-03</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-04</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h1>
      <p>首先，<code>TreeMap</code>与哈希没有任何关系，其次，哈希和Map也不是一回事，请不要先入为主。Map只是一个键值对的数据结构，哈希是将对象计算哈希码的一种算法。<code>TreeMap</code>只是通过红黑树将键值对存起来，一方面实现了二叉搜索树的排序性，另一方面维护了整棵树的平衡性，防止树退化为链表增大查询&#x2F;插入的时间复杂度。</p>

        <h1 id="排序方式"   >
          <a href="#排序方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#排序方式" class="headerlink" title="排序方式"></a>排序方式</h1>
      <p><code>TreeMap</code>对插入数据实现了排序，如果是自定义数据，要么该类实现<code>Comparable</code>接口，要么TreeMap在构造方法中传入<code>Comparator</code>接口。</p>

        <h2 id="Comparable"   >
          <a href="#Comparable" class="heading-link"><i class="fas fa-link"></i></a><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h2>
      <p>以<code>Student</code>类来说明，继承<code>Comparable</code>并重写<code>compareTo()</code>方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;<span class="comment">// 为了简单，就写一个id属性,并设为public方便获取</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id)</span> &#123;<span class="built_in">this</span>.id = id;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对比方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">        <span class="comment">// 按照id从小到大排序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.id - o.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>在<code>CompareTo()</code>中，是传入的对象和当前对象进行对比：</p>
<ul>
<li>如果对比大于0，降序排序。</li>
<li>如果对比小于0，升序。</li>
</ul>
<blockquote>
<p>其实记住当前对象-传入对象就是升序，反之则降序。</p>
</blockquote>

        <h2 id="Comparator"   >
          <a href="#Comparator" class="heading-link"><i class="fas fa-link"></i></a><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h2>
      <p>通过外部类的方式进行编写，对于<code>Comparator</code>接口的传入也可以用<code>Lambda</code>表达式</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1,Student o2)</span> &#123;</span><br><span class="line">        <span class="comment">// 第一个参数 - 第二个参数：升序</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(o1.id - o2.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以传入Lambda表达式</span></span><br><span class="line">Collections.sort(list,(Student o1,Student <span class="number">02</span>) -&gt; o1.id - o2.id);</span><br></pre></td></tr></table></div></figure>

<p>我们看一下<code>TreeMap</code>的部分属性和构造方法：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableMap</span>&lt;K,V&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传入一个Comparator接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">()</span> &#123;comparator = <span class="literal">null</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>如果没有传入<code>Comparator</code>接口实现，那么传入的<code>Key</code>必须实现<code>Comparable</code>。</p>
<blockquote>
<p><code>TreeMap</code>底层用红黑树，红黑树近似平衡，最长路径不超过最短路径的2倍。</p>
</blockquote>

        <h1 id="TreeMap"   >
          <a href="#TreeMap" class="heading-link"><i class="fas fa-link"></i></a><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h1>
      <p><code>TreeMap</code>的UML类图：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/03/a6778fc1ccf85111.jpg"></p>
<p>因为底层使用了红黑树，所以节点就是<code>Entry</code>，记录了左右节点和父节点指针，以及节点颜色。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> BLACK;</span><br><span class="line">	<span class="comment">// 构造方法，此处不写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>关于红黑树，详细的实现，也就是节点如何变色，如何左旋右旋来维持近似平衡，可以看《算法导论》，本文不会详细去讲，作者曾经也自己看着书写过红黑树，当成C++期末作业交上去了，但是过了两三天又忘了，这玩意吧，看个人兴趣吧，hhhhhh。</p>
</blockquote>

        <h2 id="put"   >
          <a href="#put" class="heading-link"><i class="fas fa-link"></i></a><a href="#put" class="headerlink" title="put()"></a>put()</h2>
      <p>直接给出<code>put</code>的执行流程：</p>
<ul>
<li>判断当前根节点为null，那么插入的第一个元素就是根节点。</li>
<li>如果存在根节点，判断插入元素在左侧还是右侧，如果对比为0，说明当前元素存在于<code>TreeMap</code>中，将其覆盖：<strong>在TreeMap中，不会存在重复元素</strong>。</li>
<li>找到插入位置，插入。</li>
<li>节点变色和旋转操作。</li>
</ul>
<blockquote>
<p>代码太长了，要看源码自己打开IDEA查看。从<code>put</code>流程也可知，时间复杂度为<em>logN</em>。</p>
</blockquote>

        <h2 id="get"   >
          <a href="#get" class="heading-link"><i class="fas fa-link"></i></a><a href="#get" class="headerlink" title="get()"></a>get()</h2>
      <p>也就是不断地对比，在红黑树中查找节点。</p>

        <h1 id="TreeSet"   >
          <a href="#TreeSet" class="heading-link"><i class="fas fa-link"></i></a><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h1>
      <p>这个就是对TreeMap进行了简单包装，不过多讲解</p>
<blockquote>
<p>额，其实关于<code>TreeMap</code>的详解应该是对红黑树的详解，但是我真的不想写，啊啊啊啊啊，以后有时间就单独写一篇博客解释一下红黑树，顺便放一个源码模板方便各位使用（等我想起了再说吧）。</p>
</blockquote>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_51192504/article/details/109775797" >https://blog.csdn.net/weixin_51192504/article/details/109775797</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/collection/java-map-TreeMap&amp;TreeSet.html" >https://pdai.tech/md/java/collection/java-map-TreeMap&amp;TreeSet.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/02/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88(3)-LinkedHashMap/">Java集合3-LinkedHashMap</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-02</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-02</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h1>
      <p><code>LinkedHashSet</code>也是用了适配器模式，对<code>LinkedHashMap</code>进行包装，所以本文主要分析<code>LinkedHashMap</code>。</p>
<p>从名字上可以看出容器是<em>Linked list</em>和<em>HashMap</em>的混合体，<strong>可以将<em>LinkedHashMap</em>看作采用<em>linked list</em>增强的<em>HashMap</em></strong>。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">HashMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><code>LinkedHashMap</code>是<code>HashMap</code>的直接子类，它的区别在于在<code>HashMap</code>的基础上采用双向链表将所有的数据节点都链接起来了，就是为了<strong>保证元素的迭代顺序和插入顺序相同</strong>。</p>
<p>还有个好处就是集合迭代时不需要遍历整个<code>table</code>，逮着双向链表的<code>header</code>遍历即可。</p>
<blockquote>
<p><code>LinkedHashMap</code>为了性能，是非同步的，多线程下需要手动同步</p>
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 也可以打包成同步的</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">m</span> <span class="operator">=</span> Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>(...));</span><br></pre></td></tr></table></div></figure>




        <h1 id="方法剖析"   >
          <a href="#方法剖析" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h1>
      <blockquote>
<p><code>get</code>方法和<code>HashMap</code>里的没什么区别，不多说。</p>
</blockquote>

        <h2 id="put"   >
          <a href="#put" class="heading-link"><i class="fas fa-link"></i></a><a href="#put" class="headerlink" title="put()"></a>put()</h2>
      <p>插入分为两部分：</p>
<ul>
<li>将元素插入<code>table</code>中，如果有哈希冲突，头插法插入到头部。</li>
<li>将元素插入双向链表中，链表尾部。</li>
</ul>
<p>其实就是在<code>HashMap</code>上加入链表的引用的修改。</p>
<p><code>LinkedHashMap</code>使用的节点是<code>Entrty</code>，该类继承了<code>HashMap</code>的<code>Node</code>类。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="remove"   >
          <a href="#remove" class="heading-link"><i class="fas fa-link"></i></a><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2>
      <p>删除也有两部分：</p>
<ul>
<li>将元素从<code>table</code>中删除。</li>
<li>将元素从双向链表中删除。</li>
</ul>

        <h1 id="经典用法"   >
          <a href="#经典用法" class="heading-link"><i class="fas fa-link"></i></a><a href="#经典用法" class="headerlink" title="经典用法"></a>经典用法</h1>
      <p>实现FIFO替换策略的缓存，<code>LinkedHashMap</code>有一个方法，作用是告诉Map删除最老的<code>Entry</code>，也就是最早插入Map的Entry。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>每次插入新元素时<code>LinkedHashMap</code>都会询问该函数是否要删除最老的元素，</p>
<blockquote>
<p><code>LinkedHashMap</code>并没有重写<code>put</code>方法，而是重写的<code>newNode</code>方法，因为<code>newNode</code>就是将要插入的键值对插放到新创建的节点中，在创建节点后马上将其加入到双向链表中即可。</p>
</blockquote>
<p>只要在子类中重载该方法，当元素个数超过一定数量时让<code>removeEldestEntry</code>返回<code>true</code>，就能实现一个固定大小的FIFO策略的缓存。其实我们写个子类继承<code>LinkedList</code>并重写一下<code>add</code>方法也是可以实现的，只是说，是哟个<code>LinkedHashMap</code>更加方便。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 一个固定大小的FIFO替换策略的缓存 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FIFOCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> cacheSize;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FIFOCache</span><span class="params">(<span class="type">int</span> cacheSize)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.cacheSize = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当Entry个数超过cacheSize时，删除最老的Entry</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> size() &gt; cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/collection/java-map-LinkedHashMap&amp;LinkedHashSet.html" >https://pdai.tech/md/java/collection/java-map-LinkedHashMap&amp;LinkedHashSet.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/u014203449/article/details/80194704" >https://blog.csdn.net/u014203449/article/details/80194704</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/02/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88(2)-HashMap/">Java集合(2)--HashMap</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-02</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-02</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h1>
      <p>关于这些集合的讲解，作者默认读者都知道该如何使用，所以不会从最基础的开始讲起，会直接跳过什么是映射关系，哈希值等概念的讲解。对于源码的解析也是最主要使用的那些方法。</p>

        <h1 id="一些概念"   >
          <a href="#一些概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h1>
      <ul>
<li>负载因子：集合容量都有上限，如果加入集合的数量超过一定允许值，集合就会扩容。负载因子就是衡量当前情况是否需要进行扩容的标准。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果数据占用率达到75%，就会扩容，扩容会重新计算哈希值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>红黑树：一种数据结构，在<code>HashMap</code>里面查询效率是<em>logN</em>，整棵树在插入数据时始终保持近似平衡（不是真的平衡）。JDK1.8后就用红黑树代替<code>HashMap</code>里面的长度超过8的冲突链表了。</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/02/760aca61cab61cfc.jpg"></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><code>TreeNode</code>就是为了实现红黑树而设计的内部类。</p>
<blockquote>
<p><code>HashMap</code>的初始容量是否应该设的比较大，在JDK1.7以前，HashMap用的是冲突链表，HashMap在迭代时，需要遍历整个数组和冲突链表。如果迭代频繁的话，就不宜将初始大小设的过大。</p>
</blockquote>
<ul>
<li><code>modCount</code>：集合只要可以使用迭代器，都需要<code>modCount</code>来记录修改次数。</li>
<li>实现<code>Map</code>接口：允许<code>key</code>和<code>value</code>都是<code>null</code>。</li>
</ul>

        <h1 id="核心方法"   >
          <a href="#核心方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h1>
      <p>有时会将Java7的方法拿出来和Java8作比较。</p>
<p>在Java7使用Entry代表数据节点，Java8使用Node，基本没有区别，都是<code>key</code>，<code>value</code>，<code>hash</code>，<code>next</code>四个属性。<code>Node</code>只能适用于链表，<code>TreeNode</code>用于红黑树。</p>

        <h2 id="put"   >
          <a href="#put" class="heading-link"><i class="fas fa-link"></i></a><a href="#put" class="headerlink" title="put()"></a>put()</h2>
      <blockquote>
<p><code>put</code>方法重点也是在于得到哈希值，然后就是处理一下<strong>扩容</strong>，<strong>哈希冲突</strong>，<strong>链表转化红黑树</strong>等问题。</p>
</blockquote>
<p>Java7是先扩容再插入值，Java8是先插入值再扩容。第一次<code>put</code>需要初始化一下<code>table</code>数组（从<code>null</code>初始化到默认容量16或者自定义容量），才能加入数据。</p>
<p>需要注意的是，如果两次使用<code>put</code>时，加入的<code>key</code>都是相同的，那么第二次的<code>value</code>应该覆盖第一次的，所以在<code>put</code>时也应该考虑到这一点，<strong>发生哈希冲突应该首先检查Key是不是相同的再进行下一步操作</strong>。</p>
<p>重点讲一下扩容操作：扩容时需要重新<code>hash</code>，并不是说要重新调用<code>hash</code>这个函数，<code>Node(TreeNode)</code>节点之前就保存了<code>hash</code>值的。</p>
<p>如果<code>hash</code>值超过了容量<code>cap</code>，需要取余操作，因为<code>cap</code>都是2的指数，所以<code>cap-1</code>（最大下标）的低位就全是1，取余操作就可以为：<code>hash &amp; (cap - 1)</code>。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/02/d1b17259fca6ec00.jpg"></p>
<p>所以一条冲突链表上的数据节点的哈希值并不一定都是相同的，可能是取余后才导致下标相同。所以在重新哈希的过程中，就需要对冲突链表拆分为两条链表，一条链表是哈希值本来就是当前下标，另一个是哈希值被取余了的（这条链表上也并不是哈希值都相同，只是取余后值都相同，5和7被2取余值也相同嘛）。</p>
<p>因为每次扩容都是容量乘2，所以后一条链表的新下标就是<code>i+cap</code>。</p>
<blockquote>
<p><code>i&lt;cap，(i+cap) % 2cap = i+cap</code>。</p>
</blockquote>

        <h2 id="get"   >
          <a href="#get" class="heading-link"><i class="fas fa-link"></i></a><a href="#get" class="headerlink" title="get()"></a>get()</h2>
      <blockquote>
<p><code>get</code>方法内部最重要的就是<code>hash()</code>得到其哈希值，然后再通过<code>equals()</code>找到对应的值。</p>
</blockquote>
<p>理解了<code>put</code>的机制和哈希值取余原理后，<code>get</code>分析就比较简单了。</p>
<ul>
<li><p>计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1)。</p>
</li>
<li><p>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步。</p>
</li>
<li><p>判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步。</p>
</li>
<li><p>遍历链表，直到找到相等(&#x3D;&#x3D;或equals)的 key。</p>
</li>
</ul>

        <h1 id="HashSet"   >
          <a href="#HashSet" class="heading-link"><i class="fas fa-link"></i></a><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1>
      <p><code>HashSet</code>使用了适配器模式，对<code>HashMap</code>进行了简单的包装，对<code>HashSet</code>的函数调用都会转换成合适的<code>HashMap</code>方法。这里提一下，不需要过多赘述。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashSet是对HashMap的简单包装</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;<span class="comment">//HashSet里面有一个HashMap</span></span><br><span class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;<span class="comment">//简单的方法转换</span></span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/collection/java-map-HashMap&amp;HashSet.html" >https://pdai.tech/md/java/collection/java-map-HashMap&amp;HashSet.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javase/syy4rz#b2b51e41" >https://www.yuque.com/qingkongxiaguang/javase/syy4rz#b2b51e41</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet%20and%20HashMap.md#get" >https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet%20and%20HashMap.md#get</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/01/Java/%E5%B9%B6%E5%8F%91/Java%E5%85%B3%E9%94%AE%E5%AD%97-volatile/">Java关键字volitale</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-01</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-01</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="volatile关键字"   >
          <a href="#volatile关键字" class="heading-link"><i class="fas fa-link"></i></a><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1>
      <p>并发存在的问题主要是可见性，原子性，有序性。原子性可以通过<code>synchronized</code>实现同步，可见性，有序性通过<code>volatile</code>解决。</p>
<p>可见性：CPU直接和内存交互太慢了，所以CPU直接和缓存交互。在多核CPU中，每个CPU各自有一个缓存，在A修改了某一变量时，可能来不及写入内存并让其他CPU读取，造成修改的不可见。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/01/14eaf6c457e413c7.jpg"></p>
<blockquote>
<p>缓存一致性协议就是为了解决一致性问题。</p>
</blockquote>
<p><code>volatile</code>可以保证可见性，当某一个线程修改了被<code>volatile</code>修饰的变量后，其他线程会马上更新这个变量。但是它依然不能解决原子性问题，就像那个最经典的多个线程<code>i++</code>一样，自增操作是被瓜分为了多个步骤完成的，虽然保证了可见性，但是只要手速够快，依然会出现两个线程同时写同一个值的问题（比如线程1刚刚将a的值更新为100，这时线程2可能也已经执行到更新a的值这条指令了，<strong>已经刹不住车了</strong>，所以依然会将a的值再更新为一次100）。</p>
<p>此处顺便介绍一下<strong>Java内存模型（JMM）</strong>：采用了类似的模型支持多线程</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/01/4d01a61364ae80bf.jpg"></p>
<ul>
<li>所有的变量全部存储在主内存。</li>
<li>每条线程有着自己的工作内存，线程对变量的所有操作，必须在工作内存中进行，不能直接操作主内存中的数据。</li>
<li>不同线程之间的工作内存相互隔离，如果需要在线程之间传递内容，只能通过主内存完成，无法直接访问对方的工作内存。</li>
</ul>
<p>有序性：为了优化程序，编译时会对指令进进行重排序，有可能暴露出未初始化的空内存出来。以双重检查的单例模式为例：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleInstance</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SignleInstance instance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SignleInstance <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//锁住这个类，无论哪个实例来执行这段代码都要拿到锁</span></span><br><span class="line">            <span class="keyword">synchronized</span>(SignleInstance.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">SingleInstance</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>对于<code>instance = new SingeInstance()</code>，正常的CPU指令为：</p>
<ol>
<li>分配内存空间</li>
<li>初始化对象</li>
<li>将instance引用指向内存空间</li>
</ol>
<p>但是重排序后可能执行顺序就是：</p>
<ol>
<li>分配内存空间</li>
<li>将instance引用指向内存空间</li>
<li>初始化对象</li>
</ol>
<p>如果线程在执行完2后中断，其他的线程再来执行<code>getInstance()</code>方法，就会拿到一个没有初始化的instance。</p>
<blockquote>
<p><code>volaitle</code>关键字可以产生内存屏障防止重排序。</p>
</blockquote>

        <h1 id="应用场景"   >
          <a href="#应用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1>
      <p>上面单例模式中为了解决重排序就可以使用<code>volatie</code>。</p>

        <h2 id="模式1：状态标志"   >
          <a href="#模式1：状态标志" class="heading-link"><i class="fas fa-link"></i></a><a href="#模式1：状态标志" class="headerlink" title="模式1：状态标志"></a>模式1：状态标志</h2>
      <p>用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> shutdownRequest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123; shutdownRequested = <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">while</span> (!shutdownRequested) &#123; </span><br><span class="line">        <span class="comment">// do stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="模式2：独立观察"   >
          <a href="#模式2：独立观察" class="heading-link"><i class="fas fa-link"></i></a><a href="#模式2：独立观察" class="headerlink" title="模式2：独立观察"></a>模式2：独立观察</h2>
      <p>安全使用 volatile 的另一种简单模式是定期 发布 观察结果供程序内部使用。例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> String lastUser;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">authenticate</span><span class="params">(String user, String password)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> passwordIsValid(user, password);</span><br><span class="line">        <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            activeUsers.add(u);</span><br><span class="line">            lastUser = user;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="模式3：volatile-bean模式"   >
          <a href="#模式3：volatile-bean模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#模式3：volatile-bean模式" class="headerlink" title="模式3：volatile bean模式"></a>模式3：volatile bean模式</h2>
      <p>在volatile bean模式中，JavaBean所有数据成员都是volatile类型，并且getter，setter方法必须非常普通—— 除了获取或设置相应的属性外，不能包含任何逻辑。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> age;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFirstName</span><span class="params">()</span> &#123; <span class="keyword">return</span> firstName; &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLastName</span><span class="params">()</span> &#123; <span class="keyword">return</span> lastName; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirstName</span><span class="params">(String firstName)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLastName</span><span class="params">(String lastName)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p>冰河《深入理解高并发编程》第一版</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/thread/java-thread-x-key-volatile.htm" >https://pdai.tech/md/java/thread/java-thread-x-key-volatile.htm</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javase/vd60g5#21cd9456" >https://www.yuque.com/qingkongxiaguang/javase/vd60g5#21cd9456</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/01/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">网络协议</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-01</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-01</span></span></div></header><div class="post-body"><div class="post-excerpt"><blockquote>
<p>整个网络协议与工具线路参照pdai的<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/develop/protocol/dev-protocol-overview.html" >Java全栈知识体系</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>学习，前半部分关于计算机网络的知识，padi也是直接使用了博客园的博主<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://home.cnblogs.com/u/googny/" >桂城老托尼</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>关于《计算机网络第五版》（谢希仁）的<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/googny/p/3682280.html" >读书笔记</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，在学习期间，作者也会参考《计算机网络-自顶向下方法》进行内容补充。</p>
</blockquote>

        <h1 id="计算机网络基础"   >
          <a href="#计算机网络基础" class="heading-link"><i class="fas fa-link"></i></a><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h1>
      <blockquote>
<p>如果学计算机网络觉得看文字过于枯燥，可以看一下中科大的<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1JV411t7ow/?spm_id_from=333.337.search-card.all.click&vd_source=5acf5a7b23d28e7633e5a9b381c57c42" >郑烇老师</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>的计算机网络的课。</p>
</blockquote>

        <h2 id="因特网概述"   >
          <a href="#因特网概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#因特网概述" class="headerlink" title="因特网概述"></a>因特网概述</h2>
      <p>一个网络可能由光纤，路由器，计算机（包括服务器）等组成，本质上就是结点和链路的组成。而<strong>因特网则是把许多网络连接在一起</strong>。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/01/4851be18068b1041.jpg"></p>
<p>组成：</p>
<ul>
<li>边缘部分：由所有连接在因特网的主机组成，这些主机又叫做端系统(end system)。</li>
<li>核心部分：大量网络和连接这些网络的<strong>路由器</strong>组成，为边缘部分提供服务的。</li>
</ul>
<p>计算机通信方式：</p>
<ul>
<li>客户服务器方式–C&#x2F;S方式，一般是客户端发起通信，否则服务端不知道客户端IP。</li>
<li>对等方式–P2P方式（Peer-to-Peer），两个主机都运行了对等连接软件，可以平等，对等连接通信。</li>
</ul>
<p>因特网中的核心部分最复杂，起特殊作用的是路由器（Router），实现分组交换。比如某一主机现需要发送一段较长的数据，发送时就会将这段数据分为一个个的分组，加上首部（事实上，我们说一个分组时，已经认为其包含了首部）。首部包含了一些有用的信息，比如这个分组实际承载的数据多大，目标地址等。</p>
<p>分组交换网中的结点交换机根据收到的分组的首部中的地址信息，把分组转发到下一个结点交换机。用这样的存储转发方式，最后分组就能到达最终目的地。接收端收到分组后剥去首部还原成报文。最后，在接收端把收到的数据恢复成为原来的报文。</p>

        <h2 id="路由器"   >
          <a href="#路由器" class="heading-link"><i class="fas fa-link"></i></a><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2>
      <p>路由器处理分组过程：</p>
<ul>
<li>把收到的分组先放入缓存（暂时存储）；</li>
<li>查找转发表，找出到某个目的地址应从哪个端口转发；</li>
<li>把分组送到适当的端口转发出去。</li>
</ul>
<blockquote>
<p>请区分好路由器和主机的区别，尽管都是因特网的节点，但是它们是不一样的。</p>
</blockquote>
<p>分组交换也存在许多问题，比如许多节点在经过同一个路由器分组转发时，需要排队，会造成一定时延，分组的首部也造成一定开销。</p>
<blockquote>
<p>除了分组交换，还有电路交换，在发送信息前，双方必须建立一条连接，路径上的交换机都将为该连接维护状态，并且预留了带宽，数据能够以恒定速率发送。</p>
</blockquote>
<p>对比：</p>
<p>早期面向终端的计算机网络是<strong>以单个主机为中心的星形网</strong>，各终端通过通信线路共享昂贵的中心主机的硬件和软件资源。分组交换网则是以网络为中心，主机都处在网络的外围。</p>

        <h2 id="网络分类"   >
          <a href="#网络分类" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络分类" class="headerlink" title="网络分类"></a>网络分类</h2>
      <p>不同作用范围：</p>
<ul>
<li>广域网 WAN（Wide Area Network），手机端移动设备是通过蜂窝网提供商运营的基站来发送和接收分组。用于仅需位于基站的数万米范围。</li>
<li>局域网 LAN（Local Area Network)，个人热点就是局域网，称为wlan–无线局域网（Wireless），WiFi是基于IEEEE 802.11技术的无线LAN接入，用户必须在接入点几十米范围内。</li>
<li>城域网 MAN</li>
<li>个人区域网 PAN</li>
</ul>
<p>根据使用者也可以分为公用网和专用网。</p>
<blockquote>
<p>重点需要提的是接入网AN（Access），由ISP–Internet Service Provider提供，起到让用户域因特网连接的桥梁作用。每个ISP自身就是一个由多台分组交换机和多段通信链路组成的网络。</p>
</blockquote>
<p>分组交换机除了路由器和链路层交换机，后者通常用于接入网，路由器用于网络核心中。</p>

        <h2 id="相关术语"   >
          <a href="#相关术语" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2>
      <p><strong>带宽</strong>：数字信道所能传送的最<strong>高数据率</strong>，单位是<strong>比特每秒b&#x2F;s</strong>。</p>
<p><strong>吞吐量</strong>：单位时间内通过某个网络（信道，接口）的数据量。</p>
<p><strong>传输时延（发送时延 ）</strong>：  发送数据时，数据块从结点进入到传输媒体所需要的时间。从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间，<strong>发送时延&#x3D;数据块长度&#x2F;带宽</strong>。</p>
<p><strong>传播时延</strong>  电磁波在信道中需要传播一定的距离而花费的时间，<strong>传播时延&#x3D;信道长度&#x2F;信号在信道上的传播速率</strong>。</p>
<p>处理时延和排队时延比较简单，跟路由器有关。</p>

        <h2 id="体系结构"   >
          <a href="#体系结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2>
      <p>经常使用的TCP&#x2F;IP协议是四层体系结构：应用层，运输层，网际层，网络接口层。和ISO折中之后，采用一种五层协议的体系结构：应用层，运输层，网络层，数据链路层，物理层。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/01/cd33ff3621dde413.jpg"></p>
<blockquote>
<p>还有UDP，这种传输协议不能对数据做出任何保证，即使在传播过程中出现丢失，比特突变，都不会做任何弥补措施，一般用于实时媒体软件，比如直播（数据丢了就丢了，无所谓）。</p>
</blockquote>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/googny/p/3682280.html" >https://www.cnblogs.com/googny/p/3682280.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>《计算机网络自顶向下》第一章</p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/29/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88(1)-PriorityQueue/">Java集合(1)--PriorityQueue</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-29</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-29</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="其他集合"   >
          <a href="#其他集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#其他集合" class="headerlink" title="其他集合"></a>其他集合</h1>
      <p>因为像ArrayList，LinkedList之类的容器比较简单，此处不会过多解释，只会列出一些需要注意的点。</p>
<p><strong>ArrayList</strong>：</p>
<ul>
<li>ArrayList为了效率没有实现同步，有需求的情况下需要自己实现。</li>
<li>向ArrayList中加入元素（add）时，都会进行容量检查，扩容都会交给grow方法。</li>
<li><code>remove</code>函数中，删除中间某一个元素会导致后面的元素向前移动，需要将最后一个位置赋为null（为了让GC起作用）。</li>
<li><code>tirmToSize()</code>，将数组容量修改为当前元素个数大小；<code>indexOf()</code>与<code>lastIndexOf()</code><br>就是获取元素第一次&#x2F;最后一次出现的index。</li>
<li><code>modCount</code>是指集合创建以来修改的次数，他保证在迭代器循环中，如果出现集合的修改就停止迭代。</li>
</ul>
<p><strong>LinkedList</strong>：</p>
<ul>
<li>LinkedList可以考虑作为栈&#x2F;队列，Java官方不建议使用Stack。但是ArrayDeque是栈或者队列的<br>首选，性能更好。</li>
<li>LinkedList没有哑节点，当链表为空的时候first和last都指向null。</li>
</ul>
<p><strong>ArrayDeque</strong>：</p>
<ul>
<li><p><code>Deque</code>是”double ended queue”, 表示双向的队列，英文读作”deck”.。</p>
</li>
<li><p>ArrayDeque是非线程安全的，不允许加入null。</p>
</li>
</ul>

        <h1 id="PriorityQueue"   >
          <a href="#PriorityQueue" class="heading-link"><i class="fas fa-link"></i></a><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h1>
      <p>优先队列保证每次取出的元素都是队列中最小的（构造时可以传入比较器<code>Comparator</code>，所以想要每次取出都是最大的，只需要反过来即可）。</p>
<p>PriorityQueue不允许放入<code>null</code>元素，<strong>内部通过数组实现小根堆</strong>，小根堆抽象上可以理解为完全二叉树。</p>
<p>数组映射完全二叉树的算数关系为：</p>
<ul>
<li><code>leftNode = ParentNode*2 + 1</code> </li>
<li><code>rightNode = ParentNode*2 + 2</code> </li>
<li><code>ParentNode = (node - 1)/2</code></li>
</ul>
<blockquote>
<p><em>PriorityQueue</em>的<code>peek()</code>和<code>element</code>操作是常数时间，<code>add()</code>, <code>offer()</code>, 无参数的<code>remove()</code>以及<code>poll()</code>方法的时间复杂度都是*log(N)*。</p>
</blockquote>
<p><code>add()</code>和<code>remove()</code>失败后就会抛出异常，而<code>offer()</code>和<code>poll()</code>就是返回<code>false</code>。</p>

        <h2 id="小根堆解析"   >
          <a href="#小根堆解析" class="heading-link"><i class="fas fa-link"></i></a><a href="#小根堆解析" class="headerlink" title="小根堆解析"></a>小根堆解析</h2>
      <p>此处不讲解PriorityQueue源码，而是理解小根堆的维护流程</p>
<p><strong>加入节点</strong>：队列只允许从队尾加入元素，大致流程如下图。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/29/a2497ab926b94de8.jpg"></p>
<p>删除节点：</p>
<ul>
<li>优先队列出队操作会导致根节点被删除，此时需要将最后一个节点放到根节点的位置在进行下降调整。</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/29/0681d1a809288d78.jpg"></p>
<ul>
<li>如果是其他关于小根堆的删除，当删除节点是尾节点时，直接删除即可。</li>
<li>当节点在中间，我们就只看以该节点尾根节点的子树，将数组最后一个节点移到当前节点，再调整。</li>
</ul>

        <h1 id="小根堆代码"   >
          <a href="#小根堆代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#小根堆代码" class="headerlink" title="小根堆代码"></a>小根堆代码</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟小根堆的增加</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>[] minHeap ,<span class="type">int</span> size , <span class="type">int</span> val)</span> &#123;</span><br><span class="line">      <span class="comment">// 假设参数合法，数组不出现越界</span></span><br><span class="line">      <span class="keyword">if</span>(size == <span class="number">0</span>) &#123; minHeap[size++] = val;<span class="keyword">return</span>;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当前父节点,index是当前val位于的位置</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (size - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>,index = size;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(minHeap[p] &gt; val) &#123;</span><br><span class="line">          minHeap[index] = minHeap[p];</span><br><span class="line">          <span class="keyword">if</span>(p == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">          index = p;</span><br><span class="line">          p = (p-<span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      minHeap[p] = val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span>[] minHeap , <span class="type">int</span> size , <span class="type">int</span> index)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(size-<span class="number">1</span> == index) &#123;minHeap[size] = -<span class="number">1</span>;<span class="keyword">return</span>;&#125;<span class="comment">// 假设-1为null</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/** 小根堆是完全二叉树，左节点下标为奇数，右节点为偶数</span></span><br><span class="line"><span class="comment">          一直向下找右节点直到到达最后一层，在倒数第二层会出现</span></span><br><span class="line"><span class="comment">          1） 该层不存在右孩子</span></span><br><span class="line"><span class="comment">          2） 该层存在右孩子</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      minHeap[index] = minHeap[--size];</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>,r = l + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 权值大的节点向下沉</span></span><br><span class="line">      <span class="keyword">while</span>(l &lt; size &amp;&amp; r &lt; size) &#123;</span><br><span class="line">          <span class="keyword">if</span>(minHeap[l] &lt; minHeap[index]) &#123;</span><br><span class="line">              minHeap[index] = minHeap[l];</span><br><span class="line">              index = l;</span><br><span class="line">              l = (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;r = l + <span class="number">1</span>; </span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minHeap[r] &lt; minHeap[index]) &#123;</span><br><span class="line">              minHeap[index] = minHeap[r];</span><br><span class="line">              index = r;</span><br><span class="line">              l = (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;r = l + <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 如果当前节点小于左右子节点，则完成</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(l &lt; size &amp;&amp; minHeap[l] &lt; minHeap[index]) &#123;</span><br><span class="line">          minHeap[index] = minHeap[l];</span><br><span class="line">          minHeap[l] = -<span class="number">1</span>;</span><br><span class="line">      &#125; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://www.cnblogs.com/CarpenterLee/p/5488070.html" >http://www.cnblogs.com/CarpenterLee/p/5488070.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/collection/java-collection-PriorityQueue.html" >https://pdai.tech/md/java/collection/java-collection-PriorityQueue.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/28/Docker/Docker(7)-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/">Docker(7)--资源管理</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-28</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="容器控制操作"   >
          <a href="#容器控制操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#容器控制操作" class="headerlink" title="容器控制操作"></a>容器控制操作</h1>
      <blockquote>
<p>补充一些Docker的命令，对于这种单纯的命令查看，建议直接看菜鸟教程。</p>
</blockquote>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器，退出：ctrl+P，ctrl+Q；终止容器运行的程序：ctrl+C</span></span><br><span class="line">docker attach 容器ID/名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行命令，这里执行的是bash，并开启一个可输入终端</span></span><br><span class="line">docker exec -it 容器ID/名称 bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">（假设容器可以执行java），就相当于让容器执行java -version</span></span><br><span class="line">docker exec 容器ID/名称 java -version</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许容器处理善后再停止运行</span></span><br><span class="line">docker kill 容器ID/名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接强制停止容器</span></span><br><span class="line">docker stop 容器ID/名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动容器（一般是容器被stop之后）</span></span><br><span class="line">docker start 容器ID/名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启容器</span></span><br><span class="line">docker restart 容器ID/名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">暂停容器(unpause--取消暂停)</span></span><br><span class="line">docker pause 容器ID/名称</span><br></pre></td></tr></table></div></figure>




        <h1 id="物理资源管理"   >
          <a href="#物理资源管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#物理资源管理" class="headerlink" title="物理资源管理"></a>物理资源管理</h1>
      <ul>
<li>内存分配：</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -m 50M --memory-swap=100M nagocoler/springboot-test:1.0</span><br></pre></td></tr></table></div></figure>

<p><code>-m</code>对容器的物理内存的限制，<code>--memory-swap</code>对内存和交换分区总和的限制。默认都是-1，即没有任何限制。如果仅指定<code>-m</code>，那么交换内存的限制也为<code>-m</code>指定的参数。</p>
<ul>
<li>CPU进行限额：</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line">docker run -c 1024 ubuntu</span><br><span class="line">docker run -c 512 ubuntu</span><br></pre></td></tr></table></div></figure>

<p>对CPU的分配只有多容器才生效，默认是1024，如果CPU不紧张，依然可以使用全部CPU资源。</p>
<blockquote>
<p>通过Ubuntu命令：<code>sudo apt install stress</code>在容器中下载压力测试工具来看一下进程分配权重对进程获得CPU资源的影响。</p>
</blockquote>
<p>还可以限制容器使用CPU：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --cpuset-cpus=1 ubuntu</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>选项后面的值不是CPU的数量，而是CPU的“编号”，即这个容器只用1这个CPU，所以指定两个CPU时也可以这样：<code>docker run -it --cpuset-cpus=0,1 ubuntu</code>。</p>
</blockquote>
<p>命令<code>--cpus</code>来限制使用CPU资源数（个数）：<code>docker run -it --cpus=1 ubuntu</code>。</p>

        <h1 id="容器监控"   >
          <a href="#容器监控" class="heading-link"><i class="fas fa-link"></i></a><a href="#容器监控" class="headerlink" title="容器监控"></a>容器监控</h1>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats</span><br></pre></td></tr></table></div></figure>

<p>可以实时对容器的各项状态进行监控，包括内存使用、CPU占用、网络I&#x2F;O、磁盘I&#x2F;O等信息。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/28/2e4f267ce01df490.jpg"></p>
<p><code>top</code>命令可以查看容器进程：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器ID/名称</span><br></pre></td></tr></table></div></figure>

<p>对于容器监管，也有页面版本的，官方<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://docs.portainer.io/start/install/server/docker/linux" >下载教程</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，此处不过多讲解。</p>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/zwhkpi/kq6rlg" >https://www.yuque.com/qingkongxiaguang/zwhkpi/kq6rlg</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-start-stop-restart-command.html" >https://www.runoob.com/docker/docker-start-stop-restart-command.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/27/Docker/Docker(6)-%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%AE%A1%E7%90%86/">Docker(6)--数据卷管理</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-27</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-28</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="数据卷"   >
          <a href="#数据卷" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h1>
      <blockquote>
<p>基于分层机制，在容器中操作的文件都是在最顶层进行，这也导致容器的销毁会导致数据丢失。通过数据卷可以实现数据共享和持久化。</p>
</blockquote>

        <h2 id="文件挂载"   >
          <a href="#文件挂载" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件挂载" class="headerlink" title="文件挂载"></a>文件挂载</h2>
      <p>Linux根目录以外的文件想要被访问，就需要将其关联到根目录下的某个目录实现，这种关联就叫挂载，目录就是挂载点，解除关联就是卸载。</p>
<blockquote>
<p>最直接的就是读取U盘的文件，如果没有挂载操作，就只能在图形化界面使用U盘，在命令行找不到的。</p>
</blockquote>
<p>进行挂载时建议重新创建一个文件夹，如果使用了系统文件夹（etc之类的），挂载操作会使得原有目录中文件被隐藏，可能会导致系统崩溃。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount 设备号 挂载点目录</span><br><span class="line"></span><br><span class="line">umount 挂载点目录</span><br></pre></td></tr></table></div></figure>




        <h2 id="容器持久化"   >
          <a href="#容器持久化" class="heading-link"><i class="fas fa-link"></i></a><a href="#容器持久化" class="headerlink" title="容器持久化"></a>容器持久化</h2>
      <blockquote>
<p>我们可以让容器将文件保存到宿主主机上，这样就算容器销毁，文件也会在宿主主机上保留，下次创建容器时，依然可以从宿主主机上读取到对应的文件。</p>
</blockquote>
<p>在宿主机创建需要挂载到容器的目录：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">随便创建点文件表示有内容</span></span><br><span class="line">vim test/hello.txt</span><br></pre></td></tr></table></div></figure>

<p>将test目录挂载到容器的某个目录上</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v ~test:/root/test ubuntu</span><br></pre></td></tr></table></div></figure>

<p>此时在容器中就可以访问宿主主机的文件，对挂载目录的文件进行编辑，就相当于编辑宿主主机的数据。在容器中创建文件，宿主主机也会创建相应文件。</p>
<blockquote>
<p>在容器中删除文件，不会影响主机的文件。</p>
</blockquote>
<p>可以部署Nginx，在宿主主机上保存前端页面，然后将这个前端页面目录挂载到Nignx容器上，这样Nginx镜像有升级，容器需要删除重新创建也不会影响前端页面。</p>
<p>我们这里使用的前端模板是<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://bootstrapmade.com/" >Arsha</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>（如何将文件传到linux上待会讲）。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /win_data/Arsha:/usr/share/nginx/html/ -p 80:80 -d nginx</span><br></pre></td></tr></table></div></figure>

<p>将解压出来的目录挂载到Nginx的默认站点目录<code>/usr/share/nginx/html/</code>，因为挂在后位于顶层，会替代镜像原有的文件。</p>
<p>进入容器将Nginx服务启动：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>在windos浏览器中输入<code>IP:80</code>，即可访问nginx服务，如果访问超时，可能是linux80端口被其他进程占用，最简单的就是重启一下linux，再启动nginx。</p>
</blockquote>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/28/72cd9dda6c186381.jpg"></p>
<p>如果在挂载时没有指定宿主主机的目录，Docker就会自动创建一个新的文件夹，并且会将容器中对应路径下的内容拷贝到这个自动创建的目录中，最后挂在到容器中，这种就是由Docker管理的数据卷了。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /root/abc ubuntu</span><br></pre></td></tr></table></div></figure>

<p>要查看Docker将文件放在了宿主机哪个位置</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器名字/ID</span><br></pre></td></tr></table></div></figure>

<p>主要是看Mount这个部分</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/28/efea66dac14a3326.jpg"></p>
<p>Docker支持从宿主主机复制文件到容器中（或者容器复制文件到宿主主机）</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 主机文件 容器名/ID:文件夹路径</span><br></pre></td></tr></table></div></figure>




        <h3 id="win文件传输到Linux"   >
          <a href="#win文件传输到Linux" class="heading-link"><i class="fas fa-link"></i></a><a href="#win文件传输到Linux" class="headerlink" title="win文件传输到Linux"></a>win文件传输到Linux</h3>
      <blockquote>
<p>如果linux装在虚拟机上，虚拟机安装了VMwareTools后，一般可以实现文件直接从win拖动到虚拟机系统里面，但是有时候抽风又不能拖动。也可以将文件放到U盘里面，然后U盘挂载到Linux上，再将文件移动到Linux其他文件夹里面使用。（无语的是我这U盘挂载也出了问题）</p>
</blockquote>
<p>这里讲通过pscp，命令行传输文件。</p>
<ul>
<li>在Linux中设置好root的密码：<code>sudo passwd</code>。在根目录下创建<code>win_data</code>文件夹（名字其实随便）</li>
<li>修改<code>sshd_config</code>文件，参考这篇文章：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/xuliangxing/p/7428737.html" >https://www.cnblogs.com/xuliangxing/p/7428737.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li>在windos下载好需要的文件</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/28/29425736a49aebd9.jpg"></p>
<ul>
<li>下载pscp：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html%EF%BC%8C%E5%B0%86%60pscp.exe%60%E6%94%BE%E5%9C%A8C:/Windows/System32%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B" >https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html，将`pscp.exe`放在C:\Windows\System32文件夹下</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/28/0879d6517d9f457d.jpg"></p>
<ul>
<li>在C:Windows\System32下打开命令行，输入：</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp 下载文件路径 root@IP:/win_data</span><br></pre></td></tr></table></div></figure>

<p>输入密码后就可以传输了，这里必须要使用root，使用一般用户的话，权限不够会拒绝访问。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/28/6d1d04a4f34aac95.jpg"></p>
<ul>
<li>最后在<code>/win_data</code>目录里解压压缩包就可以使将其挂载到nginx上了</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo unzip Arsha.zip</span><br></pre></td></tr></table></div></figure>




        <h2 id="容器数据共享"   >
          <a href="#容器数据共享" class="heading-link"><i class="fas fa-link"></i></a><a href="#容器数据共享" class="headerlink" title="容器数据共享"></a>容器数据共享</h2>
      <blockquote>
<p>容器与容器之间的数据共享</p>
</blockquote>
<p>一般思路是在宿主主机上创建公告目录，让需要共享的容器挂载到这个公共目录。也可以创建一个容器专门用于存放数据，即数据卷容器。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v ~/test:/root/test --name=data_test ubuntu</span><br><span class="line">docker run -it --volumes-from data_test ubuntu</span><br></pre></td></tr></table></div></figure>

<p>使用<code>--volumes-from</code>指定另一个容器，数据卷容器挂载的内容，在当前容器也存在，就算数据卷容器被删除，也不会影响这边，本质上还是让两个容器挂载了同样的目录实现数据共享。</p>
<p>还可以将数据完全放到容器中，通过构建一个容器将打包好的数据分享给其他容器</p>
<figure class="highlight dockerfile"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> data.tar.gz /usr/share/nginx/html</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /usr/share/nginx/html</span></span><br></pre></td></tr></table></div></figure>

<p>指令ADD，它跟COPY命令类似，也可以复制文件到容器中，但是它可以自动对压缩文件进行解压，这里只需要将压缩好的文件填入即可，后面的VOLUME指令就像我们使用<code>-v</code>参数一样，会创建一个挂载点在容器中</p>
<p>然后构建</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t 镜像名 .</span><br></pre></td></tr></table></div></figure>

<p>通过这个镜像创建按出来的容器，我们就可以使用了（假设容器名是ubuntu_test）</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80 --volumes-from=ubuntu_test -d nginx</span><br></pre></td></tr></table></div></figure>


        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p>Linux文件挂载：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://haicoder.net/linux/linux-file-mount.html" >https://haicoder.net/linux/linux-file-mount.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.bbsmax.com/A/gVdnOKP8zW/" >https://www.bbsmax.com/A/gVdnOKP8zW/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>修改sshd_config文件：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/xuliangxing/p/7428737.html" >https://www.cnblogs.com/xuliangxing/p/7428737.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>前端模板：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://bootstrapmade.com/" >https://bootstrapmade.com/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/24/Docker/Docker(5)-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/">Docker(5)--网络配置</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-27</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="Docker默认网桥"   >
          <a href="#Docker默认网桥" class="heading-link"><i class="fas fa-link"></i></a><a href="#Docker默认网桥" class="headerlink" title="Docker默认网桥"></a>Docker默认网桥</h1>
      <p>安装Docker服务会默认创建一个 docker0 网桥，它在内核层连通了其他的物理或虚拟网卡，这就<strong>将所有容器和本地主机都放到同一个物理网络</strong>。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/26/6cd3d7a5835ed737.jpg"></p>
<p>容器有三种网络类型，分别是<code>bridge</code>,<code>host</code>,<code>none</code>，创建容器时默认是<code>bridge</code>。我们可以使用命令查看</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></div></figure>

<p>先创建一个容器再来讲解</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu</span><br><span class="line"></span><br><span class="line">apt update</span><br><span class="line">apt install net-tools iputils-ping curl</span><br></pre></td></tr></table></div></figure>

<p><img src="https://s3.bmp.ovh/imgs/2022/09/26/30f79fa9a2b0bfe5.jpg"></p>
<p>可以看到这个容器的<code>IP</code>是<code>172.17.0.3</code>。该ubuntu容器启动时没有指定网络类型，默认就是<code>bridge</code>，我们看一下<code>bridge</code>的网络</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cyan@w2d:~$ docker network inspect bridge</span><br></pre></td></tr></table></div></figure>

<p>看关键部分</p>
<figure class="highlight json"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;Config&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Subnet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.17.0.0/16&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Gateway&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.17.0.1&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>我的终端倒是没有显示Gateway网关，这个其实就是docker0的IP，我们创建的容器默认就是通过docker0桥接宿主机的网络。</p>
</blockquote>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/26/726c5b32968c34d6.jpg"></p>

        <h2 id="创建容器"   >
          <a href="#创建容器" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2>
      <p>Docker在创建一个容器的时候，会执行如下操作：</p>
<ul>
<li><p>创建一对虚拟接口&#x2F;网卡，也就是veth pair，分别放到本地主机和新容器中；</p>
</li>
<li><p>本地主机一端桥接到默认的 docker0 或指定网桥上，并具有一个唯一的名字，如 vethxxxxx；</p>
</li>
<li><p>容器一端放到新容器中，并修改名字作为 eth0，这个网卡&#x2F;接口只在容器的名字空间可见；</p>
</li>
<li><p>从网桥可用地址段中（也就是与该bridge对应的network）获取一个空闲地址分配给容器的 eth0，并配置默认路由到桥接网卡 vethxxxx。</p>
</li>
</ul>
<blockquote>
<p>如果不指定–network，创建的容器默认都会挂到 docker0 上，使用本地主机上 docker0 接口的 IP 作为所有容器的默认网关</p>
</blockquote>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/26/324896ddff4fdafc.jpg"></p>

        <h1 id="网络类型"   >
          <a href="#网络类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络类型" class="headerlink" title="网络类型"></a>网络类型</h1>
      
        <h2 id="默认网络类型"   >
          <a href="#默认网络类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#默认网络类型" class="headerlink" title="默认网络类型"></a>默认网络类型</h2>
      <p>之前使用<code>docker network ls</code>查看三种网络类型，有<code>bridge</code>，<code>host</code>，<code>none</code>。，使用<code>--network</code>可以指定网络</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --network=none ubuntu</span><br></pre></td></tr></table></div></figure>

<ul>
<li><strong>none网络</strong>：只有一个本地环回网络，通过<code>ifconfig</code>查看，只有一个本地环回<code>lo</code>网络设备：</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/26/ba906a10862142e3.jpg"></p>
<p>在这种网络模式下，容器无法连接到互联网：比如，<code>ping</code>不通，纯纯单机运行。</p>
<ul>
<li><strong>bridger网络</strong>：容器默认使用的网络类型，上文我们已经讲了，此处不再赘述。</li>
<li><strong>host网络</strong>：当容器连接到此网络，会共享宿主主机的网络，网络配置是完全一样。</li>
</ul>

        <h2 id="自定义网络类型"   >
          <a href="#自定义网络类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#自定义网络类型" class="headerlink" title="自定义网络类型"></a>自定义网络类型</h2>
      <p>Docker默认提供三种网络驱动：<code>bridge</code>、<code>overlay</code>、<code>macvlan</code>，不同的驱动对应着不同的网络设备驱动，实现的功能也不一样，比如bridge类型的，其实就和我们前面介绍的桥接网络是一样的。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create --driver bridge test</span><br></pre></td></tr></table></div></figure>

<p>这就是本文最开始的<code>ifconfig</code>多显示了一个网络设备，不同网络之间的通信是相互隔离的，无法进行通信，比如我们有一个在默认网络类型的ubuntu容器，有一个在test网络下的ubuntu容器，后者的网关是<code>172.18.0.1</code>，容器IP为<code>172.18.0.2</code>，在前者中想要执行命令：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 172.18.0.2</span><br></pre></td></tr></table></div></figure>

<p>会失败，想要实现通信，需要将前者连接到另一个容器所属的网络下：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect test(网络类型) 容器ID/名称</span><br></pre></td></tr></table></div></figure>

<p>此时容器就可以互相通信。Docker的DNS服务器可以不需要指定容器IP，比如有两个可以互相通信的容器，在启动时分别用<code>--name</code>指定名称，通信时就可以使用名称而不是IP（就像有一个DNS一样将名字解析成IP）</p>
<p>两个容器也可以共享一个网络设备，即两个容器共同使用一个IP地址，只需要在创建时指定：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name=test02 --network=container:test02 ubuntu</span><br></pre></td></tr></table></div></figure>

<p>两个容器的IP地址和网卡的Mac地址是完全一样的，它们的网络现在是共享状态，此时在容器中访问，localhost，既是自己也是别人。</p>
<p>可以在容器1中，安装Nginx，然后再容器2中访问：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install -y systemctl nginx</span><br><span class="line">systemctl start nginx</span><br></pre></td></tr></table></div></figure>

<p>访问到另一个容器中的Nginx服务器。</p>
<blockquote>
<p>另外两种类型的网络用于多主机通信，多主机通信会使用物理交换机，不同主机的网卡连接到同一台交换机，就相当于各自网桥在同一物理网络了。</p>
</blockquote>

        <h2 id="容器外部网络"   >
          <a href="#容器外部网络" class="heading-link"><i class="fas fa-link"></i></a><a href="#容器外部网络" class="headerlink" title="容器外部网络"></a>容器外部网络</h2>
      <p>在默认的三种的网络下，只有共享模式和桥接模式可以连接到外网，共享模式实际上就是直接使用宿主主机的网络设备连接到互联网，这里主要来看一下桥接模式。</p>
<blockquote>
<p>桥接模式容器发送数据包时，关键部分就是NAT(Netwirk Address Translation)，将地址进行转换，再利用宿主主机的IP地址发送数据包出去。</p>
</blockquote>
<p>比如我们要访问互联网上的某个资源，要和服务器进行通信，那么就需要将数据包发送出去，同时服务器也要将数据包发送回来，我们可以知道服务器的IP地址，也可以直接去连接，因为服务器的IP地址是暴露在互联网上的，但是我们的局域网就不一样了，它仅仅局限在我们的家里，比如我们连接了家里的路由器，可以得到一个IP地址，但是你会发现，这个IP公网是无法直接访问到我们的，因为这个IP地址仅仅是一个局域网的IP地址，俗称内网IP。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/27/dab39643f8e2041e.jpg"></p>
<p>这里就借助了NAT在帮助我们与互联网上的服务器进行通信，通过NAT，可以实现将局域网的IP地址，映射为对应的公网IP地址，而NAT设备一端连接外网，另一端连接内网的所有设备，当我们想要与外网进行通信时，就可以将数据包发送给NAT设备，由它来将数据包的源地址映射为它在外网上的地址，这样服务器就能够发现它了，能够直接与它建立通信。当服务器发送数据回来时，也是直接交给NAT设备，然后再根据地址映射，转发给对应的内网设备（当然由于公网IP地址有限，所以一般采用IP+端口结合使用的形式ANPT）。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/27/e05a018b5df6da55.jpg"></p>
<p>用百度查出来的IP和在命令行使用<code>ipconfig(windows)</code>查出来的不一样，前者是NAT设备的公网地址。</p>
<p>Docker中，内网数据包想要发送到互联网上的流程为：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/27/e4ebfbc4ba947097.jpg"></p>
<p>单纯依靠NAT，只有主动与外界联系时，外界才知道我们。但是如果容器中部署了一些服务，需要外界主动连接容器的服务，就需要使用端口映射配置。</p>
<blockquote>
<p>外界连接，只知道linux的IP而不知道容器的IP，就需要通过端口映射访问。端口映射可以将容器需要对外提供服务的端口映射到宿主主机的端口上，这样，当外部访问到宿主主机的对应端口时，就会直接转发给容器内映射的端口了。</p>
</blockquote>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先部署一个nginx服务</span></span><br><span class="line">docker run -d -p 80:80 nginx</span><br></pre></td></tr></table></div></figure>

<p><code>-p</code>参数是进行端口映射配置，规则为<code>宿主端口:容器端口</code>，其实关于端口映射之前的文章已经讲过了。</p>
<p>然后在浏览器中输入：<code>Linux IP:80</code>即可访问nignx服务。</p>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/devops/docker/docker-07-network.html" >https://pdai.tech/md/devops/docker/docker-07-network.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/zwhkpi/kq6rlg#67fb97ea" >https://www.yuque.com/qingkongxiaguang/zwhkpi/kq6rlg#67fb97ea</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.it1352.com/2052892.html" >https://www.it1352.com/2052892.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/24/Docker/Docker(4)-webapp%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/">Docker(4)--webapp应用实例</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-24</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h1>
      <p>本文通过web应用展示主机如何与wen容器之间通信，为后续讲解网络提供基础。</p>

        <h1 id="web的运行与访问"   >
          <a href="#web的运行与访问" class="heading-link"><i class="fas fa-link"></i></a><a href="#web的运行与访问" class="headerlink" title="web的运行与访问"></a>web的运行与访问</h1>
      
        <h2 id="运行"   >
          <a href="#运行" class="heading-link"><i class="fas fa-link"></i></a><a href="#运行" class="headerlink" title="运行"></a>运行</h2>
      <blockquote>
<p>找到一个webapp镜像即可。</p>
</blockquote>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull training/webapp</span><br></pre></td></tr></table></div></figure>

<p>下载完成后查看</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images | grep webapp</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>我们需要跑一下这个webapp里面的app.py文件，其实就是hello world</p>
</blockquote>
<p>启动webapp</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P training/webapp python app.py</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p><code>-d</code>：让容器在后台运行</p>
<p><code>-P</code>：将容器内部使用的网络端口映射到主机上</p>
</blockquote>
<p>查看一下</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cyan@w2d:~$ docker ps</span><br><span class="line">CONTAINER ID          PORTS                                   </span><br><span class="line">e7a994ce697c     0.0.0.0:49153-&gt;5000/tcp, :::49153-&gt;5000/tcp  </span><br></pre></td></tr></table></div></figure>

<p>这里因为界面显示不够，我就只保留了ID和端口号的相关信息。</p>

        <h2 id="访问"   >
          <a href="#访问" class="heading-link"><i class="fas fa-link"></i></a><a href="#访问" class="headerlink" title="访问"></a>访问</h2>
      <p>上文端口号的解读是：Docker开放5000端口（Python Flask默认端口）映射到主机端口49153.</p>
<p>所以我们可以从49153这个端口来访问这个界面</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nltp | grep 49153</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p><code>netstat</code>命令用于显示网络状态</p>
</blockquote>
<p>在命令行：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl localhost:49153</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者在浏览器上访问，ip是虚拟机-Ubuntu的ip</span></span><br></pre></td></tr></table></div></figure>

<p><img src="https://s3.bmp.ovh/imgs/2022/09/24/1d9b4aa085083f9e.jpg"></p>
<p>容器映射到主机的端口是随机的，但是可以用-P选项来指定端口</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P 5001:500 training/webapp python app.py</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>如果浏览器访问不上，把镜像删了重新下载试试，反正是可以的</p>
</blockquote>

        <h1 id="其他功能"   >
          <a href="#其他功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h1>
      <blockquote>
<p>反正都是命令，快速过一下</p>
</blockquote>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器(映射)端口</span></span><br><span class="line">docker port ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志</span></span><br><span class="line">docker logs ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器进程</span></span><br><span class="line">docker top</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查应用底层信息，返回JSON文件记录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">容器配置和状态信息</span></span><br><span class="line">docker inspect ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止应用容器</span></span><br><span class="line">docker stop ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启容器</span></span><br><span class="line">docker restart/start ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除容器,-f就是强制删除，一般容器删除需要</span> </span><br><span class="line">docker rm ID</span><br></pre></td></tr></table></div></figure>




        <h2 id="容器互联"   >
          <a href="#容器互联" class="heading-link"><i class="fas fa-link"></i></a><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2>
      <blockquote>
<p>删除所有不再使用的容器：<code>docker container prune</code>。</p>
</blockquote>
<p>创建数据库容器：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name db training/postgres</span><br></pre></td></tr></table></div></figure>

<p>db容器与web容器建立互联关系</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P 5001:5000 --name web --link db:db training/webapp python app.py</span><br></pre></td></tr></table></div></figure>

<p><code>--link</code>参数格式为 <code>--link name:alias</code>，其中 name 是要链接的容器的名称，alias 是这个连接的别名。</p>
<p>容器之间的连接信息的查看有两种方式：</p>
<ul>
<li>查看环境变量：</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">webapp已经运行起来了,假设其名字为web</span></span><br><span class="line">docker exec -it web /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">====&gt;，这里假设ID是1cbc9aeba2a8</span></span><br><span class="line">root@1cbc9aeba2a8:/opt/webapp# env</span><br><span class="line">DB_NAME=/web/db</span><br><span class="line">DB_PORT_5432_TCP_ADDR=172.17.0.2</span><br><span class="line">DB_PORT=tcp://172.17.0.2:5432</span><br><span class="line">DB_PORT_5432_TCP=tcp://172.17.0.2:5432</span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">PWD=/opt/webapp</span><br><span class="line">DB_PORT_5432_TCP_PORT=5432</span><br><span class="line">SHLVL=1</span><br><span class="line">HOME=/root</span><br><span class="line">DB_PORT_5432_TCP_PROTO=tcp</span><br><span class="line">DB_ENV_PG_VERSION=9.3</span><br><span class="line">_=/usr/bin/env</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>DB_ 开头的环境变量是供 web 容器连接 db 容器使用，前缀采用大写的连接别名。<strong>只有在建立连接之后才会有，没有建立连接是没有这几个变量的</strong>。</p>
</blockquote>
<ul>
<li>hosts文件</li>
</ul>
<p>除了环境变量，Docker 还添加 host 信息到父容器的 <code>/etc/hosts</code> 的文件。下面是父容器 web 的 hosts 文件</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@1cbc9aeba2a8:/opt/webapp# cat /etc/hosts</span><br><span class="line">127.0.0.1       localhost</span><br><span class="line">::1     localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0 ip6-localnet</span><br><span class="line">ff00::0 ip6-mcastprefix</span><br><span class="line">ff02::1 ip6-allnodes</span><br><span class="line">ff02::2 ip6-allrouters</span><br><span class="line">172.17.0.2      db d992e3c761e0</span><br><span class="line">172.17.0.3      1cbc9aeba2a8</span><br><span class="line">root@1cbc9aeba2a8:/opt/webapp#</span><br></pre></td></tr></table></div></figure>

<p>这里有 2 个 hosts:</p>
<ul>
<li>第一个, <code>172.17.0.2 db d992e3c761e0</code> 表示 db 容器的 ip, ID和Name</li>
<li>第二个，<code>172.17.0.3 1cbc9aeba2a8</code> 表示 web 容器的 ip, ID</li>
</ul>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p>netstat命令：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-netstat.html?ivk_sa=1024320u" >https://www.runoob.com/linux/linux-comm-netstat.html?ivk_sa=1024320u</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>Java全栈知识体系：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/devops/docker/docker-03-basic-web-app.html" >https://pdai.tech/md/devops/docker/docker-03-basic-web-app.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/logo.png" alt="avatar"></div><p class="sidebar-ov-author__text">You have lots more to work on</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">69</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">2</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">11</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh_tw" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Cyan</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.2.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.7.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.7.0"></script><script src="/js/stun-boot.js?v=2.7.0"></script><script src="/js/scroll.js?v=2.7.0"></script><script src="/js/header.js?v=2.7.0"></script><script src="/js/sidebar.js?v=2.7.0"></script></body></html>