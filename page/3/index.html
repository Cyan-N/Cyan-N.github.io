<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.7.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.7.0" type="image/png" sizes="32x32"><meta name="description" content="我始终勇往直前，百折不回...">
<meta property="og:type" content="website">
<meta property="og:title" content="慕青的日记">
<meta property="og:url" content="https://cecilia.cool/page/3/index.html">
<meta property="og:site_name" content="慕青的日记">
<meta property="og:description" content="我始终勇往直前，百折不回...">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Cyan">
<meta name="twitter:card" content="summary"><title>慕青的日记 | Cyan</title><link ref="canonical" href="https://cecilia.cool/page/3/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.7.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">慕青的日记</div><div class="header-banner-info__subtitle">Cyan</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/08/16/Java/%E5%B9%B6%E5%8F%91/JUC_locks3-AQS%E4%B8%8B/">J.U.C.locks(3)--AQS下</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-08-16</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-08-17</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="模板方法模式"   >
          <a href="#模板方法模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1>
      <p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样(模板方法模式很经典的一个应用)。<code>AQS</code>底层使用模板方法，使用者继承<code>AbstractQueuedSynchronizer</code>并重写指定的方法。(这些重写方法很简单，无非是对于共享资源<code>state</code>的获取和释放) 将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</p>
<p>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="type">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="type">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="type">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="type">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></div></figure>

<p>这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。关于模板方法，可以参考这篇文章：<a href="https://cecilia.cool/2022/08/07/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/">行为型-模板方法</a>。</p>

        <h1 id="ConditionObject内部类"   >
          <a href="#ConditionObject内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#ConditionObject内部类" class="headerlink" title="ConditionObject内部类"></a>ConditionObject内部类</h1>
      <p><code>ConditionObject</code>实现了<code>Condition</code>接口，该接口在<code>j.u.c.lock</code>包下，先来看一下源码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待，当前线程在接到信号或被中断之前一直处于等待状态</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待，当前线程在接到信号之前一直处于等待状态，不响应中断</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态 </span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。此方法在行为上等效于: awaitNanos(unit.toNanos(time)) &gt; 0</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待，当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 唤醒一个等待线程。如果所有的线程都在等待此条件，则选择其中的一个唤醒。在从 await 返回之前，该线程必须重新获取锁。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 唤醒所有等待线程。如果所有的线程都在等待此条件，则唤醒所有线程。在从 await 返回之前，每个线程都必须重新获取锁。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>很明显，<code>Condition</code>定义了条件操作的规范。由于<code>ConditionObject</code>源码比较长，这里建议自己去看一下源码，之后会结合流程图讲解几个重要的方法。</p>

        <h2 id="唤醒函数"   >
          <a href="#唤醒函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#唤醒函数" class="headerlink" title="唤醒函数"></a>唤醒函数</h2>
      <p>主要是<code>signal</code>和<code>signalAll</code>，先看源码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively()) <span class="comment">// 只有获取锁，才能调用signal线程</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;<span class="comment">// 拿到等待队列的头节点</span></span><br><span class="line">    <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">        doSignal(first);<span class="comment">// 唤醒头节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)<span class="comment">// 等待队列头节点向下移动</span></span><br><span class="line">            lastWaiter = <span class="literal">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>; <span class="comment">// 需要唤醒的节点移出等待队列</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时node已经移出等待队列了</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里如果node的状态是CANCELLED，就会失败，node也就自然而然从队列中删除，等待GC</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 修改成功，加入同步队列，返回node的前驱节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ws &gt; 0 是CANCELLED</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>对应的流程图如下</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s3.bmp.ovh/imgs/2022/08/16/57b0196e8d0c797b.png" alt="image-20220816124802107"></p>
<p><code>signalAll</code>是差不多的，在<code>doSignalAll</code>只不过是不断循环从而唤醒等待队列中的所有函数</p>

        <h2 id="等待函数"   >
          <a href="#等待函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#等待函数" class="headerlink" title="等待函数"></a>等待函数</h2>
      <p><code>AQS</code>维护一个单链表队列，该队列为等待队列（也叫条件队列），当线程调用<code>await</code>时，就会进入等待队列。从<code>Condition</code>接口中可以看出，大部分函数都是和<code>await</code>有关，先看一下最简单的<code>await</code>。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter(); <span class="comment">// 将当前线程封装为node，加入Condition队列，此时node状态为CODITION</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//彻底释放已经被当前线程占用的同步资源，会唤醒后继节点，返回原本占有的同步资源数量  </span></span><br><span class="line">    <span class="comment">//如果线程没有锁资源，抛出异常并且node节点状态为CANCELLED</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 如果该节点还不存在与同步等待队列中，就阻塞掉自己  </span></span><br><span class="line">  	 <span class="comment">// 这里这样判断的原因是因为signal方法会将条件等待队列中的相应节点转移到同步队列中。</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);<span class="comment">// 完成进入等待队列吗，锁资源释放。</span></span><br><span class="line">        <span class="comment">// 如果被外界interrupt，就会返回-1或1，会中断标记清空</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// acquireQueued方法只会在成功获取到同步资源之后才会返回，返回就表明成功获取到同步资源，</span></span><br><span class="line">    <span class="comment">// 并且返回值为true表明在尝试获取同步资源的过程中发生了中断，需要恢复中断</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据interruptMode是否重新中断</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>看流程图</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s3.bmp.ovh/imgs/2022/08/16/dea46e6cb133ee9d.png" alt="image-20220816141909290"></p>
<p>关于恢复中断的机制，<code>park</code>方法被唤醒之后，发现被中断过(<code>interruptMode</code>将不为0)则跳出循环 。如果被中断过，这里也会根据情况返回处理中断异常的方式：</p>
<ul>
<li>如果仅仅发生了中断没有发送signal，或者中断发生在signal之前，则返回THROW_IE, </li>
<li>如果中断与signal同时发生或者发生在signal之后，则返回REINTERRUPT </li>
<li>如果没有中断发生，说明不是被中断唤醒，那么继续判断while条件，是否已经存在于同步等待队列，如果不在同步等待队列则继续阻塞</li>
</ul>

        <h1 id="参考文章"   >
          <a href="#参考文章" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/txmfz/p/14755920.html" >https://www.cnblogs.com/txmfz/p/14755920.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/08/07/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/">行为型-模板方法</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-08-07</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-08-07</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h1>
      <p>一个抽象类公开定义了执行它的方法的方式&#x2F;模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。</p>
<p>关键代码框架在抽象类中实现，其他步骤在子类实现。模板方法需要加上<code>final</code>防止被重写。要注意的是，子类要重写的不是模板方法，而是子类需要重写的方法。抽象类可以通过模板方法来规定一整套行为流程，但是流程中各个行为可以由子类自己实现。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">startPlay</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">endPlay</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//模板</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//初始化游戏</span></span><br><span class="line">      initialize();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//开始游戏</span></span><br><span class="line">      startPlay();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//结束游戏</span></span><br><span class="line">      endPlay();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize,startPlay,endPlay方法可以由子类重写</span></span><br></pre></td></tr></table></div></figure>




        <h1 id="意图"   >
          <a href="#意图" class="heading-link"><i class="fas fa-link"></i></a><a href="#意图" class="headerlink" title="意图"></a>意图</h1>
      <p>模板方法可以定义算法框架，将一些步骤的实现延迟到子类，通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。</p>

        <h1 id="举例"   >
          <a href="#举例" class="heading-link"><i class="fas fa-link"></i></a><a href="#举例" class="headerlink" title="举例"></a>举例</h1>
      <p>泡茶和泡咖啡都有类似的流程（烧水，倒入杯中），但是某些步骤会有点不一样（加调料，brew–酝酿？），要求复用那些相同步骤的代码。</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s3.bmp.ovh/imgs/2022/08/07/20a244dbdd6e5c6a.png" alt="image-20220807222733874"></p>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p>菜鸟教程：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/template-pattern.html" >https://www.runoob.com/design-pattern/template-pattern.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>
<p>Java全栈知识体系：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/dev-spec/pattern/17_template.html" >https://pdai.tech/md/dev-spec/pattern/17_template.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/08/07/Java/%E5%B9%B6%E5%8F%91/JUC_locks2-AQS%E4%B8%8A/">J.U.C.locks(2)--AQS上</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-08-07</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-08-15</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h1>
      <p>在<code>locks</code>包下有一个类是<code>AbstractQueuedSynchronizer</code>，其简写就是<code>AQS</code>，<code>AQS</code>是一个用来构建锁和同步器的框架，使用<code>AQS</code>能简单且高效地构造出应用广泛的大量的同步器。</p>
<p><code>AQS</code>是一个提供给用户自定义同步器的简单框架。其内部严格使用先进先出的阻塞队列，并且构造出来的同步器依赖于一个<code>int</code>类型的<code>state</code>来判断是否有线程占用锁。<code>AQS</code>提供独占模式（<code>exclusive</code>）和共享模式（<code>shared</code>），用户自定义的同步器一般支持一种模式，当然有些同步器两种也支持。</p>
<p><code>AQS</code>核心思想是，如果被请求的共享资源<strong>空闲</strong>，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态；如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的<strong>机制</strong>，这个机制<code>AQS</code>是用<strong>CLH队列锁</strong>实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<p>想要借助<code>AQS</code>实现自定义的同步器，需要继承<code>AQS</code>类，在注释中，<code>AQS</code>说明子类应该是一个内部类。</p>
<blockquote>
<p>Subclasses should be defined as non-public internal helperclasses that are used to implement the synchr onization properties of their enclosing class.</p>
</blockquote>
<p>继承<code>AQS</code>后，需要重写几个必要的方法，实际上，子类也只能重写这几个方法，因为其他方法都被<code>final</code>修饰。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前两个是独占模式需要重写的方法    </span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后两个是共享模式需要重写的方法</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否同步只与当前线程保持一致</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="实现自定义同步器"   >
          <a href="#实现自定义同步器" class="heading-link"><i class="fas fa-link"></i></a><a href="#实现自定义同步器" class="headerlink" title="实现自定义同步器"></a>实现自定义同步器</h1>
      <p>继承<code>AQS</code>的子类应该是非公有的内部类，实现的同步器依赖<code>int state</code>值判断当前锁是否被占用，这个<code>state</code>值代表的含义由用户自己来决定，我们这里用0表示没有线程占用锁，1表示有1个线程占用锁，x+1表示某个线程第x次重入这把锁。此次自定义同步器仅支持独占模式。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Syn syn;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.syn = <span class="keyword">new</span> <span class="title class_">Syn</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Syn</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquire)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState(); <span class="comment">// 获取当前state状态</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定义state状态，o--没有资源，1--有一个线程获得资源</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, arg)) &#123;<span class="comment">// 必须死用CAS，如果在CAS之前有其他线程拿到了，那么就直接返回false</span></span><br><span class="line">                    setExclusiveOwnerThread(t);<span class="comment">// 线程获取锁资源，将该线程设为独占线程</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t == getExclusiveOwnerThread()) &#123; <span class="comment">// 重入</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">nextC</span> <span class="operator">=</span> acquire + c; </span><br><span class="line">                setState(nextC);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//该线程不是当前锁的独占线程，无法获得锁</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="keyword">if</span> (t != getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - arg;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 如果存在锁重入，也就是state&gt;1，那么锁其实并没有release</span></span><br><span class="line">                free = <span class="literal">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showLockThread</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;当前独占锁资源的Thread: &quot;</span> + getExclusiveOwnerThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;syn.acquire(<span class="number">1</span>);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;syn.release(<span class="number">1</span>);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showLockThread</span><span class="params">()</span> &#123;syn.showLockThread();&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这样，我们的自定义同步器就实现了，现在使用一下</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyLock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t1 start---&quot;</span>);</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    System.out.println(<span class="string">&quot;t1 get lock---&quot;</span>);</span><br><span class="line">                    sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                    System.out.println(<span class="string">&quot;t1 unlock&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t2&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t2 start---&quot;</span>);</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    System.out.println(<span class="string">&quot;t2 get lock---&quot;</span>);</span><br><span class="line">                    sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                    System.out.println(<span class="string">&quot;t2 unlock&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        lock.showLockThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">t1 start---</span></span><br><span class="line"><span class="comment">t2 start---</span></span><br><span class="line"><span class="comment">t1 get lock---</span></span><br><span class="line"><span class="comment">当前独占锁资源的Thread: t1</span></span><br><span class="line"><span class="comment">t1 unlock</span></span><br><span class="line"><span class="comment">t2 get lock---</span></span><br><span class="line"><span class="comment">t2 unlock</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>




        <h1 id="AQS属性"   >
          <a href="#AQS属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#AQS属性" class="headerlink" title="AQS属性"></a>AQS属性</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;   </span><br><span class="line">    <span class="comment">// part1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7373984972572414691L</span>;    </span><br><span class="line">    <span class="comment">// 头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;    </span><br><span class="line">    <span class="comment">// 尾结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;    </span><br><span class="line">    <span class="comment">// 状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;    </span><br><span class="line">    <span class="comment">// 自旋时间</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">spinForTimeoutThreshold</span> <span class="operator">=</span> <span class="number">1000L</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// part2</span></span><br><span class="line">    <span class="comment">// Unsafe类实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line">    <span class="comment">// state内存偏移地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> stateOffset;</span><br><span class="line">    <span class="comment">// head内存偏移地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> headOffset;</span><br><span class="line">    <span class="comment">// state内存偏移地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> tailOffset;</span><br><span class="line">    <span class="comment">// tail内存偏移地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> waitStatusOffset;</span><br><span class="line">    <span class="comment">// next内存偏移地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> nextOffset;</span><br><span class="line">    <span class="comment">// 静态初始化块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stateOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;state&quot;</span>));</span><br><span class="line">            headOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;head&quot;</span>));</span><br><span class="line">            tailOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;tail&quot;</span>));</span><br><span class="line">            waitStatusOffset = unsafe.objectFieldOffset</span><br><span class="line">                (Node.class.getDeclaredField(<span class="string">&quot;waitStatus&quot;</span>));</span><br><span class="line">            nextOffset = unsafe.objectFieldOffset</span><br><span class="line">                (Node.class.getDeclaredField(<span class="string">&quot;next&quot;</span>));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><code>part1</code>部分，内部要维护一个<code>FIFO</code>的队列，该队列其实是一个双向链表，所以<code>AQS</code>内部存在<code>head,tail</code>两个<code>Node</code>节点。<code>Node</code>是<code>AQS</code>的内部类，<code>AQS</code>将一个线程封装为<code>Node</code>放入队列中。</p>
<p>然后就是<code>state</code>，<code>AQS</code>提供了三个方法供用户使用，<code>getState(),setState(int),compareAndSetState(int)</code>。</p>
<p><code>part2</code>部分，因为<code>AQS</code>中有很多<code>CAS</code>操作，所以必须要提前拿到各个字段在其类中的地址偏移量。</p>

        <h1 id="Node内部类"   >
          <a href="#Node内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#Node内部类" class="headerlink" title="Node内部类"></a>Node内部类</h1>
      <p>先给源码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 模式，分为共享与独占</span></span><br><span class="line">    <span class="comment">// 共享模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="comment">// 静态变量，在独占模式中，t线程拿到锁资源，EXCLUSIVE = t</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;        </span><br><span class="line">    <span class="comment">// 结点状态</span></span><br><span class="line">    <span class="comment">// CANCELLED，值为1，表示当前的线程被取消</span></span><br><span class="line">    <span class="comment">// SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark</span></span><br><span class="line">    <span class="comment">// CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中</span></span><br><span class="line">    <span class="comment">// PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行</span></span><br><span class="line">    <span class="comment">// 值为0，表示当前节点在sync队列中，等待着获取锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;        </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结点状态</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;        </span><br><span class="line">    <span class="comment">// 前驱结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;    </span><br><span class="line">    <span class="comment">// 后继结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;        </span><br><span class="line">    <span class="comment">// 结点所对应的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;        </span><br><span class="line">    <span class="comment">// 下一个等待者</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结点是否在共享模式下等待</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">nextWaiter</span> <span class="operator">=</span>= SHARED;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取前驱结点，若前驱结点为空，抛出异常</span></span><br><span class="line">    <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">        <span class="comment">// 保存前驱结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev; </span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>) <span class="comment">// 前驱结点为空，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 前驱结点不为空，返回</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    Node(Thread thread, Node mode) &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    Node(Thread thread, <span class="type">int</span> waitStatus) &#123;</span><br><span class="line">        <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>重点看<code>Node</code>的属性，关于<code>Node</code>中常量的含义，可以参考 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/trayvonnn/article/details/109285862" >AQS中Node状态</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p>
<p>先讲一下双向链表的出入队机制，一开始，<code>AQS</code>的<code>head,tail</code>都是<code>null</code>，当加入第一个节点时（<code>addWaiter</code>方法），会检查<code>tail==null</code>，如果是<code>null</code>，就说明队列为空，就会初始化队列，让<code>head,tail</code>指向<code>new Node</code>，此时头节点和尾节点指向同一个，没有实际意义的节点。然后再把要加入的节点加入到<code>head</code>后面，接着<code>tail</code>指向新加入的节点（<code>enq</code>方法实现）。</p>
<p>我们看一下两个方法的源代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暂时不用管mode，addWaiter是将当前线程加入同步队列</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);<span class="comment">// 队列没有初始化或者CAS失败，进入enq方法</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">// 无限循环，直到节点通过CAS加入到队列中</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// 初始化队列</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>关于<code>Node</code>的状态，也就是<code>waitStatus</code>，之后会详细讲到。</p>

        <h1 id="同步队列详解"   >
          <a href="#同步队列详解" class="heading-link"><i class="fas fa-link"></i></a><a href="#同步队列详解" class="headerlink" title="同步队列详解"></a>同步队列详解</h1>
      <p>在并发环境中，一个线程如果尝试获得锁资源失败后，会进入阻塞状态，同时进入阻塞队列。尽管不同的同步器对队列中的线程调度不同，可能是为了避免饥饿使用<code>FIFO</code>，也可能为了提高吞吐量使用其他调度，比如优先级之类的。但是其他的并发流程大致是一样的，比如阻塞后进入同步队列，调用了<code>wait,await</code>之类的函数会进入等待队列。该部分会讲解<code>AQS</code>如何维护同步队列（阻塞队列）。</p>

        <h2 id="acquire函数"   >
          <a href="#acquire函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#acquire函数" class="headerlink" title="acquire函数"></a>acquire函数</h2>
      <p><code>AQS</code>中队列是双向链表，一个线程只有在通过<code>acquire(int arg)</code>获取资源失败后，才会被包装成<code>Node</code>加入队列中，该队列是<code>FIFO</code>的。所以我们先看一下<code>acquire(int arg)</code>源码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><code>acquire</code>会先尝试获取资源，也就是<code>tryAcquire</code>，而这个正是我们需要重写的方法，以上面的自定义同步器重写的<code>tryAcquire</code>为例</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquire)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">       <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">       <span class="keyword">if</span>(c == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span>(compareAndSetState(c,acquire)) &#123;</span><br><span class="line">               setExclusiveOwnerThread();<span class="comment">// 在同步器中设置独占线程</span></span><br><span class="line">           	<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// 此时已经拿到锁资源了</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t == getExclusiveOwnerThread()) &#123;</span><br><span class="line">           setState(acquire+c);<span class="comment">// 此处是锁重入，不必担心并发问题，因为锁资源在当前线程手中。</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// CAS操作失败（有其他线程更快拿到锁）</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>

<p>尝试获取资源失败后，<code>AQS</code>就会将该线程加入同步队列中——<code>addWaiter(Node.EXCLUSIVE),arg)</code>。</p>
<p>我们之前看源码，发现<code>addWaiter</code>传入的参数其实并不是当前线程封装的<code>Node</code>，参数名是<code>mode</code>，我们看一下官方注解</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;...&#125;</span><br></pre></td></tr></table></div></figure>

<p>而我们在<code>acquire</code>中传入的是<code>Node.EXCLUSIVE</code>，就表示当前节点是独占模式的节点。为什么要这么区分呢？因为有些自定义同步器既可以独占模式，又可以共享模式，而<code>AQS</code>只会维护一个同步队列，那么两种模式下的节点都会在同一个节点中，所以需要区分。</p>
<p>当节点加入到队列中后，<code>AQS</code>让该线程再做一次尝试获取锁资源。但是这种尝试是有条件的，因为<code>AQS</code>是严格的<code>FIFO</code>，所以只有当该线程在同步队列中前一个节点是头节点才允许再次尝试获取资源（头节点<code>head</code>指向一个没有任何意义的节点）。只有这样，才能是公平的。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();<span class="comment">// node的前一个节点，其实就是node.prev</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">// 如果node前一个节点是head并且再次尝试获取资源成功</span></span><br><span class="line">                setHead(node);<span class="comment">// 那么node就不应该在同步队列中了，设置node为head</span></span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted; <span class="comment">// 返回false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>如果不看<code>shouldParkAfterFailedAcquire(p,node)</code>这一部分的语句，该方法就会陷入死循环，糟糕的是，即使第二个<code>if</code>语句将<code>interrupted = true</code>，但是只要第一个<code>if</code>语句不满足，就会一直死循环。</p>
<p>其实这正是设计的高明之处，我们猜测这部分语句可能存在<code>park</code>语句，让线程停下来。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    parkAndCheckInterrupt())</span><br><span class="line">    interrupted = <span class="literal">true</span>;</span><br></pre></td></tr></table></div></figure>

<p>然后当独占线程通过<code>release</code>方法释放了锁资源，同时<code>release</code>通过同步队列中<code>head</code>下一个节点取得该节点的线程<code>t</code>，然后通过<code>LockSupport.unpark(t)</code>来恢复<code>t</code>的运行，此时<code>t</code>还是在死循环中，但是下一次循环，他就会再次尝试获取锁资源。</p>
<p>并不是大家想像的那种有个线程一直在那里死循环浪费CPU资源，而是通过<code>park</code>直接让他阻塞。</p>
<p>**上述只是我的猜测，下面一起来看源码 **。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入的前一个节点，当前节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// pred节点的状态为SIGNAL，SIGNAL表示该节点的后继节点(即将)被阻塞(通过park)</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 状态为CANCELLED，需要从队列中删除</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 为PROPAGATE -3 或者是0 表示无状态,(为CONDITION -2时，表示此节点在condition queue中) </span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不能进行park操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一开始，head的waitStatus是0，如果pred是head，首先会在tryAcquire返回false</span></span><br><span class="line"><span class="comment">// 然后就会检查是否需要park，在head.waitStatus==0的情况下，head的waitStatus</span></span><br><span class="line"><span class="comment">// 会被设置为SIGNAL，之后再acquireQueued里面循环一次，最后node的线程park</span></span><br></pre></td></tr></table></div></figure>

<p>只有当该节点的前驱结点的状态为<code>SIGNAL</code>时，才可以对该结点所封装的线程进行<code>park</code>操作。否则，将不能进行<code>park</code>操作。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进行park操作并且返回该线程是否被中断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 在许可可用之前禁用当前线程，并且设置了blocker</span></span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted(); <span class="comment">// 当前线程是否已被中断，并清除中断标记位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><code>parkAndCheckInterrupt</code>方法里的逻辑是首先执行<code>park</code>操作，即禁用当前线程，然后返回该线程是否已经被中断。</p>
<p>最后看一下<code>final</code>里面的<code>cancelAcuqire</code>方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取消继续获取(资源)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cancelAcquire</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)<span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置node结点的thread为空</span></span><br><span class="line">    node.thread = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到node前驱结点中第一个状态小于0的结点，即不为CANCELLED状态的结点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>) </span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取pred结点的下一个结点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">predNext</span> <span class="operator">=</span> pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置node结点的状态为CANCELLED</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123; <span class="comment">// node结点为尾结点，则设置尾结点为pred结点</span></span><br><span class="line">        <span class="comment">// 比较并设置pred结点的next节点为null</span></span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="literal">null</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// node结点不为尾结点，或者比较设置不成功</span></span><br><span class="line">        <span class="type">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">                (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="literal">null</span>) &#123; <span class="comment">// (pred结点不为头节点，并且pred结点的状态为SIGNAL)或者 </span></span><br><span class="line">                                <span class="comment">// pred结点状态小于等于0，并且比较并设置等待状态为SIGNAL成功，并且pred结点所封装的线程不为空</span></span><br><span class="line">            <span class="comment">// 保存结点的后继</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>) <span class="comment">// 后继不为空并且后继的状态小于等于0</span></span><br><span class="line">                compareAndSetNext(pred, predNext, next); <span class="comment">// 比较并设置pred.next = next;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node); <span class="comment">// 释放node的前一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>现在，再来看<code>acquireQueued</code>方法的整个的逻辑。逻辑如下:</p>
<ul>
<li>判断结点的前驱是否为<code>head</code>并且是否成功获取(资源)。</li>
<li>若步骤1均满足，则设置结点为<code>head</code>，之后会判断是否<code>finally</code>模块，然后返回。</li>
<li>若步骤2不满足，则判断是否需要<code>park</code>当前线程，是否需要<code>park</code>当前线程的逻辑是判断结点的前驱结点的状态是否为<code>SIGNAL</code>，若是，则<code>park</code>当前结点，否则，不进行<code>park</code>操作。</li>
<li>若<code>park</code>了当前线程，之后某个线程对本线程<code>unpark</code>后，并且本线程也获得机会运行。那么，将会继续进行步骤①的判断。</li>
</ul>
<p>最后的<code>cancelAcquire</code>和<code>unparkSuccessor</code>只需要记住，是将<code>node</code>设为<code>CANCELLED</code>，执行后面的函数，会释放<code>node</code>的后继节点。</p>
<p>阅读这些源码是有必要的，最后给一个流程图</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s3.bmp.ovh/imgs/2022/08/11/d9bf2b419b32da5b.jpg" alt="ACQ--acquire执行流程"></p>

        <h2 id="release函数"   >
          <a href="#release函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#release函数" class="headerlink" title="release函数"></a>release函数</h2>
      <p>以独占模式释放对象，先看源码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123; <span class="comment">// 释放成功</span></span><br><span class="line">        <span class="comment">// 保存头节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; </span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>) <span class="comment">// 头节点不为空并且头节点状态不为0</span></span><br><span class="line">            unparkSuccessor(h); <span class="comment">//释放头节点的后继结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><code>tryRelease</code>需要我们手动重写，在上面自定义同步器的例子中，<code>release</code>在锁重入时会返回<code>false</code>。如果<code>tryRelease</code>成功，那么如果头节点不为空并且头节点的状态不为0，则释放头节点的后继节点。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放后继结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取node结点的等待状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 状态值小于0，为SIGNAL -1 或 CONDITION -2 或 PROPAGATE -3</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="comment">// 比较并且设置结点等待状态，设置为0</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取node节点的下一个结点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="comment">// 下一个结点为空或者下一个节点的等待状态大于0，即为CANCELLED</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">// s赋值为空</span></span><br><span class="line">        s = <span class="literal">null</span>; </span><br><span class="line">        <span class="comment">// 从尾结点开始从后往前开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="comment">// 找到等待状态小于等于0的结点，找到最前的状态小于等于0的结点</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) </span><br><span class="line">                <span class="comment">// 保存结点</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>) <span class="comment">// 该结点不为为空，释放许可</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>详细流程看下图</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s3.bmp.ovh/imgs/2022/08/11/3b5873dbcddf51d0.jpg" alt="unparkSuccessor流程"></p>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p>AQS 中 acquire(int) 方法调用 selfInterrupt 的理解：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://ld246.com/article/1618976505586" >https://ld246.com/article/1618976505586</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>Java全栈知识体系：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html#%E7%B1%BB%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95---acquire%E6%96%B9%E6%B3%95" >https://pdai.tech/md/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html#%E7%B1%BB%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95---acquire%E6%96%B9%E6%B3%95</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>ASQ中cancelAcquire何时会运行：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/ziya_anan/article/details/122009215" >https://blog.csdn.net/ziya_anan/article/details/122009215</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/08/06/Shell/gawk%E7%A8%8B%E5%BA%8F%E8%BF%9B%E9%98%B6/">gawk程序进阶</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-08-06</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-08-06</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h1>
      <p>关于<code>gawk</code>进阶，你可以参考这篇博客，很详细，但是请一定要看本文的<strong>结束语</strong></p>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/lilongsy/article/details/77095103?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165977810116782246412467%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165977810116782246412467&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_34-1-77095103-null-null.142%5Ev39%5Epc_rank_34,185%5Ev2%5Econtrol&utm_term=gawk%20%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%89%93%E5%8D%B0&spm=1018.2226.3001.4187" >gawk进阶</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p>
</blockquote>

        <h1 id="内建变量"   >
          <a href="#内建变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h1>
      <p><code>gawk</code>程序使用内建变量来引用程序的数据里的一些特殊功能。</p>

        <h2 id="字段和记录分隔符的变量"   >
          <a href="#字段和记录分隔符的变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#字段和记录分隔符的变量" class="headerlink" title="字段和记录分隔符的变量"></a>字段和记录分隔符的变量</h2>
      <p>类似于<code>$1,$2</code>是数据字段变量，其根据字段分隔符来划定，默认情况下，字段分隔符是空白字符(空格或制表符)。可以使用内建变量<code>FS</code>更改字段分隔符（<code>shell</code>脚本里面用的是<code>IFS</code>）</p>
<figure class="highlight txt"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FIELDWIDTHS--由空格分隔的一列数字，定义了每个数据字段确切宽度</span><br><span class="line">FS--输入字段之间分隔符</span><br><span class="line">OFS--输出字段之间分隔符</span><br><span class="line">RS--输入记录分隔符</span><br><span class="line">ORS--输出记录分隔符</span><br></pre></td></tr></table></div></figure>

<p>默认情况下，<code>OFS</code>是空格，所以<code>print $1,$2,$3 --&gt; field1 field2 field3</code>。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ gawk &#x27;BEGIN&#123;OFS=&quot;-&quot;&#125; &#123;print $1,$2,$3&#125;&#x27; data</span><br><span class="line">dog-monkey-cat</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat data</span><br><span class="line">dog monkey cat mouse</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在<span class="built_in">print</span>中，使用,隔开每个变量,同时FS=<span class="string">&quot;,&quot;</span>要使用双引号</span></span><br></pre></td></tr></table></div></figure>

<p>设置<code>FIELDWIDTHS</code>时，该变量允许你不依靠字段分隔符来读取记录，一旦设置，<code>gawk</code>就会忽略<code>FS</code>，并根据提供的字段宽度来计算字段。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gawk &#x27;BEGIN&#123;FIELDWIDTHS=&quot;3 5 2 5&quot;&#125;&#123;print $1,$2,$3,$4&#125;&#x27; data</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">那么字段<span class="variable">$1</span>长度为3,<span class="variable">$2</span>长度为5...</span></span><br></pre></td></tr></table></div></figure>

<p>变量<code>RS</code>和<code>ORS</code>定义了<code>gawk</code>程序如何处理数据流中的记录，默认下，都为换行符，默认的<code>RS</code>值表明，<br>输入数据流中的每行新文本就是一条新纪录。</p>
<p>你如果不是很清楚，可以参照这篇文章：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/yiifaa/article/details/78827080?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165977370516781685382438%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165977370516781685382438&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-78827080-null-null.142%5Ev39%5Epc_rank_34,185%5Ev2%5Econtrol&utm_term=gawk%20RS&spm=1018.2226.3001.4187" >RS、FS与ORS、OFS等内置变量的用法</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p>

        <h2 id="数据变量"   >
          <a href="#数据变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据变量" class="headerlink" title="数据变量"></a>数据变量</h2>
      <p><code>gawk</code>还提供了一些内建变量帮助你了解数据发生了什么变化，并提取<code>shell</code>环境的变化，太多了，挑几个写。</p>
<p><code>ARGC</code>和<code>ARGV</code>变量允许从<code>shell</code>中获取命令行参数的<strong>总数</strong>以及它们的值，<code>gawk</code>并不会将程序脚本当成命令行参数的一部分。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ gawk &#x27;BEGIN&#123;print ARGC,ARGV[1]&#125;&#x27; data</span><br><span class="line">2 data</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ARGC表示参数为两个，包括gawk命令和data参数(程序脚本不是参数！)</span></span><br></pre></td></tr></table></div></figure>

<p><code>ENVIRON</code>–使用关联数组来提取<code>shell</code>环境变量，该数组用文本作为数组的引索值，而不是数值。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ gawk &#x27;BEGIN&#123;print ENVIRON[&quot;HOME&quot;],ENVIRON[&quot;PATH&quot;]&#125;&#x27;</span><br><span class="line">/home/cyan /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br></pre></td></tr></table></div></figure>




        <h1 id="自定义变量"   >
          <a href="#自定义变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h1>
      <p><code>gawk</code>自定义变量不能以数字开头，直接赋值即可，不需要使用<code>$</code>，同时，<code>gawk</code>包含了标准算数操作符<code>(*,^,**,%...)</code>。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ gawk &#x27;BEGIN&#123;x=4; x= x ** 3 + 1; print x&#125;&#x27;</span><br><span class="line">65</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ gawk &#x27;BEGIN&#123;x=4; x= x ^ 3 + 1; print x&#125;&#x27;</span><br><span class="line">65</span><br></pre></td></tr></table></div></figure>


        <h1 id="数组"   >
          <a href="#数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#数组" class="headerlink" title="数组"></a>数组</h1>
      <p><code>gawk</code>使用关联数组提供数组功能，不同之处在于，其引索值可以是任意文本字符串，每个引索字符串都必须能够唯一标识出赋给他的数据元素。每个数组名自定义，数据引索值自定义！</p>
<p>基本定义格式：<code>arr[index_1]=val_1</code>。</p>
<figure class="highlight txt"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.遍历数组变量：</span><br><span class="line">    for(var in array)</span><br><span class="line">    &#123;</span><br><span class="line">        statements</span><br><span class="line">    &#125;</span><br><span class="line">2.删除数组变量：</span><br><span class="line">    delete array[index]</span><br></pre></td></tr></table></div></figure>




        <h1 id="使用模式"   >
          <a href="#使用模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用模式" class="headerlink" title="使用模式"></a>使用模式</h1>
      <p><code>gawk</code>支持多种类型的匹配模式来过滤数据，与<code>sed</code>大同小异，<code>BEGIN</code>和<code>END</code>关键字用在读取数据流之前&#x2F;后执行命令的特殊模式，也存在其他特殊模式，用于在<strong>匹配</strong>数据流时执行一些命令。</p>

        <h2 id="正则表达式"   >
          <a href="#正则表达式" class="heading-link"><i class="fas fa-link"></i></a><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2>
      <p>正则表达式必须出现在要控制的程序脚本的左花括号之前。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gawk &#x27;BEGIN&#123;FS=&quot;,&quot;&#125; /11/&#123;print $1&#125;&#x27; data</span><br></pre></td></tr></table></div></figure>




        <h2 id="匹配操作符-matching-operator"   >
          <a href="#匹配操作符-matching-operator" class="heading-link"><i class="fas fa-link"></i></a><a href="#匹配操作符-matching-operator" class="headerlink" title="匹配操作符(matching operator)"></a>匹配操作符(matching operator)</h2>
      <p>匹配操作符是波浪线<code>~</code>，允许将正则表达式限定在记录中的特定数据字段。</p>
<p>正则表达式有一定局限性，因为我们现在处理的数据，从行记录数据细化到了某个字段的数据（通过<code>FS</code>字段分隔符细化），所以，比如我想匹配每行中，第五个字段中是否有<code>cat</code>这个单词，单使用正则表达式是做不到的。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">5 ~ /cat/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$5</span>表示行记录数据中第五个字段，该表达式会过滤出第五个字段包含<span class="built_in">cat</span>的所有记录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这是一个强大的功具--用于在数据文件中搜索特定的数据元素</span></span><br></pre></td></tr></table></div></figure>

<p>它还可以和<code>!</code>一起使用，用于排除，没错，和<code>sed</code>一样的功能</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 !~ /expression/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果匹配失败就会执行指令</span></span><br></pre></td></tr></table></div></figure>




        <h2 id="数学表达式"   >
          <a href="#数学表达式" class="heading-link"><i class="fas fa-link"></i></a><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h2>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gawk -F: &#x27;$4 == 0&#123;print $1&#125;&#x27; /etc/passwd</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">该脚本查看第四个数据字段含有0的值(组ID=0--root用户组)</span></span><br></pre></td></tr></table></div></figure>

<p>常见的比较：<code>&gt;= , &lt;= , == ...</code>，也可以对文本数据使用表达式：<code>gawk &#39;$1 == &quot;data&quot;&#123;print $2&#125;&#39; data</code>。</p>

        <h1 id="结构化语句"   >
          <a href="#结构化语句" class="heading-link"><i class="fas fa-link"></i></a><a href="#结构化语句" class="headerlink" title="结构化语句"></a>结构化语句</h1>
      
        <h2 id="if语句"   >
          <a href="#if语句" class="heading-link"><i class="fas fa-link"></i></a><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (condition)</span><br><span class="line">	statement1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者是：<span class="keyword">if</span> (condition) statement</span></span><br></pre></td></tr></table></div></figure>

<p>如果要在<code>if</code>语句中执行多条语句，要使用花括号，当然，<code>gawk</code>也支持<code>else</code>子句。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (condition)</span><br><span class="line">&#123;</span><br><span class="line">	statements</span><br><span class="line">&#125; else</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以在单行使用<span class="keyword">else</span>，只是需要加;  <span class="keyword">if</span> (condition) statements; <span class="keyword">else</span> statements</span></span><br></pre></td></tr></table></div></figure>




        <h2 id="while语句"   >
          <a href="#while语句" class="heading-link"><i class="fas fa-link"></i></a><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h2>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (condition)</span><br><span class="line">&#123;</span><br><span class="line">	statements</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash"><span class="keyword">while</span>中支持<span class="built_in">break</span>和<span class="built_in">continue</span>来跳出循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>还有<code>do-while</code>语句：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">	statements</span><br><span class="line">&#125;while (condition)</span><br></pre></td></tr></table></div></figure>




        <h2 id="for语句"   >
          <a href="#for语句" class="heading-link"><i class="fas fa-link"></i></a><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for( var assignment; condition; iteration process)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其实跟普通的<span class="keyword">for</span>循环没啥区别</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">大概就是这样</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="keyword">for</span>(i=1;i&lt;4;i++)</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&#123;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">    total += <span class="variable">$i</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&#125;</span></span><br></pre></td></tr></table></div></figure>

<p>最后还是举个例子</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat commands.awk</span><br><span class="line">&#123;</span><br><span class="line">        total=0</span><br><span class="line">        for(i=0; i&lt;3; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                print $1</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ gawk -f commands.awk data</span><br><span class="line">dog</span><br><span class="line">dog</span><br><span class="line">dog</span><br></pre></td></tr></table></div></figure>




        <h1 id="格式化打印"   >
          <a href="#格式化打印" class="heading-link"><i class="fas fa-link"></i></a><a href="#格式化打印" class="headerlink" title="格式化打印"></a>格式化打印</h1>
      <p>和<code>c</code>语言的<code>printf</code>差不多，通过格式化字符来控制。</p>
<figure class="highlight txt"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">d/i--都是表示整数</span><br><span class="line">f--浮点数</span><br><span class="line">e--科学计数法</span><br><span class="line">g--科学计数法表示，或浮点数</span><br><span class="line">o--八进制</span><br><span class="line">x--十六进制</span><br><span class="line">X--十六进制，字母大写</span><br><span class="line"></span><br><span class="line">printf &quot;The answer is:%e&quot;,val</span><br></pre></td></tr></table></div></figure>

<ul>
<li><p><code>width</code>–指定输出字段最小宽度的数字值，如果输出小于这个值，文本右对齐，并用空格填充，否则按实际宽度输出。</p>
</li>
<li><p><code>prec</code>–指定了浮点数中小数点后面的位数，或者文本字符串中显示的最大字符数。</p>
</li>
<li><p><code>-</code>(减号)：指明在向格式化空间中放入数据时采取左对齐而不是右对齐。</p>
</li>
</ul>
<p>通过一个例子来讲解，<strong>FS是一行数据中各个字段的分隔符，RS是行数据之间的分隔符</strong>。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数据文件</span></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat data</span><br><span class="line">Riley Mullen,(312)555-1234</span><br><span class="line">Frank Williams,(317)555-9876</span><br><span class="line">Haley Snell,(313)555-4938</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先试一下<span class="built_in">printf</span>打印</span></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ gawk &#x27;BEGIN&#123;FS=&quot;,&quot;;RS=&quot;\n&quot;&#125; &#123;printf &quot;%s %s\n&quot;,$1,$2&#125;&#x27; data</span><br><span class="line">Riley Mullen (312)555-1234</span><br><span class="line">Frank Williams (317)555-9876</span><br><span class="line">Haley Snell (313)555-4938</span><br></pre></td></tr></table></div></figure>

<p>我们希望打印结果对齐一点，但是默认的是右对齐</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ gawk &#x27;BEGIN&#123;FS=&quot;,&quot;;RS=&quot;\n&quot;&#125; &#123;printf &quot;%20s %s\n&quot;,$1,$2&#125;&#x27; data</span><br><span class="line">        Riley Mullen (312)555-1234</span><br><span class="line">      Frank Williams (317)555-9876</span><br><span class="line">         Haley Snell (313)555-4938</span><br></pre></td></tr></table></div></figure>

<p>所以要使用<code>-</code>，指定左对齐，完美。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ gawk &#x27;BEGIN&#123;FS=&quot;,&quot;;RS=&quot;\n&quot;&#125; &#123;printf &quot;%-20s %s\n&quot;,$1,$2&#125;&#x27; data</span><br><span class="line">Riley Mullen         (312)555-1234</span><br><span class="line">Frank Williams       (317)555-9876</span><br><span class="line">Haley Snell          (313)555-4938</span><br></pre></td></tr></table></div></figure>




        <h1 id="内建函数"   >
          <a href="#内建函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h1>
      
        <h2 id="数学函数"   >
          <a href="#数学函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2>
      <figure class="highlight txt"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">atan2(x,y)--x/y反正切，x和y是弧度</span><br><span class="line">cos(x),log(x),sin(x),sqrt(x),srand(x)为计算机随机数指定种子值</span><br><span class="line">rand()--产生0~1之间的随机小数(不含0,1)</span><br><span class="line">exp(x)--x的指数函数</span><br><span class="line">int(x)--取整</span><br><span class="line"></span><br><span class="line">除了一般的数学运算外，gawk还提供位运算：</span><br><span class="line">and(x,y),compl(x)--x的补运算</span><br><span class="line">lshift(x,count)--左移,rshift(x,count)--右移</span><br><span class="line">or(x,y),xor(x,y)</span><br></pre></td></tr></table></div></figure>




        <h2 id="字符串函数"   >
          <a href="#字符串函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2>
      <p>具体详细的，要使用时，自己去查</p>
<figure class="highlight txt"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">length([s])--长度</span><br><span class="line">index(s,t)</span><br></pre></td></tr></table></div></figure>




        <h2 id="时间函数"   >
          <a href="#时间函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h2>
      <ul>
<li><code>mktime(datespec)</code>按<code>YYYY-MM-DD-HH-MM-SS[DST]</code>格式指定的日期转换成时间戳值。</li>
<li><code>strftime(formate [,timestamp])</code>将当前时间的时间戳或<code>timestamp</code>转换为格式化日期(采用<code>shell</code>的<code>date()</code>)<br><code>systime()</code>返回当前时间的时间戳</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~$ gawk &#x27;&#123;</span><br><span class="line"> date=systime()</span><br><span class="line"> date=strftime(&quot;%A, %B %d, %Y&quot;,date)</span><br><span class="line"> print date</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></div></figure>




        <h1 id="自定义函数"   >
          <a href="#自定义函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h1>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function name([varuables]) #可以传参</span><br><span class="line">&#123;</span><br><span class="line">    statements</span><br><span class="line">    return value #可以使用return返回值</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在自定义函数时，必须出现在所有代码前(包括BEGIN代码块)，有助于将函数代码和gawk程序其他部分分开</span></span><br><span class="line">  gawk &#x27;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="keyword">function</span> fun()</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&#123;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">  <span class="built_in">printf</span> <span class="string">&quot;%-16s - %s\n&quot;</span>,<span class="variable">$1</span>,<span class="variable">$4</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&#125;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">BEGIN&#123;FS=<span class="string">&quot;\n&quot;</span>; RS=<span class="string">&quot;&quot;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&#123;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">  fun()</span>    </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&#125;<span class="string">&#x27; data</span></span></span><br></pre></td></tr></table></div></figure>




        <h1 id="创建函数库"   >
          <a href="#创建函数库" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建函数库" class="headerlink" title="创建函数库"></a>创建函数库</h1>
      <p>如果函数经常使用，可以将这些函数放在专门的函数库文件中，文件可以通过<code>-f</code>参数来使用。但是，<code>-f</code>命令行参数不能和内联<code>gawk</code>脚本放到一起使用，所以在同一行命令行需要使用多个<code>-f</code>参数(也就是，将<code>gawk</code>脚本程序也放到文件中)。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gawk -f funclib -f script data</span><br></pre></td></tr></table></div></figure>




        <h1 id="结束语"   >
          <a href="#结束语" class="heading-link"><i class="fas fa-link"></i></a><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1>
      <p>至此，暑假开的<code>shell</code>系列更新结束（2022.7.28–20228.6），<strong>所有文章大致参考《Linux命令行与shell脚本编程大全》，作者是[美]布鲁姆（Richard Blum），布雷斯纳汉（Christine Bresnahan）</strong>。为什么说大致呢？首先，这本书是我在大二寒假看完的，当时笔记做的不是很完善而且还有很多错误，所以这次博客更新，我并不只是单纯从之前的笔记粘贴复制。你们现在看到的，很多例子，都是我自己想的，问题的引入和思考花费了较多时间，但是绝对不能否认的是，这本书让我收获极大。</p>
<p>本文开始推荐的博客，其实就是《Linux命令行与shell脚本编程大全》的gawk进阶的原文（作者在文末也说了参考了此书），我并不喜欢照着书抄笔记，一个是我懒，另一个是这样我还不如让你直接买一本。</p>
<p>送君千里，终有一别。在CUI（不会到现在你还不知道什么是CUI吧？）学习的路上，我们都还差得远呢，剩下的，也是唯一需要记住的就是，保持学习，尊重原创。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/08/05/Shell/sed%E7%BC%96%E8%BE%91%E5%99%A8%E8%BF%9B%E9%98%B6/">sed编辑器进阶</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-08-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-08-06</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="多行命令"   >
          <a href="#多行命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#多行命令" class="headerlink" title="多行命令"></a>多行命令</h1>
      <p><code>n</code>命令–<code>next</code>，会将<code>sed</code>编辑器移动到数据流中的<strong>下一行</strong>文本，而不用重新回到命令的最开始执行</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/head/&#123;n;d&#125;&#x27; data</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当匹配到<span class="built_in">head</span>一行，sed会马上移动到下一行开头，执行d命令</span></span><br></pre></td></tr></table></div></figure>

<p><code>N</code>命令，将数据流中两个文本行合并到同一个<strong>模式空间</strong>中，两行文本仍以换行符相隔，但是会将两行文本当作一行处理。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat data</span><br><span class="line">cat</span><br><span class="line">cat</span><br><span class="line">cat</span><br><span class="line">end</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ sed &#x27;/cat/&#123;N;s/\n/ /&#125;&#x27; data</span><br><span class="line">cat cat</span><br><span class="line">cat end</span><br></pre></td></tr></table></div></figure>

<p> 但是这个命令存在局限，比如前四行，<code>sed</code>会将第1，2行看作整体，第3，4行看作整体，如果最后一行是第五行单行，<code>sed</code>不会检查第五行，直接结束。</p>
<p><code>N,d</code>两个命令配合可以实现多行删除，对于匹配到的，模式空间中两行都会删除，<code>D</code>就只会删除模式空间第一行，第二行被保留。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat data</span><br><span class="line">cat</span><br><span class="line">cat</span><br><span class="line">cat</span><br><span class="line">cat</span><br><span class="line">end</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ sed &quot;N;/[c,e]*/d&quot; data</span><br><span class="line">end</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">N和D的配合使用，可以删除行前的空白行</span></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat data</span><br><span class="line">cat</span><br><span class="line">dog</span><br><span class="line"></span><br><span class="line">mouse</span><br><span class="line">monkey</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ sed &quot;N;/ /D&quot; data</span><br><span class="line">cat</span><br><span class="line">dog</span><br><span class="line">mouse</span><br><span class="line">monkey</span><br></pre></td></tr></table></div></figure>



<p><code>N,P</code>命令可以实现多行打印，<code>P</code>命令只打印模式空间的第一行。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat data</span><br><span class="line">cat</span><br><span class="line">dog</span><br><span class="line"></span><br><span class="line">mouse</span><br><span class="line">monkey</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ sed -n &quot;4&#123;N;P&#125;&quot; data</span><br><span class="line">mouse</span><br></pre></td></tr></table></div></figure>

<p>关于<code>sed</code>中<code>p,P</code>命令的区别，可以参考这篇文章</p>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://www.136.la/shida/show-410559.html" >http://www.136.la/shida/show-410559.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>

        <h1 id="保持空间"   >
          <a href="#保持空间" class="heading-link"><i class="fas fa-link"></i></a><a href="#保持空间" class="headerlink" title="保持空间"></a>保持空间</h1>
      <p>模式空间是一块活跃的缓冲区，sed编辑器还有另一块称作<strong>保持空间</strong>的缓冲区。对于保持空间，存在5条命令，用来将文本从模式空间复制到保持空间。这可以清空模式空间来加载其他要处理的字符串。</p>
<figure class="highlight txt"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">h--将模式空间复制到保持空间</span><br><span class="line">H--将模式空间附加到保持空间</span><br><span class="line">g--将保持空间复制到模式空间</span><br><span class="line">G--将保持空间附加到模式空间</span><br><span class="line">x--交换两个空间的内容</span><br><span class="line"></span><br><span class="line">sed -n &#x27;/first/ &#123;h;p;n;p;g;p&#125;&#x27; data</span><br></pre></td></tr></table></div></figure>

<p>现在你不用太理解，只需要有这么个空间即可。</p>

        <h1 id="排除命令"   >
          <a href="#排除命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#排除命令" class="headerlink" title="排除命令"></a>排除命令</h1>
      <p>在<code>sed</code>基础那篇文章中，提到<code>!</code>可以代替<code>/</code></p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/cat/dog/&#x27; data</span><br><span class="line"></span><br><span class="line">sed &#x27;s!cat!dog!&#x27; data</span><br></pre></td></tr></table></div></figure>

<p>在<code>sed</code>中，使用感叹号<code>!</code>还可以排除命令，让原本会起作用的命令不起作用，比如在最后一行取消使用<code>N</code>命令</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;$!N;其他命令&#x27; data</span><br></pre></td></tr></table></div></figure>

<p>现在给出一个例子，通过这个例子，我们会用到模式空间，保持空间以及排除命令</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">逆序打印文本</span></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ echo -n &quot;first</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">second</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">third</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">&quot; &gt; data</span></span></span><br><span class="line"></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ sed -n &#x27;&#123;1!G;h;$p&#125;&#x27; data</span><br><span class="line">third</span><br><span class="line">second</span><br><span class="line">first</span><br></pre></td></tr></table></div></figure>

<p>上述命令，<code>G,h</code>是关于保持空间的命令，每次将数据读取到模式空间，保持空间中的数据都会附加到模式空间(第一行除外)，然后再复制到保持空间。当然，<code>Linux</code>命令<code>tac</code>可以直接逆序文本，其实<code>tac</code>就是<code>cat</code>反着写。</p>
<p>等一下，我好像还没讲过什么是模式空间：<code>sed</code>每次读一行，都会把这一行数据读到模式空间，在使用命令处理数据，在打印到标准输出。</p>
<p>关于逆序打印文本，具体我们可以看下图</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s3.bmp.ovh/imgs/2022/08/06/759084cf022ed038.png" alt="image-20220806111008122"></p>
<p>如果你真的理解了，那么你就知道，这个命令也可以实现逆序</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;&#123;1!G;$!h;$p&#125;&#x27; data</span><br></pre></td></tr></table></div></figure>




        <h1 id="分支"   >
          <a href="#分支" class="heading-link"><i class="fas fa-link"></i></a><a href="#分支" class="headerlink" title="分支"></a>分支</h1>
      <p>分支命令共有两条：分支（b）和替代分支（t）。</p>

        <h2 id="b命令"   >
          <a href="#b命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#b命令" class="headerlink" title="b命令"></a>b命令</h2>
      <p>基于地址，地址模式或地址区间<strong>排除</strong>整块命令：<code>[address]b [label]</code>。</p>
<p><code>address</code>决定哪些行触发分支命令。<code>label</code>参数定义了要跳转的位置，如果此处没有<code>label</code>参数，跳转命令会跳转到脚本结尾（注意，是命令脚本的结尾）。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;&#123;2,3b ; s/This is/Is this/ ;s/line./test?/&#125;&#x27; data</span><br></pre></td></tr></table></div></figure>

<p><code>sed</code>还可以使用标签，使用标签后，只会跳过部分命令，也就是标签之前的命令。直到这里你可能不是很懂，我要提醒的是，在<code>sed</code>中引入分支，我建议将命令放在<code>.sed</code>命令脚本中，这样使用起来才方便。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">假设我们需要都数据文件进行处理，一行数据中一旦出现<span class="built_in">cat</span>这个单词，我们就打印其所在行号</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">否则，就打印该行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">command.sed</span></span><br><span class="line"></span><br><span class="line">/cat/b error_print</span><br><span class="line">/**/b true_print</span><br><span class="line"></span><br><span class="line">: error_print</span><br><span class="line">=</span><br><span class="line">b # 跳到结尾，不然会执行true_print的语句</span><br><span class="line"></span><br><span class="line">: true_print</span><br><span class="line">p</span><br><span class="line">b</span><br></pre></td></tr></table></div></figure>

<p>更改一下<code>data</code>的内容，执行<code>sed</code>命令</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ echo -n &quot;dog</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">monkey</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">cat</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">mouse</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">&quot; &gt; data</span></span></span><br><span class="line"></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ sed -n -f command.sed data</span><br><span class="line">dog</span><br><span class="line">monkey</span><br><span class="line">3</span><br><span class="line">mouse</span><br></pre></td></tr></table></div></figure>

<p>如果你把标签放到分支跳转的前面，很容易形成死循环。比如，通过<code>sed</code>将数据中的<code>,</code>全部删除</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~$  echo &quot;This, is, a, test, to, remove, commas.&quot; | sed -n &#x27;&#123;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">:start</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">s/,//p</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">b start</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&#125;<span class="string">&#x27;</span></span></span><br><span class="line">This is, a, test, to, remove, commas.</span><br><span class="line">This is a, test, to, remove, commas.</span><br><span class="line">This is a test, to, remove, commas.</span><br><span class="line">This is a test to, remove, commas.</span><br><span class="line">This is a test to remove, commas.</span><br><span class="line">This is a test to remove commas.</span><br><span class="line">^C</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">每次去掉一个,然后跳回start标签处</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">当然，直接使用g选项</span></span></span><br><span class="line">cyan@cyan-virtual-machine:~$  echo &quot;This, is, a, test, to, remove, commas.&quot; | sed -n &#x27;s/,//gp&#x27;</span><br><span class="line">This is a test to remove commas.</span><br></pre></td></tr></table></div></figure>

<p>上述例子，为了解决死循环，可以指定一个地址模式</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~$ echo &quot;This, is, a, test, to, remove, commas.&quot; | sed -n &#x27;&#123;</span><br><span class="line">:start</span><br><span class="line">s/,//p</span><br><span class="line">/,/b start</span><br><span class="line">&#125;&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只有再次匹配到,才会跳转</span></span><br></pre></td></tr></table></div></figure>

<p>你也可以看一下这篇文章。</p>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/m0_51642814/article/details/111461137" >https://blog.csdn.net/m0_51642814/article/details/111461137</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>

        <h1 id="t命令"   >
          <a href="#t命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#t命令" class="headerlink" title="t命令"></a>t命令</h1>
      <p>测试命令(<code>t</code>)也可以用来改变<code>sed</code>执行流程，根据测试条件跳转，而不是地址：<code>[address]t [label]</code>。</p>
<p>如果替换命令匹配并替换了一个模式，测试命令就会跳转到指定标签，否则不会跳转。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~$ echo &quot;This, is, a, test, to, remove, commas.&quot; | sed -n &#x27;&#123;</span><br><span class="line">:start</span><br><span class="line">s/,//p</span><br><span class="line">t start</span><br><span class="line">&#125;&#x27;</span><br><span class="line">This is, a, test, to, remove, commas.</span><br><span class="line">This is a, test, to, remove, commas.</span><br><span class="line">This is a test, to, remove, commas.</span><br><span class="line">This is a test to, remove, commas.</span><br><span class="line">This is a test to remove, commas.</span><br><span class="line">This is a test to remove commas.</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最后一次匹配失败，停止跳转</span></span><br></pre></td></tr></table></div></figure>




        <h1 id="模式替代"   >
          <a href="#模式替代" class="heading-link"><i class="fas fa-link"></i></a><a href="#模式替代" class="headerlink" title="模式替代"></a>模式替代</h1>
      <p><code>&amp;</code>符号，该符号可以用来代表替换命令中的匹配的模式，比如我需要匹配<code>hello</code>这个字符串，那么我就可以用<code>&amp;</code>来代替<code>hello</code>。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~$ echo &quot;The cat is cute.&quot; | sed &#x27;s/cu[^\.\ ]*/&quot;&amp;&quot;/&#x27;</span><br><span class="line">The cat is &quot;cute&quot;.</span><br></pre></td></tr></table></div></figure>

<p><code>&amp;</code>在使用正则表达式时十分方便，因为我们也不知道匹配到的模式到底是什么，我们可以直接通过<code>&amp;</code>拿到我们匹配到的模式。</p>
<p>替代单独单词：<code>&amp;</code>符号提取匹配替换命令指定模式的整个字符串，如果想要提取独立的单词，需要使用<code>()</code>。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;The system Adminstrator manual&quot; | sed &#x27;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">s/\(system\) Adminstrator/\1 user/<span class="string">&#x27;</span></span></span><br><span class="line">The system User manual</span><br></pre></td></tr></table></div></figure>

<p>被使用时，圆括号定义了替换模式中的子模式，并使用<code>\1,2,3..</code>来表示，在替换命令中使用圆括号时，<br>必须使用转义字符将它们标示为分组字符而不是普通的圆括号。</p>
<p>所以最开始的例子我们也可以这么写</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~$ echo &quot;The cat is cute.&quot; | sed &#x27;s/\(cu[^\.\ ]*\)/&quot;\1&quot;/&#x27;</span><br><span class="line">The cat is &quot;cute&quot;.</span><br></pre></td></tr></table></div></figure>

<p>最后再举一个例子：每三位添加逗号(类似于，金钱金额分隔计数)</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~$ echo $input | sed &#x27;&#123;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">: start</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">s/\(.*[0-9]\)\([0-9]\&#123;3\&#125;\)/\1,\2/</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">t start</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&#125;<span class="string">&#x27;</span></span></span><br></pre></td></tr></table></div></figure>

<p>这里说明一下，<code>grep</code>和<code>sed</code>默认不支持<code>ERE</code>–扩展正则表达式，如果要使用，<code>grep</code>需要加<code>-E</code>选项，<code>sed</code>需要使用<code>-r</code>选项。如果不加选项还想使用<code>&#123;&#125;</code>，就要加转义字符<code>\&#123;m\&#125;</code>。</p>
<p>在给例子之前，我需要提示一下，我们上面使用<code>()</code>其实就是扩展正则表达式里面的东西，因为之前没有使用<code>-r</code>选项，所以需要使用转义字符。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~$ echo $input | sed -r &#x27;</span><br><span class="line">: start;</span><br><span class="line">s/(.*[0-9])([0-9]&#123;3&#125;)/\1,\2/;</span><br><span class="line">t start;</span><br><span class="line">&#x27;</span><br><span class="line">10,913,013</span><br></pre></td></tr></table></div></figure>


        <h1 id="最后"   >
          <a href="#最后" class="heading-link"><i class="fas fa-link"></i></a><a href="#最后" class="headerlink" title="最后"></a>最后</h1>
      <p>这里有一篇求问博客，是关于<code>sed</code>和正则表达式问题的，你能先不看评论区，自己找到博主提出的问题吗？要是你能自己解决，那更是最好的。</p>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://oomake.com/question/4296530" >https://oomake.com/question/4296530</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/08/05/Shell/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-08-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-08-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h1>
      <p>本文不会为你介绍所有正则表达式规则，一是我比较懒，二是你记不住。还不如上网去查。</p>

        <h1 id="定义"   >
          <a href="#定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#定义" class="headerlink" title="定义"></a>定义</h1>
      <p>关于正则表达式与数据之间的关系，你可以这么理解</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据 --&gt; 正则表达式 --&gt; 匹配的数据</span><br><span class="line">            |</span><br><span class="line">            v</span><br><span class="line">        滤掉的数据</span><br></pre></td></tr></table></div></figure>

<p>自定义的模式模板(pattern template)，<code>Linux</code>工具(sed,gawk)用来过滤文本。</p>
<p>正则表达式是通过正则表达式引擎(<code>regular expression engine</code>)实现的，该引擎是一套底层软件，负责解释正则表达式并使用这些模式进行<strong>文本匹配</strong>。</p>
<p>在<code>Linux</code>中，存在两种流行的正则表达式引擎：</p>
<ul>
<li><code>POSIX</code>基础的正则表达式(<code>basic regular expression,BRE</code>)引擎。</li>
<li><code>POSIX</code>扩展的正则表达式(<code>extended regular expression,ERE</code>)引擎。</li>
</ul>
<p>大多数<code>Linux</code>工具都至少符合<code>BRE</code>,像<code>sed</code>等部分工具，出于速度方面的考虑，只能符合<code>BRE</code>。<code>ERE</code>通常出现依赖正则表达式进行文本过滤的编程语言中，为常见模式提供了高级模式符号和特殊符号。<code>gawk</code>程序用<code>ERE</code>引擎来处理它的正则表达式模式。</p>

        <h1 id="定义BRE模式"   >
          <a href="#定义BRE模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#定义BRE模式" class="headerlink" title="定义BRE模式"></a>定义BRE模式</h1>
      <p>正则表达式并不关心模式在数据流中的位置，也不关心模式出现了多少次，一旦匹配到文本字符串中任意位置上的模式，就会将该字符串传回<code>Linux</code>工具，值得注意的是，在正则表达式中，空格和其他字符并没有什么区别。</p>

        <h2 id="特殊字符"   >
          <a href="#特殊字符" class="heading-link"><i class="fas fa-link"></i></a><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2>
      <p>正则表达式存在特殊字符：<code>.*[]^$&#123;&#125;\+?|()</code>。要想在文本中使用这些特殊符号，需要在前加上<code>\</code>。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed -n &quot;/\$/p&quot; data</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">尽管正斜线/并不是正则表达式中的特殊字符，但是要是出现在sed和gawk的正则表达式中，也要使用转义</span></span><br><span class="line">sed -n &quot;/\//p&quot; data</span><br></pre></td></tr></table></div></figure>

<p>这些特殊字符具体是什么含义，后面讲解。</p>

        <h2 id="锚字符"   >
          <a href="#锚字符" class="heading-link"><i class="fas fa-link"></i></a><a href="#锚字符" class="headerlink" title="锚字符"></a>锚字符</h2>
      <p>默认情况下，当指定一个正则表达式模式时，只要模式出现在数据流中的任何地方，就能匹配。</p>
<ul>
<li>锁定行首，<code>^</code>–脱字符，定义从数据流中文本行的行首开始的模式，如果模式出现在行首之外，就无法匹配。</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;the book store&quot; | sed -n &#x27;/^the/p&#x27;</span><br><span class="line">the book store</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果是^book，就无法匹配</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>锁定行尾，使用<code>$</code>符号，我记得我在<code>sed</code>还是<code>gawk</code>那篇文章讲过。</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;the book&quot; | sed -n &#x27;/book$/p&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只有以book结尾的，才会被匹配</span></span><br></pre></td></tr></table></div></figure>




        <h2 id="其他字符"   >
          <a href="#其他字符" class="heading-link"><i class="fas fa-link"></i></a><a href="#其他字符" class="headerlink" title="其他字符"></a>其他字符</h2>
      <ul>
<li>点字符<code>.</code>，相当于占位符，但是该位置也必须要有字符才行。</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;at the&#x27; | sed -n &#x27;/.at/p&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">匹配失败</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>字符组<code>[]</code>，该位置如果出现字符组中的任意字符，匹配：<code>echo &quot;to ac&quot; | sed -n &#39;/[ab]c/p&#39;</code>。可以连续使用多个字符组，但是一个字符组只能占一位。</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">过滤错误的邮政编码（由5位数字组成）</span></span><br><span class="line">sed -n &#x27;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">/^[0123456789][0123456789][0123456789][0123456789][0123456789]$/p</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">&#x27; data</span></span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>排除型字符组，在字符组中开头加上<code>^</code>，代表反转，如果该位置没有字符组中的字符，匹配成功。</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;/[^ch]at/p&#x27; data</span><br></pre></td></tr></table></div></figure>

<ul>
<li>区间，对字符组的优化，比如从<code>a</code>到<code>z</code>不用再挨个列出：<code>[a-z]</code>,区间顺序是根据<code>Linux</code>采用的字符集也可以多次使用，形成不连续的区间并集：<code>[a-ch-m]</code>,区间范围为<code>a-c,h-m</code>。</li>
<li>特殊字符组（记不住没关系，我也记不住）</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[:alpha:]]		# 匹配任意字母字符，不管是大写还是小写(alphabet--全部字母;字母表)</span><br><span class="line">[[:alnum:]]		# 匹配任意字母数字字符,0-9,a-z,A-Z</span><br><span class="line">[[:blank:]]		# 匹配空格和制表符</span><br><span class="line">[[:digit:]]		# 匹配0-9之间的数字</span><br><span class="line">[[:lower:]]		# 匹配a-z</span><br><span class="line">[[:upper:]]		# 匹配A-Z</span><br><span class="line">[[:print:]]		# 匹配任意可打印字符</span><br><span class="line">[[:punct:]]		# 匹配标点符号</span><br><span class="line">[[:sapce:]]		# 匹配任意空白字符：空格，制表符，NL，FF，VT，CR</span><br></pre></td></tr></table></div></figure>

<ul>
<li>星号，在字符后面放置星号，表明<strong>该字符</strong>必须在匹配模式的文本中出现0次或多次（我觉得这个大家应该都知道吧），<code>echo &#39;ik&#39; | sed -n &#39;/ie*k/p</code>。星号也可以和字符组同时使用，<code>[ac]*</code>。</li>
</ul>

        <h1 id="扩展正则表达式-ERE"   >
          <a href="#扩展正则表达式-ERE" class="heading-link"><i class="fas fa-link"></i></a><a href="#扩展正则表达式-ERE" class="headerlink" title="扩展正则表达式(ERE)"></a>扩展正则表达式(ERE)</h1>
      <p><code>gawk</code>程序能够识别<code>ERE</code>模式，但是<code>sed</code>不能。<code>gawk</code>具备这些扩展的功能，但是正因为如此，<code>gawk</code>程序在处理数据流时通常比较慢。</p>
<ul>
<li>问号<code>?</code>，类似于*,但是前面的字符只是0次或1次，也就是，不会匹配多次出现的字符。</li>
<li>加号<code>+</code>，仍然类似于*,但是必须出现1次。</li>
<li>花括号<code>&#123;&#125;</code>，允许为可重复的正则表达式指定一个上限，通常称为间隔(<code>interval</code>),可以用两种格式来指定区间。 <code>&#123;m&#125;</code>：正则表达式准确出现<code>m</code>次，<code>&#123;m,n&#125;</code>：正则表达式至少出现<code>m</code>次，至多出现<code>n</code>次。对于<code>gawk</code>来说，默认情况下，<code>gawk</code>不会识别正则表达式间隔，必须指定<code>gawk</code>程序的<code>--re- interval</code>命令行选项才能识别正则表达式间隔。</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;bt&quot; | gawk --re-interval &#x27;/be&#123;1&#125;t/&#123;print $0&#125;&#x27; # 匹配失败</span><br><span class="line">echo &quot;bt&quot; | gawk --re-interval &#x27;/be&#123;0,1&#125;t/&#123;print $0&#125;&#x27; # 匹配成功</span><br></pre></td></tr></table></div></figure>

<ul>
<li>管道符号<code>|</code>，符号管道允许在检查数据流时，用逻辑<code>OR</code>指定正则表达式要用的两个或多个模式，如果任何一个模式匹配了数据流文本，文本通过测试</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">expr1|expr2...</span></span><br><span class="line">echo &#x27;the cat is asleep&#x27; | gawk &#x27;/cat|dog/&#123;print $0&#125;&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">你还记得lsof命令的-a选项吗</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>表达式分组<code>()</code>，该组会被视为一个标准字符，可以像对普通字符一样给该组使用特殊字符。</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;sta&quot; | gawk &#x27;/sta(urday)?/&#123;print $0&#125;&#x27;		# $0表示整行数据</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">和管道一起使用</span></span><br><span class="line">echo &quot;cat&quot; | gawk &#x27;/(c|b)a(t|d)/&#123;print $0&#125;&#x27;</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/08/05/Shell/gawk%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/">gawk程序基础</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-08-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-08-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h1>
      <p><code>gawk</code>程序是<code>Unix</code>中原始<code>gawk</code>程序的<code>GNU</code>版本，让流编辑迈上了一个新的台阶，其作用为：</p>
<ul>
<li>定义变量保存数据。</li>
<li>使用算数和字符串操作符处理数据。</li>
<li>使用结构化编程概念来为数据处理增加处理逻辑。</li>
<li>通过提取数据文件中的数据元素，将其重新排列或格式化，生成格式化报告</li>
</ul>
<p>格式：<code>gawk options program file</code>。</p>
<p><code>gawk</code>强大之处在于程序脚本，可以写脚本来读取文本行的数据，处理并显示数据，创建任何类型的输出报告。</p>
<p>如果你没有下载<code>gwak</code>，执行命令：<code>sudo apt install gawk</code>。</p>

        <h1 id="从命令行读取脚本程序"   >
          <a href="#从命令行读取脚本程序" class="heading-link"><i class="fas fa-link"></i></a><a href="#从命令行读取脚本程序" class="headerlink" title="从命令行读取脚本程序"></a>从命令行读取脚本程序</h1>
      <p><code>gawk</code>程序脚本用一对花括号定义<code>&#123;&#125;</code>,必须将脚本命令放在花括号中：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gawk &#x27;&#123;print &quot;Hello World&quot;&#125;&#x27;</span><br></pre></td></tr></table></div></figure>

<p><code>print</code>命令会将文本打印到<code>STDOUT</code>中，由于没有在命令行中指定文件，所以输入默认是接收<code>STDIN</code>。由于该命令固定显示<code>Hello World</code>，所以不论输入什么，都只会显示这个。希望结束程序，必须表明数据流已经结束，<code>ctrl+d</code>会产生一个<code>EOF</code>字符，能够终止<code>gawk</code>。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gawk &#x27;&#123;print &quot;Hello world&quot;&#125;&#x27; testfile   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用文件作为输入</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">由于gawk命令行假定脚本是个单个文本字符串，所以要使用<span class="string">&#x27;&#x27;</span></span></span><br></pre></td></tr></table></div></figure>

<p>如果要使用多命令，还是使用分号</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;this is rich&quot; | gawk &#x27;&#123;$4=&quot;Mike&quot;;print $0&#125;&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以分行</span></span><br><span class="line">    gawk &#x27;&#123;</span><br><span class="line"><span class="meta prompt_"> &gt; </span><span class="language-bash"><span class="variable">$3</span>=<span class="string">&#x27;123&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"> &gt; </span><span class="language-bash"><span class="built_in">print</span> <span class="variable">$0</span></span></span><br><span class="line"><span class="meta prompt_"> &gt; </span><span class="language-bash">&#125;<span class="string">&#x27;</span></span></span><br></pre></td></tr></table></div></figure>

<p>这个与<code>sed</code>的多命令相似，两者的格式区别在于，<code>sed</code>的命令直接使用<code>&#39;&#39;</code>，<code>gawk</code>使用<code>&#39;&#123;&#125;&#39;</code>，如果将命令放在文件中，两者是相同的，都是使用<code>-f</code>参数，文件名为了避免混淆，也会以.<code>gawk</code>后缀命名。在<code>gawk</code>命令文件中，可以定义变量，同时，使用时不需要<code>$</code>。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">text=&#x27;213&#x27;</span><br><span class="line">print text</span><br></pre></td></tr></table></div></figure>




        <h1 id="数据字段变量"   >
          <a href="#数据字段变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据字段变量" class="headerlink" title="数据字段变量"></a>数据字段变量</h1>
      <p><code>gawk</code>会给一行中每个数据元素分配一个变量（默认数据分隔符是空格）<code>$0</code>–整行数据    <code>$n</code>–第<code>n</code>个数据</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gawk -F: &#x27;&#123;print $1&#125;&#x27; data      </span><br></pre></td></tr></table></div></figure>

<p>打印data每行第一个数据，<code>-F</code>指定分隔符，以<code>:</code>为分隔符。</p>

        <h1 id="程序脚本的运行"   >
          <a href="#程序脚本的运行" class="heading-link"><i class="fas fa-link"></i></a><a href="#程序脚本的运行" class="headerlink" title="程序脚本的运行"></a>程序脚本的运行</h1>
      <p><code>gawk</code>允许指定程序脚本<strong>何时运行</strong>，默认情况下，<code>gawk</code>会从输入读取一行脚本，然后针对该行数据运行程序脚本，但是，有时需要在处理数据前运行脚本，有时在之后处理脚本。</p>
<ul>
<li><code>BEGIN</code>关键字：会强制<code>gawk</code>在读取数据前执行<code>BEIGIN</code>关键字后指定的程序脚本</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ gawk &#x27;BEGIN &#123;print &quot;hello&quot;&#125;&#x27;</span><br><span class="line">hello</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为没有其他处理数据的命令，直接退出</span></span><br></pre></td></tr></table></div></figure>

<p><code>print</code>显示完文本后会快速退出，不等待任何数据，如果想使用正常的程序脚本中处理数据，必须使用另一个脚本区域来定义程序：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ gawk &#x27;BEGIN &#123;print &quot;hello&quot;&#125;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&#123;<span class="built_in">print</span> <span class="variable">$1</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">&#x27; data</span></span></span><br><span class="line">hello</span><br><span class="line">cat</span><br><span class="line">cat</span><br><span class="line">cat</span><br><span class="line">cat</span><br><span class="line">cat</span><br></pre></td></tr></table></div></figure>

<ul>
<li><code>END</code>关键字：会在读取数据(是所有数据)处理完之后，执行<code>END</code>后面的程序脚本</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ gawk &#x27;BEGIN &#123;print &quot;The data file content:&quot;&#125;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&#123;<span class="built_in">print</span> <span class="variable">$1</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">END &#123;<span class="built_in">print</span> <span class="string">&quot;END of file&quot;</span>&#125;<span class="string">&#x27; data</span></span></span><br><span class="line">The data file content:</span><br><span class="line">cat</span><br><span class="line">cat</span><br><span class="line">cat</span><br><span class="line">cat</span><br><span class="line">cat</span><br><span class="line">END of file</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/08/04/Shell/sed%E7%BC%96%E8%BE%91%E5%99%A8%E5%9F%BA%E7%A1%80/">sed编辑器基础</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-08-04</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-08-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h1>
      <p><code>sed</code>编辑器被称作<strong>流编辑器</strong>(<code>stream editor</code>)，流编辑器会在编辑器处理数据之前基于预先提供的一组<strong>数据规则</strong>来编辑数据流。根据命令来处理数据，这些命令要么从命令行输入，要么存储在一个命令文本文件中。</p>
<p><code>sed</code>编辑器处理事务：</p>
<ol>
<li>一次从输入中读取一行数据。</li>
<li>根据提供的编辑器命令匹配数据。</li>
<li>按照命令修改流中的数据。</li>
<li>将新的数据输出到<code>STDOUT</code>。</li>
</ol>
<p><code>sed</code>将所有命令与一行数据匹配完毕后，读取下一行数据并重复该过程，处理完所有数据，终止。</p>

        <h1 id="基本格式"   >
          <a href="#基本格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h1>
      <p>格式：<code>sed options script file</code>。</p>
<p>为了更好理解，举个例子。</p>
<p>先创建一个数据文件<code>data</code>，其中包含**6行’cat’**。然后我们希望将’cat’替换为’dog’。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ sed &#x27;s/cat/dog/&#x27; data</span><br><span class="line">dog</span><br><span class="line">dog</span><br><span class="line">dog</span><br><span class="line">dog</span><br><span class="line">dog</span><br><span class="line">dog</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">‘s/cat/dog/’是后者替换前者</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此次命令没有使用选项，scirpt就是<span class="string">&#x27;s/cat/dog&#x27;</span> file就是data</span></span><br></pre></td></tr></table></div></figure>

<p><code>sed</code>命令非常快。处理一行显示一行，但是<code>sed</code>并不会修改文件原始数据，只是将结果传给<code>STDOUT</code>而已，当然，也可以重定向。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/cat/big cat/&#x27; data &gt; result</span><br></pre></td></tr></table></div></figure>

<p><code>sed</code>可以执行多个命令，使用<code>-e</code>选项，多个命令分号隔开，并且分号紧靠上一个命令</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sed -e &#x27;s/brown/green/; s/dog/cat/&#x27; data</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者是这样，shell一旦发现封尾的单引号，就会执行命令</span></span><br><span class="line">sed -e &#x27;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">s/brown/green</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">s/fox/cat</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">&#x27; data</span></span></span><br></pre></td></tr></table></div></figure>

<p>如果要执行的命令太多，可以放在文件中，使用<code>-f</code>选项，该选项会在处理输入时，将文件中指定的命令添加到已有的命令中。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sed -f script.sed data</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为避免混淆，一般将sed的命令文件后缀写为.sed</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例子</span></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat command.sed</span><br><span class="line">s/cat/dog/</span><br><span class="line">s/Jack/Mark/</span><br><span class="line"></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat data</span><br><span class="line">cat Jack</span><br><span class="line">cat Jack</span><br><span class="line">cat Jack</span><br><span class="line">cat Jack</span><br><span class="line">cat Jack</span><br><span class="line"></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ sed -f command.sed data</span><br><span class="line">dog Mark</span><br><span class="line">dog Mark</span><br><span class="line">dog Mark</span><br><span class="line">dog Mark</span><br><span class="line">dog Mark</span><br></pre></td></tr></table></div></figure>

<p>关于<code>s</code>替换命令，还有其他选项</p>
<ul>
<li><code>sed &#39;s/cat/dog/&#39; data</code>只会替换每行第一处<code>cat</code>。如果想在第<code>n</code>处替换，<code>s/cat/dog/n&#39;</code>。</li>
<li><code>g</code>选项，所有匹配到的标记都会被替换。</li>
<li><code>p</code>选项，文本原先行内容替换后要打印出来：<code>sed -n &#39;s/cat/dog/p&#39; data</code>,一般和<code>-n</code>配合使用，<code>-n</code>禁止<code>sed</code>输出，配合<code>p</code>使用，就只会打印含有标记的文本。</li>
<li><code>w file</code>,将替换的结果写到文件中：<code>sed &#39;s/cat/dog/w aim.txt&#39; data</code>。</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ sed &#x27;s/cat/dog/w test_data&#x27; data</span><br><span class="line">dog Jack</span><br><span class="line">dog Jack</span><br><span class="line">dog Jack</span><br><span class="line">dog Jack</span><br><span class="line">dog Jack</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat test_data</span><br><span class="line">dog Jack</span><br><span class="line">dog Jack</span><br><span class="line">dog Jack</span><br><span class="line">dog Jack</span><br><span class="line">dog Jack</span><br></pre></td></tr></table></div></figure>

<p>有时候，<code>/</code>使用起来比较麻烦，可以使用<code>!</code>来代替：<code>s!cat!dog!</code>。</p>

        <h1 id="使用地址"   >
          <a href="#使用地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用地址" class="headerlink" title="使用地址"></a>使用地址</h1>
      <p>可以指定命令对某些特定的行数进行处理，<code>sed</code>编辑器的行寻址有两种形式：</p>
<ul>
<li>数字表示行区间</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.对单行指定修改</span></span><br><span class="line">sed &#x27;2s/cat/dog/&#x27; data</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.对行区间进行执行修改</span></span><br><span class="line">sed &#x27;2,5s/cat/dog&#x27; data # 2~5行被修改</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.美元符号$</span></span><br><span class="line">sed &#x27;2,$s/cat/dog/&#x27; data   # 对2行及以下的数据执行命令</span><br></pre></td></tr></table></div></figure>

<ul>
<li>文本模式来过滤出行，<code>/pattern/command</code>。比如修改用户<code>cyan</code>的默认<code>shell</code>。匹配模式十分类似<code>grep</code>，固定文本作用有限，最常用的是使用正则表达式。 匹配模式十分类似grep，固定文本作用有限，最常用的是使用正则表达式。</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep cyan /etc/passwd</span></span><br><span class="line">cyan:x:1000:1000:cyan,,,:/home/cyan:/bin/bash</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sed <span class="string">&#x27;/cyan/s/bash/csh/&#x27;</span> /etc/psswd</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>当有多条命令时候。</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">address &#123; #多条命令时，需要用&#123;&#125;来限定作用域</span><br><span class="line">        command1</span><br><span class="line">        command2</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例</span></span><br><span class="line">sed &#x27;2&#123;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">commands</span>    </span><br><span class="line">&#125;&#x27; data.txt</span><br></pre></td></tr></table></div></figure>




        <h1 id="删除与修改"   >
          <a href="#删除与修改" class="heading-link"><i class="fas fa-link"></i></a><a href="#删除与修改" class="headerlink" title="删除与修改"></a>删除与修改</h1>
      <p><code>sed</code>可以替换，也可以删除，使用<code>d</code>命令：<code>sed &#39;3d&#39; data</code>，和行寻址一起使用发挥最大作用。输出到STDOUT的结果是删除指定行之后的剩余文本。</p>
<p>如果我希望删除某个区间的文本（使用文本匹配）</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cat data</span><br><span class="line">num start</span><br><span class="line">num 2</span><br><span class="line">num 3</span><br><span class="line">num end</span><br><span class="line">num 4</span><br><span class="line">num start again</span><br><span class="line">kk</span><br><span class="line">nn</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行命令：sed <span class="string">&#x27;/start/,/end/d&#x27;</span> data</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果 num 4</span> </span><br></pre></td></tr></table></div></figure>

<p>一开始遇到<code>start</code>，打开删除模式，持续删除，直到遇到<code>end</code>，关闭删除模式(没遇到就一直删除）。再次遇到<code>start</code>时(<code>num start again</code>)，打开删除模式，并持续删除。</p>
<p><code>sed</code>编辑器是不会修改原始文件的，修改的只是从<code>sed</code>编辑器的输出中消失了。</p>
<p>至于修改行的内容，之前的<code>s</code>命令需要匹配，而<code>c</code>命令是直接修改整行内容，<code>c--change</code>。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;1c\this is changed line&#x27; data.txt</span><br><span class="line">sed &#x27;/num 1/c\this is changed line&#x27; data.txt</span><br><span class="line">sed &#x27;2,3c\this is changed line&#x27; data.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">c命令之后用的是反斜杠\,并且没有封尾，也就是line后没有\</span></span><br><span class="line"><span class="language-bash"><span class="comment"># 第三个使用区间修改行，并不是将区间的每一行都修改为指定行，而是用该指定行替换数据流中区间的所有文本</span></span></span><br></pre></td></tr></table></div></figure>




        <h1 id="插入和附加文本"   >
          <a href="#插入和附加文本" class="heading-link"><i class="fas fa-link"></i></a><a href="#插入和附加文本" class="headerlink" title="插入和附加文本"></a>插入和附加文本</h1>
      <p>插入<code>insert--i</code>:会在指定行<strong>前</strong>增加一个行，<code>echo &quot;test line 2&quot; | sed &#39;i\test line 1&#39;</code>。<br>附加<code>append--a</code>:会在指定行<strong>后</strong>增加一个行，<code>echo &quot;test line 2&quot; | sed &#39;a\test line 1&#39;</code>。</p>
<p>如果想要附加到行尾，只需要使用美元符号：<code>sed &#39;$a\new line&#39; data</code>。<strong>个人觉得美元符号是数据流最后一行的意思</strong>。<br>要插入（附加）多行数据，需要在每行之间使用<code>\</code>：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;1i\</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">line 1\</span></span><br><span class="line"><span class="language-bash">&gt; line 2</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">&#x27; data</span></span></span><br></pre></td></tr></table></div></figure>




        <h1 id="转换命令"   >
          <a href="#转换命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#转换命令" class="headerlink" title="转换命令"></a>转换命令</h1>
      <p><code>y</code>命令是唯一可以处理单个字符的<code>sed</code>编辑器命令  <code>[address]y/inchars/outchars/</code>。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;y/123/789/&#x27; data</span><br></pre></td></tr></table></div></figure>

<p><code>inchars</code>的第一个字符会被映射为<code>outchars</code>的第一个字符，以此类推，直到处理完指定字符。其中，如果两者长度不一样，会报错。<br>转换命令是全局命令，无法限定只转换在特定地方出现的字符(以行为单位)，也就是<strong>一行所有的字符都要被转换</strong>。</p>

        <h1 id="打印命令"   >
          <a href="#打印命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#打印命令" class="headerlink" title="打印命令"></a>打印命令</h1>
      <p>之前使用<code>s</code>替换命令时，配合<code>-n</code>和<code>p</code>选项，打印出修改的行，还有些命令也能打印数据流信息。</p>
<p><code>=</code>命令打印<strong>行号</strong>，<strong>行号由数据流中的换行符来决定</strong>，每出现一个换行符，sed编辑器就认为一行结束了。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;=&#x27; data</span><br></pre></td></tr></table></div></figure>

<p><code>l</code>命令可以打印出数据流中的文本和不可打印的ASCII字符(一般是标准C风格或八进制)，<code>l</code>就是<code>list</code>。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;l&#x27; data</span><br></pre></td></tr></table></div></figure>




        <h1 id="处理文件"   >
          <a href="#处理文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#处理文件" class="headerlink" title="处理文件"></a>处理文件</h1>
      <ul>
<li>写入文件：<code>[address]w filename</code>。</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;1,2w aim.txt&#x27; data</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在aim.txt追加</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>读取文件：<code>[address]r filename</code>。 允许将一个独立文件中的数据插入到数据流中，插入到指定行后。</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;3r sources.txt&#x27; data</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/08/04/Shell/%E5%87%BD%E6%95%B0/">函数</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-08-04</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-08-04</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="创建函数"   >
          <a href="#创建函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h1>
      <p>格式</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式1</span></span><br><span class="line">function name &#123;</span><br><span class="line">	commands</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式2,更推荐使用</span></span><br><span class="line">name() &#123;</span><br><span class="line">	commands</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用时只需要使用函数名即可--name</span></span><br></pre></td></tr></table></div></figure>

<p>默认情况下，函数退出状态码是函数中最后一条命令返回的退出状态码，函数执行结束后，可以用标准变量<code>$?</code>来确定函数退出状态码。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">return</span>语句</span></span><br><span class="line">fun() &#123;</span><br><span class="line">	read -p &quot;please input the value:&quot; value</span><br><span class="line">    return $value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>退出状态码在<code>0~255</code>，否则就会返回错误值</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">fun() &#123;</span><br><span class="line">    var=&#x27;abc&#x27; # 会报错：line 5: return: abc: numeric argument required</span><br><span class="line">    return $var</span><br><span class="line">&#125;</span><br><span class="line">fun</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果中间有其他命令，$?就会被置0</span></span><br><span class="line">echo $?</span><br></pre></td></tr></table></div></figure>

<p>当然，如果希望从函数那得到一个任意对象，就像强类型语言那样<code>return</code>语句返回值可以用变量接收</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun() &#123;</span><br><span class="line">value=10</span><br><span class="line">echo $[$value*2]</span><br><span class="line">&#125;</span><br><span class="line">reslut=`fun` #或者是$(fun)</span><br></pre></td></tr></table></div></figure>

<p>如此可以获得任何类型的函数输出，并将其保存在变量中。</p>

        <h1 id="函数中使用变量"   >
          <a href="#函数中使用变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数中使用变量" class="headerlink" title="函数中使用变量"></a>函数中使用变量</h1>
      <p><strong>传参：</strong></p>
<ul>
<li><code>bash shell</code> 会将函数当成一个小型脚本来对待，也就是说，可以传递参数，如同脚本一样。</li>
<li>如同脚本一样，对于传入参数，依旧是使用<code>$0,$1...</code>，<code>$#</code>是传入参数数量。<code>value=$(fun 10 15)</code>,参数直接写在后面即可。</li>
<li>由于函数使用特殊参数环境变量作为自己的参数值，因此他无法直接获取脚本在命令行获取的参数值。</li>
</ul>
<p><strong>处理变量：</strong></p>
<p>比较麻烦的就是变量的作用域。默认情况下，<strong>定义的变量都是全局变量</strong>，函数外定义的变量，函数内部也可以正常使用。函数内定义的变量函数外也可以使用。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">fun() &#123;</span><br><span class="line">    var=10</span><br><span class="line">    return $var</span><br><span class="line">&#125;</span><br><span class="line">fun</span><br><span class="line">echo $var</span><br></pre></td></tr></table></div></figure>
<p>函数内部使用的任何变量都可以被声明成局部变量，只需要加上<code>local</code>关键字即可。</p>
<p><code>local temp=$[$value + 2]</code>,在函数内使用<code>temp</code>，不会影响主体脚本的<code>temp</code>的值。</p>

        <h1 id="数组"   >
          <a href="#数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#数组" class="headerlink" title="数组"></a>数组</h1>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr=(one two three)</span><br></pre></td></tr></table></div></figure>

<p>直接<code>$arr</code>只会显示<code>one</code>，使用格式为：<code>$&#123;arr[1]&#125;</code>,一次性全部显示，就是<code>$&#123;arr[*]&#125;</code>。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">fun() &#123;</span><br><span class="line">    local arr=(1,2,3,4)</span><br><span class="line">    for i in $&#123;arr[*]&#125;</span><br><span class="line">    do</span><br><span class="line">        echo -n $i</span><br><span class="line">   done</span><br><span class="line">   echo</span><br><span class="line">&#125;</span><br><span class="line">fun</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">结果：1,2,3,4</span></span><br></pre></td></tr></table></div></figure>




        <h1 id="创建库"   >
          <a href="#创建库" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建库" class="headerlink" title="创建库"></a>创建库</h1>
      <p>总有一些方法，我在很多脚本文件中都会使用，为了避免每个脚本文件都写一次，<code>bash shell</code>允许创建函数库文件，然后在多个脚本中引用。</p>
<p>我们在运行一个脚本文件时，当前的<code>shell</code>会创建一个新的<code>shell</code>运行</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat testfile</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">while var=10</span><br><span class="line">do</span><br><span class="line">        var=10</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ ./testfile &amp;</span><br><span class="line">[1] 89708</span><br><span class="line"></span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ ps --forest</span><br><span class="line">    PID TTY          TIME CMD</span><br><span class="line">  88948 pts/1    00:00:00 bash</span><br><span class="line">  89708 pts/1    00:00:08  \_ testfile</span><br><span class="line">  89710 pts/1    00:00:00  \_ ps</span><br></pre></td></tr></table></div></figure>

<p><code>shell</code>函数仅仅在定义它的<code>shell</code>会内有效，所以如果在<code>shell</code>命令行界面的提示符下运行库函数脚本，<code>shell</code>会创建一个新的<code>shell</code>运行。这个<code>shell</code>会重新定义库函数，当其他脚本想用时，是不能的。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">./funs_file</span><br><span class="line">..</span><br></pre></td></tr></table></div></figure>

<p>哪怕在<code>test</code>中运行<code>funs_file</code>库文件，这些库函数，也只能在运行库文件的<code>shell</code>里面才会生效。</p>

        <h2 id="source命令"   >
          <a href="#source命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#source命令" class="headerlink" title="source命令"></a>source命令</h2>
      <p>该命令会在当前<code>shell</code>上下文执行命令，而不是创建一个新的<code>shell</code>，并且<code>source</code>命令有个快捷别名–点操作符. <code>./fun_file</code>。</p>
<p>编写一个脚本</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ cat testfile</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">var=10</span><br></pre></td></tr></table></div></figure>

<p>如果不使用<code>source</code>命令，那么<code>var</code>对于当前<code>shell</code>是不可见的</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ ./testfile</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ echo $var</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>使用之后</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~/Templates$ . ./testfile</span><br><span class="line">cyan@cyan-virtual-machine:~/Templates$ echo $var</span><br><span class="line">10</span><br></pre></td></tr></table></div></figure>




        <h1 id="终端使用函数"   >
          <a href="#终端使用函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#终端使用函数" class="headerlink" title="终端使用函数"></a>终端使用函数</h1>
      <p>格式</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式1，分号结尾</span></span><br><span class="line">fun()&#123;echo &quot;ok&quot;;read value;&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式2</span></span><br><span class="line">  fun() &#123;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;adc&quot;</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&#125;</span></span><br></pre></td></tr></table></div></figure>

<p>在<code>.bashrc</code>文件定义函数：函数定义放在一个特殊的位置，每次启动新<code>shell</code>都会由<code>shell</code>重新在<code>.bashrc</code>中定义的函数，甚至可以在自己写的脚本中直接使用。</p>
<p>关于<code>.bashrc</code>，就是个启动文件，<code>shell</code>启动时会执行一下。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/08/04/Shell/%E6%8E%A7%E5%88%B6%E8%84%9A%E6%9C%AC/">控制脚本</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-08-04</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-08-04</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="信号"   >
          <a href="#信号" class="heading-link"><i class="fas fa-link"></i></a><a href="#信号" class="headerlink" title="信号"></a>信号</h1>
      <p><code>Linux</code>利用信号与运行在系统中的进程进行通信，常见的<code>Linux</code>系统信号：</p>
<ul>
<li>1–<code>SIGHUP</code>–挂起进程</li>
<li>2–<code>SIGINT</code>–终止进程</li>
<li>3–<code>SIGQUIT</code>–停止进程</li>
<li>9–<code>SIGLIKILL</code>–无条件终止进程</li>
<li>15–<code>SIHTERM</code>–尽可能终止进程</li>
<li>17–<code>SIGSTOP</code>–无条件停止进程，但不是终止</li>
<li>18–<code>SIGTSTP</code>–停止或暂停进程，但不是终止</li>
<li>19–<code>SIGCONT</code>–继续运行停止的进程</li>
</ul>
<p><code>crtl+c</code>会生成<code>SIGINT</code>信号，停止<code>shell</code>当前运行的所有进程。<br><code>ctrl+z</code>会生成<code>SIGTSTP</code>信号，停止<code>shell</code>中运行的任何进程。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cyan@cyan-virtual-machine:~$ sleep 1000</span><br><span class="line">^Z</span><br><span class="line">[1]+  Stopped                 sleep 1000</span><br><span class="line">cyan@cyan-virtual-machine:~$ ps -l</span><br><span class="line">F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">0 S  1000   30447   30445  0  80   0 -  3559 do_wai pts/0    00:00:00 bash</span><br><span class="line">0 T  1000   33293   30447  0  80   0 -  2789 do_sig pts/0    00:00:00 sleep</span><br><span class="line">0 R  1000   33294   30447  0  80   0 -  3623 -      pts/0    00:00:00 ps</span><br></pre></td></tr></table></div></figure>

<p><code>S</code>列中，<code>T</code>标志就是进程被暂停。使用<code>ps</code>获得希望杀死的进程的<code>PID</code>，使用<code>kill -9 PID</code>。</p>

        <h2 id="trap命令"   >
          <a href="#trap命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#trap命令" class="headerlink" title="trap命令"></a>trap命令</h2>
      <p><code>trap</code>命令：允许指定<code>shell</code>脚本监看并从<code>shell</code>中拦截的<code>Linux</code>信号。如果脚本收到了<code>trap</code>命令中列出的信号，该信号不再由<code>shell</code>处理。而是本地处理。</p>
<p>其使用格式为：<code>trap commands signals</code>。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">trap &quot;echo &#x27;I have trapped ctrl-c&#x27;&quot; SIGINT</span><br><span class="line">sleep 1000</span><br></pre></td></tr></table></div></figure>

<p>在睡眠期间使用<code>ctrl+c</code>就会打印这句话。</p>
<p>在很多程序中，想要实现程序正常运行结束或者外部发送信号退出，都会打印<code>Goodby...</code>，可以加上这句话</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trap &quot;echo &#x27;Goodby...&#x27;&quot; Exit</span><br></pre></td></tr></table></div></figure>

<p><code>trap</code>可以修改或是移除，其重点就是<strong>先到先占位</strong>，比如第一行设置了<code>trap</code>指令，在第20行修改或移除了该信号，那么第一行<code>trap</code>的只会在1~19行生效。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除,单（双）短横线都可以</span></span><br><span class="line">trap --SIGINT</span><br></pre></td></tr></table></div></figure>




        <h1 id="后台模式"   >
          <a href="#后台模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#后台模式" class="headerlink" title="后台模式"></a>后台模式</h1>
      <p>最开始就提到过，在运行脚本时加上<code>&amp;</code>，就能将进程置入后台。后台模式中，进程不会和终端会话上的<code>STDIN</code>，<code>STDOUT</code>，<code>STDERR</code>关联 。</p>

        <h1 id="最后"   >
          <a href="#最后" class="heading-link"><i class="fas fa-link"></i></a><a href="#最后" class="headerlink" title="最后"></a>最后</h1>
      <p><code>shell</code>脚本的基本编程到此为止，之后我们会进入高级<code>shell</code>脚本编程，其中会涉及到函数，著名的流编辑器<code>sed</code>和<code>gawk</code>，以及正则表达式四个主要部分。然后就可以结束此次<code>Linux</code>与<code>shell</code>编程的学习了。</p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/2/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/icons/logo.png" alt="avatar"></div><p class="sidebar-ov-author__text">You have lots more to work on</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">47</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">2</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">7</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh_tw" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Cyan</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.2.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.7.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.7.0"></script><script src="/js/stun-boot.js?v=2.7.0"></script><script src="/js/scroll.js?v=2.7.0"></script><script src="/js/header.js?v=2.7.0"></script><script src="/js/sidebar.js?v=2.7.0"></script><script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},t.src!==i&&(n.src=i)}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body></html>