<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.jpg"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><link rel="mask-icon" href="/images/logo.svg" color=""><link rel="manifest" href="/images/manifest.json"><meta name="msapplication-config" content="/images/browserconfig.xml"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="慕青の迷途" href="https://cecilia.cool/rss.xml"><link rel="alternate" type="application/atom+xml" title="慕青の迷途" href="https://cecilia.cool/atom.xml"><link rel="alternate" type="application/json" title="慕青の迷途" href="https://cecilia.cool/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="前端"><link rel="canonical" href="https://cecilia.cool/2023/05/23/%E5%89%8D%E7%AB%AF/Vue3%E5%85%A5%E9%97%A8/"><title>Vue3 发懵到发癫 | 慕青の迷途 = 欲买桂花同载酒，终不似，少年游</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Vue3 发懵到发癫</h1><div class="meta"><span class="item" title="创建时间：2023-05-23 16:15:30"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-05-23T16:15:30+08:00">2023-05-23</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>18k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>16 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">慕青の迷途</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="http://s3.bmp.ovh/imgs/2023/01/19/42b9a3808d997eef.jpg"></li><li class="item" data-background-image="http://s3.bmp.ovh/imgs/2023/01/01/d51e0450b83fd2b6.jpg"></li><li class="item" data-background-image="http://s3.bmp.ovh/imgs/2023/01/01/de59375713f35ff7.jpg"></li><li class="item" data-background-image="http://s3.bmp.ovh/imgs/2023/01/19/1004b58392784aa7.jpg"></li><li class="item" data-background-image="http://s3.bmp.ovh/imgs/2023/01/19/19019c4b5376f609.jpg"></li><li class="item" data-background-image="http://s3.bmp.ovh/imgs/2023/01/01/2d50986289f4439b.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cecilia.cool/2023/05/23/%E5%89%8D%E7%AB%AF/Vue3%E5%85%A5%E9%97%A8/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="Cyan"><meta itemprop="description" content="欲买桂花同载酒，终不似，少年游, 时雨病重症患者"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="慕青の迷途"></span><div class="body md" itemprop="articleBody"><p>欢迎各位后端程序员来到《Vue3 发懵到发癫》，各位在后端业务中神经百战，现在来试一下前端吧。</p><h1 id="vue2"><a class="anchor" href="#vue2">#</a> Vue2</h1><p>一些老项目还在用 vue2，我真的会谢，为什么呢，因为我实习时就要用 vue2</p><h1 id="vue3"><a class="anchor" href="#vue3">#</a> Vue3</h1><p>这里的技术栈主要是：Vue3-ts-vite。IDE：VSCode</p><p>其实 IDEA2023 版也支持创建 vue3 项目，方便程度都差不多吧，反正都要用命令行初始化项目，嘎嘎爽。</p><p>参考链接：</p><ul><li>首选<strong>官网</strong>：<span class="exturl" data-url="aHR0cHM6Ly9jbi52dWVqcy5vcmcv">https://cn.vuejs.org/</span></li><li>快速入门（超级推荐）：<span class="exturl" data-url="aHR0cHM6Ly92dWUzLmNoZW5ncGVpcXVhbi5jb20v">https://vue3.chengpeiquan.com/</span></li></ul><h2 id="搭建项目"><a class="anchor" href="#搭建项目">#</a> 搭建项目</h2><p>选择一个文件夹，管理员权限打开 cmd，然后执行以下命令：</p><p><code>npm install -g create-preset</code> ：尽管有很多种创建 vue 项目模式，但是这种更快，将你需要的大部分依赖包都下了，可能会提示你 <code>-g</code> 已经弃用了，叫你使用 <code>--local=global</code> ，改一下即可。 <code>-g</code> 就是全局安装，之后再希望创建项目，就有直接的模板了。</p><p><code>preset -v</code> ：检查一下是否安装成功，成功的话会有一个版本号</p><p><code>preset init hello-vue3 --template vue3-ts-vite</code> ： <code>init</code> 后的参数就是项目名，最后一个固定参数表示使用的是 vue3、typescript、vite 构建工具</p><p><code>cd hello-vue3</code> 、 <code>npm install</code> 、 <code>npm run dev</code> ：进入项目，安装一些必要的依赖，运行。</p><p>停止运行，用 vscode 打开项目，修改一下 <code>vite.config.ts</code> ：</p><p>如果在 Vite 的配置文件 vite.config.ts ，或者是在 Vue CLI（CLI 是 command-line Interface 的缩写） 的配置文件 vue.config.js 里设置了 alias 的话，因为 TypeScript 不认识里面配置的 alias 别名，所以需要再对 tsconfig.json 做一点调整，增加对应的 paths ，否则在 VSCode 里可能会路径报红，提示找不到模块或其相应的类型声明。</p><p>假设在 vite.config.ts 里配置了这些 alias ：</p><figure class="highlight json"><figcaption data-lang="JSON"></figcaption><table><tr><td data-num="1"></td><td><pre>export default defineConfig(<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token comment">//resolve () 函数在 path 包中，不要导错了</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  resolve<span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    alias<span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      '@'<span class="token operator">:</span> resolve('src')<span class="token punctuation">,</span> <span class="token comment">// 源码根目录</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      '@img'<span class="token operator">:</span> resolve('src/assets/img')<span class="token punctuation">,</span> <span class="token comment">// 图片</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      '@less'<span class="token operator">:</span> resolve('src/assets/less')<span class="token punctuation">,</span> <span class="token comment">// 预处理器</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      '@libs'<span class="token operator">:</span> resolve('src/libs')<span class="token punctuation">,</span> <span class="token comment">// 本地库</span></pre></td></tr><tr><td data-num="9"></td><td><pre>      '@plugins'<span class="token operator">:</span> resolve('src/plugins')<span class="token punctuation">,</span> <span class="token comment">// 本地插件</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      '@cp'<span class="token operator">:</span> resolve('src/components')<span class="token punctuation">,</span> <span class="token comment">// 公共组件</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      '@views'<span class="token operator">:</span> resolve('src/views')<span class="token punctuation">,</span> <span class="token comment">// 路由组件</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token comment">// ...</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span>)</pre></td></tr></table></figure><p>那么在该项目的 tsconfig.json 文件里就需要相应的加上这些 paths ：</p><figure class="highlight json"><figcaption data-lang="JSON"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// ...</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token property">"paths"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token property">"@/*"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"src/*"</span><span class="token punctuation">]</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token property">"@img/*"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"src/assets/img/*"</span><span class="token punctuation">]</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token property">"@less/*"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"src/assets/less/*"</span><span class="token punctuation">]</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token property">"@libs/*"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"src/libs/*"</span><span class="token punctuation">]</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="9"></td><td><pre>      <span class="token property">"@plugins/*"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"src/plugins/*"</span><span class="token punctuation">]</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      <span class="token property">"@cp/*"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"src/components/*"</span><span class="token punctuation">]</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      <span class="token property">"@views/*"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"src/views/*"</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">// ...</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token comment">// ...</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="入门教程"><a class="anchor" href="#入门教程">#</a> 入门教程</h2><h3 id="虚拟dom"><a class="anchor" href="#虚拟dom">#</a> 虚拟 DOM</h3><p>如果说只用 js，我们想要动态的修改一个静态标签的内容，比如 h 文本等，或者动态增加一些标签之类的，必须要手撸 DOM 才行，然后重新渲染，如果在一个页面上频繁且大量的操作真实 DOM ，频繁的触发浏览器回流（ Reflow ）与重绘（ Repaint ），会带来很大的性能开销，从而造成页面卡顿，在大型项目的性能上很是致命。</p><p>Vue 则是通过操作<strong>虚拟 DOM</strong> ，每一次数据更新都通过 <strong>Diff 算法</strong>找出需要更新的节点，只更新对应的虚拟 DOM ，再去映射到真实 DOM 上面渲染，以此避免频繁或大量的操作真实 DOM 。</p><blockquote><p>虚拟 DOM 是一种编程概念，是指将原本应该是真实 DOM 元素的 UI 界面，用数据结构来组织起完整的 DOM 结构，再同步给真实 DOM 渲染，减少浏览器的回流与重绘。在 JavaScript 里，虚拟 DOM 的表现是一个 Object 对象，其中需要包含指定的属性（例如 Vue 的虚拟 DOM 需要用 <code>type</code> 来指定当前标签是一个 <code>&lt;div /&gt;</code> 还是 <code>&lt;span /&gt;</code> ），然后框架会根据对象的属性去转换为 DOM 结构并最终完成内容的显示。</p></blockquote><h3 id="文件结构"><a class="anchor" href="#文件结构">#</a> 文件结构</h3><p><code>.vue</code> 被称为单文件组件，也就是 <code>SFC</code> ：</p><table><thead><tr><th style="text-align:center"><code>.vue</code> 文件</th><th style="text-align:center"><code>.html</code> 文件</th></tr></thead><tbody><tr><td style="text-align:center"><code>&lt;template /&gt;</code> 部分</td><td style="text-align:center">HTML 代码</td></tr><tr><td style="text-align:center"><code>&lt;style /&gt;</code> 部分</td><td style="text-align:center">CSS 代码</td></tr><tr><td style="text-align:center"><code>&lt;script /&gt;</code> 部分</td><td style="text-align:center">JavaScript 代码</td></tr></tbody></table><h3 id="mpa与spa"><a class="anchor" href="#mpa与spa">#</a> MPA 与 SPA</h3><table><thead><tr><th style="text-align:center">名词</th><th style="text-align:center">全称</th><th style="text-align:center">中文</th></tr></thead><tbody><tr><td style="text-align:center">MPA</td><td style="text-align:center">Multi-Page Application</td><td style="text-align:center">多页面应用</td></tr><tr><td style="text-align:center">SPA</td><td style="text-align:center">Single-Page Application</td><td style="text-align:center">单页面应用</td></tr></tbody></table><p>MPA 多页面应用是最传统的网站体验，当一个网站有多个页面时，会对应有多个实际存在的 HTML 文件，访问每一个页面都需要经历一次完整的页面请求过程：</p><p>从用户点击跳转开始： ---&gt; 浏览器打开新的页面 ---&gt; 请求【所有】资源 ---&gt; 加载 HTML 、CSS 、 JS 、 图片等资源 ---&gt; 完成新页面的渲染。</p><p>SPA 单页面应用是现代化的网站体验，与 MPA 相反，不论站点内有多少个页面，在 SPA 项目实际上只有一个 HTML 文件，也就是 <code>index.html</code> 首页文件。</p><p>它只有第一次访问的时候才需要经历一次完整的页面请求过程，之后的每个内部跳转或者数据更新操作，都是通过 AJAX 技术来获取需要呈现的内容并只<strong>更新指定的网页位置</strong>。</p><p>可以把 SPA 的请求过程简化为如下步骤：</p><p>SPA 页面跳转过程，从用户点击跳转开始：---&gt; 浏览器通过 <code>pushState</code> 等方法更新 URL---&gt; 请求接口数据（如果有涉及到前后端交互）---&gt; 通过 JavaScript 处理数据，拼接 HTML 片段 ---&gt; 把 HTML 片段渲染到指定位置，完成页面的 “刷新”。</p><h3 id="csr-与-ssr"><a class="anchor" href="#csr-与-ssr">#</a> CSR 与 SSR</h3><table><thead><tr><th style="text-align:center">名词</th><th style="text-align:center">全称</th><th style="text-align:center">中文</th></tr></thead><tbody><tr><td style="text-align:center">CSR</td><td style="text-align:center">Client-Side Rendering</td><td style="text-align:center">客户端渲染</td></tr><tr><td style="text-align:center">SSR</td><td style="text-align:center">Server-Side Rendering</td><td style="text-align:center">服务端渲染</td></tr></tbody></table><h3 id="工程化"><a class="anchor" href="#工程化">#</a> 工程化</h3><p>基于 Vue 3 的项目，最主流的工程化组合拳有以下两种：</p><table><thead><tr><th style="text-align:center">常用方案</th><th style="text-align:center">Runtime</th><th style="text-align:center">构建工具</th><th style="text-align:center">前端框架</th></tr></thead><tbody><tr><td style="text-align:center">方案一</td><td style="text-align:center">Node</td><td style="text-align:center">Webpack</td><td style="text-align:center">Vue</td></tr><tr><td style="text-align:center">方案二</td><td style="text-align:center">Node</td><td style="text-align:center">Vite</td><td style="text-align:center">Vue</td></tr></tbody></table><p>案一是比较传统并且过去项目使用最多的方案组合，但从 2021 年初随着 Vite 2.0 的发布，伴随着更快的开发体验和日渐丰富的社区生态，新项目很多都开始迁移到方案二。</p><h3 id="路由"><a class="anchor" href="#路由">#</a> 路由</h3><p>在传统的 Web 开发过程中，当需要实现多个站内页面时，以前需要写很多个 HTML 页面，然后通过 <code>&lt;a /&gt;</code> 标签来实现互相跳转。</p><p>在如今工程化模式下的前端开发，像 Vue 工程，可以轻松实现只用一个 HTML 文件，却能够完成多个站内页面渲染、跳转的功能，这就是路由。</p><blockquote><p><code>@views</code> 是 <code>src/views</code> 的路径别名， <code>@cp</code> 是 <code>src/components</code> 的路径别名。路径别名可以在 <code>vite.config.ts</code> 等构建工具配置文件里添加 <code>alias</code> ，在搭建项目中我们曾经提到过。</p></blockquote><p>文件结构：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>src</pre></td></tr><tr><td data-num="2"></td><td><pre>│ <span class="token comment"># 路由目录</span></pre></td></tr><tr><td data-num="3"></td><td><pre>├─router</pre></td></tr><tr><td data-num="4"></td><td><pre>│   <span class="token comment"># 路由入口文件</span></pre></td></tr><tr><td data-num="5"></td><td><pre>├───index.ts</pre></td></tr><tr><td data-num="6"></td><td><pre>│   <span class="token comment"># 路由配置，如果路由很多，可以再拆分模块文件</span></pre></td></tr><tr><td data-num="7"></td><td><pre>├───routes.ts</pre></td></tr><tr><td data-num="8"></td><td><pre>│ <span class="token comment"># 项目入口文件</span></pre></td></tr><tr><td data-num="9"></td><td><pre>└─main.ts</pre></td></tr></table></figure><p>index.ts 是路由的入口文件，如果路由很少，那么可以只维护在这个文件里，如果项目比较复杂，可以像上面这个结构一样拆分成两个文件： index.ts 和 routes.ts ，在 routes.ts 里维护路由树的结构，在 index.ts 导入路由树结构并激活路由，同时可以在该文件里配置路由钩子。</p><p>以 <code>typescript</code> 为例，路由文件的基础格式为三个部分：类型声明、数组结构、模块导出。</p><figure class="highlight ts"><figcaption data-lang="TypeScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// src/router/routes.ts</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 使用 TypeScript 时需要导入路由项目的类型声明</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">&#123;</span> RouteRecordRaw <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'vue-router'</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 使用路由项目类型声明一个路由数组</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">const</span> routes<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span>RouteRecordRaw<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">[</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token comment">// ...</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">// 将路由数组导出给其他模块使用</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">export</span> <span class="token keyword">default</span> routes</pre></td></tr></table></figure><p><code>RouteRecordRaw</code> 是路由项目的 TS 类型。</p><p><code>routes</code> 数组中，每一项的组成可以这么写：</p><figure class="highlight ts"><figcaption data-lang="TypeScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> routes<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span>RouteRecordRaw<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">[</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    path<span class="token operator">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    alias<span class="token operator">:</span> <span class="token string">'/index'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    name<span class="token operator">:</span> <span class="token string">'home'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'@views/home.vue'</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    children<span class="token operator">:</span> <span class="token punctuation">[</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            path<span class="token operator">:</span> <span class="token string">'login'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            name<span class="token operator">:</span> <span class="token string">'auth-login'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'@/components/welcome/LoginPage.vue'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            path<span class="token operator">:</span> <span class="token string">'register'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            name<span class="token operator">:</span> <span class="token string">'auth-register'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'@/components/welcome/RegisterPage.vue'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">]</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">]</span></pre></td></tr></table></figure><ul><li><p><code>path</code> 是路由的访问路径，如果域名是 <code>https://example.com</code> ， 配置为 <code>/home</code> ，那么访问路径就是 <code>https://example.com/home</code> 。</p></li><li><p><code>alias</code> 可以为路由指定一个别名，这样用户既可以通过 <code>/</code> 访问首页，也可以通过 <code>/index</code> 访问首页。</p></li><li><p><code>name</code> 是路由的名称，非必填，但是一般都会配置上去，这样可以很方便的通过 <code>name</code> 来代替 <code>path</code> 实现路由的跳转，因为像有时候的开发环境和生产环境的路径不一致，或者说路径变更，通过 <code>name</code> 无需调整，但如果通过 <code>path</code> ，可能就要修改很多文件里面的链接跳转目标了。</p></li><li><p><code>component</code> 是路由的模板文件，指向一个 vue 组件，用于指定路由在浏览器端的视图渲染，这里有两种方式来指定使用哪个组件</p><ul><li><p>同步组件：直接接收一个变量，变量的值就是对于的模板组件，在打包的时候，会把组件的所有代码都打包到一个文件里，对于大项目来说，这种方式的首屏加载是个灾难，要面对文件过大带来等待时间变长的问题。</p></li><li><p>异步组件： <code>component</code> 接收一个<strong>函数</strong>，在 return 的时候返回模板组件，同时组件里的代码在打包的时候都会生成独立的文件，并在访问到对应路由的时候按需引入。上面的代码就是异步的路由懒加载。</p></li></ul></li><li><p>然后每一项其实还有一个参数为 children，每一个 childre 的值又是一个 <code>routes</code> ，从而形成路由树。</p></li></ul><p>路由组件必须在父级组件里带有 <code>&lt;router-view/&gt;</code> 标签中，一级路由的父级组件就是 <code>src/App.vue</code> 这个根组件，直接这么写：</p><pre><code class="language-vue">&lt;template&gt;
  &lt;router-view /&gt;
&lt;/template&gt;
</code></pre><p>如果站点带有全局公共组件，比如有全站统一的页头、页脚，只有中间区域才是路由，那么可以这样配置：</p><pre><code class="language-vue">&lt;template&gt;
  &lt;!-- 全局页头 --&gt;
  &lt;Header /&gt;

  &lt;!-- 路由 --&gt;
  &lt;router-view /&gt;

  &lt;!-- 全局页脚 --&gt;
  &lt;Footer /&gt;
&lt;/template&gt;
</code></pre><p>如果有一部分路由带公共组件，一部分没有，比如大部分页面都需要有侧边栏，但登录页、注册页不需要，就可以这么处理：</p><pre><code class="language-vue">&lt;template&gt;
  &lt;!-- 登录 --&gt;
  &lt;Login v-if=&quot;route.name === 'login'&quot; /&gt;

  &lt;!-- 注册 --&gt;
  &lt;Register v-else-if=&quot;route.name === 'register'&quot; /&gt;

  &lt;!-- 带有侧边栏的其他路由 --&gt;
  &lt;div v-else&gt;
    &lt;!-- 固定在左侧的侧边栏 --&gt;
    &lt;Sidebar /&gt;

    &lt;!-- 路由 --&gt;
    &lt;router-view /&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre><p>其他页面使用 <code>router</code> 来进行路由跳转：</p><figure class="highlight ts"><figcaption data-lang="TypeScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useRouter <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'vue-router'</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token function">useRouter</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 跳转</span></pre></td></tr><tr><td data-num="6"></td><td><pre>router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    name<span class="token operator">:</span> <span class="token string">'home'</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// 或者：router.push ('/home')，直接使用 path 进行跳转</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">// 返回上一页</span></pre></td></tr><tr><td data-num="12"></td><td><pre>router<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>如果路由的 ts 文件已经定义好了 router，也可以直接导入 router，就不需要使用 <code>useRouter</code> 。</p><p>除了使用 <code>router</code> 属性以外，还可以使用 <code>&lt;router-link&gt;</code> 标签：</p><pre><code class="language-vue">&lt;template&gt;
  &lt;router-link to=&quot;/home&quot;&gt;首页&lt;/router-link&gt;
&lt;/template&gt;
</code></pre><p>该标签编译后会默认转换为 <code>a</code> 标签，如果想让其变为其他标签，在 vue2 中可以使用 <code>tag</code> 属性：</p><pre><code class="language-vue">&lt;template&gt;
  &lt;router-link tag=&quot;span&quot; to=&quot;/home&quot;&gt;首页&lt;/router-link&gt;
&lt;/template&gt;
</code></pre><p>在 vue3 中去除了 <code>tag</code> 属性，所以需要通过 <code>custom</code> 和 <code>v-slot</code> 的配合将其渲染为其他标签。</p><pre><code class="language-vue">&lt;template&gt;
  &lt;router-link to=&quot;/home&quot; custom v-slot=&quot;&#123; navigate &#125;&quot;&gt;
    &lt;span class=&quot;link&quot; @click=&quot;navigate&quot;&gt; 首页 &lt;/span&gt;
  &lt;/router-link&gt;
&lt;/template&gt;
</code></pre><p>解释：</p><ul><li><code>custom</code> ，一个布尔值，用于控制是否需要渲染为 <code>a</code> 标签，当不包含 <code>custom</code> 或者把 <code>custom</code> 设置为 <code>false</code> 时，则依然使用 <code>a</code> 标签渲染。</li><li><code>v-slot</code> 是一个对象，用来决定标签的行为，它包含了：</li></ul><table><thead><tr><th style="text-align:left">字段</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">href</td><td style="text-align:left">解析后的 URL，将会作为一个 <code>a</code> 元素的 <code>href</code> 属性</td></tr><tr><td style="text-align:left">route</td><td style="text-align:left">解析后的规范化的地址</td></tr><tr><td style="text-align:left">navigate</td><td style="text-align:left">触发导航的函数，会在必要时自动阻止事件，和 <code>router-link</code> 同理</td></tr><tr><td style="text-align:left">isActive</td><td style="text-align:left">如果需要应用激活的 <code>class</code> 则为 <code>true</code> ，允许应用一个任意的 <code>class</code></td></tr><tr><td style="text-align:left">isExactActive</td><td style="text-align:left">如果需要应用精确激活的 <code>class</code> 则为 <code>true</code> ，允许应用一个任意的 <code>class</code></td></tr></tbody></table><p>对于重定向，在路由数组中使用 <code>redirect</code> 属性即可：</p><figure class="highlight ts"><figcaption data-lang="TypeScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> routes<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span>RouteRecordRaw<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">[</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    path<span class="token operator">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    name<span class="token operator">:</span> <span class="token string">'home'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'@views/home.vue'</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    meta<span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      title<span class="token operator">:</span> <span class="token string">'Home'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  </pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    path<span class="token operator">:</span> <span class="token string">'/error'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    redirect<span class="token operator">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token comment">// 访问这个路由会被重定向到首页</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">]</span></pre></td></tr></table></figure><p>我们也可以单独写一个 404 路由页面来替代站内的跳转：</p><figure class="highlight ts"><figcaption data-lang="TypeScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> routes<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span>RouteRecordRaw<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">[</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 只要访问到不存在的路由，就会显示为这个 404 模板</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    path<span class="token operator">:</span> <span class="token string">'/:pathMatch(.*)*'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    name<span class="token operator">:</span> <span class="token string">'404'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'@views/404.vue'</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">]</span></pre></td></tr></table></figure><p>这种重定向也可以带一些参数：</p><figure class="highlight ts"><figcaption data-lang="TypeScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    path<span class="token operator">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    redirect<span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      name<span class="token operator">:</span> <span class="token string">'home'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      query<span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        from<span class="token operator">:</span> <span class="token string">'redirect'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// 相当于访问地址为： https://example.com/home?from=redirect</span></pre></td></tr></table></figure><p><code>redirect</code> 的值也可以是一个函数：</p><figure class="highlight ts"><figcaption data-lang="TypeScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function-variable function">redirect</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// `loginInfo` 是当前用户的登录信息</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 可以从 `localStorage` 或者 `Pinia` 读取</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> groupId <span class="token punctuation">&#125;</span> <span class="token operator">=</span> loginInfo</pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 根据组别 ID 进行跳转</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>groupId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token comment">// 管理员跳去仪表盘</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">return</span> <span class="token string">'/dashboard'</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token comment">// 普通用户跳去首页</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">return</span> <span class="token string">'/home'</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token comment">// 其他都认为未登录，跳去登录页</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">default</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token keyword">return</span> <span class="token string">'/login'</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>路由中也有一些全局钩子用于在跳转（前、后）时处理一些工作：</p><table><thead><tr><th style="text-align:left">可用钩子</th><th style="text-align:left">含义</th><th style="text-align:left">触发时机</th></tr></thead><tbody><tr><td style="text-align:left">beforeEach</td><td style="text-align:left">全局前置守卫</td><td style="text-align:left">在路由跳转前触发</td></tr><tr><td style="text-align:left">beforeResolve</td><td style="text-align:left">全局解析守卫</td><td style="text-align:left">在导航被确认前，同时在组件内守卫和异步路由组件被解析后</td></tr><tr><td style="text-align:left">afterEach</td><td style="text-align:left">全局后置守卫</td><td style="text-align:left">在路由跳转完成后触发</td></tr></tbody></table><figure class="highlight ts"><figcaption data-lang="TypeScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 创建路由</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token function">createRouter</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token operator">...</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 在这里调用导航守卫的钩子函数</span></pre></td></tr><tr><td data-num="5"></td><td><pre>router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> from<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token comment">// ...</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>有一些参数：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">to</td><td style="text-align:left">即将要进入的路由对象</td></tr><tr><td style="text-align:left">from</td><td style="text-align:left">当前导航正要离开的路由</td></tr></tbody></table><p>在 vue2 中第三个参数是 next，用于操作路由接下来的跳转，但是新版本路由里，已经通过 RFC 将其删除，虽然目前还是作为可选参数使用，但以后不确定是否会移除，不建议继续使用。新版本路由可以通过 <code>return</code> 来代替 <code>next</code> 。</p><figure class="highlight ts"><figcaption data-lang="TypeScript"></figcaption><table><tr><td data-num="1"></td><td><pre>router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> from<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> isNoLogin <span class="token punctuation">&#125;</span> <span class="token operator">=</span> to<span class="token punctuation">.</span>meta</pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isNoLogin<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">'/login'</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p><code>isNoLogin</code> 有 <code>&#123;&#125;</code> 是因为它是一个对象属性，需要使用解构语法来获取它的值</p><p>当然也有独享的路由钩子， <code>beforeEnter</code> 和 <code>beforeResolve</code> 。</p><h3 id="组件通信"><a class="anchor" href="#组件通信">#</a> 组件通信</h3><p>父子组件之间的通信方式包括：</p><ul><li>props/emits</li><li>v-model/emits</li><li>ref/emits</li></ul><p>第一种，子组件使用 <code>props</code> 入参来获取父组件传过来的值：</p><figure class="highlight ts"><figcaption data-lang="TypeScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Child.vue</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineComponent</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  props<span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    title<span class="token operator">:</span> String<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    index<span class="token operator">:</span> Number<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    userName<span class="token operator">:</span> String<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    uid<span class="token operator">:</span> Number<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token comment">// 在这里需要添加一个入参</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token function">setup</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">// 该入参包含了当前组件定义的所有 props</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr></table></figure><blockquote><p>如果父组件 Father.vue 传进来的数据在 Child.vue 里未定义，不仅不会拿到，并且在控制台会有警告信息。</p></blockquote><p>v-model 更为简单，操作上简化了，但是副作用就是功能上没有 props 那么多。</p><h2 id="nodejs入门"><a class="anchor" href="#nodejs入门">#</a> Node.js 入门</h2><p>Node.js （简称 Node ） 是一个基于 Chrome V8 引擎构建的 JS 运行时（ JavaScript Runtime ）。它让 JavaScript 代码不再局限于网页上，还可以跑在客户端、服务端等场景，极大的推动了前端开发的发展，现代的前端开发几乎都离不开 Node 。</p><p>Runtime ，可以叫它 “运行时” 或者 “运行时环境” ，这个概念是指，项目的代码在哪里运行，哪里就是运行时。</p><p>传统的 JavaScript 只能跑在浏览器上，每个浏览器都为 JS 提供了一个运行时环境，可以简单的把浏览器当成一个 Runtime ，明白了这一点，相信就能明白什么是 Node 。</p><p>Node 就是一个让 JS 可以脱离浏览器运行的环境，当然，这里并不是说 Node 就是浏览器。</p><p>虽然 Node 也是基于 Chrome V8 引擎构建，但它并不是一个浏览器，它提供了一个完全不一样的运行时环境，没有 Window 、没有 Document 、没有 DOM 、没有 Web API ，没有 UI 界面…</p><p>但它提供了很多浏览器做不到的能力，比如和操作系统的交互，例如 “文件读写” 这样的操作在浏览器有诸多的限制，而在 Node 则轻轻松松。</p><p>对于前端开发者来说， Node 的巨大优势在于，使用一种语言就可以编写所有东西（前端和后端），不再花费很多精力去学习各种各样的开发语言。</p><p>哪怕仅仅只做 Web 开发，也不再需要顾虑新的语言特性在浏览器上的兼容性（ e.g. ES6 、 ES7 、 ES8 、 ES9 …）， Node 配合构建工具，以及诸如 Babel 这样的代码编译器，可以帮转换为浏览器兼容性最高的 ES5 。</p><p>查看你的 node.js 版本： <code>node -v</code> 。</p><h3 id="镜像源"><a class="anchor" href="#镜像源">#</a> 镜像源</h3><p>可以先在命令行输入以下命令查看当前的 npm 配置：</p><p>bash</p><pre><code>npm config get registry
# https://registry.npmjs.org/
</code></pre><p>默认情况下，会输出 npm 官方的资源注册表地址，接下来在命令行上输入以下命令，进行镜像源的绑定：</p><pre><code>npm config set registry https://registry.npmmirror.com
</code></pre><p>可以再次运行查询命令来查看是否设置成功：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">npm</span> config get registry</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># https://registry.npmmirror.com/</span></pre></td></tr></table></figure><p>可以看到已经成功更换为中国镜像站的地址了，之后在安装 npm 包的时候，速度会有很大的提升！</p><p>如果需要删除自己配置的镜像源，可以输入以下命令进行移除，移除后会恢复默认设置：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">npm</span> config <span class="token function">rm</span> registry</pre></td></tr></table></figure><blockquote><p>如果之前已经绑定过 <code>npm.taobao</code> 系列域名，也请记得更换成 <code>npmmirror</code> 这个新的域名！随着新的域名已经正式启用，老 <code>npm.taobao.org</code> 和 <code>registry.npm.taobao.org</code> 域名在 2022 年 05 月 31 日零时后不再提供服务。</p></blockquote><h3 id="初始化项目"><a class="anchor" href="#初始化项目">#</a> 初始化项目</h3><p>在项目所在目录打开命令行：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">npm</span> init</pre></td></tr></table></figure><p>之后命令行会输出一些提示，比如：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>package name: <span class="token punctuation">(</span>demo<span class="token punctuation">)</span> hello-node</pre></td></tr></table></figure><p><code>package name</code> 是问题的题干，会询问要输入什么内容，直接回车就是默认值，等所有都填完后，会输出以下信息：</p><figure class="highlight json"><figcaption data-lang="JSON"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"hello-node"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"1.0.0"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"A demo about Node.js"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token property">"main"</span><span class="token operator">:</span> <span class="token string">"index.js"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token property">"test"</span><span class="token operator">:</span> <span class="token string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token property">"author"</span><span class="token operator">:</span> <span class="token string">"cyan"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token property">"license"</span><span class="token operator">:</span> <span class="token string">"MIT"</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>Is this OK? (yes)</pre></td></tr></table></figure><p>也可以直接加上 <code>-y</code> 参数，这样会以 Node 推荐的答案帮快速生成项目信息。而这些信息就成为 json 文件，保存在项目的 package.json 文件中</p><p>除了手动维护这些信息之外，在安装 npm 包等操作时， Node 也会帮写入数据到这个文件里，来了解一些常用字段的含义：</p><table><thead><tr><th style="text-align:center">字段名</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:center">name</td><td style="text-align:left">项目名称，如果打算发布成 npm 包，它将作为包的名称</td></tr><tr><td style="text-align:center">version</td><td style="text-align:left">项目版本号，如果打算发布成 npm 包，这个字段是必须的，遵循 <span class="exturl" data-url="aHR0cHM6Ly92dWUzLmNoZW5ncGVpcXVhbi5jb20vZ3VpZGUuaHRtbCMlRTglQUYlQUQlRTQlQjklODklRTUlOEMlOTYlRTclODklODglRTYlOUMlQUMlRTUlOEYlQjclRTclQUUlQTElRTclOTAlODY=">语义化版本号</span> 的要求</td></tr><tr><td style="text-align:center">description</td><td style="text-align:left">项目的描述</td></tr><tr><td style="text-align:center">keywords</td><td style="text-align:left">关键词，用于在 npm 网站上进行搜索</td></tr><tr><td style="text-align:center">homepage</td><td style="text-align:left">项目的官网 URL</td></tr><tr><td style="text-align:center">main</td><td style="text-align:left">项目的入口文件</td></tr><tr><td style="text-align:center">scripts</td><td style="text-align:left">指定运行脚本的命令缩写，常见的如 <code>npm run build</code> 等命令就在这里配置，详见 <span class="exturl" data-url="aHR0cHM6Ly92dWUzLmNoZW5ncGVpcXVhbi5jb20vZ3VpZGUuaHRtbCMlRTglODQlOUElRTYlOUMlQUMlRTUlOTElQkQlRTQlQkIlQTQlRTclOUElODQlRTklODUlOEQlRTclQkQlQUU=">脚本命令的配置</span></td></tr><tr><td style="text-align:center">author</td><td style="text-align:left">作者信息</td></tr><tr><td style="text-align:center">license</td><td style="text-align:left">许可证信息，可以选择适当的许可证进行开源</td></tr><tr><td style="text-align:center">dependencies</td><td style="text-align:left">记录当前项目的生产依赖，安装 npm 包时会自动生成，详见：<span class="exturl" data-url="aHR0cHM6Ly92dWUzLmNoZW5ncGVpcXVhbi5jb20vZ3VpZGUuaHRtbCMlRTQlQkUlOUQlRTglQjUlOTYlRTUlOEMlODUlRTUlOTIlOEMlRTYlOEYlOTIlRTQlQkIlQjY=">依赖包和插件</span></td></tr><tr><td style="text-align:center">devDependencies</td><td style="text-align:left">记录当前项目的开发依赖，安装 npm 包时会自动生成，详见：<span class="exturl" data-url="aHR0cHM6Ly92dWUzLmNoZW5ncGVpcXVhbi5jb20vZ3VpZGUuaHRtbCMlRTQlQkUlOUQlRTglQjUlOTYlRTUlOEMlODUlRTUlOTIlOEMlRTYlOEYlOTIlRTQlQkIlQjY=">依赖包和插件</span></td></tr><tr><td style="text-align:center">type</td><td style="text-align:left">配置 Node 对 CJS 和 ESM 的支持</td></tr></tbody></table><h3 id="项目命名规则"><a class="anchor" href="#项目命名规则">#</a> 项目命名规则</h3><p>如果打算发布成 npm 包，它将作为包的名称，可以是普通包名，也可以是范围包的包名。</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:left">释义</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:center">范围包</td><td style="text-align:left">具备 <code>@scope/project-name</code> 格式，一般有一系列相关的开发依赖之间会以相同的 scope 进行命名</td><td style="text-align:left">如 <code>@vue/cli</code> 、 <code>@vue/cli-service</code> 就是一系列相关的范围包</td></tr><tr><td style="text-align:center">普通包</td><td style="text-align:left">其他命名都属于普通包</td><td style="text-align:left">如 <code>vue</code> 、 <code>vue-router</code></td></tr></tbody></table><p>包名有一定的书写规则：</p><ul><li>名称必须保持在 1 ~ 214 个字符之间（包括范围包的 <code>@scope/</code> 部分）</li><li>只允许使用小写字母、下划线、短横线、数字、小数点（并且只有范围包可以以点或下划线开头）</li><li>包名最终成为 URL 、命令行参数或者文件夹名称的一部分，所以名称不能包含任何非 URL 安全字符</li></ul><p>想要查询包名是否存在： <code>npm view &lt;package-name&gt;</code></p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>vue@3.3.4 <span class="token operator">|</span> MIT <span class="token operator">|</span> deps: <span class="token number">5</span> <span class="token operator">|</span> versions: <span class="token number">445</span></pre></td></tr><tr><td data-num="2"></td><td><pre>The progressive JavaScript framework <span class="token keyword">for</span> building modern web UI.</pre></td></tr><tr><td data-num="3"></td><td><pre>https://github.com/vuejs/core/tree/main/packages/vue<span class="token comment">#readme</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>keywords: vue</pre></td></tr></table></figure><p>如果该包名不存在，就会返回 404 信息</p><h3 id="版本号格式与升级规则"><a class="anchor" href="#版本号格式与升级规则">#</a> 版本号格式与升级规则</h3><blockquote><p>超级重要的常识</p></blockquote><p>版本号的格式为： <code>Major.Minor.Patch</code> （简称 <code>X.Y.Z</code> ），它们的含义和升级规则如下：</p><table><thead><tr><th style="text-align:center">英文</th><th style="text-align:center">中文</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:center">Major</td><td style="text-align:center">主版本号</td><td style="text-align:left">当项目作了大量的变更，与旧版本存在一定的不兼容问题</td></tr><tr><td style="text-align:center">Minor</td><td style="text-align:center">次版本号</td><td style="text-align:left">做了向下兼容的功能改动或者少量功能更新</td></tr><tr><td style="text-align:center">Patch</td><td style="text-align:center">修订号</td><td style="text-align:left">修复上一个版本的少量 BUG</td></tr></tbody></table><p>一般情况下，三者均为正整数，并且从 <code>0</code> 开始，遵循这三条注意事项：</p><ul><li>当主版本号升级时，次版本号和修订号归零</li><li>当次版本号升级时，修订号归零，主版本号保持不变</li><li>当修订号升级时，主版本号和次版本号保持不变</li></ul><p>下面以一些常见的例子帮助快速理解版本号的升级规则：</p><ul><li>如果不打算发布，可以默认为 <code>0.0.0</code> ，代表它不是一个进入发布状态的包</li><li>在正式发布之前，可以将其设置为 <code>0.1.0</code> 发布第一个<strong>测试版本</strong>，自此，代表已进入发布状态，但还处于初期开发阶段，这个阶段可能经常改变 API ，但不需要频繁的更新主版本号</li><li>在 <code>0.1.0</code> 发布后，修复了 BUG ，下一个版本号将设置为 <code>0.1.1</code> ，即更新了一个修订号</li><li>在 <code>0.1.1</code> 发布后，有<strong>新的功能发布</strong>，下一个版本号可以升级为 <code>0.2.0</code> ，即更新了一个次版本号</li><li>当觉得这个项目已经功能稳定、没有什么 BUG 了，决定正式发布并给用户使用时，那么就可以进入了 <code>1.0.0</code> 正式版了</li></ul><p><code>npm run dev</code> 、 <code>npm run build</code> 是什么？其实就是运行 <code>package.json</code> 文件中的 <code>scripts</code> 里的内容：</p><figure class="highlight json"><figcaption data-lang="JSON"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token property">"test"</span><span class="token operator">:</span> <span class="token string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token property">"dev"</span><span class="token operator">:</span> <span class="token string">"node index"</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>假设内容如上，执行 <code>npm run dev</code> 就会执行 <code>node index</code> 命令，执行 <code>npm run test</code> 就会执行 <code>echo</code> 。这里我们在项目下创建一个 <code>index.js</code> ，并写入：</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"===="</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>然后执行 <code>npm run dev</code> ，就会在控制台打印 &quot;====&quot;，所以 <code>npm run</code> 后面接的参数是什么不重要，它只是 <code>scripts</code> 里对应 <code>key</code> 的 <code>value</code> 的映射。</p><h3 id="module"><a class="anchor" href="#module">#</a> Module</h3><p>软工里有个原则：单一职责，一个完整业务应该是各种高内聚的模块组合到一起，每个单一职责的代码块就叫做模块（Module）。</p><ul><li>ESM （ ES Module ） 是 JavaScript 在 ES6（ ECMAScript 2015 ）版本推出的模块化标准，旨在成为浏览器和服务端通用的模块解决方案。</li><li>CJS （ CommonJS ） 原本是服务端的模块化标准（设计之初也叫 ServerJS ），是为 JavaScript 设计的用于浏览器之外的一个模块化方案， Node 默认支持了该规范，在 Node 12 之前也只支持 CJS ，但从 Node 12 开始，已经同时支持 ES Module 的使用。（老项目还是可能会遇到）</li></ul><blockquote><p>一个独立的文件就是一个模块，该文件内部的变量必须通过导出才能被外部访问到，而外部文件想访问这些变量，需要导入对应的模块才能生效。</p></blockquote><h3 id="cjs设计模块"><a class="anchor" href="#cjs设计模块">#</a> CJS 设计模块</h3><p>先调整一下目录结构：</p><ol><li>删掉 <code>index.js</code> 文件</li><li>创建一个 <code>src</code> 文件夹，在里面再创建一个 <code>cjs</code> 文件夹</li><li>在 <code>cjs</code> 文件夹里面创建两个文件： <code>index.cjs</code> 和 <code>module.cjs</code></li></ol><blockquote><p>使用了 <code>.cjs</code> 文件扩展名，其实它也是 JS 文件，但这个扩展名是 Node 专门为 CommonJS 规范设计的</p></blockquote><p>再改一下 <code>scripts</code> 里的内容：</p><figure class="highlight json"><figcaption data-lang="JSON"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token property">"dev:cjs"</span><span class="token operator">:</span> <span class="token string">"node src/cjs/index.cjs"</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>cjs</code> 使用 <code>module.exports</code> 导出，使用 <code>require</code> 导入：</p><ul><li>在 <code>module.cjs</code> 写入代码：</li></ul><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// src/cjs/module.cjs</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token string">'Hello World from bar.'</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// 导出</span></pre></td></tr><tr><td data-num="9"></td><td><pre>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  foo<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  bar</pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>在 <code>index.js</code> 写入代码：</li></ul><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// src/cjs/index.cjs</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">const</span> m <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./module.cjs'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span></pre></td></tr></table></figure><p>运行之后会发现 m 其实是一个对象，也就是 <code>module.cjs</code> 模块抽象出来的对象，需要通过 <code>m.foo()</code> 、 <code>m.bar</code> 的形式才可以拿到值。</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> m <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./module.cjs'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>m<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>m<span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token string">'after change bar'</span></pre></td></tr><tr><td data-num="5"></td><td><pre>m<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 结果都是 This is bar.</span></pre></td></tr></table></figure><p>也可以这样：</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// src/cjs/index.cjs</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> foo2<span class="token punctuation">,</span> bar <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./module.cjs'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">foo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span></pre></td></tr></table></figure><p>这里注意 <code>foo: foo2</code> ，可以直接写成 <code>foo</code> ，前者是为了重命名，避免模块多了命名冲突</p><h3 id="esm设计模块"><a class="anchor" href="#esm设计模块">#</a> ESM 设计模块</h3><p>不过因为历史原因，如果要直接在浏览器里使用该方案，在不同的浏览器里会有一定的兼容问题，因此一般情况下都需要借助<strong>构建工具</strong>进行开发，工具通常会提供开箱即用的本地服务器用于开发调试，并且最终打包的时候还可以抹平不同浏览器之间的差异。</p><p>esm 的默认导出为： <code>export default</code> ；命名导出为 <code>export</code> 。默认导出的意思是，一个模块只包含一个值；而导入默认值则意味着，导入时声明的变量名就是对应模块的值。</p><p>使用 <code>import ... from ...</code> 导入模块，在导入的时候，如果文件扩展名是 <code>.js</code> 则可以省略文件名后缀，否则需要把扩展名也完整写出来。</p><h4 id="默认导出和导入"><a class="anchor" href="#默认导出和导入">#</a> 默认导出和导入</h4><p>在 <code>module.mjs</code> 写入：</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// src/esm/module.mjs</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token string">'Hello World'</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 如果是 cjs，其实就是 module.exports = 'Hello World'</span></pre></td></tr></table></figure><p>然后在 <code>index.mjs</code> 中写入：</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// src/esm/index.mjs</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">import</span> m <span class="token keyword">from</span> <span class="token string">'./module.mjs'</span></pre></td></tr><tr><td data-num="3"></td><td><pre>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span></pre></td></tr></table></figure><h4 id="命名导出和导入"><a class="anchor" href="#命名导出和导入">#</a> 命名导出和导入</h4><p>命名导出： <code>export const bar = 'xx'</code> ，不论是变量还是函数，直接加上 <code>export</code> 即可。</p><p>命名导入：</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// src/esm/index.mjs</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">import</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  foo <span class="token keyword">as</span> foo2<span class="token punctuation">,</span>  <span class="token comment">// 这里进行了重命名</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  bar</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./module.mjs'</span></pre></td></tr></table></figure><h3 id="依赖包和插件"><a class="anchor" href="#依赖包和插件">#</a> 依赖包和插件</h3><p>项目的依赖建议优先选择本地安装（项目中的 node_module 目录），这是因为本地安装可以把依赖列表记录到 package.json 里，多人协作的时候可以减少很多问题出现，特别是当本地依赖与全局依赖版本号不一致的时候。</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">--save</span> <span class="token operator">&lt;</span>package-name<span class="token operator">></span>@<span class="token operator">&lt;</span>version <span class="token operator">|</span> tag<span class="token operator">></span></pre></td></tr></table></figure><blockquote><p>需要提前在命令行 <code>cd</code> 到的项目目录下再执行安装。另外， <code>--save</code> 或者 <code>-S</code> 选项在实际使用的时候可以省略，因为它是默认选项。</p></blockquote><p>可以在项目的 <code>package.json</code> 文件里的 <code>dependencies</code> 字段查看是否已安装成功，例如：</p><figure class="highlight json"><figcaption data-lang="JSON"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// package.json</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 生产依赖包会被安装到项目根目录下的 node_modules 目录里。</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token comment">// 生产依赖包： --save</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token property">"dependencies"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 以 "包名"："版本号" 的格式写入</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token property">"vue-router"</span><span class="token operator">:</span> <span class="token string">"^4.0.14"</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token comment">// 开发依赖包: --save-dev/-D</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token property">"devDependencies"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">// 以 "包名"："版本号" 的格式写入</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token property">"eslint"</span><span class="token operator">:</span> <span class="token string">"^8.6.0"</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>开发依赖包和生产依赖包不同的点在于，只在开发环境生效，构建部署到生产环境时可能会被抛弃，一些只在开发环境下使用的包，就可以安装到开发依赖里，比如检查代码是否正确的 <code>ESLint</code> 就可以用这个方式安装。</p><p>至于<strong>全局安装</strong>，也就类似于 <code>@vue/cli</code> 、 <code>create-preset</code> 之类的脚手架会提供全局安装的服务，安装后，就可以使用 <code>vue create xxx</code> 等命令直接创建 Vue 项目了。</p><h3 id="一些命令"><a class="anchor" href="#一些命令">#</a> 一些命令</h3><ul><li><p>版本升级： <code>npm update</code></p></li><li><p>本地卸载： <code>npm uninstall &lt;package-name&gt;</code></p></li><li><p>全局卸载： <code>npm uninstall --global &lt;package-name&gt;</code></p></li></ul><h2 id="babel"><a class="anchor" href="#babel">#</a> Babel</h2><p>Babel 是一个 JavaScript 编译器，它可以让开发者仅需维护一份简单的 JSON 配置文件，即可调动一系列工具链<strong>将源代码编译为目标浏览器指定版本所支持的语法</strong>。</p><p>详细参考：<span class="exturl" data-url="aHR0cHM6Ly92dWUzLmNoZW5ncGVpcXVhbi5jb20vZ3VpZGUuaHRtbCNiYWJlbC0lRTclOUElODQlRTQlQkQlQkYlRTclOTQlQTglRTUlOTIlOEMlRTklODUlOEQlRTclQkQlQUU=">Babel 的使用和配置</span></p><h2 id="typescript"><a class="anchor" href="#typescript">#</a> TypeScript</h2><p>既是一门新语言，有是 JS 的一个超集，它是在 JavaScript 的基础上增加了一套类型系统，它支持所有的 JS 语句，为工程化开发而生，最终在编译的时候去掉<strong>类型</strong>和特有的语法，生成 JS 代码。</p><p>强类型语言，我焯，爽。</p><h3 id="新建项目"><a class="anchor" href="#新建项目">#</a> 新建项目</h3><p><code>src</code> 文件夹下创建一个 <code>ts</code> 文件夹，并在 <code>ts</code> 下创建 <code>index.ts</code> ：</p><figure class="highlight ts"><figcaption data-lang="TypeScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// src/ts/index.ts</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">function</span> <span class="token function">getFirstWord</span><span class="token punctuation">(</span>msg<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">getFirstWord</span><span class="token punctuation">(</span><span class="token string">'Hello World'</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>然后安装两个依赖包：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">-D</span> typescript ts-node</pre></td></tr></table></figure><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdHlwZXNjcmlwdA==">typescript</span> 这个包是用 TypeScript 编程的语言依赖包</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdHMtbm9kZQ==">ts-node</span> 是让 Node 可以运行 TypeScript 的执行环境</li></ul><p>这次添加了一个 <code>-D</code> 参数，因为 TypeScript 和 TS-Node 是开发过程中使用的依赖，所以将其添加到 package.json 的 <code>devDependencies</code> 字段里。</p><p>修改 scripts 字段，增加一个 <code>dev:ts</code> 的 script ：</p><figure class="highlight json"><figcaption data-lang="JSON"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token property">"dev:cjs"</span><span class="token operator">:</span> <span class="token string">"node src/cjs/index.cjs"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token property">"dev:esm"</span><span class="token operator">:</span> <span class="token string">"node src/esm/index.mjs"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token property">"dev:ts"</span><span class="token operator">:</span> <span class="token string">"ts-node src/ts/index.ts"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token property">"compile"</span><span class="token operator">:</span> <span class="token string">"babel src/babel --out-dir compiled"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token property">"serve"</span><span class="token operator">:</span> <span class="token string">"node server/index.js"</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="原始数据类型"><a class="anchor" href="#原始数据类型">#</a> 原始数据类型</h3><table><thead><tr><th style="text-align:center">原始数据类型</th><th style="text-align:center">JavaScript</th><th style="text-align:center">TypeScript</th></tr></thead><tbody><tr><td style="text-align:center">字符串</td><td style="text-align:center">String</td><td style="text-align:center">string</td></tr><tr><td style="text-align:center">数值</td><td style="text-align:center">Number</td><td style="text-align:center">number</td></tr><tr><td style="text-align:center">布尔值</td><td style="text-align:center">Boolean</td><td style="text-align:center">boolean</td></tr><tr><td style="text-align:center">大整数</td><td style="text-align:center">BigInt</td><td style="text-align:center">bigint</td></tr><tr><td style="text-align:center">符号</td><td style="text-align:center">Symbol</td><td style="text-align:center">symbol</td></tr><tr><td style="text-align:center">不存在</td><td style="text-align:center">Null</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">未定义</td><td style="text-align:center">Undefined</td><td style="text-align:center">undefined</td></tr></tbody></table><p>在 ts 定义变量的类型，不是放在变量名前面，而是后面：</p><figure class="highlight ts"><figcaption data-lang="TypeScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 字符串</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">const</span> str<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">'Hello World'</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 数值</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">const</span> num<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 布尔值</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">const</span> bool<span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">=</span> <span class="token boolean">true</span></pre></td></tr></table></figure><p>至于<strong>数组</strong>的定义：</p><table><thead><tr><th style="text-align:center">数组里的数据</th><th style="text-align:center">类型写法 1</th><th style="text-align:center">类型写法 2</th></tr></thead><tbody><tr><td style="text-align:center">字符串</td><td style="text-align:center"><code>string[]</code></td><td style="text-align:center"><code>Array&lt;string&gt;</code></td></tr><tr><td style="text-align:center">数值</td><td style="text-align:center"><code>number[]</code></td><td style="text-align:center"><code>Array&lt;number&gt;</code></td></tr><tr><td style="text-align:center">布尔值</td><td style="text-align:center"><code>boolean[]</code></td><td style="text-align:center"><code>Array&lt;boolean&gt;</code></td></tr><tr><td style="text-align:center">大整数</td><td style="text-align:center"><code>bigint[]</code></td><td style="text-align:center"><code>Array&lt;bigint&gt;</code></td></tr><tr><td style="text-align:center">符号</td><td style="text-align:center"><code>symbol[]</code></td><td style="text-align:center"><code>Array&lt;symbol&gt;</code></td></tr><tr><td style="text-align:center">不存在</td><td style="text-align:center"><code>null[]</code></td><td style="text-align:center"><code>Array&lt;null&gt;</code></td></tr><tr><td style="text-align:center">未定义</td><td style="text-align:center"><code>undefined[]</code></td><td style="text-align:center"><code>Array&lt;undefined&gt;</code></td></tr></tbody></table><p>一开始如果没有知名数据类型，或者编译器无法通过元素推断出数组类型，比如：</p><figure class="highlight ts"><figcaption data-lang="TypeScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 这个时候会认为是 any [] 或者 never [] 类型</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">const</span> nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 这个时候再 push 一个 number 数据进去，也不会使其成为 number []</span></pre></td></tr><tr><td data-num="5"></td><td><pre>nums<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h3 id="对象接口"><a class="anchor" href="#对象接口">#</a> 对象（接口）</h3><blockquote><p>感觉就是类型的定义</p></blockquote><p>对象的类型定义有两个语法支持： <code>type</code> 和 <code>interface</code> 。</p><figure class="highlight ts"><figcaption data-lang="TypeScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 定义用户对象的类型</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">interface</span> <span class="token class-name">UserItem</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  name<span class="token operator">:</span> <span class="token builtin">string</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token comment">// 这个属性变成了可选</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  age<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// 在声明变量的时候将其关联到类型上</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">const</span> petter<span class="token operator">:</span> UserItem <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  name<span class="token operator">:</span> <span class="token string">'Petter'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  age<span class="token operator">:</span> <span class="token number">20</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>在实际的业务中，有可能会出现一些属性并不是必须的，就像这个年龄，可以将其设置为可选属性，通过添加 <code>?</code> 来定义。</p></blockquote><h3 id="继承"><a class="anchor" href="#继承">#</a> 继承</h3><p>直接用 <code>extends</code> 即可：</p><figure class="highlight ts"><figcaption data-lang="TypeScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 这里继承了 UserItem 的所有属性类型，并追加了一个权限等级属性</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">interface</span> <span class="token class-name">Admin</span> <span class="token keyword">extends</span> <span class="token class-name">UserItem</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  permissionLevel<span class="token operator">:</span> <span class="token builtin">number</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>如果父类有些类型用不上，可以借助 <code>Omit</code> 在继承的时候选择删除：</p><figure class="highlight ts"><figcaption data-lang="TypeScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">type</span> <span class="token class-name">Omit<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">symbol</span><span class="token operator">></span></span></pre></td></tr></table></figure><p><code>T</code> 代表已有的一个对象类型， <code>K</code> 代表要删除的属性名，如果只有一个属性就直接是一个字符串，如果有多个属性，用 <code>|</code> 来分隔开，下面的例子就是删除了两个不需要的属性：</p><figure class="highlight ts"><figcaption data-lang="TypeScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">interface</span> <span class="token class-name">UserItem</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  name<span class="token operator">:</span> <span class="token builtin">string</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  age<span class="token operator">:</span> <span class="token builtin">number</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  enjoyFoods<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  friendList<span class="token operator">?</span><span class="token operator">:</span> UserItem<span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// 这里在继承 UserItem 类型的时候，删除了两个多余的属性</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">interface</span> <span class="token class-name">Admin</span> <span class="token keyword">extends</span> <span class="token class-name">Omit<span class="token operator">&lt;</span>UserItem<span class="token punctuation">,</span> <span class="token string">'enjoyFoods'</span> <span class="token operator">|</span> <span class="token string">'friendList'</span><span class="token operator">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  permissionLevel<span class="token operator">:</span> <span class="token builtin">number</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">// 现在的 admin 就非常精简了</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">const</span> admin<span class="token operator">:</span> Admin <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  name<span class="token operator">:</span> <span class="token string">'Petter'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  age<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  permissionLevel<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="类"><a class="anchor" href="#类">#</a> 类</h3><p>使用 <code>class</code> 关键字：</p><figure class="highlight ts"><figcaption data-lang="TypeScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 定义一个类</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token comment">//constructor 上的数据需要先这样定好类型</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  name<span class="token operator">:</span> <span class="token builtin">string</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token comment">// 入参也要定义类型</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token function">constructor</span><span class="token punctuation">(</span>userName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> userName</pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token comment">// 通过 new 这个类得到的变量，它的类型就是这个类</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token keyword">const</span> petter<span class="token operator">:</span> User <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">'Petter'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>petter<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Petter</span></pre></td></tr></table></figure><h3 id="联合类型"><a class="anchor" href="#联合类型">#</a> 联合类型</h3><p>其实就是通过 <code>|</code> 来联合多种类型：</p><figure class="highlight ts"><figcaption data-lang="TypeScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">counter</span><span class="token punctuation">(</span>count<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">The current count is: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>count<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 不论传数值还是字符串，都可以达到的目的</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">counter</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">// The current count is: 1.</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">counter</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span>  <span class="token comment">// The current count is: 2.</span></pre></td></tr></table></figure><h3 id="异步函数返回值"><a class="anchor" href="#异步函数返回值">#</a> 异步函数返回值</h3><p>对于异步函数，需要用 <code>Promise&lt;T&gt;</code> 类型来定义它的返回值，这里的 <code>T</code> 是泛型，取决于的函数最终返回一个什么样的值（ <code>async / await</code> 也适用这个类型）。</p><figure class="highlight ts"><figcaption data-lang="TypeScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 注意这里的返回值类型</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">function</span> <span class="token function">queryData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Promise</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'Hello World'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token function">queryData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h3 id="type包"><a class="anchor" href="#type包">#</a> @Type 包</h3><p>有些包并不支持 ts，在 ts 文件中使用会报错：</p><figure class="highlight ts"><figcaption data-lang="TypeScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// src/ts/index.ts</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">import</span> md5 <span class="token keyword">from</span> <span class="token string">'md5'</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">md5</span><span class="token punctuation">(</span><span class="token string">'Hello World'</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>这是因为缺少 md5 这个包的类型定义，根据命令行的提示，安装 <code>@types/md5</code> 这个包。这是因为这些包是很早期用 JavaScript 编写的，因为功能够用作者也没有进行维护更新，所以缺少相应的 TS 类型，因此开源社区推出了一套 @types 类型包，专门处理这样的情况。</p><p>@types 类型包的命名格式为 <code>@types/&lt;package-name&gt;</code> ，也就是在原有的包名前面拼接 <code>@types</code> ，日常开发要用到的知名 npm 包都会有相应的类型包，只需要将其安装到 package.json 的 <code>devDependencies</code> 里即可解决该问题。</p><p>以 md5 为例：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">-D</span> @types/md5</pre></td></tr></table></figure><h3 id="编译"><a class="anchor" href="#编译">#</a> 编译</h3><p>但最终可能需要的是一个 JS 文件，比如要通过 <code>&lt;script src&gt;</code> 来放到 HTML 页面里，这就涉及到对 TypeScript 的编译。</p><p>来看看如何把一个 TS 文件编译成 JS 文件，让其从 TypeScript 变成 JavaScript 代码。</p><p>在 package.json 里增加一个 build script，然后执行 <code>npm run build</code> 。</p><figure class="highlight json"><figcaption data-lang="JSON"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token property">"dev:cjs"</span><span class="token operator">:</span> <span class="token string">"node src/cjs/index.cjs"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token property">"dev:esm"</span><span class="token operator">:</span> <span class="token string">"node src/esm/index.mjs"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token property">"dev:ts"</span><span class="token operator">:</span> <span class="token string">"ts-node src/ts/index.ts"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token property">"build"</span><span class="token operator">:</span> <span class="token string">"tsc src/ts/index.ts --outDir dist"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token property">"compile"</span><span class="token operator">:</span> <span class="token string">"babel src/babel --out-dir compiled"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token property">"serve"</span><span class="token operator">:</span> <span class="token string">"node server/index.js"</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr></table></figure><h2 id="构建工具"><a class="anchor" href="#构建工具">#</a> 构建工具</h2><p>为什么以前的前端页面直接编写代码就可以在浏览器访问，现在却还要进行构建编译，是否 “多此一举” ？</p><p>构建工具主要的功能有：</p><ul><li>项目中代码可以复用，抽离成模块、组件，交给构建工具合并打包</li><li>npm 包开箱即用，剩下的工作交给构建工具去按需抽离与合并</li><li>CSS 写起来很慢，可以使用 Sass、Less 等 CSS 预处理器，利用它们的变量支持、混合继承等功能提高开发效率，最终交给构建工具去按需抽离与合并。</li></ul><p>最常见的就是 webpack 和 vite 两种构建器，前者是在项目启动时就打包所有的模块，再启动开发服务器，所以随着项目的模块变多，项目启动也会越慢；Vite 则是按需打包，将打包的部分工作交给了浏览器（支持 ES Module 的浏览器），不需要预先打包，而是直接启动开发服务器，请求（http 请求）到对应的模块的时候在进行编译。所以项目启动更快。</p><p>一般来说，像这种 BS 项目，上线时启动时间并不会影响生产，只是开发者很难受，Vite 是增加了开发者的幸福感。但由于 Vite 是面向现代浏览器，所以如果的项目有兼容低版本浏览器的需求的话，建议还是用 Webpack 来打包，否则，Vite 是目前的更优解。</p><div class="tags"><a href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag"><i class="ic i-tag"></i> 前端</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-06-01 16:21:06" itemprop="dateModified" datetime="2023-06-01T16:21:06+08:00">2023-06-01</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Cyan <i class="ic i-at"><em>@</em></i>慕青の迷途</li><li class="link"><strong>本文链接：</strong> <a href="https://cecilia.cool/2023/05/23/%E5%89%8D%E7%AB%AF/Vue3%E5%85%A5%E9%97%A8/" title="Vue3 发懵到发癫">https://cecilia.cool/2023/05/23/前端/Vue3入门/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/05/23/Tools/VsCode%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/" itemprop="url" rel="prev" data-background-image="http:&#x2F;&#x2F;s3.bmp.ovh&#x2F;imgs&#x2F;2023&#x2F;01&#x2F;19&#x2F;19019c4b5376f609.jpg" title="VsCode使用手册"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>VsCode使用手册</h3></a></div><div class="item right"><a href="/2023/05/24/408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="next" data-background-image="http:&#x2F;&#x2F;s3.bmp.ovh&#x2F;imgs&#x2F;2023&#x2F;01&#x2F;01&#x2F;d51e0450b83fd2b6.jpg" title="操作系统从入门到找不到门"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>操作系统从入门到找不到门</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#vue2"><span class="toc-number">1.</span> <span class="toc-text">Vue2</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue3"><span class="toc-number">2.</span> <span class="toc-text">Vue3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.1.</span> <span class="toc-text">搭建项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">入门教程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9Fdom"><span class="toc-number">2.2.1.</span> <span class="toc-text">虚拟 DOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.2.</span> <span class="toc-text">文件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mpa%E4%B8%8Espa"><span class="toc-number">2.2.3.</span> <span class="toc-text">MPA 与 SPA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#csr-%E4%B8%8E-ssr"><span class="toc-number">2.2.4.</span> <span class="toc-text">CSR 与 SSR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="toc-number">2.2.5.</span> <span class="toc-text">工程化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1"><span class="toc-number">2.2.6.</span> <span class="toc-text">路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">2.2.7.</span> <span class="toc-text">组件通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nodejs%E5%85%A5%E9%97%A8"><span class="toc-number">2.3.</span> <span class="toc-text">Node.js 入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E6%BA%90"><span class="toc-number">2.3.1.</span> <span class="toc-text">镜像源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.3.2.</span> <span class="toc-text">初始化项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-number">2.3.3.</span> <span class="toc-text">项目命名规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E5%8F%B7%E6%A0%BC%E5%BC%8F%E4%B8%8E%E5%8D%87%E7%BA%A7%E8%A7%84%E5%88%99"><span class="toc-number">2.3.4.</span> <span class="toc-text">版本号格式与升级规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#module"><span class="toc-number">2.3.5.</span> <span class="toc-text">Module</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9D%97"><span class="toc-number">2.3.6.</span> <span class="toc-text">CJS 设计模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#esm%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9D%97"><span class="toc-number">2.3.7.</span> <span class="toc-text">ESM 设计模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%AF%BC%E5%87%BA%E5%92%8C%E5%AF%BC%E5%85%A5"><span class="toc-number">2.3.7.1.</span> <span class="toc-text">默认导出和导入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E5%AF%BC%E5%87%BA%E5%92%8C%E5%AF%BC%E5%85%A5"><span class="toc-number">2.3.7.2.</span> <span class="toc-text">命名导出和导入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%8C%85%E5%92%8C%E6%8F%92%E4%BB%B6"><span class="toc-number">2.3.8.</span> <span class="toc-text">依赖包和插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4"><span class="toc-number">2.3.9.</span> <span class="toc-text">一些命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#babel"><span class="toc-number">2.4.</span> <span class="toc-text">Babel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typescript"><span class="toc-number">2.5.</span> <span class="toc-text">TypeScript</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.5.1.</span> <span class="toc-text">新建项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.5.2.</span> <span class="toc-text">原始数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.5.3.</span> <span class="toc-text">对象（接口）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">2.5.4.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">2.5.5.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.5.6.</span> <span class="toc-text">联合类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">2.5.7.</span> <span class="toc-text">异步函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type%E5%8C%85"><span class="toc-number">2.5.8.</span> <span class="toc-text">@Type 包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91"><span class="toc-number">2.5.9.</span> <span class="toc-text">编译</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7"><span class="toc-number">2.6.</span> <span class="toc-text">构建工具</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Cyan" data-src="/images/avatar.png"><p class="name" itemprop="name">Cyan</p><div class="description" itemprop="description">时雨病重症患者</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">149</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">1</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">23</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0N5YW4tTg==" title="https:&#x2F;&#x2F;github.com&#x2F;Cyan-N"><i class="ic i-github"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/05/23/Tools/VsCode%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/05/24/408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2022 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Cyan @ 慕青の迷途</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">608k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">9:12</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/05/23/前端/Vue3入门/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>