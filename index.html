<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.7.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.7.0" type="image/png" sizes="32x32"><meta name="description" content="我始终勇往直前，百折不回...">
<meta property="og:type" content="website">
<meta property="og:title" content="慕青的日记">
<meta property="og:url" content="https://cecilia.cool/index.html">
<meta property="og:site_name" content="慕青的日记">
<meta property="og:description" content="我始终勇往直前，百折不回...">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Cyan">
<meta name="twitter:card" content="summary"><title>慕青的日记 | Cyan</title><link ref="canonical" href="https://cecilia.cool/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.7.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">慕青的日记</div><div class="header-banner-info__subtitle">Cyan</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/10/Java/JVM/JVM(4)-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">JVM(4)--类加载器</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-10</span></span></div></header><div class="post-body"><div class="post-excerpt"><blockquote>
<p>jvm启动的时候，并不会一次性加载所有的class文件，而是根据需要去动态加载。ClassLoader的具体作用就是将class文件加载到jvm虚拟机中去，程序就可以正确运行了。普通的<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://lib.csdn.net/base/javase" >Java</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>开发者其实用到的不多，但对于某些框架开发者来说却非常常见。</p>
</blockquote>

        <h1 id="使用"   >
          <a href="#使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用" class="headerlink" title="使用"></a>使用</h1>
      <blockquote>
<p>看了很多文章，个人觉得先把如何使用类加载器–<code>ClassLoader</code>弄明白，再来讲解原理效果好得多。</p>
</blockquote>
<p><code>class</code>字节码文件，需要使用类加载器加载字节码，即在java中所有类都会通过加载器加载才能运行。下文提到的类似<code>Bootstrap ClassLoader</code>，<code>Extension ClassLoader</code>等，都是JDK自带的，正是这些自带的类加载器，我们才能将源码的class文件加载字节码。</p>

        <h2 id="自定义ClassLoader"   >
          <a href="#自定义ClassLoader" class="heading-link"><i class="fas fa-link"></i></a><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a>自定义ClassLoader</h2>
      <p>核心方法：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loadClass(String className); <span class="comment">// 根据名字加载一个类</span></span><br><span class="line">defineClass(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len); <span class="comment">// 将字节流定义为类</span></span><br><span class="line">findClass(String name); <span class="comment">// 查找一个类</span></span><br><span class="line">findLoaderClass(String name); <span class="comment">// 在已加载的类中，查找一个类</span></span><br><span class="line">resolveClass(链接指定的Java类);</span><br></pre></td></tr></table></div></figure>

<p>比如我们需要动态加载一些东西，或者从C盘某个特定的文件夹加载一个class文件，又或者从网络上下载class主内容然后再进行加载等。分三步搞定：</p>
<ul>
<li>编写一个类继承<code>ClassLoader</code>抽象类。</li>
<li>重写<code>findClass()</code>方法。</li>
<li>在<code>findClass()</code>方法中调用<code>defineClass()</code>方法即可实现自定义<code>ClassLoader</code>。</li>
</ul>
<p>我们先写一个类：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译得到class文件-&gt;写程序将class文件转换为字节流</span></span><br><span class="line"><span class="comment">// InputStream fis = new FileInputStream(&quot;test.class&quot;);</span></span><br><span class="line"><span class="comment">// byte[] bytes = IOUtils.readFully(fis, -1, false);</span></span><br></pre></td></tr></table></div></figure>

<p><img src="https://s3.bmp.ovh/imgs/2022/10/10/67d06fbed9be1513.jpg"></p>
<p>自定义加载器类：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JVM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.IOUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InputStream fis;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] bytes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">testClassname</span> <span class="operator">=</span> <span class="string">&quot;JVM.Test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException,</span><br><span class="line">    		ClassNotFoundException, InstantiationException,</span><br><span class="line">            IllegalAccessException, NoSuchMethodException, </span><br><span class="line">    		InvocationTargetException </span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/JVM/Test.class&quot;</span>);</span><br><span class="line">        bytes = IOUtils.readFully(fis, -<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建加载器</span></span><br><span class="line">        <span class="type">ClassLoaderTest</span> <span class="variable">classloadertest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassLoaderTest</span>();</span><br><span class="line">        <span class="comment">//使用我们自定义的类去加载testClassname</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">aClass</span> <span class="operator">=</span> classloadertest.loadClass(testClassname);</span><br><span class="line">        <span class="comment">//反射创建test类对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">        <span class="comment">//反射获取method方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> o.getClass().getMethod(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">        <span class="comment">//反射去调用执行method方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) method.invoke(o);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//只处理JVM.Test类</span></span><br><span class="line">        <span class="keyword">if</span> (name.equals(testClassname)) &#123;</span><br><span class="line">            <span class="comment">//将一个字节流定义为一个类。</span></span><br><span class="line">            <span class="comment">//其实这个名字可以随便取</span></span><br><span class="line">            <span class="keyword">return</span> defineClass(testClassname, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p><img src="https://s3.bmp.ovh/imgs/2022/10/10/b6c86511a9b493e8.jpg"></p>

        <h1 id="类加载器层次"   >
          <a href="#类加载器层次" class="heading-link"><i class="fas fa-link"></i></a><a href="#类加载器层次" class="headerlink" title="类加载器层次"></a>类加载器层次</h1>
      <p>站在开发人员角度：</p>
<ul>
<li><code>Bootstrap ClassLoader</code>：启动类加载器，无法被Java程序直接引用，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载)。</li>
<li><code>Extension ClassLoader</code>：扩展类加载器，负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。</li>
<li><code>Application ClassLoader</code>：负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<img src="https://s3.bmp.ovh/imgs/2022/10/10/715b39e6e2f34500.jpg" style="zoom:80%;" />

<blockquote>
<p>还可以加入自定义的类加载器，因为JVM自带的ClassLoader只能从本地文件系统加载标准的<code>java.class</code>文件。</p>
</blockquote>
<p>看一个小例子：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pdai.jvm.classloader;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        System.out.println(loader.getParent());</span><br><span class="line">        System.out.println(loader.getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sun.misc.Launcher$AppClassLoader@64fef26a</span></span><br><span class="line"><span class="comment">// sun.misc.Launcher$ExtClassLoader@1ddd40f3</span></span><br><span class="line"><span class="comment">// null</span></span><br></pre></td></tr></table></div></figure>

<p>并没有获取到<code>ExtClassLoader</code>的父Loader，原因是<code>BootstrapLoader</code>(引导类加载器)是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回<code>null</code>。</p>

        <h1 id="类的加载"   >
          <a href="#类的加载" class="heading-link"><i class="fas fa-link"></i></a><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h1>
      <p>类加载有三种方式：</p>
<ul>
<li>启动应用时由JVM初始化加载</li>
<li>通过<code>Class.forName()</code>方法动态加载</li>
<li>通过<code>Class.loader.loadClass()</code>方法动态加载。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException &#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;使用loader.loadClass()：&quot;</span>);</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> Main.class.getClassLoader();</span><br><span class="line">        loader.loadClass(<span class="string">&quot;com.Test&quot;</span>);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 默认执行初始化块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用Class.forName()：&quot;</span>);</span><br><span class="line">        Class.forName(<span class="string">&quot;com.Test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定ClassLoader，初始化不执行静态块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用Class.forName(name,false,loader)：&quot;</span>);</span><br><span class="line">        Class.forName(<span class="string">&quot;com.Test&quot;</span>, <span class="literal">false</span>, loader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态初始化块执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//使用loader.loadClass()：</span></span><br><span class="line"><span class="comment">//使用Class.forName()：</span></span><br><span class="line"><span class="comment">//静态初始化块执行了！</span></span><br><span class="line"><span class="comment">//使用Class.forName(name,false,loader)：</span></span><br></pre></td></tr></table></div></figure>

<blockquote>
<p><code>Class.forName()</code>和<code>ClassLoader.loadClass()</code>区别？</p>
</blockquote>
<ul>
<li><p>Class.forName(): 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</p>
</li>
<li><p><code>ClassLoader.loadClass()</code>：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在<code>newInstance</code>才会去执行static块。</p>
</li>
<li><p><code>Class.forName(name,initialize,loader)</code>：可控制是否加载<code>static</code>块。</p>
</li>
</ul>

        <h1 id="JVM类加载机制"   >
          <a href="#JVM类加载机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h1>
      <p><strong>全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p>
<p><strong>父类委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p>
<p><strong>缓存机制</strong>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p>
<p><strong>双亲委派机制</strong> 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>

        <h2 id="双亲委派"   >
          <a href="#双亲委派" class="heading-link"><i class="fas fa-link"></i></a><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h2>
      <ol>
<li>当<code>AppClassLoader</code>加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<code>ExtClassLoader</code>去完成。</li>
<li>当<code>ExtClassLoader</code>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给<code>BootStrapClassLoader</code>去完成。</li>
<li>如果<code>BootStrapClassLoader</code>加载失败(例如在<code>$JAVA_HOME/jre/lib</code>里未查找到该class)，会使用<code>ExtClassLoader</code>来尝试加载；</li>
<li>若<code>ExtClassLoader</code>也加载失败，则会使用<code>AppClassLoader</code>来加载，如果<code>AppClassLoader</code>也加载失败，则会报出异常<code>ClassNotFoundException</code>。</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name)<span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    								  <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 首先判断该类型是否已经被加载</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果没有被加载，就委托给父类加载或者委派给启动类加载器加载</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果存在父类加载器，就委派给父类加载器加载</span></span><br><span class="line">                c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法</span></span><br><span class="line">                <span class="comment">//native Class findBootstrapClass(String name)</span></span><br><span class="line">                c = findBootstrapClass0(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能</span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/nice0e3/p/13719903.html#0x02--classloader%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8" >Java安全之ClassLoader类加载器</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>.</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javase/keopmg#9995ffcc" >https://www.yuque.com/qingkongxiaguang/javase/keopmg#9995ffcc</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/jvm/java-jvm-classload.htm" >https://pdai.tech/md/java/jvm/java-jvm-classload.htm</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>一个小例子，可以看看：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.freesion.com/article/2178308798/" >https://www.freesion.com/article/2178308798/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>三大类加载器的源码解读：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.bbsmax.com/A/n2d9bO0wzD/" >https://www.bbsmax.com/A/n2d9bO0wzD/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/09/Java/JVM/JVM(3)-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">JVM(3)--类加载机制</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-09</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="类的生命周期"   >
          <a href="#类的生命周期" class="heading-link"><i class="fas fa-link"></i></a><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1>
      <p><img src="https://s3.bmp.ovh/imgs/2022/10/09/167570c48203f9c9.jpg"></p>
<p><code>加载</code>、<code>验证</code>、<code>准备</code>和<code>初始化</code>这四个阶段发生的顺序是确定的，而<code>解析</code>阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定(也成为动态绑定或晚期绑定)。</p>
<blockquote>
<p>这些阶段知识按顺序开始，并不是按顺序结束，这些阶段往往互相交叉混合进行，再一个阶段执行过程中调用或激活另一个阶段。</p>
</blockquote>

        <h1 id="类的加载"   >
          <a href="#类的加载" class="heading-link"><i class="fas fa-link"></i></a><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h1>
      <p>首先介绍几个概念：</p>
<ul>
<li>方法区：JVM实例内部，类型信息被存储在方法区的内存逻辑区中。类型信息是由类加载时从类文件中提取出来的。方法区又叫做静态区，被所有线程共享，方法区包含所有<code>class</code>和<code>static</code>。静态<strong>常量</strong>存放在方法区的常量区中，这之后会讲解。</li>
</ul>
<p>加载阶段虚拟机需要完成：</p>
<ul>
<li>通过类的全限定名（从方法区）来获取其定义的二进制字节流。</li>
<li>字节流代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在Java堆中生成代表这个类的<code>java.lang.Class</code>对象，作为对方法区中这些数据的访问入口。</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/09/842b5cd01faa5b42.jpg"></p>
<p>类加载器不需要等待某个类首次主动使用时在加载，JVM允许预料某个类需要使用时主动加载。在<strong>预加载</strong>中遇到.class文件缺失或存在错误，类加载器必须在程序<strong>首次主动使用</strong>该类时才会报错误–LinkageError。</p>

        <h1 id="连接"   >
          <a href="#连接" class="heading-link"><i class="fas fa-link"></i></a><a href="#连接" class="headerlink" title="连接"></a>连接</h1>
      
        <h2 id="验证"   >
          <a href="#验证" class="heading-link"><i class="fas fa-link"></i></a><a href="#验证" class="headerlink" title="验证"></a>验证</h2>
      <p>确保被加载的类的正确性，也就是Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全。</p>
<blockquote>
<p>如果使用纯Java代码编写的类，编译出来的class文件是相对安全的。但是.class文件并不只是由Java源码编译而来，哪怕用键盘输入01并将文件后缀改为.class都可以，所以验证非常有必要。</p>
</blockquote>
<p>验证阶段的检验动作：</p>
<ul>
<li><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范。（魔数，主次版本，常量的tag标志等）</li>
<li><strong>元数据验证</strong>：对字节码描述的信息进行语义分析。（该类是否继承不可继承的final类，是否覆盖父类的final字段等）</li>
<li><strong>字节码验证</strong>：通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。</li>
<li><strong>符号引用验证</strong>：确保解析动作能正确执行。</li>
</ul>
<blockquote>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
</blockquote>

        <h2 id="准备"   >
          <a href="#准备" class="heading-link"><i class="fas fa-link"></i></a><a href="#准备" class="headerlink" title="准备"></a>准备</h2>
      <p>正式为类变量分配内存并设置类变量<strong>初始值</strong>的阶段，<strong>这些内存都将在方法区中分配</strong>。</p>
<ul>
<li>内存分配的仅包括静态变量，<strong>不包括</strong>实例变量。<strong>实例变量是在对象实例化时随着对象一块分配在Java堆中</strong>。</li>
<li>初始值：<code>0,0L,null,false</code>等。</li>
</ul>
<p>比如某个类由以下语句：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></div></figure>

<p>在准备阶段只会赋值0，将<code>value</code>赋值为3的<code>put static</code>指令存放于<code>&lt;clinit()&gt;</code>方法中。所以初始化阶段才会赋值为3。</p>
<p><code>&lt;clinit&gt;</code>方法是类加载的<strong>初始化</strong>过程中，编译器按语句在源文件中出现的顺序，依次自动收集类中的静态变量的赋值动作和静态代码块中的语句合并产生<code>&lt;clinit&gt;</code>方法。并且 <code>&lt;clinit&gt;()</code> 不需要显式调用父类（接口除外，接口不需要调用父接口的初始化方法，只有使用到父接口中的静态变量时才需要调用）的初始化方法 <code>&lt;clinit&gt;()</code>，虚拟机会保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行之前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行完毕。</p>
<p>随便写个类：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>编译后通过<code>jclasslib</code>插件查看：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/09/f122fdb91f027a3f.jpg"></p>
<blockquote>
<p>当 int 取值 -128~127 时，JVM 采用 <code>bipush</code> 指令将常量压入栈中。</p>
</blockquote>
<p>还需要注意几点：</p>
<ul>
<li>对于同时被<code>static</code>和<code>final</code>修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>此时编译会报错：<strong>java: 变量 tmp 未在默认构造器中初始化</strong>。</p>
<p>必须在构造器中将<code>final</code>变量初始化：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.k = k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>同时被<code>static</code>和<code>final</code>修饰的常量，类会为它生成<code>ConstantValue</code>属性，在准备阶段JVM就会根据<code>ConstantValue</code>的设置将变量赋值。</li>
</ul>

        <h2 id="解析"   >
          <a href="#解析" class="heading-link"><i class="fas fa-link"></i></a><a href="#解析" class="headerlink" title="解析"></a>解析</h2>
      <p>JVM将常量池内的符号引用替换为直接引用的过程，解析动作主要针对<code>类</code>或<code>接口</code>、<code>字段</code>、<code>类方法</code>、<code>接口方法</code>、<code>方法类型</code>、<code>方法句柄</code>和<code>调用点</code>限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p>
<p><code>直接引用</code>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>

        <h2 id="初始化"   >
          <a href="#初始化" class="heading-link"><i class="fas fa-link"></i></a><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2>
      <p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。</p>
<blockquote>
<p>也就是<code>&lt;clinit&gt;</code>方法。</p>
</blockquote>
<p><strong>类初始化时机</strong>: 只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种:</p>
<ul>
<li><p>创建类的实例，也就是new的方式</p>
</li>
<li><p>访问某个类或接口的静态变量，或者对该静态变量赋值</p>
</li>
<li><p>调用类的静态方法（也经常和第二点合并在一起）</p>
</li>
<li><p>反射(如Class.forName(“com.pdai.jvm.Test”))</p>
</li>
<li><p>初始化某个类的子类，则其父类也会被初始化</p>
</li>
<li><p>Java虚拟机启动时被标明为启动类的类(Java Test)，直接使用java.exe命令来运行某个主类</p>
</li>
</ul>
<p>只有这六种是主动使用，其他的都是被动使用，被动使用不会初始化。被动引用的例子可以看这篇<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/zhangliangzi/article/details/51319033" >博客</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p>

        <h3 id="注意"   >
          <a href="#注意" class="heading-link"><i class="fas fa-link"></i></a><a href="#注意" class="headerlink" title="注意"></a>注意</h3>
      <p>关于访问类的静态变量，一定要注意这里写的是<strong>变量，变量，变量</strong>（重要的是强调三遍）。<code>static final int a = 10;</code>是<strong>常量，常量，常量</strong>。访问<code>a</code>不会让类被加载。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Test.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>写一下<code>Test</code>类：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我被初始化了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;都看到这里了，不给个三连+关注吗？&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>先编译一下，看一下<code>Main.class</code>的内容：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Main</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;都看到这里了，不给个三连+关注吗？&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>字节码文件中，将<code>Test.str</code>直接替换成了字符串，那么执行时和<code>Test</code>也就没有任何关系了，自然也不会实例化<code>Test</code>。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/09/28f0a77b42aeafb5.jpg"></p>
<blockquote>
<p>当 int 取值 -2147483648~2147483647 时，JVM 采用 <code>ldc</code> 指令将常量压入栈中。</p>
</blockquote>

        <h2 id="卸载"   >
          <a href="#卸载" class="heading-link"><i class="fas fa-link"></i></a><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2>
      <p>JVM将结束生命周期的几种情况：</p>
<ul>
<li>执行了System.exit()方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
</ul>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/zhangliangzi/article/details/51319033" >https://blog.csdn.net/zhangliangzi/article/details/51319033</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/jvm/java-jvm-classload.html" >https://pdai.tech/md/java/jvm/java-jvm-classload.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javase/keopmg#ddafc876" >https://www.yuque.com/qingkongxiaguang/javase/keopmg#ddafc876</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/wangguoning/p/6109377.html" >https://www.cnblogs.com/wangguoning/p/6109377.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>《深入理解Java虚拟机》第三版</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/czwbig/p/11155555.html" >https://www.cnblogs.com/czwbig/p/11155555.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/08/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%AE%BF%E9%97%AE%E8%80%85/">行为型--访问者</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-08</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-08</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="访问者-Visitor"   >
          <a href="#访问者-Visitor" class="heading-link"><i class="fas fa-link"></i></a><a href="#访问者-Visitor" class="headerlink" title="访问者(Visitor)"></a>访问者(Visitor)</h1>
      <blockquote>
<p>当想要为对象的组合增加新的能力且封装并不重要时，就可以使用访问者模式。</p>
</blockquote>
<p>现在需要知道的就是，被访问的类需要将自身引用传入访问者。讲起来比较空泛，所以先看代码。</p>

        <h2 id="实现"   >
          <a href="#实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#实现" class="headerlink" title="实现"></a>实现</h2>
      <blockquote>
<p>代码来自菜鸟教程。</p>
</blockquote>
<ul>
<li>定义表示元素的接口：</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ComputerPart</span> &#123;</span><br><span class="line">    <span class="comment">// 接口定义的行为：元素提供一个方法供访问者进入</span></span><br><span class="line">    <span class="comment">// 假设存在ComputerPartVisitor接口定义了访问者的visit行为</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>创建扩展上述类的实体类</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个键盘实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Keybord</span> <span class="keyword">implements</span> <span class="title class_">ComputerPart</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> &#123;</span><br><span class="line">        <span class="comment">// 实体类实现的行为是：将自己的引用this暴露给外部访问者</span></span><br><span class="line">        computerPartVisitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个监视器实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Monitor</span> <span class="keyword">implements</span> <span class="title class_">ComputerPart</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    publicvoid <span class="title function_">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> &#123;</span><br><span class="line">        computerPartVisitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个鼠标实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mouse</span>  <span class="keyword">implements</span> <span class="title class_">ComputerPart</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> &#123;</span><br><span class="line">      computerPartVisitor.visit(<span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>再写一个总体的类</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> <span class="keyword">implements</span> <span class="title class_">ComputerPart</span> &#123;</span><br><span class="line">	ComputerPart[] parts;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Computer</span><span class="params">()</span> &#123;</span><br><span class="line">        parts = <span class="keyword">new</span> <span class="title class_">ComputerPart</span>[] &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Mouse</span>(),<span class="keyword">new</span> <span class="title class_">Keyboard</span>(),<span class="keyword">new</span> <span class="title class_">Monitor</span>()</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">                parts[i].accept(computerPartVisitor);</span><br><span class="line">            &#125;</span><br><span class="line">            computerPartVisitor.visit(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>创建一个实体访问者类</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComputerPartDisplayVisitor</span> <span class="keyword">implements</span> <span class="title class_">ComputerPartVisitor</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Computer computer)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Displaying Computer.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Mouse mouse)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Displaying Mouse.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Keyboard keyboard)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Displaying Keyboard.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Monitor monitor)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Displaying Monitor.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>最后运行一下</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisitorPatternDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="type">ComputerPart</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">      computer.accept(<span class="keyword">new</span> <span class="title class_">ComputerPartDisplayVisitor</span>());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h2>
      <p>代码逻辑简单：</p>
<ul>
<li>访问者有处理被访问者的行为。</li>
<li>被访问者有接收访问者并将自身引用暴露给访问者的行为。</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/08/c634509b4c630678.jpg"></p>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p>菜鸟教程：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/visitor-pattern.html?_=1478060039" >https://www.runoob.com/design-pattern/visitor-pattern.html?_=1478060039</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>Java全栈知识体系：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/dev-spec/pattern/20_visitor.html" >https://pdai.tech/md/dev-spec/pattern/20_visitor.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/08/Java/JVM/JVM(2)-%E5%AD%97%E8%8A%82%E7%A0%81%E5%A2%9E%E5%BC%BA/">JVM(2)--字节码增强</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-08</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-08</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="JVM基础-字节码增强"   >
          <a href="#JVM基础-字节码增强" class="heading-link"><i class="fas fa-link"></i></a><a href="#JVM基础-字节码增强" class="headerlink" title="JVM基础-字节码增强"></a>JVM基础-字节码增强</h1>
      <blockquote>
<p>字节码增强技术就是一类对现有字节码进行修改或者动态生成全新字节码文件的技术。</p>
</blockquote>

        <h2 id="ASM"   >
          <a href="#ASM" class="heading-link"><i class="fas fa-link"></i></a><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h2>
      <p>ASM可以直接生成<code>.class</code>字节码文件，也可以在类被加载入JVM之前动态修改类行为。ASM框架是JDK内部自带的，最基本的就是通过<code>ClassWriter</code>对象编辑类的字节码文件。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(ClassWriter.COMPUTE_MAXS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>在学习ASM前，请先学习一下<a href="https://cecilia.cool/2022/10/08/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%AE%BF%E9%97%AE%E8%80%85/">访问者模式</a>。</p>
</blockquote>
<p>字节码文件的结构是由JVM固定的，适合利用访问者模式对字节码文件进行修改。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/08/b57b44956364c1b6.jpg"></p>

        <h3 id="核心API"   >
          <a href="#核心API" class="heading-link"><i class="fas fa-link"></i></a><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h3>
      <ul>
<li><p><code>ClassReader</code>：用于读取已经编译好的.class文件。</p>
</li>
<li><p><code>ClassWriter</code>：用于重新构建编译后的类，如修改类名、属性以及方法，也可以生成新的类的字节码文件。</p>
</li>
<li><p>各种<code>Visitor</code>类：如上所述，CoreAPI根据字节码从上到下依次处理，对于字节码文件中不同的区域有不同的Visitor，比如用于访问方法的<code>MethodVisitor</code>、用于访问类变量的<code>FieldVisitor</code>、用于访问注解的<code>AnnotationVisitor</code>等。</p>
</li>
</ul>
<blockquote>
<p>API文档：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://tool.oschina.net/apidocs/apidoc?api=asm" >https://tool.oschina.net/apidocs/apidoc?api=asm</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>

        <h2 id="方法名和描述符"   >
          <a href="#方法名和描述符" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法名和描述符" class="headerlink" title="方法名和描述符"></a>方法名和描述符</h2>
      <p>这里补充一下类文件中方法名和描述符的表示。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>使用<code>jclasslib</code>插件查看一下：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/08/d03410a93bae253c.jpg"></p>
<p>可以看到，方法名在字节码文件中被<code>&lt;&gt;</code>包围，描述符其实就是返回值和参数列表，也都被<code>&lt;&gt;</code>包围。<code>&lt;()I&gt;</code>表示：</p>
<ul>
<li>括号里的是参数，后面的是返回值。</li>
<li><code>I</code>表示<code>int</code>，也就是说，该方法返回<code>int</code>，如果是<code>void</code>，这里就会是<code>V</code>。</li>
</ul>
<p>这样我们就固定了方法的方法名和参数列表以及返回值。从图中可以看到，<code>inc</code>方法上面还有个<code>&lt;init&gt;</code>方法，那就是构造方法。</p>
<p>如果方法参数中加入了对象：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">(String s,Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 描述符：&lt;(Ljava/lang/String;Ljava/lang/Object;)I&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">(<span class="type">char</span>[][] a)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 描述符：&lt;([[C)I&gt;</span></span><br></pre></td></tr></table></div></figure>

<p><code>L</code>开头表示是一个对象，参数之间要用<code>;</code>隔开。详细的读者可以自己写一些方法来看一下具体的效果。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/08/5d052fc53aef3cb4.jpg"></p>

        <h2 id="基本使用"   >
          <a href="#基本使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(ClassWriter.COMPUTE_MAXS);</span><br></pre></td></tr></table></div></figure>

<p>构造函数里的参数与操作数栈和局部临时变量表有关，不想琢磨，用<code>COMPUTE_MAXS</code>即可。</p>
<p>首先指定一下类的基本信息：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(ClassWriter.COMPUTE_MAXS);</span><br><span class="line">        <span class="comment">// 因为这里用到的常量比较多，所以说直接一次性静态导入：</span></span><br><span class="line">        <span class="comment">// import static jdk.internal.org.objectweb.asm.Opcodes.*;</span></span><br><span class="line">        writer.visit(V1_8, ACC_PUBLIC,<span class="string">&quot;com/JVM/Main&quot;</span>, <span class="literal">null</span>,</span><br><span class="line">                     <span class="string">&quot;java/lang/Object&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 第三个参数，需要根据自己的Main路径填写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>设定的基本信息依次是：版本–Java8，修饰符–<code>ACC_PUBLIC</code>，类名–要携带包名，标签–<code>null</code>，父类–<code>Object</code>。</p>
<p>将其保存，然后写入到自己生成的字节码文件当中：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(ClassWriter.COMPUTE_MAXS);</span><br><span class="line">        writer.visit(V1_8, ACC_PUBLIC,<span class="string">&quot;com/test/Main&quot;</span>, <span class="literal">null</span>,</span><br><span class="line">                     <span class="string">&quot;java/lang/Object&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//调用visitEnd表示结束编辑</span></span><br><span class="line">        writer.visitEnd();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>(<span class="type">FileOutputStream</span> <span class="variable">stream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./Main.class&quot;</span>))&#123;</span><br><span class="line">            stream.write(writer.toByteArray());  </span><br><span class="line">            <span class="comment">//直接通过ClassWriter将字节码文件转换为byte数组，并保存到根目录下</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>结果为：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/08/f0c63a80acdf6c29.jpg"></p>
<p>从class文件可知，<code>Main.class</code>没有构造方法，所以可以添加一个</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过visitMethod方法可以添加一个新的方法</span></span><br><span class="line"><span class="comment">// 放在writer.visitEnd();前面即可</span></span><br><span class="line">writer.visitMethod(ACC_PUBLIC, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></div></figure>

<p>再次编译，发现存在构造方法，之前讲了字节码文件中的方法名和描述符，读者可以自行修改描述符感受一下效果。</p>
<p>但是<code>Main</code>继承了<code>Object</code>类，所以在子类构造方法中应该调用父类的构造方法。也就是说，沃恩需要在方法中添加父类构造方法调用指令：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public com.test.Main();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1             // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 11: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/test/Main;</span><br></pre></td></tr></table></div></figure>

<p>所以我们开始访问代码（<code>visitCode()</code>)，也就是对方法进行详细i编辑：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过MethodVisitor接收返回值，进行进一步操作</span></span><br><span class="line"><span class="type">MethodVisitor</span> <span class="variable">visitor</span> <span class="operator">=</span> writer.visitMethod(ACC_PUBLIC, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始编辑代码</span></span><br><span class="line">visitor.visitCode();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Label用于存储行号，当前代码写到哪行了，l1得到的就是多少行</span></span><br><span class="line"><span class="type">Label</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加源代码行数对应表(字节码中的LineNumberTable)</span></span><br><span class="line">visitor.visitListNumber(<span class="number">11</span>,l1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同类型的指令需要不同方法调用</span></span><br><span class="line">visitor.visitVarInsn(ALOAD,<span class="number">0</span>);</span><br><span class="line">visitor.visitMethodInsn(INVOKESPECIAL, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">visitor.visitInsn(RETURN);</span><br><span class="line"></span><br><span class="line"><span class="type">Label</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">visitor.visitLabel(l2);</span><br><span class="line"><span class="comment">// 添加本地变量表(字节码中的LocalVariableTable)，这里是this关键字</span></span><br><span class="line">visitor.visiLocalVariable(<span class="string">&quot;this&quot;</span>,,<span class="string">&quot;Lcom/JVM/Main;&quot;</span>,<span class="literal">null</span>,l1, l2, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后设定最大栈深度和本地变量数</span></span><br><span class="line">visitor.visitMaxs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//结束编辑</span></span><br><span class="line">visitor.visitEnd();</span><br></pre></td></tr></table></div></figure>

<p>至此构造方法编辑完成，可以看到是非常麻烦的一件事，其实哪怕只是完成一个</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>都是非常复杂的一件事：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始安排main方法</span></span><br><span class="line"><span class="type">MethodVisitor</span> <span class="variable">v2</span> <span class="operator">=</span> writer.visitMethod(ACC_PUBLIC | ACC_STATIC, <span class="string">&quot;main&quot;</span>, </span><br><span class="line">                                      <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">v2.visitCode();</span><br><span class="line"><span class="comment">//记录起始行信息</span></span><br><span class="line"><span class="type">Label</span> <span class="variable">l3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">v2.visitLabel(l3);</span><br><span class="line">v2.visitLineNumber(<span class="number">13</span>, l3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先是int a = 10的操作，执行指令依次为：</span></span><br><span class="line"><span class="comment">// bipush 10     将10推向操作数栈顶</span></span><br><span class="line"><span class="comment">// istore_1      将操作数栈顶元素保存到1号本地变量a中</span></span><br><span class="line">v2.visitIntInsn(BIPUSH, <span class="number">10</span>);</span><br><span class="line">v2.visitVarInsn(ISTORE, <span class="number">1</span>);</span><br><span class="line"><span class="type">Label</span> <span class="variable">l4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">v2.visitLabel(l4);</span><br><span class="line"><span class="comment">//记录一下行信息</span></span><br><span class="line">v2.visitLineNumber(<span class="number">14</span>, l4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里是获取System类中的out静态变量（PrintStream接口），用于打印</span></span><br><span class="line">v2.visitFieldInsn(GETSTATIC, <span class="string">&quot;java/lang/System&quot;</span>, <span class="string">&quot;out&quot;</span>, <span class="string">&quot;Ljava/io/PrintStream;&quot;</span>);</span><br><span class="line"><span class="comment">//把a的值取出来</span></span><br><span class="line">v2.visitVarInsn(ILOAD, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//调用接口中的抽象方法println</span></span><br><span class="line">v2.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/io/PrintStream&quot;</span>, <span class="string">&quot;println&quot;</span>, <span class="string">&quot;(I)V&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//再次记录行信息</span></span><br><span class="line"><span class="type">Label</span> <span class="variable">l6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">v2.visitLabel(l6);</span><br><span class="line">v2.visitLineNumber(<span class="number">15</span>, l6);</span><br><span class="line"></span><br><span class="line">v2.visitInsn(RETURN);</span><br><span class="line"><span class="type">Label</span> <span class="variable">l7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">v2.visitLabel(l7);</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后是本地变量表中的各个变量</span></span><br><span class="line">v2.visitLocalVariable(<span class="string">&quot;args&quot;</span>, <span class="string">&quot;[Ljava/lang/String;&quot;</span>, <span class="literal">null</span>, l3, l7, <span class="number">0</span>);</span><br><span class="line">v2.visitLocalVariable(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="literal">null</span>, l4, l7, <span class="number">1</span>);</span><br><span class="line">v2.visitMaxs(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//终于OK了</span></span><br><span class="line">v2.visitEnd();</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>写之前就需要先写好Java程序进行反编译，再照着字节码一行一行使用<code>MathodVisitor</code>编辑。</p>
</blockquote>

        <h2 id="例子：实现AOP"   >
          <a href="#例子：实现AOP" class="heading-link"><i class="fas fa-link"></i></a><a href="#例子：实现AOP" class="headerlink" title="例子：实现AOP"></a>例子：实现AOP</h2>
      <blockquote>
<p>AOP–面向切面编程，Spring核心之一，如果你不了解AOP，就暂时理解为，在一个执行流程（模块）中，加入一个切面，通过这个切面的方法可以被切面加入一些操作，如记录日志啥的。</p>
</blockquote>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/08/972d8fa05bf61137.jpg"></p>
<p>我们希望通过ASM来实现AOP：在方法调用前后增加逻辑（也叫做前置通知和后置通知）。</p>
<p>具体代码实现感兴趣的读者可以参考：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/jvm/java-jvm-class-enhancer.html#%E5%AD%97%E8%8A%82%E7%A0%81%E5%A2%9E%E5%BC%BA%E6%8A%80%E6%9C%AF" >直接利用ASM实现AOP</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javase/keopmg" >https://www.yuque.com/qingkongxiaguang/javase/keopmg</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/jvm/java-jvm-class-enhancer.html" >https://pdai.tech/md/java/jvm/java-jvm-class-enhancer.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/05/Java/JVM/JVM(1)-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/">JVM(1)--类文件结构</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-07</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="类文件结构"   >
          <a href="#类文件结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1>
      <p>计算机是不能直接运行java代码的，必须要先运行java虚拟机，再由java虚拟机运行编译后的java代码。这个编译后的java代码，就是本文要介绍的java字节码。</p>
<ul>
<li>Java代码间接翻译成字节码，储存字节码的文件再交由运行于不同平台上的JVM虚拟机去读取执行，从而实现一次编写，到处运行的目的。</li>
<li>JVM也不再只支持Java，由此衍生出了许多基于JVM的编程语言，如Groovy, Scala, Koltin等等。</li>
</ul>
<blockquote>
<p>许多开发语言支持将源代码编译为<code>.class</code>字节码文件格式，以便交给JVM运行</p>
</blockquote>

        <h2 id="类文件信息"   >
          <a href="#类文件信息" class="heading-link"><i class="fas fa-link"></i></a><a href="#类文件信息" class="headerlink" title="类文件信息"></a>类文件信息</h2>
      <p>先写一个例子：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>编译生成<code>Test.class</code>文件。</p>
<blockquote>
<p>下载WinHex软件，以十六进制格式查看字节码文件（将编译好的<code>class</code>文件拖进去），每一位都是4个bit</p>
</blockquote>
<p>呈现出来的是酱紫的：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/06/227b1ae28c54688f.jpg"></p>
<p>但是winHex我这打开总是有些毛病，所以选择另一个工具（IEDA插件）查看十六进制字节码：</p>
<ul>
<li>安装插件：Binary&#x2F;hexadecimal editor。</li>
<li>右键class文件，选择Open As Binary。</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/06/995affe6c346a8aa.jpg"></p>
<p>有时直接查看16进制的结果不方便，为了能够方便查看字节码信息，需要安装另一个插件：</p>
<ul>
<li>安装插件：jclasslib Bytecode Viewer。</li>
<li>选中要查看的java文件（不是class文件），点击view（视图），再点击<code>show Bytecode with jclasslib</code>。</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/06/8f19ae55706ab1c2.jpg"></p>
<ul>
<li>这样查看字节码文件中的常量池什么的就非常方便。</li>
</ul>
<p>对于类文件信息，需要知道的部分如下图：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/05/868070b026d6842b.jpg"></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="魔数与版本"   >
          <a href="#魔数与版本" class="heading-link"><i class="fas fa-link"></i></a><a href="#魔数与版本" class="headerlink" title="魔数与版本"></a>魔数与版本</h3>
      <p>字节码文件前4个字节（32bit）组成了魔数，魔数机制检验该文件是否是JVM可以直接运行的字节码文件。字节码文件的魔数为：<strong>CAFFBABE</strong>。</p>
<p>魔数后面的4个字节存储的是字节码文件的版本号，前两个是次要版本号（现在基本不用了），后两个是主要版本号，将16进制换算成10进制之后，得到的可以参照：52代表JDK8编译的字节码文件（51是JDK7，53是JDK9）。</p>

        <h3 id="常量池"   >
          <a href="#常量池" class="heading-link"><i class="fas fa-link"></i></a><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3>
      <p><code>Constant pool</code>意为常量池，可以理解为<code>Class</code>文件中的资源仓库，是程序运行一些需要用到的常量数据，主要存放<strong>字面量</strong>和<strong>符号引用</strong>。字面量类似于Java中的常量概念，如文本字符串，<code>final</code>常量等。</p>
<p>符号引用属于编译原理的概念：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p>常量的数量不是确定的，所以在<strong>最开始的位置</strong>会存放常量池中<strong>常量的数量</strong>（是从1开始计算的，不是0，比如18，翻译为10进制就是24，所以实际上有23个常量）。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br></pre></td></tr></table></div></figure>

<p>每一项常量池里面的数据都是一个表，都是以_info结尾的（通过插件查看即可），有14种表。</p>

        <h3 id="访问标志"   >
          <a href="#访问标志" class="heading-link"><i class="fas fa-link"></i></a><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3>
      <p>两个字节，代表访问标志，用于识别一些类或者接口层次的访问信息，包括：Class是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/07/d412705d408b4988.jpg"></p>
<p>反编译一下<code>Test.class</code>文件查看访问标志：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p -private 显示所有类和成员</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-v -verbose 输出附加信息</span></span><br><span class="line">javap -verbose -p Test.class</span><br></pre></td></tr></table></div></figure>

<p>对于结果为：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/07/175494f35c4a5e2e.jpg"></p>

        <h3 id="类索引和接口索引集合"   >
          <a href="#类索引和接口索引集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#类索引和接口索引集合" class="headerlink" title="类索引和接口索引集合"></a>类索引和接口索引集合</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">u2             super_class;<span class="comment">//父类</span></span><br><span class="line">u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br></pre></td></tr></table></div></figure>

<p>在访问标志的反编译图中也可以看到<strong>当前类索引</strong>，<strong>父类索引</strong>，<strong>接口索引</strong>。</p>
<p><strong>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</strong></p>
<p><strong>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按<code>implents</code>(如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中。</strong></p>

        <h3 id="字段表集合"   >
          <a href="#字段表集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             fields_count;<span class="comment">//Class 文件的字段的个数</span></span><br><span class="line">field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段</span></span><br></pre></td></tr></table></div></figure>

<p>用于描述接口或类中声明的变量。不包括方法内部的局部变量。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/07/a82c68d88210068a.jpg"></p>
<ul>
<li><strong>access_flags:</strong> 字段的作用域（<code>public</code> ,<code>private</code>,<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写），各个修饰符都是布尔值，要么有某个修饰符，要么没有，适合使用标志位来表示。</li>
<li><strong>name_index:</strong> 对<strong>常量池</strong>的引用，表示的字段的名称；</li>
<li><strong>descriptor_index:</strong> 对常量池的引用，表示字段和方法的描述符；&#x2F;&#x2F;</li>
<li><strong>attributes_count:</strong> 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li>
<li><strong>attributes[attributes_count]:</strong> 存放具体属性具体内容。</li>
</ul>

        <h3 id="方法表集合"   >
          <a href="#方法表集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             methods_count;<span class="comment">//Class 文件的方法的数量</span></span><br><span class="line">method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br></pre></td></tr></table></div></figure>

<p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表（<code>method_info</code>）的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项（所以参照上图<code>field_info</code>）。</p>
<p>得到的结果（这里只看方法那部分）：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Chapter1.Test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC				<span class="comment">// 这就是access_flag取值</span></span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: getfield      #<span class="number">2</span>                <span class="comment">// Field m:I</span></span><br><span class="line">         <span class="number">4</span>: iconst_1</span><br><span class="line">         <span class="number">5</span>: iadd</span><br><span class="line">         <span class="number">6</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>其中<code>access_flag</code>取值为：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/07/f8a119d3fd7bb199.jpg"></p>
<blockquote>
<p>因为<code>volatile</code>修饰符和<code>transient</code>修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了<code>synchronized</code>、<code>native</code>、<code>abstract</code>等关键字修饰方法，所以也就多了这些关键字对应的标志。</p>
</blockquote>
<p>code内的主要属性为:</p>
<ul>
<li><strong>stack</strong>： 最大操作数栈，JVM运行时会根据这个值来分配栈帧(Frame)中的操作栈深度,此处为1<strong>（递归？）</strong></li>
<li><strong>locals</strong>：局部变量所需的存储空间，单位为Slot, Slot是虚拟机为局部变量分配内存时所使用的最小单位，为4个字节大小。方法参数(包括实例方法中的隐藏参数this)，显示异常处理器的参数(try catch中的catch块所定义的异常)，方法体中定义的局部变量都需要使用<strong>局部变量表</strong>来存放。值得一提的是，locals的大小并不一定等于所有局部变量所占的Slot之和，因为局部变量中的Slot是可以重用的。</li>
<li><strong>args_size</strong>：方法参数的个数，这里是1，因为每个实例方法都会有一个隐藏参数this</li>
<li><strong>attribute_info</strong>: 方法体内容，0,1,4为字节码”行号”，该段代码的意思是将第一个引用类型本地变量推送至栈顶，然后执行该类型的实例方法，也就是常量池存放的第一个变量，也就是注释里的<code>java/lang/Object.&quot;&quot;:()V</code>, 然后执行返回语句，结束方法。</li>
<li><strong>LineNumberTable</strong>：该属性的作用是描述源码行号与字节码行号(字节码偏移量)之间的对应关系。可以使用 -g:none 或-g:lines选项来取消或要求生成这项信息，如果选择不生成LineNumberTable，当程序运行异常时将无法获取到发生异常的源码行号，也无法按照源码的行数来调试程序。</li>
</ul>
<p>有时还会出现这个：</p>
<ul>
<li><strong>LocalVariableTable</strong>：该属性的作用是描述帧栈中局部变量与源码中定义的变量之间的关系。可以使用 -g:none 或 -g:vars来取消或生成这项信息，如果没有生成这项信息，那么当别人引用这个方法时，将无法获取到参数名称，取而代之的是arg0, arg1这样的占位符。 start 表示该局部变量在哪一行开始可见，length表示可见行数，Slot代表所在帧栈位置，Name是变量名称，然后是类型签名。</li>
</ul>

        <h3 id="属性表集合"   >
          <a href="#属性表集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br></pre></td></tr></table></div></figure>

<p>用于描述某些场景专有的信息。</p>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485250&idx=2&sn=33793bcce3f2ff31b83cf2f9c32df153&chksm=cea24889f9d5c19fa3e2b7d4f59762b59e6cd9e5e6564fe73c6993bd06e08bddd40cc0f3cba0&scene=0&xtrack=1&key=49cd1e59990c3d1f207865d32759f1ff2ae7fdf676f3b0a02ba49906a5af3ccdbd73e43bbe31515866f9748388c78cb9e4406d880eaf2d51afcf32168f3ad271769cc1c93cbfb0135046210b41d7d036&ascene=1&uin=MjMxMDk4NDI3&devicetype=Windows+7&version=62060739&lang=zh_CN&pass_ticket=J0+LnrNgEFouK4etBnwg1HUabsFw7ji5W1fiSveug54=" >谈谈Java类文件结构</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html" >https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://coolshell.cn/articles/9229.html" >https://coolshell.cn/articles/9229.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/luanlouis/article/details/39960815" >https://blog.csdn.net/luanlouis/article/details/39960815</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>《实战 Java 虚拟机》</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/jvm/java-jvm-class.html" >https://pdai.tech/md/java/jvm/java-jvm-class.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javase/keopmg" >https://www.yuque.com/qingkongxiaguang/javase/keopmg</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/04/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88(5)-WeakHashMap/">Java集合(5)--WeakHashMap</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-04</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="引用类型"   >
          <a href="#引用类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1>
      
        <h2 id="强引用"   >
          <a href="#强引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2>
      <p>最普遍的引用，如果一个对象<strong>具有</strong>强引用，GC绝不会回收。如果不使用，要弱化引用</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">o = <span class="literal">null</span>;<span class="comment">// help GC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">test方法内部有一个强引用，引用保存在栈中，new的对象保存在</span></span><br><span class="line"><span class="comment">堆中，当方法运行结束会退出方法栈，则引用内容的引用不存在，Object</span></span><br><span class="line"><span class="comment">就会被回收。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>如果o是全局变量，需要在不用对象时赋值为null。</p>
</blockquote>

        <h2 id="软引用"   >
          <a href="#软引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2>
      <p>一个对象只有软引用，在内存空间足够时，垃圾回收器不会回收它；当内存空间不足，就会回收这些对象的内存。</p>
<blockquote>
<p>软引用可以用于实现内存敏感的高速缓存。</p>
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弱引用</span></span><br><span class="line">SoftReference&lt;String&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(str);</span><br></pre></td></tr></table></div></figure>

<p>浏览器的后退按钮，后退时显示的网页应该是重新进行请求还是从缓存中取出的取决于具体的实现策略。如果将浏览的网页全部强引用存储到内存中，就会造成浪费甚至内存溢出。</p>
<p>此时使用软引用：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Browser</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Browser</span>();<span class="comment">// 页面浏览</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浏览后设为软引用</span></span><br><span class="line"><span class="type">SoftReference</span> <span class="variable">sr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SoftReference</span>(prev);</span><br><span class="line"><span class="keyword">if</span>(sr.get != <span class="literal">null</span>) &#123;</span><br><span class="line">    rev = (Browser) sr.get();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    prev = <span class="keyword">new</span> <span class="title class_">Broswer</span>();<span class="comment">// 内存吃紧，软引用对象回收</span></span><br><span class="line">    sr = <span class="keyword">new</span> <span class="title class_">SoftReference</span>(prev);<span class="comment">// 重新构建</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="弱引用"   >
          <a href="#弱引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2>
      <p>区别于软引用，只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">WeakReference&lt;String&gt; abcWeakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;String&gt;(str);</span><br><span class="line"></span><br><span class="line">str=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以恢复强引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">abc</span> <span class="operator">=</span> abcWeakRef.get();</span><br></pre></td></tr></table></div></figure>


        <h2 id="虚引用"   >
          <a href="#虚引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2>
      <p>虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p>
<p> 虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。</p>

        <h1 id="WeakHashMap"   >
          <a href="#WeakHashMap" class="heading-link"><i class="fas fa-link"></i></a><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h1>
      <p>先看一下<strong>引用队列</strong>：</p>
<ul>
<li>一般情况，一个对象被标记为垃圾（不代表回收了），会加入到引用队列。</li>
<li>对于虚引用来说，它指向的对象会只有被<strong>回收后</strong>才会加入到引用队列（其他是被标记），所以可以用作记录该引用指向的对象是否被回收。</li>
</ul>
<p><code>WeakHashMap</code>与<code>HashMap</code>没什么区别，只是引用采取的是弱引用的<code>key</code>存储，**GC回收的是<code>key</code>**。这种结构适合缓存处理。底层是因为<code>Entry</code>继承了<code>WeakReference</code>。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> </span><br><span class="line">    							<span class="title class_">WeakReference</span>&lt;Object&gt;</span><br><span class="line">                                <span class="keyword">implements</span></span><br><span class="line">                                <span class="title class_">Map</span>.Entry&lt;K,V&gt; </span><br><span class="line">&#123;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Entry(Object key, V value,</span><br><span class="line">          ReferenceQueue&lt;Object&gt; queue,</span><br><span class="line">          <span class="type">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(key, queue);</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.hash  = hash;</span><br><span class="line">        <span class="built_in">this</span>.next  = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>为了将<code>key</code>改写为弱引用，在<code>Entry</code>中又调用了一个<code>super(key, queue)</code>。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WeakReference构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">WeakReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; q)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(referent, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><code>WeakHashMap</code>除了<code>WeakReference</code>，还有<code>ReferenceQueue</code>重要。</p>
<blockquote>
<p>再次强调一下，<code>WeakHashMap</code>基于弱引用可以淘汰内部元素，同样的，<code>LinkedHashMap</code>也是具备淘汰机制的，只不过是通过阈值来限定节点个数的先进先出缓存。</p>
</blockquote>

        <h2 id="弱引用回收"   >
          <a href="#弱引用回收" class="heading-link"><i class="fas fa-link"></i></a><a href="#弱引用回收" class="headerlink" title="弱引用回收"></a>弱引用回收</h2>
      <p><code>Reference</code>类有一段静态代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Lock</span> &#123; &#125;;</span><br><span class="line"><span class="comment">// 有一个全局锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lock</span>();  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Reference</span> <span class="variable">pending</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">          </span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="type">ThreadGroup</span> <span class="variable">tg</span> <span class="operator">=</span> Thread.currentThread().getThreadGroup();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">ThreadGroup</span> <span class="variable">tgn</span> <span class="operator">=</span> tg;</span><br><span class="line">         tgn != <span class="literal">null</span>;</span><br><span class="line">         tg = tgn, tgn = tg.getParent());</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceHandler</span>(tg, <span class="string">&quot;Reference Handler&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 优先级最高</span></span><br><span class="line">    handler.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">    handler.setDaemon(<span class="literal">true</span>);</span><br><span class="line">    handler.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>假设<code>WeakHashMap</code>对象里面保存了很多对象引用：</p>
<ul>
<li>GC时，会创建一个CMST线程进行GC，该线程被创建的同时还会创建一个SLT线程并启动。</li>
<li>CMST开始GC时，会发送一个消息给SLT让他去获取Java层<code>Reference</code>对象的全局锁<code>lock</code>。</li>
<li>当GC完毕时，JVM会将WeakHashMap中所有被回收的对象所属的<code>WeakReference</code>容器对象放入到<code>Reference</code>的<code>pending</code>属性中（每次GC完毕后，<code>pending</code>属性基本上不会为null了）。</li>
<li>然后通知SLT释放并且<code>notify</code>全局锁<code>lock</code>，此时激活了<code>ReferenceHandler</code>线程的<code>run</code>方法，脱离wait状态开始运行。</li>
<li><code>Handler</code>线程会将pending中所有<code>WeakReference</code>对象移动到各自队列中（比如当前这个<code>WeakReference</code>属于某个<code>WeakHashMap</code>对象，那么它就会被放入相应的<code>ReferenceQueue</code>列队里面（该列队是链表结构））。</li>
</ul>
<p>最后看一下<code>ReferenceHandler</code>的源码，如何将<code>WeakRenference</code>压入队列：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReferenceHandler</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class="line">        <span class="built_in">super</span>(g, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Reference r;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pending != <span class="literal">null</span>) &#123;</span><br><span class="line">            r = pending;</span><br><span class="line">            <span class="type">Reference</span> <span class="variable">rn</span> <span class="operator">=</span> r.next;</span><br><span class="line">            pending = (rn == r) ? <span class="literal">null</span> : rn;</span><br><span class="line">            r.next = r;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException x) &#123; &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Fast path for cleaners</span></span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> Cleaner) &#123;</span><br><span class="line">            ((Cleaner)r).clean();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ReferenceQueue</span> <span class="variable">q</span> <span class="operator">=</span> r.queue;</span><br><span class="line">        <span class="keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;                 </span><br></pre></td></tr></table></div></figure>

<p>在调用<code>get()</code>，<code>replaceAll()</code>，<code>put()</code>，<code>remove()</code>等方法时（都需要获取<code>table</code>）,不是直接拿到<code>table</code>数组，而是通过<code>getTable()</code>方法先把数组中<code>key</code>为<code>null</code>的<code>Entry</code>删除掉在返回。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry&lt;K,V&gt;[] getTable() &#123;</span><br><span class="line">    <span class="comment">// 真正删除Entry的执行者 </span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>在<code>expungeStaleEntries()</code>方法中，存储被GC回收对象的<code>queue</code>会接收GC发送的回收消息，将queue（通过<code>synchronized</code>上锁）中的<code>key</code>对应的<code>value</code>赋值为<code>null</code>，即<code>help GC</code>。</p>
<blockquote>
<p><code>Entry</code>中保存了hash码，即使<code>key</code>被GC了，仍可以通过hash码来定位需要被删除的<code>Entry</code>。通过<code>Entry</code>的地址在冲突链表中定位（其实我觉得也可以判断<code>Entry.key == null</code>。</p>
</blockquote>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/phlive/p/6030446.html" >https://www.cnblogs.com/phlive/p/6030446.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.jianshu.com/p/2ba55345fd94" >https://www.jianshu.com/p/2ba55345fd94</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/shkstart/article/details/107019371?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-107019371-blog-106545340.pc_relevant_multi_platform_whitelistv4&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-107019371-blog-106545340.pc_relevant_multi_platform_whitelistv4&utm_relevant_index=3" >一文带你了解WeakHashMap</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>.</p>
<p>这篇讲得可以：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_33774883/article/details/89613271" >https://blog.csdn.net/weixin_33774883/article/details/89613271</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/03/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88(4)-TreeMap/">Java集合(4)-TreeMap</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-03</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-04</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h1>
      <p>首先，<code>TreeMap</code>与哈希没有任何关系，其次，哈希和Map也不是一回事，请不要先入为主。Map只是一个键值对的数据结构，哈希是将对象计算哈希码的一种算法。<code>TreeMap</code>只是通过红黑树将键值对存起来，一方面实现了二叉搜索树的排序性，另一方面维护了整棵树的平衡性，防止树退化为链表增大查询&#x2F;插入的时间复杂度。</p>

        <h1 id="排序方式"   >
          <a href="#排序方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#排序方式" class="headerlink" title="排序方式"></a>排序方式</h1>
      <p><code>TreeMap</code>对插入数据实现了排序，如果是自定义数据，要么该类实现<code>Comparable</code>接口，要么TreeMap在构造方法中传入<code>Comparator</code>接口。</p>

        <h2 id="Comparable"   >
          <a href="#Comparable" class="heading-link"><i class="fas fa-link"></i></a><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h2>
      <p>以<code>Student</code>类来说明，继承<code>Comparable</code>并重写<code>compareTo()</code>方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;<span class="comment">// 为了简单，就写一个id属性,并设为public方便获取</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id)</span> &#123;<span class="built_in">this</span>.id = id;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对比方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">        <span class="comment">// 按照id从小到大排序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.id - o.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>在<code>CompareTo()</code>中，是传入的对象和当前对象进行对比：</p>
<ul>
<li>如果对比大于0，降序排序。</li>
<li>如果对比小于0，升序。</li>
</ul>
<blockquote>
<p>其实记住当前对象-传入对象就是升序，反之则降序。</p>
</blockquote>

        <h2 id="Comparator"   >
          <a href="#Comparator" class="heading-link"><i class="fas fa-link"></i></a><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h2>
      <p>通过外部类的方式进行编写，对于<code>Comparator</code>接口的传入也可以用<code>Lambda</code>表达式</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1,Student o2)</span> &#123;</span><br><span class="line">        <span class="comment">// 第一个参数 - 第二个参数：升序</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(o1.id - o2.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以传入Lambda表达式</span></span><br><span class="line">Collections.sort(list,(Student o1,Student <span class="number">02</span>) -&gt; o1.id - o2.id);</span><br></pre></td></tr></table></div></figure>

<p>我们看一下<code>TreeMap</code>的部分属性和构造方法：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableMap</span>&lt;K,V&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传入一个Comparator接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">()</span> &#123;comparator = <span class="literal">null</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>如果没有传入<code>Comparator</code>接口实现，那么传入的<code>Key</code>必须实现<code>Comparable</code>。</p>
<blockquote>
<p><code>TreeMap</code>底层用红黑树，红黑树近似平衡，最长路径不超过最短路径的2倍。</p>
</blockquote>

        <h1 id="TreeMap"   >
          <a href="#TreeMap" class="heading-link"><i class="fas fa-link"></i></a><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h1>
      <p><code>TreeMap</code>的UML类图：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/03/a6778fc1ccf85111.jpg"></p>
<p>因为底层使用了红黑树，所以节点就是<code>Entry</code>，记录了左右节点和父节点指针，以及节点颜色。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> BLACK;</span><br><span class="line">	<span class="comment">// 构造方法，此处不写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>关于红黑树，详细的实现，也就是节点如何变色，如何左旋右旋来维持近似平衡，可以看《算法导论》，本文不会详细去讲，作者曾经也自己看着书写过红黑树，当成C++期末作业交上去了，但是过了两三天又忘了，这玩意吧，看个人兴趣吧，hhhhhh。</p>
</blockquote>

        <h2 id="put"   >
          <a href="#put" class="heading-link"><i class="fas fa-link"></i></a><a href="#put" class="headerlink" title="put()"></a>put()</h2>
      <p>直接给出<code>put</code>的执行流程：</p>
<ul>
<li>判断当前根节点为null，那么插入的第一个元素就是根节点。</li>
<li>如果存在根节点，判断插入元素在左侧还是右侧，如果对比为0，说明当前元素存在于<code>TreeMap</code>中，将其覆盖：<strong>在TreeMap中，不会存在重复元素</strong>。</li>
<li>找到插入位置，插入。</li>
<li>节点变色和旋转操作。</li>
</ul>
<blockquote>
<p>代码太长了，要看源码自己打开IDEA查看。从<code>put</code>流程也可知，时间复杂度为<em>logN</em>。</p>
</blockquote>

        <h2 id="get"   >
          <a href="#get" class="heading-link"><i class="fas fa-link"></i></a><a href="#get" class="headerlink" title="get()"></a>get()</h2>
      <p>也就是不断地对比，在红黑树中查找节点。</p>

        <h1 id="TreeSet"   >
          <a href="#TreeSet" class="heading-link"><i class="fas fa-link"></i></a><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h1>
      <p>这个就是对TreeMap进行了简单包装，不过多讲解</p>
<blockquote>
<p>额，其实关于<code>TreeMap</code>的详解应该是对红黑树的详解，但是我真的不想写，啊啊啊啊啊，以后有时间就单独写一篇博客解释一下红黑树，顺便放一个源码模板方便各位使用（等我想起了再说吧）。</p>
</blockquote>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_51192504/article/details/109775797" >https://blog.csdn.net/weixin_51192504/article/details/109775797</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/collection/java-map-TreeMap&amp;TreeSet.html" >https://pdai.tech/md/java/collection/java-map-TreeMap&amp;TreeSet.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/02/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88(3)-LinkedHashMap/">Java集合3-LinkedHashMap</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-02</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-02</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h1>
      <p><code>LinkedHashSet</code>也是用了适配器模式，对<code>LinkedHashMap</code>进行包装，所以本文主要分析<code>LinkedHashMap</code>。</p>
<p>从名字上可以看出容器是<em>Linked list</em>和<em>HashMap</em>的混合体，<strong>可以将<em>LinkedHashMap</em>看作采用<em>linked list</em>增强的<em>HashMap</em></strong>。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">HashMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><code>LinkedHashMap</code>是<code>HashMap</code>的直接子类，它的区别在于在<code>HashMap</code>的基础上采用双向链表将所有的数据节点都链接起来了，就是为了<strong>保证元素的迭代顺序和插入顺序相同</strong>。</p>
<p>还有个好处就是集合迭代时不需要遍历整个<code>table</code>，逮着双向链表的<code>header</code>遍历即可。</p>
<blockquote>
<p><code>LinkedHashMap</code>为了性能，是非同步的，多线程下需要手动同步</p>
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 也可以打包成同步的</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">m</span> <span class="operator">=</span> Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>(...));</span><br></pre></td></tr></table></div></figure>




        <h1 id="方法剖析"   >
          <a href="#方法剖析" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h1>
      <blockquote>
<p><code>get</code>方法和<code>HashMap</code>里的没什么区别，不多说。</p>
</blockquote>

        <h2 id="put"   >
          <a href="#put" class="heading-link"><i class="fas fa-link"></i></a><a href="#put" class="headerlink" title="put()"></a>put()</h2>
      <p>插入分为两部分：</p>
<ul>
<li>将元素插入<code>table</code>中，如果有哈希冲突，头插法插入到头部。</li>
<li>将元素插入双向链表中，链表尾部。</li>
</ul>
<p>其实就是在<code>HashMap</code>上加入链表的引用的修改。</p>
<p><code>LinkedHashMap</code>使用的节点是<code>Entrty</code>，该类继承了<code>HashMap</code>的<code>Node</code>类。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="remove"   >
          <a href="#remove" class="heading-link"><i class="fas fa-link"></i></a><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2>
      <p>删除也有两部分：</p>
<ul>
<li>将元素从<code>table</code>中删除。</li>
<li>将元素从双向链表中删除。</li>
</ul>

        <h1 id="经典用法"   >
          <a href="#经典用法" class="heading-link"><i class="fas fa-link"></i></a><a href="#经典用法" class="headerlink" title="经典用法"></a>经典用法</h1>
      <p>实现FIFO替换策略的缓存，<code>LinkedHashMap</code>有一个方法，作用是告诉Map删除最老的<code>Entry</code>，也就是最早插入Map的Entry。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>每次插入新元素时<code>LinkedHashMap</code>都会询问该函数是否要删除最老的元素，</p>
<blockquote>
<p><code>LinkedHashMap</code>并没有重写<code>put</code>方法，而是重写的<code>newNode</code>方法，因为<code>newNode</code>就是将要插入的键值对插放到新创建的节点中，在创建节点后马上将其加入到双向链表中即可。</p>
</blockquote>
<p>只要在子类中重载该方法，当元素个数超过一定数量时让<code>removeEldestEntry</code>返回<code>true</code>，就能实现一个固定大小的FIFO策略的缓存。其实我们写个子类继承<code>LinkedList</code>并重写一下<code>add</code>方法也是可以实现的，只是说，是哟个<code>LinkedHashMap</code>更加方便。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 一个固定大小的FIFO替换策略的缓存 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FIFOCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> cacheSize;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FIFOCache</span><span class="params">(<span class="type">int</span> cacheSize)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.cacheSize = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当Entry个数超过cacheSize时，删除最老的Entry</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> size() &gt; cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/collection/java-map-LinkedHashMap&amp;LinkedHashSet.html" >https://pdai.tech/md/java/collection/java-map-LinkedHashMap&amp;LinkedHashSet.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/u014203449/article/details/80194704" >https://blog.csdn.net/u014203449/article/details/80194704</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/02/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88(2)-HashMap/">Java集合(2)--HashMap</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-02</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-04</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h1>
      <p>关于这些集合的讲解，作者默认读者都知道该如何使用，所以不会从最基础的开始讲起，会直接跳过什么是映射关系，哈希值等概念的讲解。对于源码的解析也是最主要使用的那些方法。</p>

        <h1 id="一些概念"   >
          <a href="#一些概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h1>
      <ul>
<li>负载因子：集合容量都有上限，如果加入集合的数量超过一定允许值，集合就会扩容。负载因子就是衡量当前情况是否需要进行扩容的标准。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果数据占用率达到75%，就会扩容，扩容会重新计算哈希值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>红黑树：一种数据结构，在<code>HashMap</code>里面查询效率是<em>logN</em>，整棵树在插入数据时始终保持近似平衡（不是真的平衡）。JDK1.8后就用红黑树代替<code>HashMap</code>里面的长度超过8的冲突链表了。</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/02/760aca61cab61cfc.jpg"></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><code>TreeNode</code>就是为了实现红黑树而设计的内部类。</p>
<blockquote>
<p><code>HashMap</code>的初始容量是否应该设的比较大，在JDK1.7以前，HashMap用的是冲突链表，HashMap在迭代时，需要遍历整个数组和冲突链表。如果迭代频繁的话，就不宜将初始大小设的过大。</p>
</blockquote>
<ul>
<li><code>modCount</code>：集合只要可以使用迭代器，都需要<code>modCount</code>来记录修改次数。</li>
<li>实现<code>Map</code>接口：允许<code>key</code>和<code>value</code>都是<code>null</code>。</li>
</ul>

        <h1 id="核心方法"   >
          <a href="#核心方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h1>
      <p>有时会将Java7的方法拿出来和Java8作比较。</p>
<p>在Java7使用Entry代表数据节点，Java8使用Node，基本没有区别，都是<code>key</code>，<code>value</code>，<code>hash</code>，<code>next</code>四个属性。<code>Node</code>只能适用于链表，<code>TreeNode</code>用于红黑树。</p>

        <h2 id="put"   >
          <a href="#put" class="heading-link"><i class="fas fa-link"></i></a><a href="#put" class="headerlink" title="put()"></a>put()</h2>
      <blockquote>
<p><code>put</code>方法重点也是在于得到哈希值，然后就是处理一下<strong>扩容</strong>，<strong>哈希冲突</strong>，<strong>链表转化红黑树</strong>等问题。</p>
</blockquote>
<p>Java7是先扩容再插入值，Java8是先插入值再扩容。第一次<code>put</code>需要初始化一下<code>table</code>数组（从<code>null</code>初始化到默认容量16或者自定义容量），才能加入数据。</p>
<p>需要注意的是，如果两次使用<code>put</code>时，加入的<code>key</code>都是相同的，那么第二次的<code>value</code>应该覆盖第一次的，所以在<code>put</code>时也应该考虑到这一点，<strong>发生哈希冲突应该首先检查Key是不是相同的再进行下一步操作</strong>。</p>
<p>重点讲一下扩容操作：扩容时需要重新<code>hash</code>，并不是说要重新调用<code>hash</code>这个函数，<code>Node(TreeNode)</code>节点之前就保存了<code>hash</code>值的。</p>
<p>如果<code>hash</code>值超过了容量<code>cap</code>，需要取余操作，因为<code>cap</code>都是2的指数，所以<code>cap-1</code>（最大下标）的低位就全是1，取余操作就可以为：<code>hash &amp; (cap - 1)</code>。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/02/d1b17259fca6ec00.jpg"></p>
<p>所以一条冲突链表上的数据节点的哈希值并不一定都是相同的，可能是取余后才导致下标相同。所以在重新哈希的过程中，就需要对冲突链表拆分为两条链表，一条链表是哈希值本来就是当前下标，另一个是哈希值被取余了的（这条链表上也并不是哈希值都相同，只是取余后值都相同，5和7被2取余值也相同嘛）。</p>
<p>因为每次扩容都是容量乘2，所以后一条链表的新下标就是<code>i+cap</code>。</p>
<blockquote>
<p><code>i&lt;cap，(i+cap) % 2cap = i+cap</code>。</p>
</blockquote>

        <h2 id="get"   >
          <a href="#get" class="heading-link"><i class="fas fa-link"></i></a><a href="#get" class="headerlink" title="get()"></a>get()</h2>
      <blockquote>
<p><code>get</code>方法内部最重要的就是<code>hash()</code>得到其哈希值，然后再通过<code>equals()</code>找到对应的值。</p>
</blockquote>
<p>理解了<code>put</code>的机制和哈希值取余原理后，<code>get</code>分析就比较简单了。</p>
<ul>
<li><p>计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1)。</p>
</li>
<li><p>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步。</p>
</li>
<li><p>判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步。</p>
</li>
<li><p>遍历链表，直到找到相等(&#x3D;&#x3D;或equals)的 key。</p>
</li>
</ul>

        <h1 id="HashSet"   >
          <a href="#HashSet" class="heading-link"><i class="fas fa-link"></i></a><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1>
      <p><code>HashSet</code>使用了适配器模式，对<code>HashMap</code>进行了简单的包装，对<code>HashSet</code>的函数调用都会转换成合适的<code>HashMap</code>方法。这里提一下，不需要过多赘述。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashSet是对HashMap的简单包装</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;<span class="comment">//HashSet里面有一个HashMap</span></span><br><span class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;<span class="comment">//简单的方法转换</span></span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/collection/java-map-HashMap&amp;HashSet.html" >https://pdai.tech/md/java/collection/java-map-HashMap&amp;HashSet.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javase/syy4rz#b2b51e41" >https://www.yuque.com/qingkongxiaguang/javase/syy4rz#b2b51e41</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet%20and%20HashMap.md#get" >https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet%20and%20HashMap.md#get</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/01/Java/%E5%B9%B6%E5%8F%91/Java%E5%85%B3%E9%94%AE%E5%AD%97-volatile/">Java关键字volitale</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-01</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-01</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="volatile关键字"   >
          <a href="#volatile关键字" class="heading-link"><i class="fas fa-link"></i></a><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1>
      <p>并发存在的问题主要是可见性，原子性，有序性。原子性可以通过<code>synchronized</code>实现同步，可见性，有序性通过<code>volatile</code>解决。</p>
<p>可见性：CPU直接和内存交互太慢了，所以CPU直接和缓存交互。在多核CPU中，每个CPU各自有一个缓存，在A修改了某一变量时，可能来不及写入内存并让其他CPU读取，造成修改的不可见。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/01/14eaf6c457e413c7.jpg"></p>
<blockquote>
<p>缓存一致性协议就是为了解决一致性问题。</p>
</blockquote>
<p><code>volatile</code>可以保证可见性，当某一个线程修改了被<code>volatile</code>修饰的变量后，其他线程会马上更新这个变量。但是它依然不能解决原子性问题，就像那个最经典的多个线程<code>i++</code>一样，自增操作是被瓜分为了多个步骤完成的，虽然保证了可见性，但是只要手速够快，依然会出现两个线程同时写同一个值的问题（比如线程1刚刚将a的值更新为100，这时线程2可能也已经执行到更新a的值这条指令了，<strong>已经刹不住车了</strong>，所以依然会将a的值再更新为一次100）。</p>
<p>此处顺便介绍一下<strong>Java内存模型（JMM）</strong>：采用了类似的模型支持多线程</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/01/4d01a61364ae80bf.jpg"></p>
<ul>
<li>所有的变量全部存储在主内存。</li>
<li>每条线程有着自己的工作内存，线程对变量的所有操作，必须在工作内存中进行，不能直接操作主内存中的数据。</li>
<li>不同线程之间的工作内存相互隔离，如果需要在线程之间传递内容，只能通过主内存完成，无法直接访问对方的工作内存。</li>
</ul>
<p>有序性：为了优化程序，编译时会对指令进进行重排序，有可能暴露出未初始化的空内存出来。以双重检查的单例模式为例：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleInstance</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SignleInstance instance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SignleInstance <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//锁住这个类，无论哪个实例来执行这段代码都要拿到锁</span></span><br><span class="line">            <span class="keyword">synchronized</span>(SignleInstance.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">SingleInstance</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>对于<code>instance = new SingeInstance()</code>，正常的CPU指令为：</p>
<ol>
<li>分配内存空间</li>
<li>初始化对象</li>
<li>将instance引用指向内存空间</li>
</ol>
<p>但是重排序后可能执行顺序就是：</p>
<ol>
<li>分配内存空间</li>
<li>将instance引用指向内存空间</li>
<li>初始化对象</li>
</ol>
<p>如果线程在执行完2后中断，其他的线程再来执行<code>getInstance()</code>方法，就会拿到一个没有初始化的instance。</p>
<blockquote>
<p><code>volaitle</code>关键字可以产生内存屏障防止重排序。</p>
</blockquote>

        <h1 id="应用场景"   >
          <a href="#应用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1>
      <p>上面单例模式中为了解决重排序就可以使用<code>volatie</code>。</p>

        <h2 id="模式1：状态标志"   >
          <a href="#模式1：状态标志" class="heading-link"><i class="fas fa-link"></i></a><a href="#模式1：状态标志" class="headerlink" title="模式1：状态标志"></a>模式1：状态标志</h2>
      <p>用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> shutdownRequest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123; shutdownRequested = <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">while</span> (!shutdownRequested) &#123; </span><br><span class="line">        <span class="comment">// do stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="模式2：独立观察"   >
          <a href="#模式2：独立观察" class="heading-link"><i class="fas fa-link"></i></a><a href="#模式2：独立观察" class="headerlink" title="模式2：独立观察"></a>模式2：独立观察</h2>
      <p>安全使用 volatile 的另一种简单模式是定期 发布 观察结果供程序内部使用。例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> String lastUser;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">authenticate</span><span class="params">(String user, String password)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> passwordIsValid(user, password);</span><br><span class="line">        <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            activeUsers.add(u);</span><br><span class="line">            lastUser = user;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="模式3：volatile-bean模式"   >
          <a href="#模式3：volatile-bean模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#模式3：volatile-bean模式" class="headerlink" title="模式3：volatile bean模式"></a>模式3：volatile bean模式</h2>
      <p>在volatile bean模式中，JavaBean所有数据成员都是volatile类型，并且getter，setter方法必须非常普通—— 除了获取或设置相应的属性外，不能包含任何逻辑。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> age;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFirstName</span><span class="params">()</span> &#123; <span class="keyword">return</span> firstName; &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLastName</span><span class="params">()</span> &#123; <span class="keyword">return</span> lastName; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirstName</span><span class="params">(String firstName)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLastName</span><span class="params">(String lastName)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p>冰河《深入理解高并发编程》第一版</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/thread/java-thread-x-key-volatile.htm" >https://pdai.tech/md/java/thread/java-thread-x-key-volatile.htm</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javase/vd60g5#21cd9456" >https://www.yuque.com/qingkongxiaguang/javase/vd60g5#21cd9456</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/logo.png" alt="avatar"></div><p class="sidebar-ov-author__text">You have lots more to work on</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">75</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">2</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">12</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh_tw" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Cyan</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.2.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.7.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.7.0"></script><script src="/js/stun-boot.js?v=2.7.0"></script><script src="/js/scroll.js?v=2.7.0"></script><script src="/js/header.js?v=2.7.0"></script><script src="/js/sidebar.js?v=2.7.0"></script></body></html>