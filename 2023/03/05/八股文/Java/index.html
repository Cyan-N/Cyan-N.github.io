<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.jpg"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><link rel="mask-icon" href="/images/logo.svg" color=""><link rel="manifest" href="/images/manifest.json"><meta name="msapplication-config" content="/images/browserconfig.xml"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="慕青の迷途" href="https://cecilia.cool/rss.xml"><link rel="alternate" type="application/atom+xml" title="慕青の迷途" href="https://cecilia.cool/atom.xml"><link rel="alternate" type="application/json" title="慕青の迷途" href="https://cecilia.cool/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="八股文"><link rel="canonical" href="https://cecilia.cool/2023/03/05/%E5%85%AB%E8%82%A1%E6%96%87/Java/"><title>Java | 慕青の迷途 = 欲买桂花同载酒，终不似，少年游</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Java</h1><div class="meta"><span class="item" title="创建时间：2023-03-05 10:02:30"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-03-05T10:02:30+08:00">2023-03-05</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>4.7k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>4 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">慕青の迷途</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="http://s3.bmp.ovh/imgs/2023/01/02/56251922ad3fec57.jpg"></li><li class="item" data-background-image="http://s3.bmp.ovh/imgs/2023/01/19/2bad64102fa0d427.jpg"></li><li class="item" data-background-image="http://s3.bmp.ovh/imgs/2023/01/04/490d9b02ccc2f34b.jpg"></li><li class="item" data-background-image="http://s3.bmp.ovh/imgs/2023/01/01/10ae4369630f97f2.png"></li><li class="item" data-background-image="http://s3.bmp.ovh/imgs/2023/01/01/439e4c4ff106c9a5.jpg"></li><li class="item" data-background-image="http://s3.bmp.ovh/imgs/2023/01/19/39744d34873248e5.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cecilia.cool/2023/03/05/%E5%85%AB%E8%82%A1%E6%96%87/Java/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="Cyan"><meta itemprop="description" content="欲买桂花同载酒，终不似，少年游, 时雨病重症患者"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="慕青の迷途"></span><div class="body md" itemprop="articleBody"><h1 id="基础"><a class="anchor" href="#基础">#</a> 基础</h1><blockquote><p>1. 谈谈深拷贝和浅拷贝</p></blockquote><ul><li>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li><li>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li></ul><p>在 <code>Object</code> 类中，有个 <code>clone()</code> 方法，默认的就是浅拷贝，一个类想要重写 <code>clone()</code> 函数，需要实现 <code>Cloneable</code> 接口，自己实现深拷贝，就可以在 <code>clone</code> 函数中直接 <code>new</code> 就行。序列化也是深拷贝，这里直接给代码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">DeepClone</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>     <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">1412L</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>     <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">deepClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>          <span class="token comment">// 序列化，将数据存到 bos 中</span></pre></td></tr><tr><td data-num="6"></td><td><pre>          <span class="token class-name">ByteArrayOutputStream</span> bos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>          <span class="token class-name">ObjectOutputStream</span> oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>bos<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>          oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>          <span class="token comment">// 反序列化</span></pre></td></tr><tr><td data-num="10"></td><td><pre>          <span class="token class-name">ByteArrayInputStream</span> bis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>bos<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>          <span class="token class-name">ObjectInputStream</span> ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>bis<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>          <span class="token keyword">return</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>     <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里解释一下序列化的两个类：</p><ul><li><code>ByteArrayOutputStream</code> ：提供了一个输出流的实现，将数据写入一个字节数组。它是 <code>OutputStream</code> 的子类，当您需要将数据写入字节数组而不是文件或其他输出流时， <code>ByteArrayOutputStream</code> 非常有用</li><li><code>ObjectOutputStream</code> ：它提供了一个输出流的实现，将对象写入一个字节流。它是 <code>OutputStream</code> 的子类，提供了向字节流写入对象和检索字节流内容的方法。 <code>ObjectOutputStream</code> 可以与 <code>ByteArrayOutputStream</code> 一起使用，将对象写入字节数组而不是文件或其他输出流。</li></ul><h1 id="集合"><a class="anchor" href="#集合">#</a> 集合</h1><p>涉及到 Java 集合部分，也包括线程安全的集合，还是以面试题的形式记录。</p><blockquote><p>1. <code>ArrayList</code> 和 <code>LinkedList</code> 遍历谁更快？</p></blockquote><p><code>ArrayList</code> 更快， <code>ArrayList</code> 的优势就是内存连续，如果遍历 <code>LinkedList</code> ，随机 IO 可能更多一些</p><blockquote><p>2. 谈谈你对 <code>ArrayList</code> 的理解</p></blockquote><p>从我学习程度来看， <code>ArrayList</code> 需要注意的是：</p><ul><li>线程不安全，如果要保证安全，可以使用 <code>Vector</code> 或者使用 <code>Collections.synchronizedList(xx)</code> ，前者在每个操作方法上都加了 <code>synchronized</code> 关键字，后者内部会维护一个排他锁，每次对集合操作时，都需要先竞争锁。</li><li>迭代器的 <code>fail-fast</code> 机制：这其实是每个实现了 <code>iterator</code> 集合都需要注意的地方，每次对数组进行增删，都会使得 <code>modCount++</code> ，而迭代器的 <code>next</code> 函数会检测 <code>modCount</code> 是否和最开始的自己保存的 <code>modCount</code> 相同，也就是检测在迭代的过程中数组是否发生了改变，<strong>因为这可能使得迭代过程中漏了某些元素或者重复遍历某些元素</strong>。</li><li><code>ArrayList</code> 内部是使用 <code>Object</code> 数组 -- <code>elementData</code> ，但是该变量没有被 <code>private</code> 修饰，代码注释写的是方便内部类更快的访问该属性，如果被 <code>private</code> 修饰，那么同样的代码反编译后的字节码文件更复杂一些。</li><li>扩容时，是 1.5 倍增长，而 <code>Vector</code> 扩容默认两倍扩容。</li></ul><blockquote><p>3. <code>HashMap</code> 了解吗？1.7 版本和 1.8 版本都什么区别</p></blockquote><p><code>JDK1.7</code> 的 <code>HashMap</code> 使用的是数组桶加链表，如果链表过长，那么时间复杂度会退化为 O (n)，而 1.8 使用的引入了红黑树，当链表节点为 8 时，就转为红黑树。至于为什么是 8，估计也是个统计概率值。</p><p><code>1.7</code> 节点插入时使用的是头插法，而 1.8 使用的是尾插法，头插在并发环境下容易出现环导致死循环，具体形成原因我并没有仔细研究，因为我认为 <code>HashMap</code> 本身就是线程不安全的，无论是头插还是尾插，在并发环境下都不能使用 <code>HashMap</code> ，曾经也有人向社区报告 <code>bug</code> 说 1.7 的 <code>HashMap</code> 尾插会在并发环境下出现死循环，但是社区并没有管，而是回复 “ <code>HashMap</code> 本来就不是给你在并发环境用的，想要安全请使用 <code>ConcurrentHashMap</code> ”。</p><blockquote><p>4. <code>HashMap</code> 扩容机制了解过吗，为什么容量大小必须是 2 的指数</p></blockquote><p><code>HashMap</code> 的容量大小默认是 16，阿里巴巴开发规范插件提示在初始化 <code>HashMap</code> 时尽量指定容量大小（预计存储个数 / 负载因子 + 1），因为没有指定可能会导致多次扩容，这个涉及到重建 <code>Hash</code> 表，链表分拆的操作，比较耗时。如果构造函数传入的容量不是 2 的指数，那么会将容量设置为既是 2 的指数，又是大于传入参数的最小数。</p><p>至于为什么是 2 的指数，涉及 <code>hash</code> 公式，也就是 <code>index = hash &amp; (len - 1)</code> ，这个公式其实就相当于用长度取模 <code>index = hash % len</code> ，只不过位运算快很多。扩容机制为两倍扩容，公式为 <code>newCap = 2 * oldCap</code> ，我们假设下标为 <code>i</code> 的那一部分，这个部分的链表的节点都满足 <code>hash / len = y ... i</code> ，也就是说，我们假设商为 <code>y</code> ，那么当商为奇数时（ <code>hash &amp; oldCap == 0</code> ），扩容后再使用 <code>hash</code> 公式得到的结果就是 <code>i+n</code> ，如果商为偶数的话，扩容后再 <code>hash</code> 的结果还是 <code>i</code> 。这就使得每次扩容，都将现有的链表拆为两部分，一部分留在当前下标，另一部分转移到扩容后的 <code>i+n</code> 处，这种机制使用扩容时逻辑简单，操作迅速，还使得数组中节点分布均匀，不会出现那种节点都分布在前半部分或者后半部分。</p><blockquote><p>5. 为什么重写 <code>equals</code> 方法的同时建议重写 <code>hashCode方法</code> ，能用 <code>HashMap</code> 举个例子吗？</p></blockquote><p>我们假设一个类为 <code>People</code> ，只有一个属性 <code>name</code> ，那么现实情况下，两个对象相等，要么他们内存地址相同，要么 <code>equals</code> 比较后相同，这里也就是 <code>name</code> 相同。如果不重写 <code>hashCode</code> 方法，也就是使用 <code>Object</code> 内置的方法。现在有两个内存地址不同的 <code>People</code> 对象， <code>name</code> 相同使得 <code>equals</code> 相同，但是 <code>hashCode</code> 却不相同，那么当这两个对象作为 <code>Key</code> 加入到 <code>HashMap</code> 时，我们希望的是后加入的对象会覆盖前面加入的，因为两个对象是相同的，但是因为 <code>hashCode</code> 不同，他们两个甚至连映射出来的数组下标都不同，是无法覆盖的。这也就导致 <code>HashMap</code> 中有两个相同的 <code>key</code> ，这明显不符合哈希表的定义。</p><p>再来看 <code>HashMap</code> 的源码，为了实现覆盖操作，首先就要使得 <code>equals</code> 相同的对象 <code>hashCode</code> 也相同才一定能映射到同样的下标，然后顺着链表向下查找，如果 <code>HashCode</code> 相同，同时 <code>equals</code> 也相同就会覆盖，反之如果遍历了整个链表都没有这样的节点，就算做新增节点，尾插到链表中。</p><blockquote><p>6. 说说 <code>HashMap</code> 与 <code>HashTable</code> 的区别</p></blockquote><ul><li>并发： <code>HashTable</code> 用于并发环境，通过在方法上加入 <code>synchronized</code> 关键字保证线程安全，但是并行度太低了，所以大多数都使用 <code>ConcurrentHashMap</code> 。而 <code>HashMap</code> 是线程不安全的。</li><li>存储： <code>HashTable</code> 键值对不允许存储 <code>null</code> ，而 <code>HashMap</code> 却可以， <code>HashTable</code> 源码中会先判断 <code>value</code> 是不是 <code>null</code> ，从而抛出空指针异常，并且会直接调用 <code>key</code> 的 <code>hashCode</code> 方法，计算比较粗暴，而 <code>HashMap</code> 统一指定 <code>key==null</code> 时 <code>hashCode</code> 为 0，至于 <code>value</code> 是否为 <code>null</code> 完全不重要，因为插入删除过程都不会涉及到 <code>value</code> ，只会比较 <code>key</code> 。</li><li>迭代： <code>HashTable</code> 有两个迭代器， <code>Enumeration</code> 使用的是安全失败机制（ <code>fail-safe</code> ），而 <code>Iterator</code> 是快速失败机制。 <code>HashMap</code> 使用的是快速失败机制。</li></ul><blockquote><p>7. 刚才提到 <code>ConcurrentHashMap</code> ，你知道什么？</p></blockquote><p>参考链接：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvTXk0UF9CQlhEbkFHWDFnaDYzMFpLdw==">https://mp.weixin.qq.com/s/My4P_BBXDnAGX1gh630ZKw</span></p><p>这个也要分 <code>1.7</code> 和 <code>1.8</code> 两个版本：</p><ul><li><code>1.7</code> 使用的是数组桶 + 链表，分段，段数决定并行度。通俗来讲， <code>1.7</code> 版本维护了一个数组，数组中每个元素都是一个 <code>HashMap</code> ，上锁就是对每个段上锁。所以并行度并不高</li><li><code>1.8</code> 使用的是数组桶 + 链表（升级红黑树），同时锁的粒度更小了，使用 <code>CAS+synchronized</code> 来实现并发安全。维护的数组和 <code>HashMap</code> 的数组是一致的，只不过每次上锁都是对要修改的下标单个元素进行上锁。由于 <code>Synchronized</code> 的性能采用锁升级的方式优化后， <code>ConcurrentHashMap</code> 的性能也随之上升。</li></ul><p>至于 <code>CAS</code> 操作，是对数组元素进行修改，也就是<strong>链表的表头</strong>。</p><p>只要上了锁，保证了线程安全，其他的都和 <code>HashMap</code> 没有太多区别，也就有些细节不同，比如 <code>HashMap</code> 再加入一个键值对就要扩容了，它会先插入再扩容，而 <code>ConcurrenHashMap</code> 是先扩容再插入。</p><blockquote><p>8. 这么了解 <code>ConcurrentHashMap</code> ，你实际用过吗，或者你看源码有什么地方用过吗？</p></blockquote><p>我倒是还没有做过并发项目，所以也就是看别人用过，这里举一个比较偏的现实例子。在日志框架中，日志门面 <code>slf4j-api</code> 自带了一个实现，叫做 <code>slf4j-simple</code> ，它在实现 <code>LoggerFactory</code> 时就用到了 <code>ConcurrenMap</code> ，键值对是 <code>&lt;String,Logger&gt;</code> ，这里的 <code>String</code> 对应的就是 <code>name</code> 。当外界传给 <code>LoggerFactory</code> 一个 <code>name</code> 时，就会从 <code>ConcurrentHashMap</code> 中找，如果有就返回，没有就新建一个，缓存起来再返回。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleLoggerFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ILoggerFactory</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token class-name">ConcurrentMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Logger</span><span class="token punctuation">></span></span> loggerMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">SimpleLoggerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">SimpleLogger</span><span class="token punctuation">.</span><span class="token function">lazyInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Logger</span> <span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token class-name">Logger</span> simpleLogger <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Logger</span><span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>loggerMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>simpleLogger <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">return</span> simpleLogger<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token class-name">Logger</span> newInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleLogger</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token class-name">Logger</span> oldInstance <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Logger</span><span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>loggerMap<span class="token punctuation">.</span><span class="token function">putIfAbsent</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> newInstance<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Logger</span><span class="token punctuation">)</span><span class="token punctuation">(</span>oldInstance <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> newInstance <span class="token operator">:</span> oldInstance<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>loggerMap<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>其实日志中使用 <code>ConcurrentHashMap</code> 很正常，因为日志打印本身就经常处于并发环境中，有些甚至会专门分配线程去处理日志。有时类专门有一个 <code>Logger</code> ，其对应键值就是类的全类限定名，多个线程可能都会请求这个 <code>logger</code> ，自然就需要线程安全的容器来缓存。</p><div class="tags"><a href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" rel="tag"><i class="ic i-tag"></i> 八股文</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-04-17 17:30:56" itemprop="dateModified" datetime="2023-04-17T17:30:56+08:00">2023-04-17</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Cyan <i class="ic i-at"><em>@</em></i>慕青の迷途</li><li class="link"><strong>本文链接：</strong> <a href="https://cecilia.cool/2023/03/05/%E5%85%AB%E8%82%A1%E6%96%87/Java/" title="Java">https://cecilia.cool/2023/03/05/八股文/Java/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/02/27/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="prev" data-background-image="http:&#x2F;&#x2F;s3.bmp.ovh&#x2F;imgs&#x2F;2023&#x2F;01&#x2F;19&#x2F;d57032385ca89b73.jpg" title="计算机网络"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>计算机网络</h3></a></div><div class="item right"><a href="/2023/03/05/%E4%BA%8C%E6%AC%A1%E5%85%83/Galgame%E7%9B%AE%E5%BD%95/" itemprop="url" rel="next" data-background-image="http:&#x2F;&#x2F;s3.bmp.ovh&#x2F;imgs&#x2F;2023&#x2F;01&#x2F;01&#x2F;de59375713f35ff7.jpg" title="Galgame目录"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>Galgame目录</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">基础</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">2.</span> <span class="toc-text">集合</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Cyan" data-src="/images/avatar.png"><p class="name" itemprop="name">Cyan</p><div class="description" itemprop="description">时雨病重症患者</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">149</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">1</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">24</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0N5YW4tTg==" title="https:&#x2F;&#x2F;github.com&#x2F;Cyan-N"><i class="ic i-github"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/02/27/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/03/05/%E4%BA%8C%E6%AC%A1%E5%85%83/Galgame%E7%9B%AE%E5%BD%95/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2022 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Cyan @ 慕青の迷途</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">613k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">9:17</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/03/05/八股文/Java/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>