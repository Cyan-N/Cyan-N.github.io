<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.7.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.7.0" type="image/png" sizes="32x32"><meta name="description" content="我始终勇往直前，百折不回...">
<meta property="og:type" content="website">
<meta property="og:title" content="慕青的日记">
<meta property="og:url" content="https://cecilia.cool/index.html">
<meta property="og:site_name" content="慕青的日记">
<meta property="og:description" content="我始终勇往直前，百折不回...">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Cyan">
<meta name="twitter:card" content="summary"><title>慕青的日记 | Cyan</title><link ref="canonical" href="https://cecilia.cool/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.7.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">慕青的日记</div><div class="header-banner-info__subtitle">Cyan</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/16/%E5%A8%B1%E4%B9%90/%E8%BD%BB%E5%B0%8F%E8%AF%B4%E7%BB%93%E5%B1%80%E9%AD%94%E6%94%B9/%E3%80%8A%E6%88%91%E5%92%8C%E5%A5%B3%E5%8F%8B%E7%9A%84%E5%A6%B9%E5%A6%B9%E6%8E%A5%E5%90%BB%E4%BA%86%E3%80%8B/">《我和女友的妹妹接吻了》</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-16</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-17</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h1>
      <p>这本书每次更新，在GA文库里面，直接就是S级热度，褒贬不一，但大家最统一的意见就是对结局不满意（汉化结局还没出，但是有人看了日文版，然后剧透，我谢谢。处于对结局的不满，我会在汉化版更新完后按照自己的想法重构以下结局，之于我喜欢的结局。</p>
<p>作者<strong>海陆空</strong>，说实话，这本书关于人物心理描写是很到位了，剧情矛盾也十分突出，个人人为最重要的，最好的，就是每个人的个性鲜明，而且至始至终。无论是两面为难，抉择不定的佐藤博道，还是堪称完美的佐藤时雨（没错，我对时雨的评价非常高：颜值高，格斗强，会持家，擅长理解包容他人，敢爱敢恨等等，我就是时雨重度患者），以及将周围理想化的才川晴香。</p>
<blockquote>
<p>其实仅限三个人，人物塑造难度也不大。</p>
</blockquote>
<p>下面给出一些节选，我觉得写的比较好：</p>
<p>佐藤博道心理活动：</p>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不是的，晴香，不是这样的。</span><br><span class="line">......我其实才不在乎什么烟火大会，对那一点兴趣也没有。约会也一样。今天也好明天也罢，哪天都无所谓。只是......我就只是希望......你能够选择我。</span><br></pre></td></tr></table></div></figure>

<p>佐藤时雨对话：</p>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">要是这样的感情能传达给哥哥，那么和姊姊的关系如何，对我来说都无所谓了。曾经是挚爱的姊姊，也变得不重要。</span><br><span class="line">......就是这强烈的执著，将我的世界划分为【唯一一人】和【其他人】两个部分。我想这就是所谓的爱吧。</span><br></pre></td></tr></table></div></figure>

<p>才川晴香心理活动：</p>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">那个瞬间，我感觉我的一切不愉快都被吹到了身后。</span><br><span class="line">从自己最喜欢的人那，第一次拿到生日礼物。我内心的一切阴霾皆被那沾满各种色彩的刷子有力地覆盖掉了。</span><br><span class="line">我知道博道君一定准备好了礼物。</span><br><span class="line">就像我知道他一定只爱着我一样。</span><br><span class="line">我相信他会一直回应我的期待，这点自信我还是有的。但是，一旦得到了他的回应，我感觉自己的身体，从脸颊遍及全身，都热的像是要融化了一样。</span><br></pre></td></tr></table></div></figure>



<p>我要说的是</p>
<blockquote>
<p>虽然我很推荐这本轻小说，但是，如果你觉得你是那种对于爱情忠贞不渝，无论对方怎么”冷落“你，你都会回应她的期待，如果你觉得你总是能快刀斩乱麻，如果你觉得这本书一看标题就是让人无语的ntr小说，抱歉，请不要看这本书，因为它确实不适合你。不过分地说，我就是为了这本书单独开了这么一个<strong>轻小说结局魔改</strong>的tag，因为结局让我意难平啊。</p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/16/Java/Mybatis/Mybatis(1)-%E5%88%9D%E4%BD%BF%E7%94%A8/">Mybatis(1)--初使用</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-16</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-16</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="XML语言"   >
          <a href="#XML语言" class="heading-link"><i class="fas fa-link"></i></a><a href="#XML语言" class="headerlink" title="XML语言"></a>XML语言</h1>
      <p><code>xml</code>与<code>html</code>都是标准通用标记语言的子集，SGML(SGM)标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言，具有极好的扩展性。</p>
<ul>
<li><code>html</code>用于显示数据，其中元素是固定的，浏览器解析执行。</li>
<li><code>xml</code>用于传输和存储数据，标签可以是用户自定义的，<code>xml</code>解析器需要自己写。</li>
</ul>

        <h2 id="文档声明"   >
          <a href="#文档声明" class="heading-link"><i class="fas fa-link"></i></a><a href="#文档声明" class="headerlink" title="文档声明"></a>文档声明</h2>
      <p><code>xml</code>文档首先需要使用<strong>文档声明</strong>来声明文档，且必须出现在文档第一行：</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;GB2312&quot;</span> standalone=<span class="string">&quot;yes&quot;</span>?&gt;</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li><p><code>version</code>是版本号，<code>xml 1.0</code>版本在1998年发布，2004年发布<code>1.1</code>版本，但是<code>1.1</code>版本不向下兼容<code>1.0</code>版本，所以现在使用的依然是<code>1.0</code>。</p>
</li>
<li><p><code>encoding</code>表示编码格式。</p>
</li>
<li><p><code>standalone</code>表示文档是否独立，即是否依赖其他文档。</p>
</li>
</ul>
<blockquote>
<p>没有文档声明的<code>xml</code>文档，不是格式良好的<code>xml</code>文档。文档声明必须从<code>xml</code>文档的1行1列开始 也就是必须第一行顶格写。</p>
</blockquote>

        <h2 id="XML元素"   >
          <a href="#XML元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#XML元素" class="headerlink" title="XML元素"></a>XML元素</h2>
      <p>元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。元素可包含其他元素、文本或者两者的混合物。元素也可以拥有属性。</p>
<blockquote>
<p>一个标签就是一个元素。</p>
</blockquote>
<p>要求：</p>
<ul>
<li>元素都必须有关闭标签,省略关闭标签是非法的。声明不是XML的元素,所以第一行的声明,并不需要关闭标签。</li>
<li>大小敏感，必须正确嵌套。</li>
<li>有且必须只有一个根元素。</li>
</ul>
<blockquote>
<p>标签命名应尽可能简短，可以使用下划线_，避免使用连字符 -。</p>
</blockquote>
<p>一个元素（标签）可以有多个属性，<code>xml</code>属性是键值对形式，如<code>sex = &quot;male&quot;</code>，值必须加单（双）引号。</p>

        <h2 id="注释"   >
          <a href="#注释" class="heading-link"><i class="fas fa-link"></i></a><a href="#注释" class="headerlink" title="注释"></a>注释</h2>
      <p><code>CDATA</code>区段中的文本会被解析器忽略——<code>&lt;![CDATA[]]&gt;</code>。</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">&lt;![CDATA[to be or not to be]]&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></div></figure>




        <h2 id="解析XML"   >
          <a href="#解析XML" class="heading-link"><i class="fas fa-link"></i></a><a href="#解析XML" class="headerlink" title="解析XML"></a>解析XML</h2>
      <blockquote>
<p>JDK内置了一个<code>org.w3c</code>的XML解析库。</p>
</blockquote>
<p>首先我们创建一个<code>test.xml</code>文件，为了简单，直接把它放在项目目录下（与<code>src</code>同级）</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">message</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">to</span>&gt;</span>Mike<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">from</span>&gt;</span>Bob<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">content</span>&gt;</span>please get up<span class="tag">&lt;/<span class="name">content</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>这是最基本的<code>xml</code>内容，也是w3c的例子。</p>
<p>再写一下解析代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建DocumentBuilderFactory对象</span></span><br><span class="line">    <span class="type">DocumentBuilderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">    <span class="comment">// 创建DocumentBuilder对象</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">DocumentBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> factory.newDocumentBuilder();</span><br><span class="line">        <span class="comment">// 这里要改成test.xml路径，因为直接放在根目录下，所以只需要写文件名</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">d</span> <span class="operator">=</span> builder.parse(<span class="string">&quot;test.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 每一个标签都作为一个节点</span></span><br><span class="line">        <span class="type">NodeList</span> <span class="variable">nodeList</span> <span class="operator">=</span> d.getElementsByTagName(<span class="string">&quot;message&quot;</span>);  <span class="comment">// 可能有很多个名字为message的标签</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">rootNode</span> <span class="operator">=</span> nodeList.item(<span class="number">0</span>); <span class="comment">// 获取首个</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 一个节点下可能会有很多个节点，比如根节点下就囊括了所有的节点</span></span><br><span class="line">        <span class="type">NodeList</span> <span class="variable">childNodes</span> <span class="operator">=</span> rootNode.getChildNodes(); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//节点可以是一个带有内容的标签（它内部就还有子节点），也可以是一段文本内容</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; childNodes.getLength(); i++) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">child</span> <span class="operator">=</span> childNodes.item(i);</span><br><span class="line">            <span class="comment">//过滤换行符之类的内容，因为它们都被认为是一个文本节点</span></span><br><span class="line">            <span class="keyword">if</span>(child.getNodeType() == Node.ELEMENT_NODE)  </span><br><span class="line">                System.out.println(child.getNodeName() + <span class="string">&quot;：&quot;</span> +child.getFirstChild().getNodeValue());</span><br><span class="line">            <span class="comment">// 输出节点名称，也就是标签名称，以及标签内部的文本（内部的内容都是子节点，所以要获取内部的节点）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>结果：</p>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">to：Mike</span><br><span class="line">from：Bob</span><br><span class="line">content：please get up</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>Mybatis也是使用的JDK内置的<code>xml</code>解析器。</p>
</blockquote>

        <h1 id="初次使用"   >
          <a href="#初次使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#初次使用" class="headerlink" title="初次使用"></a>初次使用</h1>
      <blockquote>
<p>首先要说明的是，Mybatis很好用，可以高效代替<code>JDBC</code>，但是在某些实际场景中，涉及到复杂的联表查询等操作，还是得乖乖手写sql语句，这也警示我们：算法很重要，框架只是节省时间，方便开发。</p>
</blockquote>
<p>通过maven导入依赖：</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>在项目根目录下（web项目放在resources目录）创建<code>mybatis-config.xml</code>文件，其实名字随便取：</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;驱动类（含包名）&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;数据库连接URL&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;用户名&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;密码&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>留个小坑–使用变量</p>
</blockquote>
<p>这里以web项目为例，将<code>xml</code>配置文件放到Resources目录里面，构建一个<code>SqlSessionFactory</code>：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlUtil</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            factory = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().</span><br><span class="line">                build(Resources.getResourceAsReader(<span class="string">&quot;mybatis-config.xml&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title function_">getSqlSession</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> factory.openSession(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的，我们可以通过<code>SqlSessionFactory</code>来创建多个新的会话，<code>SqlSession</code>对象，每个会话就相当于我不同的地方登陆一个账号去访问数据库，你也可以认为这就是之前JDBC中的<code>Statement</code>对象，会话之间相互隔离，没有任何关联。</p>
<p>编写一个实体类Student：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Lombok很方便</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> sid;</span><br><span class="line">    <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>根目录下创建一个mapper文件夹，新建一个<code>TestMapper.xml</code>文件作为映射器：</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;TestMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudent&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.cyan.entity.Student&quot;</span>&gt;</span></span><br><span class="line">        select * from student</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>需要注意<code>resultType</code>属性的包路径，每个人不一样。</p>
</blockquote>
<p>其中<code>namespace</code>就是命名空间，每个Mapper都是唯一的，<strong>因此需要用一个命名空间来区分</strong>，它还可以用来绑定一个接口。在里面写入了一个select标签，表示添加一个select操作，同时<strong>id作为操作的名称</strong>，resultType指定为我们刚刚定义的实体类，表示将数据库结果映射为<code>Student</code>类，然后就在标签中写入我们的查询语句即可。</p>
<p>编写好后再配置文件的<code>&lt;configuration&gt;</code>标签下，添加这个Mapper映射器：</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:mappers/TestMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    这里用的是url，也可以使用其他类型，我们会在后面讲解    --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>最后在程序中使用定义好的Mapper：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlUtil.getSqlSession) &#123;</span><br><span class="line">        List&lt;Student&gt; student = sqlSession.sqlSelectList(<span class="string">&quot;selectStudent&quot;</span>);</span><br><span class="line">        student.forEach(System.out.println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>尽管此时<code>Mybatis</code>使用起来非常方便，但是配置<code>Mapper.xml</code>，映射接口还是有点低效，之后会有更快捷的办法。</p>
</blockquote>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p>xml部分：</p>
<ul>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.w3school.com.cn/xml/xml_cdata.asp" >https://www.w3school.com.cn/xml/xml_cdata.asp</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/noteless/archive/2018/08/01/9400633.html" >https://www.cnblogs.com/noteless/archive/2018/08/01/9400633.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ul>
<p>Mybatis部分：</p>
<ul>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javaweb/gn0syt#af990acc" >https://www.yuque.com/qingkongxiaguang/javaweb/gn0syt#af990acc</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ul>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/14/Java/JVM/JVM(9)-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">JVM(9)-垃圾收集器</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-14</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="垃圾收集器"   >
          <a href="#垃圾收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1>
      <blockquote>
<p>主要是介绍不同收集器得优劣以及使用</p>
</blockquote>
<ul>
<li><p>单线程与多线程: 单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程。</p>
</li>
<li><p>串行与并行: 串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并形指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</p>
</li>
</ul>

        <h2 id="Serial收集器"   >
          <a href="#Serial收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2>
      <p><code>Serial</code>翻译为串行，即以串行的方式执行。它是单线程的收集器，只会使用一个线程进行垃圾收集工作。在进行垃圾收集时，其他线程都要暂停等待。尽管缺点明显，但是从JDK1.3.1开始，Serial收集器就是默认的垃圾收集器了（客户端模式）。</p>
<p>优点：</p>
<ul>
<li>设计简单高效。</li>
<li>在用户的桌面应用场景中，内存一般不大，可以在较短时间内完成垃圾收集，只要不频繁发生，使用串行回收器是可以接受的。</li>
</ul>
<blockquote>
<p>客户端模式一般是一些桌面级图形化界面应用程序，使用内存较少。</p>
</blockquote>
<p>我们可以修改JDK当前模式为客户端模式，可以在jvm.cfg文件将内容修改为</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-client KNOWN</span><br><span class="line">-server IGNORE</span><br></pre></td></tr></table></div></figure>

<p>使用<code>java -version</code>查看当前模式。（下图还没有修改为客户端模式）</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/14/df6e14722988927f.jpg"></p>
<blockquote>
<p>它是 Client 模式下的默认新生代收集器，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。</p>
</blockquote>

        <h2 id="ParNew收集器"   >
          <a href="#ParNew收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2>
      <p>是 Serial 收集器的多线程版本。</p>
<p>是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。</p>
<p>默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。</p>

        <h2 id="Parallel-Scavenge收集器"   >
          <a href="#Parallel-Scavenge收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2>
      <p>其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是<strong>达到一个可控制的吞吐量</strong>，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。</p>
<ul>
<li>停顿时间短适合用于与用户交互的程序，<strong>良好的响应速度提升用户体验</strong>。</li>
<li>高吞吐量可以尽快完成程序运算任务，适合后台运算而不需要太多交互的任务。</li>
</ul>
<blockquote>
<p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的: 新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p>
</blockquote>
<p>还有个<strong>Parallel Old收集器</strong>，是Parallel Scavenge老年代版本，在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p>

        <h2 id="Serial-Old收集器"   >
          <a href="#Serial-Old收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h2>
      <p>Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。</p>
<p>如果用在 Server 模式下，它有两大用途:</p>
<ul>
<li>在 JDK 1.5 以及之前版本(Parallel Old 诞生以前)中与 Parallel Scavenge 收集器搭配使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>
</ul>

        <h2 id="CMS收集器"   >
          <a href="#CMS收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2>
      <blockquote>
<p>CMS(Concurrent Mark Sweep)，Mark Sweep 指的是标记 - 清除算法。</p>
</blockquote>
<p>这款收集器是HotSpot虚拟机中第一款真正意义上的并发（注意这里的并发和之前的并行是有区别的，并发可以理解为同时运行用户线程和GC线程，而并行可以理解为多条GC线程同时工作）收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/14/17a1a966f2a69388.jpg"></p>
<p>整个流程分为四个阶段：</p>
<ul>
<li>初始标记（需要暂停用户线程）：这个阶段的主要任务仅仅只是标记出GC Roots能<strong>直接关联</strong>到的对象，速度比较快，不用担心会停顿太长时间。</li>
</ul>
<blockquote>
<p>直接关联：虚拟机栈，本地方法栈，被锁的对象，静态引用（方法区），虚拟机内部使用的对象</p>
</blockquote>
<ul>
<li><p>并发标记：从GC Roots的直接关联对象开始<strong>遍历整个对象图</strong>的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</p>
</li>
<li><p>重新标记（需要暂停用户线程）：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。这个时间会比初始标记时间长一丢丢。</p>
</li>
<li><p>并发清除：最后就可以直接将所有标记好的无用对象进行删除，因为这些对象程序中也用不到了，所以可以与用户线程并发运行。</p>
</li>
</ul>
<p>具有以下缺点:</p>
<ul>
<li>吞吐量低: 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li>
<li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指<strong>并发清除阶段（第四个阶段）</strong>由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li>
<li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li>
</ul>

        <h2 id="G1收集器"   >
          <a href="#G1收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2>
      <p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1（Garbage First ） 可以直接对新生代和老年代一起回收。</p>
<p>垃圾回收分为<code>Minor GC</code>、<code>Major GC</code>和<code>Full GC</code>，它们分别对应的是新生代，老年代和整个堆内存的垃圾回收，而G1收集器巧妙地绕过了这些约定，它将整个Java堆划分成<code>2048</code>个大小相同的独立<code>Region</code>块，每个<code>Region块</code>的大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且都为2的N次幂。所有的<code>Region</code>大小相同，且在JVM的整个生命周期内不会发生改变。</p>
<p>每一个<code>Region</code>都可以根据需要，自由决定扮演哪个角色（Eden、Survivor和老年代），收集器会根据对应的角色采用不同的回收策略。此外，G1收集器还存在一个Humongous区域，它专门用于存放大对象（一般认为大小超过了Region容量一半的对象为大对象）这样，新生代、老年代在物理上，不再是一个连续的内存区域，而是到处分布的。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/14/9472c91267ced332.jpg"></p>
<p>回收过程与CMS相似：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/14/ec5b94383e100df0.jpg"></p>
<ul>
<li><p>初始标记（暂停用户线程）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。</p>
</li>
<li><p>并发标记：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。</p>
</li>
<li><p>最终标记（暂停用户线程）：对用户线程做一个短暂的暂停，用于处理并发标记阶段漏标的那部分对象。</p>
</li>
<li><p>筛选回收：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，<strong>可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间</strong>。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多个收集器线程并行完成的。</p>
</li>
</ul>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javase/hla7hr#2466c792" >https://www.yuque.com/qingkongxiaguang/javase/hla7hr#2466c792</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/jvm/java-jvm-gc.html#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8" >https://pdai.tech/md/java/jvm/java-jvm-gc.html#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/13/Java/JVM/JVM(8)-%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%B4%BB%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">JVM(8)--对象存活与垃圾回收</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-14</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="对象存活算法"   >
          <a href="#对象存活算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#对象存活算法" class="headerlink" title="对象存活算法"></a>对象存活算法</h1>
      <blockquote>
<p>尽量以简短精炼的语言讲解，唔，所见即所得。</p>
</blockquote>

        <h2 id="引用计数算法"   >
          <a href="#引用计数算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2>
      <p>给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p>
<p>两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。</p>
<p>正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objectA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objectB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        objectA.instance = objectB;</span><br><span class="line">        objectB.instance = objectA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="可达性分析算法"   >
          <a href="#可达性分析算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2>
      <p>通过GC Roots作为起始点进行搜索，能够达到的对象都是存活的，不可达的对象可被回收。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/13/b793a432c31cfc5a.jpg"></p>
<p>GC Roots一般包含：</p>
<ul>
<li><a href="https://cecilia.cool/2022/10/10/Java/JVM/JVM(5)-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89/#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">虚拟机栈</a>中引用的对象（每个线程都有一个虚拟机栈）。</li>
<li><a href="https://cecilia.cool/2022/10/10/Java/JVM/JVM(5)-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89/#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88">本地方法栈</a>中引用的对象（调用native方法）。</li>
<li><a href="https://cecilia.cool/2022/10/11/Java/JVM/JVM(6)-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB/#%E6%96%B9%E6%B3%95%E5%8C%BA">方法区</a>中类静态属性，常量引用的对象（方法区其实就是heap老年代后面那个，又叫元数据区，永久代）。</li>
<li>被添加了锁的对象</li>
<li>虚拟机内部需要用到的对象。</li>
</ul>
<p>一旦已经存在的根节点不满足存在的条件时，那么根节点与对象之间的连接将被断开。此时虽然对象1仍存在对其他对象的引用，但是由于其没有任何根节点引用，所以此对象即可被判定为不再使用。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/13/1622fa539ace74ea.jpg"></p>

        <h2 id="方法区回收"   >
          <a href="#方法区回收" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法区回收" class="headerlink" title="方法区回收"></a>方法区回收</h2>
      <blockquote>
<p>方法区主要存放永久代对象，其回收率很低，因此在方法区主要是对常量池的回收和对类的卸载</p>
</blockquote>
<p>大量使用反射，动态代理，CGLib等框架，这类频繁定义ClassLoader的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。</p>
<p>类卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载：</p>
<ul>
<li><p>该类所有实例都被回收</p>
</li>
<li><p>加载该类的<code>ClassLoader</code>已经被回收</p>
</li>
<li><p>该类对象的Class对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</p>
</li>
</ul>

        <h2 id="finalize"   >
          <a href="#finalize" class="heading-link"><i class="fas fa-link"></i></a><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h2>
      <p><code>finalize()</code> 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，<strong>因此最好不要使用</strong>。</p>
<p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。<strong>自救只能进行一次</strong>，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 <code>finalize()</code> 方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法在Object类中</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="引用类型"   >
          <a href="#引用类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1>
      <p>这个在<code>WeakHashMap</code>中讲过，相关<a href="https://cecilia.cool/2022/10/04/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88(5)-WeakHashMap/">链接</a>。</p>

        <h1 id="垃圾回收"   >
          <a href="#垃圾回收" class="heading-link"><i class="fas fa-link"></i></a><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1>
      
        <h2 id="标记-清除"   >
          <a href="#标记-清除" class="heading-link"><i class="fas fa-link"></i></a><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h2>
      <p><img src="https://s3.bmp.ovh/imgs/2022/10/14/6e2c2f6a36068e2f.jpg"></p>
<p>单纯清理掉未被标记的对象：标记和清除过程效率不高，但是会产生大量不连续的内存碎片。</p>

        <h2 id="标记-整理"   >
          <a href="#标记-整理" class="heading-link"><i class="fas fa-link"></i></a><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h2>
      <p><img src="https://s3.bmp.ovh/imgs/2022/10/14/e25babeccdf54b47.jpg"></p>
<p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>

        <h2 id="复制"   >
          <a href="#复制" class="heading-link"><i class="fas fa-link"></i></a><a href="#复制" class="headerlink" title="复制"></a>复制</h2>
      <p><img src="https://s3.bmp.ovh/imgs/2022/10/14/ea3a84203595777f.jpg"></p>
<p>有没有想起堆区中的两个幸存者区，尽管这不是，这种复制的缺点是只是用了内存的一半，现在的JVM都采用这种收集算法回收新生代，而不是将新生代划分为大小相等的两块，而是分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中一块Survivor。</p>
<p>HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 <strong>8:1</strong>，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，<strong>那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象</strong>（这就是空间分配担保机制）。</p>
<p>先看一下垃圾收集类别：</p>
<ul>
<li><p>Minor GC  -  次要垃圾回收，主要进行新生代区域的垃圾收集。 </p>
</li>
<li><ul>
<li>触发条件：新生代的Eden区容量已满时。</li>
</ul>
</li>
<li><p>Major GC  -  主要垃圾回收，主要进行老年代的垃圾收集。</p>
</li>
<li><p>Full GC    -   完全垃圾回收，对整个Java堆内存和方法区进行垃圾回收。 </p>
</li>
<li><ul>
<li>触发条件1：每次晋升到老年代的对象平均大小大于老年代剩余空间</li>
</ul>
</li>
<li><ul>
<li>触发条件2：Minor GC后存活的对象超过了老年代剩余空间</li>
</ul>
</li>
<li><ul>
<li>触发条件3：永久代内存不足（JDK8之前）</li>
</ul>
</li>
<li><ul>
<li>触发条件4：手动调用<code>System.gc()</code>方法</li>
</ul>
</li>
</ul>
<p><strong>详细的空间分配担保</strong>：</p>
<p>当新生代无法容纳更多的的对象时，可以把新生代中的对象移动到老年代中，这样新生代就腾出了空间来容纳更多的对象。</p>
<p>如果老年代也装不下，首先会判断一下之前的每次垃圾回收进入老年代的平均大小是否小于当前老年代的剩余空间，如果小于，那么说明也许可以放得下（不过也仅仅是也许，依然有可能放不下，因为判断的实际上只是平均值，万一这一次突然非常大呢），否则，会先来一次Full GC，进行一次大规模垃圾回收，来尝试腾出空间，再次判断老年代是否有空间存放，要是还是装不下，直接抛出OOM错误，摆烂。</p>

        <h2 id="分代收集"   >
          <a href="#分代收集" class="heading-link"><i class="fas fa-link"></i></a><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h2>
      <p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p>
<p>一般将堆分为新生代和老年代。</p>
<ul>
<li>新生代使用: 复制算法</li>
<li>老年代使用: 标记 - 清除 或者 标记 - 整理 算法</li>
</ul>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/jvm/java-jvm-gc.html" >https://pdai.tech/md/java/jvm/java-jvm-gc.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javase/hla7hr#ccb10fe4" >https://www.yuque.com/qingkongxiaguang/javase/hla7hr#ccb10fe4</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/12/Java/JVM/JVM(7)-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">JVM(7)--内存模型</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-13</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="引入"   >
          <a href="#引入" class="heading-link"><i class="fas fa-link"></i></a><a href="#引入" class="headerlink" title="引入"></a>引入</h1>
      <blockquote>
<p>内存模型和内存结构不一样，通过本节从堆栈角度引入JMM，为后续内容做铺垫。</p>
</blockquote>
<p>JMM在线程栈和堆之间划分内存，如果你系统的学习过Java，一定听过<strong>引用保存在栈中，实例化对象保存在堆中</strong>这样的话。从逻辑上说明JMM：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/12/542b995303607bcd.jpg"></p>
<p>由线程创建的局部变量对于创建它的线程以外的所有其他线程是不可见的。 即使两个线程正在执行完全相同的代码，两个线程仍将在每个自己的线程堆栈中创建该代码的局部变量。</p>
<blockquote>
<p>基本类型的局部变量完全存储在线程堆栈中，对其他线程不可见；但是<code>new</code>对象时，都存储在堆上，这个对象的成员变量与对象一起存储在堆上。</p>
</blockquote>

        <h2 id="JMM与硬件内存结构关系"   >
          <a href="#JMM与硬件内存结构关系" class="heading-link"><i class="fas fa-link"></i></a><a href="#JMM与硬件内存结构关系" class="headerlink" title="JMM与硬件内存结构关系"></a>JMM与硬件内存结构关系</h2>
      <blockquote>
<p>其实该部分在<code>J.U.C</code>的<code>volatile</code>关键字讲过。</p>
</blockquote>
<p>先看内存结构图：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/12/f8124fb203ff9b3a.jpg"></p>
<p><code>内存-&gt;cache-&gt;寄存器</code>：有些结构是将<code>cache</code>也到了CPU里面。</p>
<p>因为JVM也是一个运行在CPU的程序，所以堆内存和线程栈的数据可能在三个位置，就会导致可见性和同步性的问题：</p>
<blockquote>
<p>可见性：对象共享后，某一个线程做出修改，但是还没有刷新到主存中，就会导致另一个线程看不到修改。</p>
<p>同步性：多个线程的修改，后一个线程可能会掩盖前一个线程的修改。</p>
</blockquote>
<p>这些都是并发讲过的，不多说了，前一个问题通过<code>volatile</code>解决，后一个问题通过上锁解决。</p>
<p>关于第二个问题，同步块有个特性：同步块还保证在同步块内访问的所有变量都将从主存储器中读入，当线程退出同步块时，所有更新的变量将再次刷新回主存储器，无论变量是不是声明为volatile。</p>

        <h1 id="内存模型"   >
          <a href="#内存模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1>
      <blockquote>
<p>接下来的内容与并发内容多有相似之处。总结于Info上的深入理解Java内存模型，作者程晓明。</p>
</blockquote>

        <h2 id="基础"   >
          <a href="#基础" class="heading-link"><i class="fas fa-link"></i></a><a href="#基础" class="headerlink" title="基础"></a>基础</h2>
      <p>线程之间通信机制有两种：共享内存和消息传递。前者很简单，后者的模型中，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</p>
<p>Java 的并发采用的是共享内存模型，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p>

        <h3 id="JMM抽象"   >
          <a href="#JMM抽象" class="heading-link"><i class="fas fa-link"></i></a><a href="#JMM抽象" class="headerlink" title="JMM抽象"></a>JMM抽象</h3>
      <p>在引入中就讲到JMM，线程之间内存不共享。Java中，所有实例，静态域，数组元素存储在堆内存中。我们常说的线程通信，其实就是通过主内存进行通信，因为每个线程都有副本，所以会出现可见性问题。</p>
<p><strong>happens-before</strong>：这个概念用来阐述操作之间的内存可见性，如果a操作的结果需要对b操作可见，那么这两个操作必须存在happens-before关系。</p>
<ul>
<li><p>程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</p>
</li>
<li><p>监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</p>
</li>
<li><p>volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。</p>
</li>
<li><p>传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。</p>
</li>
</ul>
<p>happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。</p>
<blockquote>
<p>因为内容完整性才写的这个，感觉都没什么好说的，知道有这么个概念即可。</p>
</blockquote>

        <h2 id="重排序"   >
          <a href="#重排序" class="heading-link"><i class="fas fa-link"></i></a><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2>
      <p><strong>数据依赖性</strong>：如果两个指令（操作）重排序会导致执行结果改变，就不允许重排序：写后读，读后写，写后写。</p>
<blockquote>
<p>编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p>
</blockquote>
<p><strong>as-if-serial</strong>：不管怎么重排序，（单线程）程序的执行结果不能被改变。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">3.14</span>; <span class="comment">//A</span></span><br><span class="line"><span class="type">double</span> <span class="variable">r</span>   <span class="operator">=</span> <span class="number">1.0</span>; <span class="comment">//B</span></span><br><span class="line"><span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> pi * r * r; <span class="comment">//C</span></span><br></pre></td></tr></table></div></figure>

<p>三个操作数依赖关系：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/12/fb20c093ac1b648f.jpg"></p>
<blockquote>
<p>其实就是A，B可以随意交换执行顺序。其实在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的开发并行度。编译器和处理器遵从这一目标，从 happens- before 的定义我们可以看出，JMM 同样遵从这一目标。</p>
</blockquote>

        <h1 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h1>
      <blockquote>
<p>个人感觉：JMM就是为了（多）线程指令正确执行而做出的努力。</p>
</blockquote>
<p>一般的处理器内存模型都符合这么一个规律：越是追求性能的处理器，内存模型设计会越弱，因为处理器希望内存模型对他们的束缚越少越好。毕竟为了保证并发环境下程序正确执行，会消耗大量资源。</p>
<blockquote>
<p>JMM 是一个语言级的内存模型，处理器内存模型是硬件级的内存模型</p>
</blockquote>
<p>不同处理器平台对于指令的重排序也不相同，JMM通过插入内存屏障阻止这些不同处理器的不同重排序，向上屏蔽了处理器内存模型的差异，它在不同的处理器平台之上为 java 程序员呈现了一个一致的内存模型。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/12/b09bbd238021753d.jpg"></p>

        <h2 id="JMM的设计"   >
          <a href="#JMM的设计" class="heading-link"><i class="fas fa-link"></i></a><a href="#JMM的设计" class="headerlink" title="JMM的设计"></a>JMM的设计</h2>
      <p>从 JMM 设计者的角度来说，在设计 JMM 时，需要考虑两个关键因素：</p>
<ul>
<li>程序员对内存模型的使用。程序员希望内存模型易于理解，易于编程。程序员希望基于一个强内存模型来编写代码。</li>
<li>编译器和处理器对内存模型的实现。编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。编译器和处理器希望实现一个弱内存模型。</li>
</ul>
<blockquote>
<p>一方面要为程序员提供足够强的内存可见性保证；另一方面，对编译器和处理器的限制要尽可能的放松。</p>
</blockquote>
<p>下面让我们看看 JSR-133 是如何实现这一目标的。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span>  <span class="operator">=</span> <span class="number">3.14</span>;    <span class="comment">//A</span></span><br><span class="line"><span class="type">double</span> <span class="variable">r</span>   <span class="operator">=</span> <span class="number">1.0</span>;     <span class="comment">//B</span></span><br><span class="line"><span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> pi * r * r; <span class="comment">//C</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>A happens- before B；</li>
<li>B happens- before C；</li>
<li>A happens- before C；</li>
</ul>
<p>happens- before 的定义会要求：A 操作执行的结果要对 B 可见，且 A 操作的执行顺序排在 B 操作之前。 但是从程序语义的角度来说，<strong>对 A 和 B 做重排序即不会改变程序的执行结果</strong>，也还能提高程序的执行性能（允许这种重排序减少了对编译器和处理器优化的束缚）。也就是说，上面这 3 个 happens- before 关系中，虽然 2 和 3 是必需要的，但 1 是不必要的。因此，JMM 把 happens- before <strong>要求禁止的重排序</strong>分为了下面两类：</p>
<ul>
<li>会改变程序执行结果的重排序。</li>
<li>不会改变程序执行结果的重排序。</li>
</ul>
<blockquote>
<p>这里说的happens- before <strong>要求禁止的重排序</strong>就是A happens-before B，也就是A的结果B必须可见（但是显然这不是必须的）。</p>
</blockquote>
<p>JMM 对这两种不同性质的重排序，采取了不同的策略：</p>
<ul>
<li>对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序。</li>
<li>对于不会改变程序执行结果的重排序，JMM 对编译器和处理器不作要求（JMM 允许这种重排序）。</li>
</ul>
<blockquote>
<p>第二种就是，JMM放养了，随便编译器和处理器是否排序。</p>
</blockquote>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/jvm/java-jvm-jmm.html" >https://pdai.tech/md/java/jvm/java-jvm-jmm.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.infoq.cn/minibook/java_memory_model" >https://www.infoq.cn/minibook/java_memory_model</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/11/Java/JVM/JVM(6)-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB/">JVM(6)--内存结构之线程共享</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-11</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-11</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h1>
      <p>关于内存结构的第二篇：包含堆内存，方法区。</p>

        <h1 id="堆内存"   >
          <a href="#堆内存" class="heading-link"><i class="fas fa-link"></i></a><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h1>
      <blockquote>
<p>Java 堆是 Java 虚拟机管理的内存中最大的一块，被所有线程共享。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。</p>
</blockquote>
<p>JVM把堆内存逻辑上划分为三个区域（划分的唯一理由就是优化GC性能）:</p>
<ul>
<li>年轻代：新对象和没达到一定年龄的对象都在新生代。</li>
<li>老年代：被长时间使用的对象，老年代的内存空间应该要比年轻代更大。</li>
<li>元空间（JDK1.8 之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存。</li>
</ul>
<p>主流虚拟机都是可扩展的（通过 <code>-Xmx</code> 和 <code>-Xms</code> 控制），如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出 <code>OutOfMemoryError</code> 异常。</p>

        <h2 id="年轻代"   >
          <a href="#年轻代" class="heading-link"><i class="fas fa-link"></i></a><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h2>
      <p>年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为 <strong>Minor GC</strong>。年轻一代被分为三个部分——伊甸园（<strong>Eden Memory</strong>）和两个幸存区（<strong>Survivor Memory</strong>，被称为from&#x2F;to或s0&#x2F;s1），默认比例是<code>8:1:1</code></p>
<ul>
<li>大多数新创建的对象都位于 Eden 内存空间中，此时JVM会给对象定义一个对象年轻计数器。（<code>-XX:MaxTenuringThreshold</code>）。</li>
<li>当 Eden 空间被对象填（<strong>空间不足</strong>）时，执行<strong>Minor GC</strong>，并将所有幸存者对象移动到一个幸存者空间中。</li>
<li>Minor GC 检查幸存者对象，并将它们移动到<strong>另一个</strong>幸存者空间。所以每次，一个幸存者空间总是空的</li>
<li>经过多次 GC 循环（每次Minor GC对象年龄+1）后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的年龄阈值来实现的，然后他们才有资格提升到老一代。</li>
</ul>
<blockquote>
<p>对象超过了<code>-XX:PetenureSizeThreshold</code>，对象会<strong>直接被分配到老年代</strong>。默认是15次回收标记。</p>
</blockquote>

        <h2 id="老年代"   >
          <a href="#老年代" class="heading-link"><i class="fas fa-link"></i></a><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h2>
      <p>旧的一代内存包含那些经过许多轮小型 GC 后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集称为 主GC（Major GC），通常需要更长的时间。</p>
<p><strong>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个Survivor 区之间发生大量的内存拷贝</strong>。</p>
<blockquote>
<p>在老年代，如果内存不足，触发Major GC，进行内存清理。之后发现依然无法进行对象的保存，就会产生 OOM 异常。</p>
</blockquote>

        <h2 id="元空间"   >
          <a href="#元空间" class="heading-link"><i class="fas fa-link"></i></a><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h2>
      <p>不管是 JDK8 之前的永久代，还是 JDK8 及以后的元空间，都可以看作是 Java 虚拟机规范中方法区的实现。</p>
<p>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开</p>

        <h2 id="设置堆内存大小和OOM"   >
          <a href="#设置堆内存大小和OOM" class="heading-link"><i class="fas fa-link"></i></a><a href="#设置堆内存大小和OOM" class="headerlink" title="设置堆内存大小和OOM"></a>设置堆内存大小和OOM</h2>
      <p>堆的大小可以在JVM启动时确定，通过<code>-Xmx</code>和<code>-Xms</code>设定：</p>
<ul>
<li><code>-Xms</code>表示堆的起始内存，等价于<code>-XX:InitialHeapSize</code>。</li>
<li><code>-Xmx</code>表示堆的最大内存，等价于<code>-XX:MaxHeapSize</code>。</li>
</ul>
<p>如果堆的内存大小超过 <code>-Xmx</code> 设定的最大内存， 就会抛出 <code>OutOfMemoryError</code> 异常。</p>
<p>通常会将 <code>-Xmx</code> 和 <code>-Xms</code> 两个参数配置为相同的值，其目的是为了能够在垃圾回收机制清理完堆区后不再需要重新分隔计算堆的大小，从而提高性能</p>
<ul>
<li>默认情况下，初始堆内存大小为：电脑内存大小&#x2F;64</li>
<li>默认情况下，最大堆内存大小为：电脑内存大小&#x2F;4</li>
</ul>
<blockquote>
<p>也可能出现偏差，导致下面代码的内存并不符合这种计算。</p>
</blockquote>
<p>可以通过代码获取到我们的设置值，当然也可以模拟 OOM：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回 JVM 堆大小</span></span><br><span class="line">  <span class="type">long</span> <span class="variable">initalMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() / <span class="number">1024</span> /<span class="number">1024</span>;</span><br><span class="line">  <span class="comment">//返回 JVM 堆的最大内存</span></span><br><span class="line">  <span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory() / <span class="number">1024</span> /<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;-Xms : &quot;</span>+initalMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">  System.out.println(<span class="string">&quot;-Xmx : &quot;</span>+maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;系统内存大小：&quot;</span> + initalMemory * <span class="number">64</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line">  System.out.println(<span class="string">&quot;系统内存大小：&quot;</span> + maxMemory * <span class="number">4</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="查看JVM堆内存分配"   >
          <a href="#查看JVM堆内存分配" class="heading-link"><i class="fas fa-link"></i></a><a href="#查看JVM堆内存分配" class="headerlink" title="查看JVM堆内存分配"></a>查看JVM堆内存分配</h2>
      <ol>
<li>在默认不配置 JVM 堆内存大小的情况下，JVM 根据默认值来配置当前内存大小</li>
<li>默认情况下新生代和老年代的比例是 1:2，可以通过 <code>–XX:NewRatio</code> 来配置<ul>
<li>新生代中的 <strong>Eden</strong>:<strong>From Survivor</strong>:<strong>To Survivor</strong> 的比例是 <strong>8:1:1</strong>，可以通过 <code>-XX:SurvivorRatio</code> 来配置</li>
</ul>
</li>
<li>若在 JDK 7 中开启了 <code>-XX:+UseAdaptiveSizePolicy</code>，JVM 会动态调整 JVM 堆中各个区域的大小以及进入老年代的年龄。此时 <code>–XX:NewRatio</code> 和 <code>-XX:SurvivorRatio</code>  将会失效，而 JDK 8 是默认开启<code>-XX:+UseAdaptiveSizePolicy</code>。在 JDK 8中，<strong>不要随意关闭</strong><code>-XX:+UseAdaptiveSizePolicy</code>，除非对堆内存的划分有明确的规划。</li>
</ol>
<blockquote>
<p>所以记住了比例也是然并卵对吗？</p>
</blockquote>
<p>每次 GC 后都会重新计算 Eden、From Survivor、To Survivor 的大小</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -version | grep HeapSize</span><br><span class="line">    uintx ErgoHeapSizeLimit                         = 0                                   &#123;product&#125;</span><br><span class="line">    uintx HeapSizePerGCThread                       = 87241520                            &#123;product&#125;</span><br><span class="line">    uintx InitialHeapSize                          := 134217728                           &#123;product&#125;</span><br><span class="line">    uintx LargePageHeapSizeThreshold                = 134217728                           &#123;product&#125;</span><br><span class="line">    uintx MaxHeapSize                              := 2147483648                          &#123;product&#125;</span><br><span class="line">java version &quot;1.8.0_211&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_211-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)</span><br></pre></td></tr></table></div></figure>


        <h2 id="扩展：逃逸分析"   >
          <a href="#扩展：逃逸分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#扩展：逃逸分析" class="headerlink" title="扩展：逃逸分析"></a>扩展：逃逸分析</h2>
      <blockquote>
<p>随着 JIT 编译期的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。 ——《深入理解 Java 虚拟机》</p>
</blockquote>
<p><strong>逃逸分析(Escape Analysis)是目前 Java 虚拟机中比较前沿的优化技术</strong>。通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定<strong>是否要将这个对象分配到堆上</strong>。</p>
<p>逃逸分析的基本行为就是分析对象动态作用域：</p>
<ul>
<li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中，称为方法逃逸。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title function_">craeteStringBuffer</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">   <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">   sb.append(s1);</span><br><span class="line">   sb.append(s2);</span><br><span class="line">   <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sb就可以被外部方法访问，即方法逃逸，如果还被外部线程访问了，就是线程逃逸。</span></span><br><span class="line"><span class="comment">// 如果不想sb逃逸出去，可以写成sb.toString()，当然方法返回类型改为String</span></span><br></pre></td></tr></table></div></figure>

<p>使用逃逸分析，编译器可以对代码做优化：</p>
<ul>
<li><strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配（这个可以有，而且优化效果会非常明显）。</li>
</ul>
<p>JVM 通过逃逸分析确定该对象不会被外部访问。那就通过标量替换将该对象分解在栈上分配内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。</p>
<ul>
<li><strong>同步省略</strong>：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keep</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">keeper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  <span class="keyword">synchronized</span>(keeper) &#123;</span><br><span class="line">    System.out.println(keeper);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当然，这种更考验开发人员写代码的水平，因为本来就不该给keeper</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而存储在 CPU 寄存器</li>
</ul>
<p>分离对象（标量替换）说直白点就是将对象拆分为标量。</p>
<blockquote>
<p><strong>标量</strong>（Scalar）是指一个无法再分解成更小的数据的数据，其他的就是聚合量。</p>
</blockquote>
<p>通过 <code>-XX:+EliminateAllocations</code> 可以开启标量替换，<code>-XX:+PrintEliminateAllocations</code> 查看标量替换情况。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   alloc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>（<span class="number">1</span>,<span class="number">2</span>）;</span><br><span class="line">   System.out.println(<span class="string">&quot;point.x=&quot;</span>+point.x+<span class="string">&quot;; point.y=&quot;</span>+point.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>point 对象并没有逃逸出 <code>alloc()</code> 方法，并且 point 对象是可以拆解成标量的。那么，JIT 就不会直接创建 Point 对象，而是直接使用两个标量 int x ，int y 来替代 Point 对象。</p>
<p><strong>总结</strong>：</p>
<p><strong>虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</strong>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也并不是十分成熟的。</p>

        <h1 id="方法区"   >
          <a href="#方法区" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1>
      <p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本&#x2F;字段&#x2F;方法&#x2F;接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是 <code>String.intern()</code>方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryErro</code>r 异常。</p>

        <h3 id="解惑"   >
          <a href="#解惑" class="heading-link"><i class="fas fa-link"></i></a><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h3>
      <p>你是否也有看不同的参考资料，有的内存结构图有方法区，有的又是永久代，元数据区，一脸懵逼的时候？</p>
<ul>
<li><strong>方法区（method area）只是 JVM 规范中定义的一个概念</strong>，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而<strong>永久代（PermGen）是 Hotspot 虚拟机特有的概念， Java8 的时候又被元空间</strong>取代了，永久代和元空间都可以理解为方法区的落地实现。</li>
<li>永久代物理是堆的一部分，和新生代，老年代地址是连续的（受垃圾回收器管理），而元空间存在于本地内存（我们常说的堆外内存，不受垃圾回收器管理），这样就不受 JVM 限制了，也比较难发生OOM（都会有溢出异常）。</li>
<li>Java7 中我们通过<code>-XX:PermSize</code> 和 <code>-xx:MaxPermSize</code> 来设置永久代参数，Java8 之后，随着永久代的取消，这些参数也就随之失效了，改为通过<code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 用来设置元空间参数。</li>
<li>存储内容不同，元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中。</li>
<li>如果方法区域中的内存不能用于满足分配请求，则 Java 虚拟机抛出 <code>OutOfMemoryError</code>。</li>
<li>JVM 规范说方法区在逻辑上是堆的一部分，但目前实际上是与 Java 堆分开的（Non-Heap）。</li>
</ul>
<p>所以对于方法区，Java8 之后的变化：</p>
<ul>
<li>移除了永久代（PermGen），替换为元空间（Metaspace）；</li>
<li>永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；</li>
<li>永久代中的 interned Strings 和 class static variables 转移到了 Java heap；</li>
<li>永久代参数 （PermSize MaxPermSize） -&gt; 元空间参数（MetaspaceSize MaxMetaspaceSize）</li>
</ul>

        <h3 id="方法区内部结构"   >
          <a href="#方法区内部结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法区内部结构" class="headerlink" title="方法区内部结构"></a>方法区内部结构</h3>
      <blockquote>
<p>方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p>
</blockquote>

        <h4 id="类型信息"   >
          <a href="#类型信息" class="heading-link"><i class="fas fa-link"></i></a><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h4>
      <p>对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息</p>
<ul>
<li>这个类型的完整有效名称（全名&#x3D;包名.类名）</li>
<li>这个类型直接父类的完整有效名（对于 interface或是 java.lang.Object，都没有父类）</li>
<li>这个类型的修饰符（public，abstract，final 的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ul>

        <h4 id="域信息"   >
          <a href="#域信息" class="heading-link"><i class="fas fa-link"></i></a><a href="#域信息" class="headerlink" title="域信息"></a>域信息</h4>
      <ul>
<li>JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序</li>
<li>域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient 的某个子集）</li>
</ul>

        <h4 id="方法信息"   >
          <a href="#方法信息" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法信息" class="headerlink" title="方法信息"></a>方法信息</h4>
      <p>JVM 必须保存所有方法的</p>
<ul>
<li>方法名称</li>
<li>方法的返回类型</li>
<li>方法参数的数量和类型</li>
<li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract 的一个子集）</li>
<li>方法的字符码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）</li>
<li>异常表（abstract 和 native 方法除外）<ul>
<li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ul>
</li>
</ul>

        <h3 id="运行时常量池"   >
          <a href="#运行时常量池" class="heading-link"><i class="fas fa-link"></i></a><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3>
      <p>运行时常量池（Runtime Constant Pool）是方法区的一部分，在加载类和结构到虚拟机后，就会创建对应的运行时常量池。</p>
<ul>
<li>常量池表（Constant Pool Table）是 Class 文件的一部分，用于存储编译期生成的各种字面量和符号引用，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong>。</li>
<li>JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</li>
<li>运行时常量池中包含各种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。运行时常量池，相对于 Class 文件常量池的另一个重要特征是：<strong>动态性</strong>，Java 语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String 类的 <code>intern()</code> 方法就是这样的。</li>
<li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛出 OutOfMemoryError 异常。</li>
</ul>

        <h3 id="方法区的GC"   >
          <a href="#方法区的GC" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法区的GC" class="headerlink" title="方法区的GC"></a>方法区的GC</h3>
      <p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再使用的类型</strong>。</p>
<p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p>HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p>
<p>判定一个类型是否属于“不再被使用的类”，需要同时满足三个条件：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例</li>
<li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常很难达成</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
<p>Java 虚拟机被允许堆满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot 虚拟机提供了 <code>-Xnoclassgc</code> 参数进行控制，还可以使用 <code>-verbose:class</code> 以及 <code>-XX:+TraceClassLoading</code> 、<code>-XX:+TraceClassUnLoading</code> 查看类加载和卸载信息。</p>
<p>在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>

        <h1 id="参考与感谢"   >
          <a href="#参考与感谢" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考与感谢" class="headerlink" title="参考与感谢"></a>参考与感谢</h1>
      <ul>
<li>作者：海星</li>
<li>来源于：JavaKeeper</li>
</ul>
<p>原作者参考内容如下</p>
<p>算是一篇学习笔记，共勉，主要来源：</p>
<p>《深入理解 Java 虚拟机 第三版》</p>
<p>宋红康老师的 JVM 教程</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/index.html" >https://docs.oracle.com/javase/specs/index.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/wicfhwffg/p/9382677.html" >https://www.cnblogs.com/wicfhwffg/p/9382677.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/hollischuang/p/12501950.html" >https://www.cnblogs.com/hollischuang/p/12501950.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/10/Java/JVM/JVM(5)-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89/">JVM(5)--内存结构之线程私有</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-11</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h1>
      <p>JVM内存结构主要分为5个：</p>
<ul>
<li><p>线程私有：程序计数器，虚拟机栈，本地方法栈。</p>
</li>
<li><p>线程共享：方法区，堆内存。</p>
</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/10/db2c0ead0de42c67.jpg"></p>
<blockquote>
<p>因为内容较多，所以分两篇讲完。</p>
</blockquote>

        <h1 id="程序计数器"   >
          <a href="#程序计数器" class="heading-link"><i class="fas fa-link"></i></a><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1>
      <p>程序计数寄存器（<strong>Program Counter Register</strong>），Register 的命名源于 CPU 的寄存器，寄存器存储指令相关的线程信息，CPU 只有把数据装载到寄存器才能够运行。</p>
<p>这里，并非是广义上所指的物理寄存器，叫程序计数器（或PC计数器或指令计数器）会更加贴切，并且也不容易引起一些不必要的误会。<strong>JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟</strong>。</p>
<blockquote>
<p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的<strong>行号指示器</strong>。</p>
</blockquote>

        <h2 id="作用"   >
          <a href="#作用" class="heading-link"><i class="fas fa-link"></i></a><a href="#作用" class="headerlink" title="作用"></a>作用</h2>
      <p>PC 寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/10/8fd60a5f2a320f84.jpg"></p>
<p>通过两个问题来理解PC寄存器：</p>
<ul>
<li><strong>使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？</strong></li>
</ul>
<p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
<ul>
<li><strong>PC寄存器为什么会被设定为线程私有的？</strong></li>
</ul>
<p>多线程在一个特定的时间段内只会执行其中某一个线程方法，CPU会不停的做任务切换，这样必然会导致经常中断或恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为<strong>每个线程都分配了一个PC寄存器，每个线程都独立计算，不会互相影响</strong>。</p>
<blockquote>
<p>总结如下：</p>
</blockquote>
<ul>
<li>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域</li>
<li>在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致</li>
<li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。如果当前线程正在执行的是 Java 方法，程序计数器记录的是 JVM 字节码指令地址，如果是执行 native 方法，则是未指定值(undefined)</li>
<li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</li>
<li><strong>它是唯一一个在 JVM 规范中没有规定任何 <code>OutOfMemoryError</code> 情况的区域</strong></li>
</ul>

        <h1 id="虚拟机栈"   >
          <a href="#虚拟机栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1>
      <p>每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame），对应着一次次 Java 方法调用，是线程私有的，生命周期和线程一致。</p>
<blockquote>
<p>方法调用会入栈，方法递归时，其实就是一个个方法不断入栈。如果一直递归无法结束，就会<code>StackOverflowError</code>。</p>
</blockquote>
<p><strong>栈中可能出现的异常</strong>：</p>
<p>Java 虚拟机规范允许 <strong>Java虚拟机栈的大小是动态的或者是固定不变的</strong></p>
<ul>
<li>如果采用<strong>固定大小</strong>的 Java 虚拟机栈，容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 <strong>StackOverflowError</strong> 异常</li>
<li>如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个<strong>OutOfMemoryError</strong>异常</li>
</ul>

        <h2 id="存储单位"   >
          <a href="#存储单位" class="heading-link"><i class="fas fa-link"></i></a><a href="#存储单位" class="headerlink" title="存储单位"></a>存储单位</h2>
      <ul>
<li><p>栈中的数据都是以<strong>栈帧（Stack Frame）的格式存在</strong></p>
</li>
<li><p>在这个线程上正在执行的每个方法都各自有对应的一个栈帧</p>
</li>
<li><p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</p>
</li>
</ul>

        <h2 id="运行原理"   >
          <a href="#运行原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h2>
      <ul>
<li><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（<strong>栈顶栈帧</strong>）是有效的，这个栈帧被称为<strong>当前栈帧</strong>（Current Frame），与当前栈帧对应的方法就是<strong>当前方法</strong>（Current Method），定义这个方法的类就是<strong>当前类</strong>（Current Class）</p>
</li>
<li><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前栈帧</p>
</li>
<li><p>Java 方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出</strong>。</p>
</li>
</ul>

        <h2 id="栈帧内部结构"   >
          <a href="#栈帧内部结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#栈帧内部结构" class="headerlink" title="栈帧内部结构"></a>栈帧内部结构</h2>
      <img src="https://s3.bmp.ovh/imgs/2022/10/10/25ba31a0be03434f.jpg"  />

<p>上图最右边即是栈帧的内部结构：</p>
<ul>
<li>动态链接：指向运行时常量池的方法引用。</li>
<li>方法返回地址：正常退出或异常退出的地址。</li>
</ul>

        <h3 id="局部变量表"   >
          <a href="#局部变量表" class="heading-link"><i class="fas fa-link"></i></a><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3>
      <p><strong>局部变量表所需要的容量大小是编译期确定下来的</strong>，并保存在方法的 Code 属性的 <code>maximum local variables</code> 数据项中。在方法运行期间是不会改变局部变量表的大小的。</p>
<blockquote>
<p>局部变量不仅包括基本数据类型，还包括对象引用。</p>
</blockquote>
<p>局部变量表最基本的存储单元是<code>Slot</code>–槽：</p>
<ul>
<li>在局部变量表中，32 位以内的类型只占用一个 Slot(包括returnAddress类型)，64 位的类型（long和double）占用两个连续的 Slot。</li>
<li>byte、short、char 在存储前被转换为int，boolean也被转换为int，0 表示 false，非 0 表示 true。</li>
</ul>
<blockquote>
<p>所以有时候在方法里面想着节省空间，将<code>int</code>在允许的情况下换成<code>byte</code>啥的，其实并不节省空间。</p>
</blockquote>
<ul>
<li><p>每个Slot对应一个访问索引，范围从0到Slot最大数量。</p>
</li>
<li><p>如果当前帧是由构造方法或实例方法创建的，那么该对象引用 this 将会存放在 index 为 0 的 Slot 处，其余的参数按照参数表顺序继续排列（这里就引出一个问题：静态方法中为什么不可以引用 this，就是因为this 变量不存在于当前方法的局部变量表中）。</p>
</li>
<li><p><strong>栈帧中的局部变量表中的槽位是可以重用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而<strong>达到节省资源的目的</strong>。</p>
</li>
<li><p><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong>。</p>
</li>
</ul>

        <h3 id="操作数栈"   >
          <a href="#操作数栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3>
      <p><strong>在方法执行过程中，根据字节码指令，往操作数栈中写入数据或提取数据，即入栈（push）、出栈（pop）</strong>。</p>
<blockquote>
<p>对，就是操作数的一个数据结构。</p>
</blockquote>
<p>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如，执行复制、交换、求和等操作。</p>

        <h3 id="动态链接"   >
          <a href="#动态链接" class="heading-link"><i class="fas fa-link"></i></a><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3>
      <p>在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为<strong>符号引用</strong>（Symbolic Reference）保存在 Class 文件的常量池中。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/10/05c85fc5e1233e0a.jpg"></p>
<p><strong>方法调用</strong>：唯一任务著是确定被调用方法的版本（即调用哪一个方法），不涉及方法内部的具体运行过程。Class 文件的编译过程中不包括传统编译器中的连接步骤，一切<strong>方法调用</strong>在 Class文件里面存储的都是<strong>符号引用</strong>，而不是方法在实际运行时内存布局中的入口地址（<strong>直接引用</strong>）。也就是需要在类加载阶段，甚至到运行期才能确定目标方法的直接引用。</p>
<ul>
<li><p><strong>静态链接</strong>：当一个字节码文件被装载进 JVM 内部时，如果被调用的<strong>目标方法在编译期可知</strong>，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</p>
</li>
<li><p><strong>动态链接</strong>：如果被调用的方法在编译期无法被确定下来，也就是说，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接</p>
</li>
</ul>
<p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次</strong>。</p>
<blockquote>
<p>早期和晚期的区别在于<strong>被调用的目标方法如果在编译期可知，且运行期保持不变时</strong>，即可将这个方法与所属的类型进行绑定。这种方法也叫做非虚方法。</p>
</blockquote>

        <h3 id="方法返回地址"   >
          <a href="#方法返回地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3>
      <p>方法退出后都返回到<strong>该方法被调用的位置</strong>。方法正常退出时，调用者的 <strong>PC 计数器的值</strong>作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过<strong>异常表</strong>来确定的，栈帧中一般不会保存这部分信息。</p>
<p>在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称<strong>异常完成出口</strong>。</p>
<p>正常完成出口和异常完成出口的区别在于：<strong>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值</strong>。</p>

        <h1 id="本地方法栈"   >
          <a href="#本地方法栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1>
      <p>一个 Native Method 就是一个 Java 调用非 Java 代码的接口。我们知道的 Unsafe 类就有很多本地方法。</p>
<p>我们在开发程序时，有时会不可避免地使用本地方法。</p>
<ul>
<li>Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用。</li>
<li>允许线程固定或者可动态扩展的内存大小（抛出异常机制和虚拟机栈一样）。</li>
<li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区，它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量的内存。</li>
<li><strong>在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一</strong>。</li>
</ul>
<blockquote>
<p><strong>栈是运行时的单位，而堆是存储的单位</strong>。</p>
<p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。</p>
</blockquote>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <p><strong>海星的javakeeper公众号</strong>整理的文章，写得好就直接用了。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/10/Java/JVM/JVM(4)-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">JVM(4)--类加载器</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-10</span></span></div></header><div class="post-body"><div class="post-excerpt"><blockquote>
<p>jvm启动的时候，并不会一次性加载所有的class文件，而是根据需要去动态加载。ClassLoader的具体作用就是将class文件加载到jvm虚拟机中去，程序就可以正确运行了。普通的<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://lib.csdn.net/base/javase" >Java</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>开发者其实用到的不多，但对于某些框架开发者来说却非常常见。</p>
</blockquote>

        <h1 id="使用"   >
          <a href="#使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用" class="headerlink" title="使用"></a>使用</h1>
      <blockquote>
<p>看了很多文章，个人觉得先把如何使用类加载器–<code>ClassLoader</code>弄明白，再来讲解原理效果好得多。</p>
</blockquote>
<p><code>class</code>字节码文件，需要使用类加载器加载字节码，即在java中所有类都会通过加载器加载才能运行。下文提到的类似<code>Bootstrap ClassLoader</code>，<code>Extension ClassLoader</code>等，都是JDK自带的，正是这些自带的类加载器，我们才能将源码的class文件加载字节码。</p>

        <h2 id="自定义ClassLoader"   >
          <a href="#自定义ClassLoader" class="heading-link"><i class="fas fa-link"></i></a><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a>自定义ClassLoader</h2>
      <p>核心方法：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loadClass(String className); <span class="comment">// 根据名字加载一个类</span></span><br><span class="line">defineClass(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len); <span class="comment">// 将字节流定义为类</span></span><br><span class="line">findClass(String name); <span class="comment">// 查找一个类</span></span><br><span class="line">findLoaderClass(String name); <span class="comment">// 在已加载的类中，查找一个类</span></span><br><span class="line">resolveClass(链接指定的Java类);</span><br></pre></td></tr></table></div></figure>

<p>比如我们需要动态加载一些东西，或者从C盘某个特定的文件夹加载一个class文件，又或者从网络上下载class主内容然后再进行加载等。分三步搞定：</p>
<ul>
<li>编写一个类继承<code>ClassLoader</code>抽象类。</li>
<li>重写<code>findClass()</code>方法。</li>
<li>在<code>findClass()</code>方法中调用<code>defineClass()</code>方法即可实现自定义<code>ClassLoader</code>。</li>
</ul>
<p>我们先写一个类：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译得到class文件-&gt;写程序将class文件转换为字节流</span></span><br><span class="line"><span class="comment">// InputStream fis = new FileInputStream(&quot;test.class&quot;);</span></span><br><span class="line"><span class="comment">// byte[] bytes = IOUtils.readFully(fis, -1, false);</span></span><br></pre></td></tr></table></div></figure>

<p><img src="https://s3.bmp.ovh/imgs/2022/10/10/67d06fbed9be1513.jpg"></p>
<p>自定义加载器类：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JVM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.IOUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InputStream fis;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] bytes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">testClassname</span> <span class="operator">=</span> <span class="string">&quot;JVM.Test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException,</span><br><span class="line">    		ClassNotFoundException, InstantiationException,</span><br><span class="line">            IllegalAccessException, NoSuchMethodException, </span><br><span class="line">    		InvocationTargetException </span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/JVM/Test.class&quot;</span>);</span><br><span class="line">        bytes = IOUtils.readFully(fis, -<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建加载器</span></span><br><span class="line">        <span class="type">ClassLoaderTest</span> <span class="variable">classloadertest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassLoaderTest</span>();</span><br><span class="line">        <span class="comment">//使用我们自定义的类去加载testClassname</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">aClass</span> <span class="operator">=</span> classloadertest.loadClass(testClassname);</span><br><span class="line">        <span class="comment">//反射创建test类对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">        <span class="comment">//反射获取method方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> o.getClass().getMethod(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">        <span class="comment">//反射去调用执行method方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) method.invoke(o);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//只处理JVM.Test类</span></span><br><span class="line">        <span class="keyword">if</span> (name.equals(testClassname)) &#123;</span><br><span class="line">            <span class="comment">//将一个字节流定义为一个类。</span></span><br><span class="line">            <span class="comment">//其实这个名字可以随便取</span></span><br><span class="line">            <span class="keyword">return</span> defineClass(testClassname, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p><img src="https://s3.bmp.ovh/imgs/2022/10/10/b6c86511a9b493e8.jpg"></p>

        <h1 id="类加载器层次"   >
          <a href="#类加载器层次" class="heading-link"><i class="fas fa-link"></i></a><a href="#类加载器层次" class="headerlink" title="类加载器层次"></a>类加载器层次</h1>
      <p>站在开发人员角度：</p>
<ul>
<li><code>Bootstrap ClassLoader</code>：启动类加载器，无法被Java程序直接引用，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载)。</li>
<li><code>Extension ClassLoader</code>：扩展类加载器，负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。</li>
<li><code>Application ClassLoader</code>：负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<img src="https://s3.bmp.ovh/imgs/2022/10/10/715b39e6e2f34500.jpg" style="zoom:80%;" />

<blockquote>
<p>还可以加入自定义的类加载器，因为JVM自带的ClassLoader只能从本地文件系统加载标准的<code>java.class</code>文件。</p>
</blockquote>
<p>看一个小例子：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pdai.jvm.classloader;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        System.out.println(loader.getParent());</span><br><span class="line">        System.out.println(loader.getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sun.misc.Launcher$AppClassLoader@64fef26a</span></span><br><span class="line"><span class="comment">// sun.misc.Launcher$ExtClassLoader@1ddd40f3</span></span><br><span class="line"><span class="comment">// null</span></span><br></pre></td></tr></table></div></figure>

<p>并没有获取到<code>ExtClassLoader</code>的父Loader，原因是<code>BootstrapLoader</code>(引导类加载器)是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回<code>null</code>。</p>

        <h1 id="类的加载"   >
          <a href="#类的加载" class="heading-link"><i class="fas fa-link"></i></a><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h1>
      <p>类加载有三种方式：</p>
<ul>
<li>启动应用时由JVM初始化加载</li>
<li>通过<code>Class.forName()</code>方法动态加载</li>
<li>通过<code>Class.loader.loadClass()</code>方法动态加载。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException &#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;使用loader.loadClass()：&quot;</span>);</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> Main.class.getClassLoader();</span><br><span class="line">        loader.loadClass(<span class="string">&quot;com.Test&quot;</span>);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 默认执行初始化块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用Class.forName()：&quot;</span>);</span><br><span class="line">        Class.forName(<span class="string">&quot;com.Test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定ClassLoader，初始化不执行静态块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用Class.forName(name,false,loader)：&quot;</span>);</span><br><span class="line">        Class.forName(<span class="string">&quot;com.Test&quot;</span>, <span class="literal">false</span>, loader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态初始化块执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//使用loader.loadClass()：</span></span><br><span class="line"><span class="comment">//使用Class.forName()：</span></span><br><span class="line"><span class="comment">//静态初始化块执行了！</span></span><br><span class="line"><span class="comment">//使用Class.forName(name,false,loader)：</span></span><br></pre></td></tr></table></div></figure>

<blockquote>
<p><code>Class.forName()</code>和<code>ClassLoader.loadClass()</code>区别？</p>
</blockquote>
<ul>
<li><p>Class.forName(): 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</p>
</li>
<li><p><code>ClassLoader.loadClass()</code>：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在<code>newInstance</code>才会去执行static块。</p>
</li>
<li><p><code>Class.forName(name,initialize,loader)</code>：可控制是否加载<code>static</code>块。</p>
</li>
</ul>

        <h1 id="JVM类加载机制"   >
          <a href="#JVM类加载机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h1>
      <p><strong>全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p>
<p><strong>父类委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p>
<p><strong>缓存机制</strong>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p>
<p><strong>双亲委派机制</strong> 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>

        <h2 id="双亲委派"   >
          <a href="#双亲委派" class="heading-link"><i class="fas fa-link"></i></a><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h2>
      <ol>
<li>当<code>AppClassLoader</code>加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<code>ExtClassLoader</code>去完成。</li>
<li>当<code>ExtClassLoader</code>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给<code>BootStrapClassLoader</code>去完成。</li>
<li>如果<code>BootStrapClassLoader</code>加载失败(例如在<code>$JAVA_HOME/jre/lib</code>里未查找到该class)，会使用<code>ExtClassLoader</code>来尝试加载；</li>
<li>若<code>ExtClassLoader</code>也加载失败，则会使用<code>AppClassLoader</code>来加载，如果<code>AppClassLoader</code>也加载失败，则会报出异常<code>ClassNotFoundException</code>。</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name)<span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    								  <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 首先判断该类型是否已经被加载</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果没有被加载，就委托给父类加载或者委派给启动类加载器加载</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果存在父类加载器，就委派给父类加载器加载</span></span><br><span class="line">                c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法</span></span><br><span class="line">                <span class="comment">//native Class findBootstrapClass(String name)</span></span><br><span class="line">                c = findBootstrapClass0(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能</span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/nice0e3/p/13719903.html#0x02--classloader%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8" >Java安全之ClassLoader类加载器</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>.</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javase/keopmg#9995ffcc" >https://www.yuque.com/qingkongxiaguang/javase/keopmg#9995ffcc</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/jvm/java-jvm-classload.htm" >https://pdai.tech/md/java/jvm/java-jvm-classload.htm</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>一个小例子，可以看看：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.freesion.com/article/2178308798/" >https://www.freesion.com/article/2178308798/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>三大类加载器的源码解读：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.bbsmax.com/A/n2d9bO0wzD/" >https://www.bbsmax.com/A/n2d9bO0wzD/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/09/Java/JVM/JVM(3)-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">JVM(3)--类加载机制</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-09</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="类的生命周期"   >
          <a href="#类的生命周期" class="heading-link"><i class="fas fa-link"></i></a><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1>
      <p><img src="https://s3.bmp.ovh/imgs/2022/10/09/167570c48203f9c9.jpg"></p>
<p><code>加载</code>、<code>验证</code>、<code>准备</code>和<code>初始化</code>这四个阶段发生的顺序是确定的，而<code>解析</code>阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定(也成为动态绑定或晚期绑定)。</p>
<blockquote>
<p>这些阶段知识按顺序开始，并不是按顺序结束，这些阶段往往互相交叉混合进行，再一个阶段执行过程中调用或激活另一个阶段。</p>
</blockquote>

        <h1 id="类的加载"   >
          <a href="#类的加载" class="heading-link"><i class="fas fa-link"></i></a><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h1>
      <p>首先介绍几个概念：</p>
<ul>
<li>方法区：JVM实例内部，类型信息被存储在方法区的内存逻辑区中。类型信息是由类加载时从类文件中提取出来的。方法区又叫做静态区，被所有线程共享，方法区包含所有<code>class</code>和<code>static</code>。静态<strong>常量</strong>存放在方法区的常量区中，这之后会讲解。</li>
</ul>
<p>加载阶段虚拟机需要完成：</p>
<ul>
<li>通过类的全限定名（从方法区）来获取其定义的二进制字节流。</li>
<li>字节流代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在Java堆中生成代表这个类的<code>java.lang.Class</code>对象，作为对方法区中这些数据的访问入口。</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/09/842b5cd01faa5b42.jpg"></p>
<p>类加载器不需要等待某个类首次主动使用时在加载，JVM允许预料某个类需要使用时主动加载。在<strong>预加载</strong>中遇到.class文件缺失或存在错误，类加载器必须在程序<strong>首次主动使用</strong>该类时才会报错误–LinkageError。</p>

        <h1 id="连接"   >
          <a href="#连接" class="heading-link"><i class="fas fa-link"></i></a><a href="#连接" class="headerlink" title="连接"></a>连接</h1>
      
        <h2 id="验证"   >
          <a href="#验证" class="heading-link"><i class="fas fa-link"></i></a><a href="#验证" class="headerlink" title="验证"></a>验证</h2>
      <p>确保被加载的类的正确性，也就是Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全。</p>
<blockquote>
<p>如果使用纯Java代码编写的类，编译出来的class文件是相对安全的。但是.class文件并不只是由Java源码编译而来，哪怕用键盘输入01并将文件后缀改为.class都可以，所以验证非常有必要。</p>
</blockquote>
<p>验证阶段的检验动作：</p>
<ul>
<li><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范。（魔数，主次版本，常量的tag标志等）</li>
<li><strong>元数据验证</strong>：对字节码描述的信息进行语义分析。（该类是否继承不可继承的final类，是否覆盖父类的final字段等）</li>
<li><strong>字节码验证</strong>：通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。</li>
<li><strong>符号引用验证</strong>：确保解析动作能正确执行。</li>
</ul>
<blockquote>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
</blockquote>

        <h2 id="准备"   >
          <a href="#准备" class="heading-link"><i class="fas fa-link"></i></a><a href="#准备" class="headerlink" title="准备"></a>准备</h2>
      <p>正式为类变量分配内存并设置类变量<strong>初始值</strong>的阶段，<strong>这些内存都将在方法区中分配</strong>。</p>
<ul>
<li>内存分配的仅包括静态变量，<strong>不包括</strong>实例变量。<strong>实例变量是在对象实例化时随着对象一块分配在Java堆中</strong>。</li>
<li>初始值：<code>0,0L,null,false</code>等。</li>
</ul>
<p>比如某个类由以下语句：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></div></figure>

<p>在准备阶段只会赋值0，将<code>value</code>赋值为3的<code>put static</code>指令存放于<code>&lt;clinit()&gt;</code>方法中。所以初始化阶段才会赋值为3。</p>
<p><code>&lt;clinit&gt;</code>方法是类加载的<strong>初始化</strong>过程中，编译器按语句在源文件中出现的顺序，依次自动收集类中的静态变量的赋值动作和静态代码块中的语句合并产生<code>&lt;clinit&gt;</code>方法。并且 <code>&lt;clinit&gt;()</code> 不需要显式调用父类（接口除外，接口不需要调用父接口的初始化方法，只有使用到父接口中的静态变量时才需要调用）的初始化方法 <code>&lt;clinit&gt;()</code>，虚拟机会保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行之前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行完毕。</p>
<p>随便写个类：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>编译后通过<code>jclasslib</code>插件查看：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/09/f122fdb91f027a3f.jpg"></p>
<blockquote>
<p>当 int 取值 -128~127 时，JVM 采用 <code>bipush</code> 指令将常量压入栈中。</p>
</blockquote>
<p>还需要注意几点：</p>
<ul>
<li>对于同时被<code>static</code>和<code>final</code>修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>此时编译会报错：<strong>java: 变量 tmp 未在默认构造器中初始化</strong>。</p>
<p>必须在构造器中将<code>final</code>变量初始化：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.k = k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>同时被<code>static</code>和<code>final</code>修饰的常量，类会为它生成<code>ConstantValue</code>属性，在准备阶段JVM就会根据<code>ConstantValue</code>的设置将变量赋值。</li>
</ul>

        <h2 id="解析"   >
          <a href="#解析" class="heading-link"><i class="fas fa-link"></i></a><a href="#解析" class="headerlink" title="解析"></a>解析</h2>
      <p>JVM将常量池内的符号引用替换为直接引用的过程，解析动作主要针对<code>类</code>或<code>接口</code>、<code>字段</code>、<code>类方法</code>、<code>接口方法</code>、<code>方法类型</code>、<code>方法句柄</code>和<code>调用点</code>限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p>
<p><code>直接引用</code>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>

        <h2 id="初始化"   >
          <a href="#初始化" class="heading-link"><i class="fas fa-link"></i></a><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2>
      <p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。</p>
<blockquote>
<p>也就是<code>&lt;clinit&gt;</code>方法。</p>
</blockquote>
<p><strong>类初始化时机</strong>: 只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种:</p>
<ul>
<li><p>创建类的实例，也就是new的方式</p>
</li>
<li><p>访问某个类或接口的静态变量，或者对该静态变量赋值</p>
</li>
<li><p>调用类的静态方法（也经常和第二点合并在一起）</p>
</li>
<li><p>反射(如Class.forName(“com.pdai.jvm.Test”))</p>
</li>
<li><p>初始化某个类的子类，则其父类也会被初始化</p>
</li>
<li><p>Java虚拟机启动时被标明为启动类的类(Java Test)，直接使用java.exe命令来运行某个主类</p>
</li>
</ul>
<p>只有这六种是主动使用，其他的都是被动使用，被动使用不会初始化。被动引用的例子可以看这篇<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/zhangliangzi/article/details/51319033" >博客</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p>

        <h3 id="注意"   >
          <a href="#注意" class="heading-link"><i class="fas fa-link"></i></a><a href="#注意" class="headerlink" title="注意"></a>注意</h3>
      <p>关于访问类的静态变量，一定要注意这里写的是<strong>变量，变量，变量</strong>（重要的是强调三遍）。<code>static final int a = 10;</code>是<strong>常量，常量，常量</strong>。访问<code>a</code>不会让类被加载。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Test.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>写一下<code>Test</code>类：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我被初始化了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;都看到这里了，不给个三连+关注吗？&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>先编译一下，看一下<code>Main.class</code>的内容：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Main</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;都看到这里了，不给个三连+关注吗？&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>字节码文件中，将<code>Test.str</code>直接替换成了字符串，那么执行时和<code>Test</code>也就没有任何关系了，自然也不会实例化<code>Test</code>。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/09/28f0a77b42aeafb5.jpg"></p>
<blockquote>
<p>当 int 取值 -2147483648~2147483647 时，JVM 采用 <code>ldc</code> 指令将常量压入栈中。</p>
</blockquote>

        <h2 id="卸载"   >
          <a href="#卸载" class="heading-link"><i class="fas fa-link"></i></a><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2>
      <p>JVM将结束生命周期的几种情况：</p>
<ul>
<li>执行了System.exit()方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
</ul>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/zhangliangzi/article/details/51319033" >https://blog.csdn.net/zhangliangzi/article/details/51319033</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/jvm/java-jvm-classload.html" >https://pdai.tech/md/java/jvm/java-jvm-classload.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javase/keopmg#ddafc876" >https://www.yuque.com/qingkongxiaguang/javase/keopmg#ddafc876</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/wangguoning/p/6109377.html" >https://www.cnblogs.com/wangguoning/p/6109377.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>《深入理解Java虚拟机》第三版</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/czwbig/p/11155555.html" >https://www.cnblogs.com/czwbig/p/11155555.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/08/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%AE%BF%E9%97%AE%E8%80%85/">行为型--访问者</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-08</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-08</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="访问者-Visitor"   >
          <a href="#访问者-Visitor" class="heading-link"><i class="fas fa-link"></i></a><a href="#访问者-Visitor" class="headerlink" title="访问者(Visitor)"></a>访问者(Visitor)</h1>
      <blockquote>
<p>当想要为对象的组合增加新的能力且封装并不重要时，就可以使用访问者模式。</p>
</blockquote>
<p>现在需要知道的就是，被访问的类需要将自身引用传入访问者。讲起来比较空泛，所以先看代码。</p>

        <h2 id="实现"   >
          <a href="#实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#实现" class="headerlink" title="实现"></a>实现</h2>
      <blockquote>
<p>代码来自菜鸟教程。</p>
</blockquote>
<ul>
<li>定义表示元素的接口：</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ComputerPart</span> &#123;</span><br><span class="line">    <span class="comment">// 接口定义的行为：元素提供一个方法供访问者进入</span></span><br><span class="line">    <span class="comment">// 假设存在ComputerPartVisitor接口定义了访问者的visit行为</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>创建扩展上述类的实体类</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个键盘实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Keybord</span> <span class="keyword">implements</span> <span class="title class_">ComputerPart</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> &#123;</span><br><span class="line">        <span class="comment">// 实体类实现的行为是：将自己的引用this暴露给外部访问者</span></span><br><span class="line">        computerPartVisitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个监视器实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Monitor</span> <span class="keyword">implements</span> <span class="title class_">ComputerPart</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    publicvoid <span class="title function_">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> &#123;</span><br><span class="line">        computerPartVisitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个鼠标实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mouse</span>  <span class="keyword">implements</span> <span class="title class_">ComputerPart</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> &#123;</span><br><span class="line">      computerPartVisitor.visit(<span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>再写一个总体的类</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> <span class="keyword">implements</span> <span class="title class_">ComputerPart</span> &#123;</span><br><span class="line">	ComputerPart[] parts;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Computer</span><span class="params">()</span> &#123;</span><br><span class="line">        parts = <span class="keyword">new</span> <span class="title class_">ComputerPart</span>[] &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Mouse</span>(),<span class="keyword">new</span> <span class="title class_">Keyboard</span>(),<span class="keyword">new</span> <span class="title class_">Monitor</span>()</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">                parts[i].accept(computerPartVisitor);</span><br><span class="line">            &#125;</span><br><span class="line">            computerPartVisitor.visit(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>创建一个实体访问者类</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComputerPartDisplayVisitor</span> <span class="keyword">implements</span> <span class="title class_">ComputerPartVisitor</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Computer computer)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Displaying Computer.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Mouse mouse)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Displaying Mouse.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Keyboard keyboard)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Displaying Keyboard.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Monitor monitor)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Displaying Monitor.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>最后运行一下</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisitorPatternDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="type">ComputerPart</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">      computer.accept(<span class="keyword">new</span> <span class="title class_">ComputerPartDisplayVisitor</span>());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h2>
      <p>代码逻辑简单：</p>
<ul>
<li>访问者有处理被访问者的行为。</li>
<li>被访问者有接收访问者并将自身引用暴露给访问者的行为。</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/08/c634509b4c630678.jpg"></p>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p>菜鸟教程：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/visitor-pattern.html?_=1478060039" >https://www.runoob.com/design-pattern/visitor-pattern.html?_=1478060039</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>Java全栈知识体系：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/dev-spec/pattern/20_visitor.html" >https://pdai.tech/md/dev-spec/pattern/20_visitor.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/logo.png" alt="avatar"></div><p class="sidebar-ov-author__text">You have lots more to work on</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">82</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">2</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">14</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh_tw" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Cyan</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.2.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.7.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.7.0"></script><script src="/js/stun-boot.js?v=2.7.0"></script><script src="/js/scroll.js?v=2.7.0"></script><script src="/js/header.js?v=2.7.0"></script><script src="/js/sidebar.js?v=2.7.0"></script></body></html>