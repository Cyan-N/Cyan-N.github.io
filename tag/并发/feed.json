{
    "version": "https://jsonfeed.org/version/1",
    "title": "慕青の迷途 • All posts by \"并发\" tag",
    "description": "时雨病重症患者",
    "home_page_url": "https://cecilia.cool",
    "items": [
        {
            "id": "https://cecilia.cool/2022/12/21/Java/%E5%B9%B6%E5%8F%91/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87C/",
            "url": "https://cecilia.cool/2022/12/21/Java/%E5%B9%B6%E5%8F%91/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87C/",
            "title": "操作系统篇C",
            "date_published": "2022-12-21T15:08:32.000Z",
            "content_html": "<h2 id=\"并发缺陷\"><a class=\"anchor\" href=\"#并发缺陷\">#</a> 并发缺陷</h2>\n<p>并发的缺陷主要分为死锁和非死锁缺陷。</p>\n<h3 id=\"非死锁缺陷\"><a class=\"anchor\" href=\"#非死锁缺陷\">#</a> 非死锁缺陷</h3>\n<p>《操作系统导论》中基于 Lu 及其同事的研究，讨论了<strong>违反原子性缺陷</strong>和<strong>错误顺序缺陷</strong>。</p>\n<ul>\n<li>违反原子性缺陷：</li>\n</ul>\n<p>mysql 中出现过的例子：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Thread <span class=\"token number\">1</span><span class=\"token operator\">::</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>thd<span class=\"token operator\">-></span>proc_info<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">//....</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token function\">fputs</span><span class=\"token punctuation\">(</span>thd<span class=\"token operator\">-></span>proc_info<span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>Thread <span class=\"token number\">2</span><span class=\"token operator\">::</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>thd<span class=\"token operator\">-></span>proc_info <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>如果线程 1 在 <code>fputs</code>  前发生中断，线程 2 将 <code>proc_info</code>  设为空，再执行线程 1 就会出现引用空指针。通过<strong>加锁</strong>就可以解决该问题。</p>\n<ul>\n<li>违反顺序缺陷：</li>\n</ul>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Thread <span class=\"token number\">1</span><span class=\"token operator\">::</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">// ...</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    mThread <span class=\"token operator\">=</span> <span class=\"token function\">PR_CreateThred</span><span class=\"token punctuation\">(</span>mMain<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>Thread <span class=\"token number\">2</span><span class=\"token operator\">::</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">mMain</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token comment\">// ...</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    mState <span class=\"token operator\">=</span> mThread<span class=\"token operator\">-></span>State<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>线程 2 默认了 <code>mState</code>  已经初始化了，如果线程 1 没有先执行，就会引用空指针。所以<strong>需要强制顺序</strong>，即引入条件变量。</p>\n<h3 id=\"死锁缺陷\"><a class=\"anchor\" href=\"#死锁缺陷\">#</a> 死锁缺陷</h3>\n<p>产生条件：</p>\n<ul>\n<li>互斥：线程对于需要的资源进行互斥的访问。</li>\n<li>持有并等待：线程持有资源，等待其他资源。</li>\n<li>非抢占：线程获取的资源不能被抢占。</li>\n<li>循环等待：线程之间存在一个环路，环路上每个线程都额外持有一个资源，而这 个资源又是下一个线程要申请的。</li>\n</ul>\n<p>总结一句话就是：死锁出现的条件就是两个线程各自持有某一资源的锁，然后再请求对方的资源。</p>\n<blockquote>\n<p>当然可能不只是两个线程，多个线程且请求形成环即可。</p>\n</blockquote>\n<p>要预防死锁，就需要避免出现死锁条件</p>\n<h4 id=\"循环等待\"><a class=\"anchor\" href=\"#循环等待\">#</a> 循环等待</h4>\n<p>如果整个系统中，对于锁获得的顺序总是相同的，那么就不会出现循环等待。比如总共有两个锁 <code>L1</code>  和 <code>L2</code> ，如果每次都先申请 L1 再申请 L2，就不会出现死锁问题。这叫做<strong>全序</strong>。</p>\n<p>全序很难做到，偏序可能更现实一点。也就是部分的锁的获取顺序是固定的。</p>\n<blockquote>\n<p>但是其实设计都很复杂，需要很仔细。</p>\n</blockquote>\n<p>当一个函数需要抢多个锁时，为了避免死锁问题而固定锁的顺序，有些人旋转根据锁的地址作为获取锁的顺序。</p>\n<h4 id=\"持有并等待\"><a class=\"anchor\" href=\"#持有并等待\">#</a> 持有并等待</h4>\n<p>通过原子抢锁避免，就是在线程抢锁的过程中不会被打断。其实相当于就是在最外部加上一个全局锁。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span>prevention<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span>L1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span>L2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">//....</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span>prevention<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"非抢占\"><a class=\"anchor\" href=\"#非抢占\">#</a> 非抢占</h4>\n<p>假设 AB 两个线程各自抢了 ab 锁，然后请求对方的锁，会造成死锁。死锁的原因之一就是 AB 都不会主动释放自己的锁。</p>\n<p>在很多语言的线程库中都会提供一个 <code>trylock()</code>  函数，它会尝试抢锁，如果失败，不会阻塞而是返回 - 1，所以为了避免死锁问题，可以让线程抢对方的锁失败后主动释放自己的锁让对方抢：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>top<span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span>L1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">trylock</span><span class=\"token punctuation\">(</span>L2<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span>L1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token keyword\">goto</span> top<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>但是也可能出现活锁，两个线程不断重复，都抢锁然后再释放锁，可以设置一个随机的等待时间，降低线程之间的相互干扰。</p>\n<blockquote>\n<p>关于 <code>trylock</code>  的使用，较为麻烦的就是 <code>goto top</code>  的实现，如果代码在中途中获取了某些资源，必须确保也能释放这些资源。</p>\n</blockquote>\n<h4 id=\"互斥\"><a class=\"anchor\" href=\"#互斥\">#</a> 互斥</h4>\n<p>使资源的访问不再互斥，更多的是使用硬件支持，从而设计出无等待的数据结构。比如使用 <code>CAS</code>  设计链表插入：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token class-name\">node_t</span> <span class=\"token operator\">*</span>n <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">node_t</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    n<span class=\"token operator\">-></span>val <span class=\"token operator\">=</span> val<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">do</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        n<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">CompareAndSet</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>head<span class=\"token punctuation\">,</span> n<span class=\"token operator\">-></span>next<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"基于事件的并发\"><a class=\"anchor\" href=\"#基于事件的并发\">#</a> 基于事件的并发</h2>\n<p>这部分属于进阶内容，怎么说呢，如果你了解网络编程，如果你了解过 Netty，那么这部分理解起来就很简单。但是本部分要讲的内容也不会很多。</p>\n<blockquote>\n<p>所以你听过 <code>select()</code>  和 <code>poll()</code>  这两个 API 吗？</p>\n</blockquote>\n<p>基于事件的服务器，最经典的设计就是写一个死循环，然后监听是否有事件，没有事件就会一直阻塞。 <code>select/poll</code>  就是用于支持检查是否有网络数据包到达。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token comment\">// ...</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token keyword\">int</span> rc <span class=\"token operator\">=</span> <span class=\"token function\">select</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token comment\">// ...</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>使用单个 CPU + 基于事件的应用程序就不会出现并发问题，因为一次只会处理一个事件（其实性能非常 <code>low</code> ，为了并发处理，也就有了 <code>Netty</code> ）。</p>\n<p>当某个事件需要程序发出阻塞的系统调用，如从磁盘读文件，再返回给客户端。这样就需要发送 <code>I/O</code>  请求，造成阻塞，整个系统处于闲置状态，所以基于事件的系统（单线程）必须遵守：不允许调用阻塞调用。</p>\n<p>许多现代操作系统都支持异步 I/O，当事件需要请求 I/O，异步 I/O 的接口使程序发送 I/O 请求，并且在 I/O 完成前将控制权立即返回给调用者，然后有其他接口轮询 I/O 是否完成。</p>\n<p>随着客户端数量连接上升，单线程的基于事件的并发是不可能满足需求的，到时候依然需要，不可避免地创建新的线程来处理：事件，I/O 请求等，详细知识可以参考网络编程标签。</p>\n<h2 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h2>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYWdlcy5jcy53aXNjLmVkdS9+cmVtemkvT1NURVAvQ2hpbmVzZS8zMi5wZGY=\">https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/32.pdf</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYWdlcy5jcy53aXNjLmVkdS9+cmVtemkvT1NURVAvQ2hpbmVzZS8zMy5wZGY=\">https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/33.pdf</span></p>\n</blockquote>\n",
            "tags": [
                "并发"
            ]
        },
        {
            "id": "https://cecilia.cool/2022/12/21/Java/%E5%B9%B6%E5%8F%91/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87B/",
            "url": "https://cecilia.cool/2022/12/21/Java/%E5%B9%B6%E5%8F%91/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87B/",
            "title": "操作系统篇B",
            "date_published": "2022-12-21T02:58:42.000Z",
            "content_html": "<h2 id=\"条件变量\"><a class=\"anchor\" href=\"#条件变量\">#</a> 条件变量</h2>\n<p>线程有时需要检查某一条件（condition）满足后才能继续运行：<strong>子线程 join 父线程</strong>。这也就意味着父线程需要等待子线程运行完才能继续运行。</p>\n<ul>\n<li>设计一个共享变量：这样父线程就需要一直自旋来等待子线程运行结束，将共享变量改为父线程可用状态。这种设计缺点就是浪费时间，某些情况甚至是错误的。</li>\n<li>加入等待队列：其实整个设计思想和 A 篇中我们讲到设计锁的思想很相似，这里的条件变量就是”<strong> 锁</strong> “。当条件不满足时，线程就将自己加入队列，等待该条件。某个线程修改了条件状态，就唤醒一个或多个等待线程。</li>\n</ul>\n<p><strong>定义：条件变量是一个显示的队列，当某些执行状态（即条件）不满足时，线程就将自己加入队列，等待条件</strong>。</p>\n<p>关于条件变量的两种操作： <code>wait()</code>  和 <code>singal()</code> 。 <code>wait()</code>  职责是释放锁，并让调用线程休眠（原子地），当线程被唤醒时，<strong>需要重新竞争锁再返回调用者</strong>，<strong>这是为了避免线程陷入休眠时产生一些竞态条件</strong>； <code>signal()</code>  唤醒等待在某个条件变量上的睡眠线程。</p>\n<blockquote>\n<p><code>wait</code>  会释放锁，牢记，实际上，在 Java 语言中， <code>Object</code>  也有 <code>await()</code>  函数，该方法也会释放锁。</p>\n</blockquote>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> done <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">pthread_cond_wait</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">pthread_cond_t</span> <span class=\"token operator\">*</span>c<span class=\"token punctuation\">,</span> <span class=\"token class-name\">pthread_mutex_t</span> <span class=\"token operator\">*</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">pthread_cond_signal</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">pthread_cond_t</span> <span class=\"token operator\">*</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">thread_exit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 假设已经初始化了一个宏变量 m 作为锁</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    done <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token function\">pthread_cond_signal</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 假设已经初始化了一个宏变量 c 作为等待队列</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">child</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"child\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token function\">thread_exit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">thread_join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>done <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> </pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token function\">pthread_cond_wait</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>agrv<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"parent: begin\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    thread p<span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token function\">thread_create</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> child<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    <span class=\"token function\">thread_join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"parent: end\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>设想如果在发送信号和等待时都不加锁会发生什么问题？在操作系统 A 篇中讲过：<strong>改变锁的状态时一定要是线程安全的</strong>。这里保证互斥除了锁，还有条件变量，也就是信号。</p>\n<blockquote>\n<p>DIjkstra 最早在 “私有信号量” 提出等待条件这个思想，Hoare 在关于观察者的工作中，将这种类似的思想称为<strong>条件变量</strong>。</p>\n</blockquote>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">thr_exit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    done <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token function\">pthread_cond_signal</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">thr_join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>done <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token function\">pthread_cond_wait</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>设想，如果父线程调用 <code>thr_join()</code> ，检查到 <code>done==0</code> ，然后试图休眠，此时发生中断，然后子线程修改 <code>done=1</code> ，发出信号，此时子线程检查到没有等待线程。父线程再次运行，进入休眠，之后就会一直休眠，没有线程唤醒。</p>\n<p>发信号时总是持有锁，但也有一些情况可以不加锁，而这可能是你应该避免的。因此，为 了简单，请在调用  <code>signal</code>  时持有锁（<strong>hold the lock when calling signal</strong>）。同样的，在 <code>wait</code>  时也必须持有锁，这是 <code>wait</code>  语法强制要求的。因为  <code>wait</code>  调 用总是假设你调用它时已经持有锁、调用者睡眠之前会释放锁以及返回前重新持有锁。因此，这个提示 的一般化形式是正确的：调用  <code>signal</code>  和  <code>wait</code>  时要持有锁（<strong>hold the lock when calling signal or wait</strong>）。</p>\n<blockquote>\n<p>在操作系统 A 篇中我们最后给了一个设计锁的例子，结构体里面也有一个队列 <code>queue_t *q</code> ，该队列是竞争锁失败后，线程进入阻塞队列等待锁空闲。线程为了节省时间也会休眠。但是条件变量不同的是需要线程主动调用 <code>wait</code>  主动放弃锁的占用，进入等待队列从而休眠，需要等到一个指定条件发生才会被唤醒。</p>\n</blockquote>\n<h3 id=\"生产消费问题\"><a class=\"anchor\" href=\"#生产消费问题\">#</a> 生产 / 消费问题</h3>\n<p>这也是 Dijkstra 提出来的 —— 生产者消费者问题。我们回顾前面的代码，你也许认为将：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>done <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>改成：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>done <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>也是符合逻辑的。在父线程 / 子线程的案例中，这确实是合理的，但是在使用条件变量时，应该总是使用 <code>while</code> ，在生产者消费者问题中就能够体现出来。</p>\n<p>先看伪代码： <code>count==1</code>  表示缓冲区有数据可以被消费，消费之后就为 0。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">producer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> loops<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>            <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token function\">put</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">consumer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> loops<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token keyword\">int</span> tmp <span class=\"token operator\">=</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span>tmp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>上述代码使用的就是 <code>if</code>  语句，我们假设只有一个生产者。如果只有一个消费者，那么这段代码不会出现问题。但是当出现两个消费者时，就会导致错误。</p>\n<blockquote>\n<p>首先，这个问题肯定是当缓冲区没有数据，就不应该调用 <code>get</code>  的。</p>\n</blockquote>\n<p>设想 <code>C1</code> ， <code>C2</code>  两个消费者此时都 <code>wait</code> ，等待缓冲区加入数据。生产者产生数据后，唤醒了 <code>C1</code>  并拿到了锁， <code>C1</code>  开始执行 <code>int tmp = get();</code>  这段代码。然后继续唤醒等待队列中的线程。当然有可能唤醒 <code>C2</code>  线程并且拿到锁，那么 <code>C2</code>  此时也会执行 <code>get()</code>  函数，但是此时缓冲区并没有数据，<strong>缓冲区无法消费</strong>，就会断言触发，<strong>提示整个并发环境出现了问题</strong>。所以需要将 <code>if</code>  改成 <code>while</code> ，每次被唤醒都需要重新检查一下缓冲区是否还可以消费。</p>\n<blockquote>\n<p>其实导致我们需要循环检查缓冲区消费情况的本质原因是：消费者在休眠的时候 <code>count</code>  可能会减小。</p>\n</blockquote>\n<p>但是仅仅是将 <code>if</code>  改为 <code>while</code>  还是存在问题，主要原因是生产者和消费者都位于同一个休眠（等待，阻塞）队列（这是我自己总结的原因，先不用急着反驳）。</p>\n<p>设想这种情况： <code>P1</code>  作为生产者， <code>C1</code> ， <code>C2</code>  作为两个消费者. <code>C1</code> ， <code>C2</code>  因为缓冲区没有数据先休眠，进入队列。当 <code>P1</code>  向缓冲区放入数据，然后进入队列。此时 <code>C1</code>  被唤醒，消费了数据之后，需要唤醒一个队列中的线程。</p>\n<p>此时应该唤醒一个生产者，因为缓冲区没有数据了，但是不同的队列的管理方式不同，并不是所有队列都是 <code>FIFO</code> ，所以程序运行到后期你根本不知道下一个被唤醒的是生产者还是消费者。如果恰好此时 <code>C2</code>  被唤醒了，进入 <code>while</code>  循环发现缓冲区没有数据，于是继续 <code>wait</code>  休眠，进入队列。此时三个线程都休眠了，就不会再有线程来唤醒队列中的线程了，程序崩溃。</p>\n<p>所以只需要使用两个队列即可，标准的说法就是使用两个条件变量。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">cond_t</span> empty<span class=\"token punctuation\">,</span> fill<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// producer</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>empty<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 当缓冲区为空时，就需要从 empty 唤醒生产者</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>fill<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">// consumer</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>fill<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">int</span> tmp <span class=\"token operator\">=</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>empty<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"覆盖条件\"><a class=\"anchor\" href=\"#覆盖条件\">#</a> 覆盖条件</h3>\n<p>这其实就是 <code>signal_all()</code>  方法，将休眠的线程全部唤醒。有时这样的操作是有必要的，尽管他比较损耗性能。</p>\n<p>举个内存分配的问题，当 <code>allocate(int size)</code>  遇到了内存不足时，就会休眠等待，相应的，线程释放内存会发出信号说有更多内存空间，但是，代码中有一个问题就是，应该缓行哪个线程？</p>\n<p>极端的情况就是：共有 3 个线程，2 个都在休眠等待，最后一个线程释放了内存后，现在还有 50 的内存，线程 A 需要 100，线程 B 需要 10，但是不能够保证一定唤醒 B 线程，如果唤醒了 A 线程，那么所有线程都会进入休眠，所以有人的解决方案就是将所有线程都唤醒，这就是覆盖条件。</p>\n<blockquote>\n<p>其实单论这个问题的话，可以用优先队列来解决，当然我只是借这个问题引出覆盖条件的概念。</p>\n</blockquote>\n<h2 id=\"信号量\"><a class=\"anchor\" href=\"#信号量\">#</a> 信号量</h2>\n<p>信号量是有一个<strong>整数值</strong>的对象，可以用两个函数操作它。在 POSIX 标准中，是 <code>sem_wait()</code>  和 <code>sem_post()</code> 。当线程完成一次对信号量对象的等待（wait）时，计数值减一；当线程完成一次对信号量的释放（release）时，计数值加一。</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/12/21/e73efde1c65e3fc7.jpg\" alt=\"\" /></p>\n<h3 id=\"应用锁\"><a class=\"anchor\" href=\"#应用锁\">#</a> 应用：锁</h3>\n<p>最简单的例子就是使用信号量作为锁，那么同时间进入临界区只能有一个线程，假设最开始 A 线程进入临界区，此时需要调用 <code>wait()</code> ，将信号量减一，如果此时不允许其他线程进入，那么信号量此时至少为 0. 因为其他线程进入临界区之前也需要调用一下 <code>wait()</code> ，此时再判断信号量为负，不能进入临界区，进入休眠。因为锁只有两种状态，所以这种用法有时也叫做<strong>二值信号量</strong>。</p>\n<blockquote>\n<p>所以信号量作为锁，初始化的计数值应该为 1。 图中的 <code>signal</code>  相当于 <code>POSIX</code>  中的 <code>sme_post()</code> 。</p>\n</blockquote>\n<h3 id=\"应用条件变量\"><a class=\"anchor\" href=\"#应用条件变量\">#</a> 应用：条件变量</h3>\n<p>本文最开始讲解条件变量时的例子是父线程创建子线程，并等待子线程执行结束。用一个显示队列作为条件变量，使用 <code>wait/signal</code>  来保证线程安全。</p>\n<p>下面讲一下如何用信号量来实现这种效果。</p>\n<p>首先要理解一个点，信号量并不是什么很特别的东西，本质就是一个整数，只是说，操作系统存在调用，如 <code>sem_wait()</code>  和 <code>sem_signal()</code> 。重要的是它能够让线程停下来等待，放弃 CPU 资源进入休眠。</p>\n<p>父线程等待子线程的例子中，逻辑为：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">child</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"child\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token function\">sem_post</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">sem_init</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 0 表示同一进程所有线程都共享信号量，计数值初始化为 x</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"parent:begin\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token function\">thread_create</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> child<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 创建子线程并运行</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token function\">sem_wait</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"parent:end\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>使用信号量代替条件变量，计数值初始化为 0。</p>\n<blockquote>\n<p>需要思考父线程先执行 <code>sem_wait()</code>  和子线程先执行 <code>sem_post()</code>  两种情况。</p>\n</blockquote>\n<h3 id=\"应用实现信号量\"><a class=\"anchor\" href=\"#应用实现信号量\">#</a> 应用：实现信号量</h3>\n<p>该部分模拟实现一下 <code>sem_wait</code>  和 <code>sem_post</code> 。《操作系统导论》一书中将这个自定义信号量称为 <code>Zemaphore</code> ，我们延用一下。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">_Zem_t</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> val<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 计数值</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token class-name\">pthread_cond_t</span> cond<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 休眠 / 等待队列，肯定要有，不然你以为谁替你维护一个队列</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token class-name\">pthread_mutex_t</span> lock<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 锁</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">Zem_init</span><span class=\"token punctuation\">(</span>Zem_t <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    s<span class=\"token operator\">-></span>val <span class=\"token operator\">=</span> val<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token function\">Cond_init</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token operator\">-></span>cond<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 初始化阻塞队列</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token function\">Mutex_init</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token operator\">-></span>lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 初始化锁，</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">Zem_wait</span><span class=\"token punctuation\">(</span>Zem_t <span class=\"token operator\">*</span>s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token function\">Mutex_lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token operator\">-></span>lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">-></span>val <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 进入队列休眠 </span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token function\">Cond_wait</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token operator\">-></span>cond<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>s<span class=\"token operator\">-></span>lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    s<span class=\"token operator\">-></span>val<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token function\">Mutex_unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token operator\">-></span>lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">Zem_post</span><span class=\"token punctuation\">(</span>Zem_t <span class=\"token operator\">*</span>s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token function\">Mutex_lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token operator\">-></span>lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    s<span class=\"token operator\">-></span>val<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token function\">Cond_signal</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token operator\">-></span>cond<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token function\">Mutex_unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token operator\">-></span>lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>只用了一把锁、一个条件变量和一个状态的变量来记录信号量的值。是不是感觉信号量就是将锁和条件变量封装了一下。</p>\n<h2 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h2>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYWdlcy5jcy53aXNjLmVkdS9+cmVtemkvT1NURVAvQ2hpbmVzZS8zMC5wZGY=\">https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/30.pdf</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYWdlcy5jcy53aXNjLmVkdS9+cmVtemkvT1NURVAvQ2hpbmVzZS8zMS5wZGY=\">https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/31.pdf</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvemgtaGFucy8lRTQlQkYlQTElRTUlOEYlQjclRTklODclOEY=\">https://zh.m.wikipedia.org/zh-hans/ 信号量</span></p>\n</blockquote>\n",
            "tags": [
                "并发"
            ]
        }
    ]
}