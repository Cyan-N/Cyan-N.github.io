<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.7.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.7.0" type="image/png" sizes="32x32"><meta name="description" content="我始终勇往直前，百折不回...">
<meta property="og:type" content="website">
<meta property="og:title" content="慕青的日记">
<meta property="og:url" content="https://cecilia.cool/page/2/index.html">
<meta property="og:site_name" content="慕青的日记">
<meta property="og:description" content="我始终勇往直前，百折不回...">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Cyan">
<meta name="twitter:card" content="summary"><title>慕青的日记 | Cyan</title><link ref="canonical" href="https://cecilia.cool/page/2/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.7.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">慕青的日记</div><div class="header-banner-info__subtitle">Cyan</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/20/Docker/Docker(1)-%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8/">Docker(1)--容器技术入门</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-20</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-24</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="虚拟化技术"   >
          <a href="#虚拟化技术" class="heading-link"><i class="fas fa-link"></i></a><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h1>
      <p>Virtualization是一种资源管理技术，将计算机各种实体资源（服务器，内存，网络）予以抽象，打破实体结构间不可切割的障碍，使用户可以更好的方式利用资源。从而实现在同一主机上运行多个系统或应用。</p>
<p>软件虚拟化技术是利用软件技术，在现有的物理平台上实现对物理平台访问的截获和模拟。有些软件虚拟化技术需要依赖硬件支持，比如：VMware，KVM。</p>
<p>Docker就是软件虚拟化，软件虚拟化分为好几类，Docker实际是操作系统层虚拟化。<strong>操作系统级虚拟化也被称为容器化</strong>，它允许多个相互隔离的用户空间实例存在，这些用户空间实例也被<strong>容器</strong>。</p>
<blockquote>
<p>普通的进程可以看到计算机所有资源而容器只能看到分配给该容器的资源</p>
</blockquote>
<p>实现操作系统虚拟化需要用到<strong>Namespace</strong>及<strong>cgroups</strong>技术。</p>
<p>因为不是主要讲解虚拟化技术的底层实现，所以详细可以看这篇文章：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://my.oschina.net/kelvinxupt/blog/1602990" >操作系统级虚拟化概述</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p>

        <h2 id="Docker虚拟化"   >
          <a href="#Docker虚拟化" class="heading-link"><i class="fas fa-link"></i></a><a href="#Docker虚拟化" class="headerlink" title="Docker虚拟化"></a>Docker虚拟化</h2>
      <p>Docker是一个开源的应用容器引擎，它让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到安装了任何 Linux 发行版本的机器上。Docker是直接运行在宿主操作系统之上的一个容器（操作系统级别的虚拟化），<strong>所有容器用的都是宿主操作系统的内核</strong>。</p>
<p>Docker能快速搭建开发环境，并且每个容器相互隔离：我们只需要将这些环境打包成镜像，到需要在服务器上部署时，可以直接下载镜像实现一键部署。</p>

        <h2 id="Docker与虚拟机区别"   >
          <a href="#Docker与虚拟机区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#Docker与虚拟机区别" class="headerlink" title="Docker与虚拟机区别"></a>Docker与虚拟机区别</h2>
      <p><img src="https://s3.bmp.ovh/imgs/2022/09/20/204f57e058964113.jpg"></p>
<p><strong>虚拟机</strong></p>
<ul>
<li>基础设施（Infrastructure）：个人电脑，服务器，云主机。</li>
<li>主操作系统（Host Operating System）：基础设施上运行的MacOS，Windows或者某个Linux发行版。</li>
<li>虚拟机管理系统（Hypervisor）：利用Hypervisor，可以在主操作系统之上运行多个不同的从操作系统。类型1的Hypervisor有支持MacOS的HyperKit，支持Windows的Hyper-V以及支持Linux的KVM。类型2的Hypervisor有VirtualBox和VMWare。</li>
<li><strong>操作系统（Guest Operating System）</strong>：假设你需要运行3个相互隔离的应用，则需要使用Hypervisor启动3个从操作系统，也就是3个虚拟机。这些虚拟机都非常大，也许有700MB，这就意味着它们将占用2.1GB的磁盘空间。更糟糕的是，它们还会消耗很多CPU和内存。</li>
<li>各种依赖：每一个从操作系统都需要安装许多依赖。如果你的的应用需要连接PostgreSQL的话，则需要安装libpq-dev；如果你使用Ruby的话，应该需要安装gems；如果使用其他编程语言，比如Python或者Node.js，都会需要安装对应的依赖库。</li>
</ul>
<p><strong>Docker容器</strong></p>
<ul>
<li>主操作系统（Host Operating System）：所有主流的Linux发行版都可以运行Docker。对于MacOS和Windows，也有一些办法”运行”Docker。</li>
<li>Docker守护进程（Docker Daemon）：Docker守护进程取代了Hypervisor，它是运行在操作系统之上的后台进程，<strong>负责管理Docker容器</strong>。</li>
<li>各种依赖。对于Docker，<strong>应用的所有依赖都打包在Docker镜像中，Docker容器是基于Docker镜像创建的</strong>。</li>
<li>应用。应用的源代码与它的依赖都打包在Docker镜像中，不同的应用需要不同的Docker镜像。不同的应用运行在不同的Docker容器中，它们是相互隔离的。</li>
</ul>
<blockquote>
<p>Docker守护进程可以直接与主操作系统进行通信，为各个Docker容器分配资源；它还可以将容器与主操作系统隔离，并将各个容器互相隔离。</p>
</blockquote>

        <h1 id="Docker架构"   >
          <a href="#Docker架构" class="heading-link"><i class="fas fa-link"></i></a><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h1>
      <p>Docker是C&#x2F;S架构，通过远程API来管理和创建容器。</p>
<p>客户端：客户端通过命令行或者其他工具使用Docker SDK和Docker守护进程通信。</p>
<p>主机：物理或虚拟机器，用于执行Docker守护进程和容器。</p>
<p>其他的基本概念：</p>
<ul>
<li><p><strong>镜像（Image）</strong>：Docker 镜像（Image），就相当于是一个 root 文件系统。</p>
</li>
<li><p><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
</li>
<li><p><strong>仓库（Repository）</strong>：仓库可看着一个代码控制中心，用来保存镜像。</p>
</li>
</ul>

        <h1 id="Docker安装"   >
          <a href="#Docker安装" class="heading-link"><i class="fas fa-link"></i></a><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1>
      <blockquote>
<p>我使用的系统是Ubuntu 20.04.3版本</p>
</blockquote>
<p>先安装一些工具</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ca-certificates curl gnupg lsb-release</span><br></pre></td></tr></table></div></figure>

<p>再安装官方的GPG key：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/apt/keyrings</span><br><span class="line"></span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br></pre></td></tr></table></div></figure>

<p>将Docker的库添加到apt资源列表中：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></div></figure>

<p>更新apt：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></div></figure>

<p>安装Docker CE版本</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker-ce</span><br></pre></td></tr></table></div></figure>

<p>等待安装后，查看Docker版本</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker --version</span><br></pre></td></tr></table></div></figure>

<p>但是我们使用了sudo命令（因为当前用户使用权限可能不足），所以需要将当前用户加入到Docker组里面</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker &lt;用户名&gt;</span><br></pre></td></tr></table></div></figure>

<p>退出ssh终端，重新连接即可生效。</p>
<p>我们可以先看一下Docker这个组</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里把提示符部分也写出来是为了展示一下我的用户名</span></span><br><span class="line">cyan@cyan-virtual-machine:~$ cat /etc/group</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最后一排：docker:x:998:cyan</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我已经执行过usermod命令了，所以docker组有cyan这个用户</span></span><br></pre></td></tr></table></div></figure>

<p>关于详细的Linux组的知识，你可以参考这篇文章：<a href="https://cecilia.cool/2022/07/31/Shell/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/">Linux文件权限</a>。</p>
<blockquote>
<p>如果加入组后权限依然不够，执行：<code>newgrp docker</code>。newgrp命令是登入群组。</p>
</blockquote>
<p>前文提到Docker架构（C&#x2F;S），现在部署Nginx服务器</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d -p 80:80 nginx</span><br></pre></td></tr></table></div></figure>

<p>会从镜像仓库里面下载对应的镜像，下载完成后就在后台运行了</p>
<blockquote>
<p>在浏览器的url中输入虚拟机IP，就能看到Nginx启动了</p>
</blockquote>
<p>该命令流程：</p>
<ol>
<li>Docker客户端将操作发送给服务端，告诉服务端我们要运行nginx这个镜像。</li>
<li>Docker服务端先看看本地有没有这个镜像，发现没有。</li>
<li>接着只能从公共仓库Docker Hub去查找下载镜像了。</li>
<li>下载完成，镜像成功保存到本地。</li>
<li>Docker<strong>服务端加载Nginx镜像</strong>，启动容器开始正常运行。</li>
</ol>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/devops/docker/docker-01-docker-vm.html" >https://pdai.tech/md/devops/docker/docker-01-docker-vm.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/zwhkpi/kq6rlg" >https://www.yuque.com/qingkongxiaguang/zwhkpi/kq6rlg</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://my.oschina.net/kelvinxupt/blog/1602990" >https://my.oschina.net/kelvinxupt/blog/1602990</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/jie-fang/p/10279629.html" >https://www.cnblogs.com/jie-fang/p/10279629.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/19/%E4%BA%91%E8%AE%A1%E7%AE%97/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A/">云计算作业</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-19</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h1>
      <p>用MapReduce实现wordCount（单词计数）</p>
<blockquote>
<p>软件2004-20207127云计算作业</p>
</blockquote>

        <h1 id="相关类"   >
          <a href="#相关类" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h1>
      
        <h2 id="WordCountMapper"   >
          <a href="#WordCountMapper" class="heading-link"><i class="fas fa-link"></i></a><a href="#WordCountMapper" class="headerlink" title="WordCountMapper"></a>WordCountMapper</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCountMapper</span> <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;LongWritable, Text,Text, IntWritable&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        System.out.println(key);</span><br><span class="line">        String line=value.toString();</span><br><span class="line">        String[] words=line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String word : words)&#123;</span><br><span class="line">            context.write(<span class="keyword">new</span> <span class="title class_">Text</span>(word),<span class="keyword">new</span> <span class="title class_">IntWritable</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="WordCountReduce"   >
          <a href="#WordCountReduce" class="heading-link"><i class="fas fa-link"></i></a><a href="#WordCountReduce" class="headerlink" title="WordCountReduce"></a>WordCountReduce</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCountReduce</span> <span class="keyword">extends</span> <span class="title class_">Reducer</span>&lt;Text, IntWritable,Text,IntWritable&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> total=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(IntWritable value : values)&#123;</span><br><span class="line">            total+=value.get();</span><br><span class="line">        &#125;</span><br><span class="line">        context.write(key,<span class="keyword">new</span> <span class="title class_">IntWritable</span>(total));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="WordCountMain"   >
          <a href="#WordCountMain" class="heading-link"><i class="fas fa-link"></i></a><a href="#WordCountMain" class="headerlink" title="WordCountMain"></a>WordCountMain</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCountMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//1.建立连接</span></span><br><span class="line">        Configuration cfg=<span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">        Job job=Job.getInstance(cfg,<span class="string">&quot;wc&quot;</span>);</span><br><span class="line">        job.setJarByClass(WordCountMain.class);</span><br><span class="line">        <span class="comment">//2.指定mapper和reduce</span></span><br><span class="line">        job.setMapperClass(WordCountMapper.class);</span><br><span class="line">        job.setReducerClass(WordCountReduce.class);</span><br><span class="line">        <span class="comment">//指定mapper输出类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(IntWritable.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定reduce输出类型</span></span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(IntWritable.class);</span><br><span class="line">        <span class="comment">//指定输出路径</span></span><br><span class="line">        FileInputFormat.setInputPaths(job,<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;S:/test/data.txt&quot;</span>));</span><br><span class="line">        FileOutputFormat.setOutputPath(job,<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;S:/test/M&quot;</span>));</span><br><span class="line">        <span class="comment">//3.运行</span></span><br><span class="line">        <span class="type">boolean</span> result=job.waitForCompletion(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(result?<span class="string">&quot;成功&quot;</span>:<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">        System.exit(result?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="运行结果"   >
          <a href="#运行结果" class="heading-link"><i class="fas fa-link"></i></a><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1>
      <p><img src="https://s3.bmp.ovh/imgs/2022/09/19/fc49e140e301e8d5.jpg"></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/15/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty%E6%A1%86%E6%9E%B6(5)-Http%E5%8D%8F%E8%AE%AE%E9%80%9A%E4%BF%A1/">Netty框架(5)--Http协议通信</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-15</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-15</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="通信协议设计"   >
          <a href="#通信协议设计" class="heading-link"><i class="fas fa-link"></i></a><a href="#通信协议设计" class="headerlink" title="通信协议设计"></a>通信协议设计</h1>
      <p>在TCP网络编程中，发送方和接收方的数据包格式都是二进制，发送方将对象转化成二进制流发送给接收方，接收方获得<strong>二进制数据</strong>后需要知道如何解析成对象。</p>
<p>一个完备的网络协议需要具备以下基本要素</p>

        <h2 id="魔数"   >
          <a href="#魔数" class="heading-link"><i class="fas fa-link"></i></a><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2>
      <p>作用是防止任何人随便向服务器端口发送数据。服务端在接收到数据时会解析出前几个固定字节的魔数做对比，如果和约定的魔数不匹配，就会认为是非法数据。</p>
<p>魔数的思想在压缩算法，Java Class文件就有魔数<code>0XCAFFBABE</code>，调侃为咖啡宝贝，在加载Class文件时就会首先验证魔数的正确性。</p>

        <h2 id="序列化算法"   >
          <a href="#序列化算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#序列化算法" class="headerlink" title="序列化算法"></a>序列化算法</h2>
      <p>序列化算法表示数据发送方应该用何种方法将请求的对象转化为二进制，以及如何将二进制转化为对象等，如JSON，Hessian，Java自带序列化等。</p>
<blockquote>
<p>可以从Http协议中看出，完整的网络协议还需要长度域字段，请求数据，状态，保留字段，报文类型，协议版本号等。</p>
</blockquote>
<figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> 魔数 <span class="number">2</span>byte <span class="operator">|</span> 协议版本号 <span class="number">1</span>byte <span class="operator">|</span> 序列化算法 <span class="number">1</span>byte <span class="operator">|</span> 报文类型 <span class="number">1</span>byte  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> 状态 <span class="number">1</span>byte <span class="operator">|</span>        保留字段 <span class="number">4</span>byte     <span class="operator">|</span>      数据长度 <span class="number">4</span>byte     <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>                   数据内容 （长度不定）                          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------------------------+</span></span><br></pre></td></tr></table></div></figure>




        <h1 id="实现Http协议通信"   >
          <a href="#实现Http协议通信" class="heading-link"><i class="fas fa-link"></i></a><a href="#实现Http协议通信" class="headerlink" title="实现Http协议通信"></a>实现Http协议通信</h1>
      <p>需要使用到我们上一篇讲到的解码器和编码器</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">HttpRequestDecoder</span>())   <span class="comment">//Http请求解码器</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="comment">//看看是个啥类型</span></span><br><span class="line">                System.out.println(<span class="string">&quot;收到客户端的数据：&quot;</span>+msg.getClass());  </span><br><span class="line">                </span><br><span class="line">              	<span class="comment">//收到浏览器请求后，我们需要给一个响应回去</span></span><br><span class="line">                <span class="comment">//HTTP版本为1.1，状态码就OK（200）即可</span></span><br><span class="line">                <span class="type">FullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">                    <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1, </span><br><span class="line">                                            HttpResponseStatus.OK);  </span><br><span class="line">              	<span class="comment">//直接向响应内容中写入数据</span></span><br><span class="line">                response.content().writeCharSequence(<span class="string">&quot;Hello World!&quot;</span>,</span><br><span class="line">                                                     StandardCharsets.UTF_8);</span><br><span class="line">                ctx.channel().writeAndFlush(response);   <span class="comment">//发送响应</span></span><br><span class="line">                ctx.channel().close();   <span class="comment">//HTTP请求是一次性的，所以记得关闭</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">HttpResponseEncoder</span>());   <span class="comment">//响应记得也要编码后发送哦</span></span><br></pre></td></tr></table></div></figure>

<p>用浏览器访问一下</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/15/baca09d46ab8eb8c.jpg"></p>
<p>控制台打印的类型为：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class.io.netty.handler.codec.http.DefaultHttpRequest</span><br><span class="line">class.io.neety.handler.codec.http.LastHttpContent$<span class="number">1</span></span><br><span class="line">class.io.netty.handler.codec.http.DefaultHttpRequest</span><br><span class="line">class.io.neety.handler.codec.http.LastHttpContent$<span class="number">1</span></span><br></pre></td></tr></table></div></figure>

<p>可以看到一次请求是一个<code>DefaultHttpRequest</code>+<code>LastHttpContent$1</code>，这里有两组是因为浏览器请求了一个地址后紧接着又请求了网站的favicon图标。</p>
<p>如果不希望一次请求被拆分为两个，可以在<code>HttpRequestDecoder</code>后面加上聚合器</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将内容聚合为一个FullHttpRequest，参数是最大内容长度</span></span><br><span class="line">.addLast(<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(Integer.MAX_VALUE))</span><br></pre></td></tr></table></div></figure>

<p>我们再改一下channelRead里的内容</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">FullHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> (FullHttpRequest) msg;</span><br><span class="line">    System.out.println(<span class="string">&quot;浏览器请求路径：&quot;</span>+request.uri());  <span class="comment">//直接获取请求相关信息</span></span><br><span class="line">    <span class="type">FullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1,</span><br><span class="line">                                                            HttpResponseStatus.OK);</span><br><span class="line">    response.content().writeCharSequence(<span class="string">&quot;Hello World!&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">    ctx.channel().writeAndFlush(response);</span><br><span class="line">    ctx.channel().close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浏览器总共发送了两次请求</span></span><br><span class="line"><span class="comment">// 浏览器请求路径：/</span></span><br><span class="line"><span class="comment">// 浏览器请求路径：/favicon.ico</span></span><br></pre></td></tr></table></div></figure>

<p>如果我们是请求服务器网页资源，需要自定义一个解析器（本质就是通过请求路径拿到相关资源）</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageResolver</span> &#123;</span><br><span class="line">		<span class="comment">//直接单例模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">PageResolver</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageResolver</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">PageResolver</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PageResolver <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//请求路径给进来，接着我们需要将页面拿到，然后转换成响应数据包发回去</span></span><br><span class="line">    <span class="keyword">public</span> FullHttpResponse <span class="title function_">resolveResource</span><span class="params">(String path)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.startsWith(<span class="string">&quot;/&quot;</span>))  &#123;  <span class="comment">//判断一下是不是正常的路径请求</span></span><br><span class="line">            </span><br><span class="line">             <span class="comment">//如果是直接请求根路径，那就默认返回index页面，否则就该返回什么路径的文件就返回什么</span></span><br><span class="line">            path = path.equals(<span class="string">&quot;/&quot;</span>) ? <span class="string">&quot;index.html&quot;</span> : path.substring(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span>(<span class="type">InputStream</span> <span class="variable">stream</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader()</span><br><span class="line">                .getResourceAsStream(path)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(stream != <span class="literal">null</span>) &#123;   <span class="comment">//拿到文件输入流之后，才可以返回页面</span></span><br><span class="line">                    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[stream.available()];</span><br><span class="line">                    stream.read(bytes);</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.packet(HttpResponseStatus.OK, bytes);  </span><br><span class="line">                    <span class="comment">//数据先读出来，然后交给下面的方法打包</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//其他情况一律返回404</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.packet(HttpResponseStatus.NOT_FOUND,</span><br><span class="line">                           <span class="string">&quot;404 Not Found!&quot;</span>.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//包装成FullHttpResponse，把状态码和数据写进去</span></span><br><span class="line">    <span class="keyword">private</span> FullHttpResponse <span class="title function_">packet</span><span class="params">(HttpResponseStatus status, <span class="type">byte</span>[] data)</span>&#123;</span><br><span class="line">        <span class="type">FullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1, status);</span><br><span class="line">        response.content().writeBytes(data);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>在<code>channelRead</code>方法中使用该类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">FullHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> (FullHttpRequest) msg;</span><br><span class="line">    <span class="comment">//请求进来了直接走解析</span></span><br><span class="line">    <span class="type">PageResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> PageResolver.getInstance();</span><br><span class="line">    ctx.channel().writeAndFlush(resolver.resolveResource(request.uri()));</span><br><span class="line">    ctx.channel().close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="其他内置Handler"   >
          <a href="#其他内置Handler" class="heading-link"><i class="fas fa-link"></i></a><a href="#其他内置Handler" class="headerlink" title="其他内置Handler"></a>其他内置Handler</h1>
      <p>Netty内置了其他很有用的Handler，比如日志打印</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">HttpRequestDecoder</span>())</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(Integer.MAX_VALUE))</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))  </span><br><span class="line">    	<span class="comment">//添加一个日志Handler，在请求到来时会自动打印相关日志</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></div></figure>

<p>每次请求的内容和详细信息都会在日志中出现，包括详细的数据包解析过程，请求头信息都是完整地打印在控制台上的。</p>
<p>还可以使用Handler对IP地址进行过滤，比如我们不希望某些IP地址连接我们的服务器：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">HttpRequestDecoder</span>())</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(Integer.MAX_VALUE))</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">RuleBasedIpFilter</span>(<span class="keyword">new</span> <span class="title class_">IpFilterRule</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(InetSocketAddress inetSocketAddress)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> !inetSocketAddress.getHostName().equals(<span class="string">&quot;127.0.0.1&quot;</span>);  </span><br><span class="line">              	<span class="comment">//进行匹配，返回false表示匹配失败</span></span><br><span class="line">              	<span class="comment">//如果匹配失败，那么会根据下面的类型决定该干什么，</span></span><br><span class="line">                <span class="comment">//比如这里判断是不是本地访问的，如果是那就拒绝</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> IpFilterRuleType <span class="title function_">ruleType</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> IpFilterRuleType.REJECT;   </span><br><span class="line">                <span class="comment">//类型，REJECT表示拒绝连接，ACCEPT表示允许连接</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;))</span><br></pre></td></tr></table></div></figure>

<p><code>IdleStateHandler</code>可以对空闲的连接进行处理（idle–闲置的）</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>())</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>))  <span class="comment">//侦测连接空闲状态</span></span><br><span class="line">        <span class="comment">//第一个参数表示连接多少秒没有读操作时触发事件，第二个是写操作，</span></span><br><span class="line">    	<span class="comment">//第三个是读写操作都算，0表示禁用</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//事件需要在ChannelInboundHandlerAdapter中进行监听处理</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;收到客户端数据：&quot;</span>+msg);</span><br><span class="line">                ctx.channel().writeAndFlush(<span class="string">&quot;已收到！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="comment">//这个方法原来是在这个时候用的</span></span><br><span class="line">                <span class="keyword">if</span>(evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">                    <span class="type">IdleStateEvent</span> <span class="variable">event</span> <span class="operator">=</span> (IdleStateEvent) evt;</span><br><span class="line">                    <span class="keyword">if</span>(event.state() == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;长时间没有写操作&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(event.state() == IdleState.READER_IDLE) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;长时间没有读操作&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br></pre></td></tr></table></div></figure>




        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%20RPC%20%E5%AE%9E%E8%B7%B5-%E5%AE%8C/07%20%20%E6%8E%A5%E5%A4%B4%E6%9A%97%E8%AF%AD%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%20Netty%20%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE%E9%80%9A%E4%BF%A1%EF%BC%9F.md" >利用Netty实现自定义协议通信</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>
<p>语雀·青空の霞光：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javase/ibx6ug#37653588" >https://www.yuque.com/qingkongxiaguang/javase/ibx6ug#37653588</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/14/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty%E6%A1%86%E6%9E%B6(4)-%E7%BC%96%E7%A0%81%E5%99%A8%E4%B8%8E%E8%A7%A3%E7%A0%81%E5%99%A8/">Netty(4)--编码器与解码器</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-14</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h1>
      <p>编解码器分为两部分，解码器负责入站（可以理解为将字节流转为原来的格式）；编码器负责出站。</p>
<ul>
<li>解码器负责入站操作，需要实现<code>ChannelInboundHandler</code>接口，解码器本质上也是<code>ChannelInboundHandler</code>。</li>
<li>编码器负责出站操作，需要实现<code>ChannelOutboundhandler</code>接口，编码器本质上也是<code>ChannelOutboundHandler</code>。</li>
</ul>

        <h1 id="解码器"   >
          <a href="#解码器" class="heading-link"><i class="fas fa-link"></i></a><a href="#解码器" class="headerlink" title="解码器"></a>解码器</h1>
      <p>Netty提供了一些常用的<strong>解码器</strong>，他们都继承了<code>ByteToMessageDecoder</code>类 ：</p>
<ul>
<li><code>RedisDecoder</code>基于Redis协议的解码器。</li>
<li><code>XmlDecoder</code>基于XML格式的解码器。</li>
<li><code>JosnObjectDecoder</code>基于json数据格式的解码器</li>
<li><code>HttpObjectDecoder</code>:基于http协议的解码器</li>
</ul>
<p>Netty也提供了<code>MessageToMeMessageDecoder</code>，将一种格式转化为另一种格式的解码器。下面的类都继承了该抽象类。</p>
<ul>
<li><code>StringDecoder</code>将接收到<code>ByteBuf</code>转化字符串</li>
<li><code>ByteArrayDecoder</code>将接收到<code>ByteBuf</code>转化为字节数组</li>
<li><code>Base64Decoder</code>将由<code>ByteBuf</code>或<code>US-ASCII</code>字符串编码的Base64解码为<code>ByteBuf</code>。</li>
</ul>
<p>解码器本质就是<code>ChannelInboundHandler</code>接口，所以上面所有的类其实都是实现了该接口。</p>
<p>所以我们在流水线上就可以直接将解码器（编码器也是）当成<code>ChannelHandler</code>来使用</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">    channel.pipeline()</span><br><span class="line">            <span class="comment">//解码器本质上也算是一种ChannelInboundHandlerAdapter，用于处理入站请求</span></span><br><span class="line">            .addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>())  </span><br><span class="line">            .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span><br><span class="line">                    <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="comment">//经过StringDecoder转换后，msg直接就是一个字符串，所以打印就行了</span></span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>看一下<code>StringDecoder</code>类图</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/14/c48d5bdb8a78fd87.jpg"></p>
<p>要使用自定义的解码器，我们可以继承<code>MessageToMeMessage</code>类，重写<code>decode</code>方法即可。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDecoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageDecoder</span>&lt;ByteBuf&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, </span></span><br><span class="line"><span class="params">                          ByteBuf buf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据已收到，正在进行解码...&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> buf.toString(StandardCharsets.UTF_8);  <span class="comment">//直接转换为UTF8字符串</span></span><br><span class="line">        list.add(text);  </span><br><span class="line">        <span class="comment">//解码后需要将解析后的数据丢进List中，如果丢进去多个数据，</span></span><br><span class="line">        <span class="comment">//相当于数据被分成了多个，后面的Handler就需要每个都处理一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="编码器"   >
          <a href="#编码器" class="heading-link"><i class="fas fa-link"></i></a><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h1>
      <p>Netty提供了一些常用<strong>编码器</strong>类型，它们继承了<code>MessageToByteEncoder</code>类：</p>
<ul>
<li><code>ObjectEncoder</code>：对象（需要实现<code>Serializable</code>接口）编码成字节流。</li>
<li><code>SocketMessageEncoder</code>：将<code>SocketMessage</code>编码为字节流。</li>
<li><code>HAProxyMessageEncoder</code>：将<code>HAProxyMessage</code>编码成字节流。</li>
</ul>
<p>Netty也提供了<code>MessageToMessageEncoder</code>，将一种格式转化为另一种格式的编码器，下面类都是继承此类：</p>
<ul>
<li><code>RedisEncoder</code>：将Redis协议的对象进行编码。</li>
<li><code>StringEncoder</code>：将字符串进行编码操作。</li>
<li><code>Base64Encoder</code>：将Base64字符串进行编码操作。</li>
</ul>
<p>我们编写一下客户端的代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line"></span><br><span class="line">        bootstrap.group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        socketChannel.pipeline()</span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>()) <span class="comment">// 解码器</span></span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext channelHandlerContext,</span></span><br><span class="line"><span class="params">                                                            Object o)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                        System.out.println(<span class="string">&quot;&gt;&gt; 接收到客户端发送的数据：&quot;</span> + o);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;)</span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;localhost&quot;</span>,<span class="number">8888</span>).channel();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>(<span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;&lt;&lt; 请输入要发送给服务端的内容：&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line">                <span class="keyword">if</span>(text.isEmpty()) <span class="keyword">continue</span>;</span><br><span class="line">                channel.writeAndFlush(text);  <span class="comment">//直接发送字符串就行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端断开连接&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="编解码器"   >
          <a href="#编解码器" class="heading-link"><i class="fas fa-link"></i></a><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h1>
      <p>它是既继承了<code>ChannelInboundHandlerAdapter</code>也实现了<code>ChannelOutboundHandler</code>接口，又能处理出站也能处理入站请求，实际上就是将之前的给组合到一起了，比如我们也可以实现一个缝合在一起的<code>StringCodec</code>类：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要指定两个泛型，第一个是入站的消息类型，一个是出站的消息类型，出站是String类型，我们要转成ByteBuf</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringCodec</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageCodec</span>&lt;ByteBuf, String&gt; &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, String buf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在处理出站数据...&quot;</span>);</span><br><span class="line">        list.add(Unpooled.wrappedBuffer(buf.getBytes()));   <span class="comment">//同样的，添加的数量就是出站的消息数量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf buf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在处理入站数据...&quot;</span>);</span><br><span class="line">        list.add(buf.toString(StandardCharsets.UTF_8));  <span class="comment">//和之前一样，直接一行解决</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="常用的解码器"   >
          <a href="#常用的解码器" class="heading-link"><i class="fas fa-link"></i></a><a href="#常用的解码器" class="headerlink" title="常用的解码器"></a>常用的解码器</h1>
      
        <h2 id="FixedLengthFrameDecoder"   >
          <a href="#FixedLengthFrameDecoder" class="heading-link"><i class="fas fa-link"></i></a><a href="#FixedLengthFrameDecoder" class="headerlink" title="FixedLengthFrameDecoder"></a>FixedLengthFrameDecoder</h2>
      <p>固定长度解码器：通过构造函数设置固定长度的大小<code>frameLength</code>，无论接收方依次获取多大的数据，都会严格按照该大小进行解码，如果积累读取到长度大小<code>frameLength</code>的消息，解码器才会处理。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有效解决粘包拆包问题</span></span><br><span class="line">channel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">FixedLengthFrameDecoder</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></div></figure>




        <h2 id="DelimiterBasedFrameDecoder"   >
          <a href="#DelimiterBasedFrameDecoder" class="heading-link"><i class="fas fa-link"></i></a><a href="#DelimiterBasedFrameDecoder" class="headerlink" title="DelimiterBasedFrameDecoder"></a>DelimiterBasedFrameDecoder</h2>
      <p>特殊分隔符解码器，其重要属性：</p>
<ul>
<li><code>delimiters</code>：指定特殊分隔符，通过写入<code>ByteBuf</code>作为参数传入。<code>delimiters</code>的类型是<code>ByteBuf</code>数组，所以可以同时指定多个分隔符。</li>
<li><code>maxLength</code>：报文最大长度限制，如果超过该长度还没有检测到分隔符，就会抛出<code>TooLongFrameException</code>异常，是对程序在极端情况下的一种保护。</li>
<li><code>failFast</code>：设置<code>failFast</code>可以控制抛出<code>TooLongFrameException</code>的时机。如果<code>failFast = true</code>，就会在超过<code>maxLength</code>立即抛出。反之，就会等到解码出一个完整的消息才会抛出异常。</li>
<li><code>StripDelimiter</code>：是判断解码后得到的消息是否去除分隔符</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">DelimiterBasedFrameDecoder</span>(<span class="number">1024</span>, Unpooled.wrappedBuffer(<span class="string">&quot;!&quot;</span>.getBytes())))</span><br><span class="line">        <span class="comment">// 指定一个特定的分隔符，比如我们这里以感叹号为分隔符</span></span><br><span class="line">  		<span class="comment">// 在收到分隔符之前的所有数据，都作为同一个数据包的内容</span></span><br></pre></td></tr></table></div></figure>

<p>也可以这么写</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">delimiter</span> <span class="operator">=</span> Unpooled.copiedBuffer(<span class="string">&quot;&amp;&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">DelimiterBasedFrameDecoder</span>(<span class="number">10</span>, <span class="literal">true</span>, <span class="literal">true</span>, delimiter);</span><br></pre></td></tr></table></div></figure>




        <h2 id="LengthFieldBasedFrameDecoder"   >
          <a href="#LengthFieldBasedFrameDecoder" class="heading-link"><i class="fas fa-link"></i></a><a href="#LengthFieldBasedFrameDecoder" class="headerlink" title="LengthFieldBasedFrameDecoder"></a>LengthFieldBasedFrameDecoder</h2>
      <p>长度域解码器：解决TCP拆包&#x2F;粘包问题最常用的解码器、基本可以覆盖大部分基于长度拆包场景。</p>
<p>属性：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 长度字段的偏移量，也就是存放长度数据的起始位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> lengthFieldOffset; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 长度字段所占用的字节数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> lengthFieldLength; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 消息长度的修正值</span></span><br><span class="line"><span class="comment">   在很多较为复杂一些的协议设计中，长度域不仅仅包含消息的长度，而且包含其他的数据，</span></span><br><span class="line"><span class="comment">   如版本号、数据类型、数据状态等，那么这时候我们需要使用 lengthAdjustment 进行修正</span></span><br><span class="line"><span class="comment">   lengthAdjustment = 包体的长度值 - 长度域的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> lengthAdjustment; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码后需要跳过的初始字节数，也就是消息内容字段的起始位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> initialBytesToStrip;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 长度字段结束的偏移量，</span></span><br><span class="line"><span class="comment">// lengthFieldEndOffset = lengthFieldOffset + lengthFieldLength</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> lengthFieldEndOffset;</span><br></pre></td></tr></table></div></figure>

<p>也有一些和上面两个解码器相似的属性。</p>
<p>其实，如果对计算机网络的TCP协议和报文段传输比较熟悉，就知道该解码器的工作机制</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/14/f3327f194dd6c465.jpg"></p>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p>语雀·青空の霞光：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javase/ibx6ug#91071a42" >https://www.yuque.com/qingkongxiaguang/javase/ibx6ug#91071a42</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>51CTO：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.51cto.com/article/636349.html" >https://www.51cto.com/article/636349.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%20RPC%20%E5%AE%9E%E8%B7%B5-%E5%AE%8C/07%20%20%E6%8E%A5%E5%A4%B4%E6%9A%97%E8%AF%AD%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%20Netty%20%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE%E9%80%9A%E4%BF%A1%EF%BC%9F.md" >技术文章摘抄</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%20RPC%20%E5%AE%9E%E8%B7%B5-%E5%AE%8C/08%20%20%E5%BC%80%E7%AE%B1%E5%8D%B3%E7%94%A8%EF%BC%9ANetty%20%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E8%A7%A3%E7%A0%81%E5%99%A8%EF%BC%9F.md" >开箱即用：Netty 支持哪些常用的解码器？</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/13/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty%E6%A1%86%E6%9E%B6(3)-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">Netty框架(3)--任务调度</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-13</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="EventLoop"   >
          <a href="#EventLoop" class="heading-link"><i class="fas fa-link"></i></a><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h1>
      <p>我们在上一章节的例子中，首先创建bossGroup和workerGroup两个<code>EventLoopGroup</code>：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为博客显示问题，我这里写成两行</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br></pre></td></tr></table></div></figure>

<p>我们之前也提到，这两个类似于主从Reactor。之前在编写NIO代码时，就是用了<code>while</code>循环，不断使用<code>selector</code>监听新的事件，EventLoop也是这种思想，本质是事件等待&#x2F;处理线程。</p>
<p>但是这与NIO又有不同：</p>
<ul>
<li><code>EvetnLoopGroup</code>包含多个<code>EventLoop</code>。</li>
<li>一个<code>EventLoop</code>绑定一个线程，只有第一次执行时才会通过<code>ThreadFactory</code>创建线程</li>
<li>一个<code>Channel</code>只会绑定一个<code>EventLoop</code>，绑定后不会修改。但是一个<code>EventLoop</code>可以被多个<code>Channel</code>绑定（多对一的关系）</li>
</ul>
<p>先看一下示意图：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/13/f46a4aa6c8e4214a.jpg"></p>
<p>我们之前写的代码，多个<code>Channel</code>注册到同一个EventLoop中，本身没有什么问题。但是我们将数据的读写和数据的处理（其他操作）放在了一起，如果某一个<code>Channel</code>的数据处理阻塞了，就会导致其他<code>Channel</code>也阻塞。<strong>所以使用Netty进行程序开发时，我们需要对ChannelHandler的实现逻辑有充分的风险意识</strong>。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">    channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到客户端发送的数据：&quot;</span>+</span><br><span class="line">                                   buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                <span class="comment">//这里我们直接卡10秒假装在处理任务</span></span><br><span class="line">                <span class="comment">//就会导致阻塞，其他Channel不能处理</span></span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);   </span><br><span class="line">                ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>在IO多路复用详解就说过，Reactor模型是事件驱动，在完成读写请求时不会阻塞，因为只有客户端真的发送了读写请求，服务端才会进行读写操作。所以会出现阻塞的只有数据处理那一部分。</p>
</blockquote>
<p>我们回忆一下多线程Reactor模型中，Handler负责处理读写，其他任务（解码，编码等）都交给线程池处理</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        channel.read(buffer);</span><br><span class="line">        buffer.flip();</span><br><span class="line">        POOL.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到客户端数据：&quot;</span>+</span><br><span class="line">                                   <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, </span><br><span class="line">                                              buffer.remaining()));</span><br><span class="line">                channel.write(ByteBuffer.wrap(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Netty处理这种情况，可以再创建一个<code>EventLoopGroup</code>来专门处理阻塞事件</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">handlerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">    handlerGroup.submit(() -&gt; &#123;   </span><br><span class="line">        <span class="comment">//由于继承自ScheduledExecutorService，直接提交任务</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>当然也可以写成流水线，一个ChannelHandler处理读写事件，然后将任务传给下一个ChannelHandler，处理阻塞时间</p>
</blockquote>
<p>最后顺便给出客户端代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 客户端也通过Bootstrap启动</span></span><br><span class="line">    <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">    <span class="comment">// 客户端只需要一个EventLoop即可</span></span><br><span class="line">    bootstrap.group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    		 .channel(NioSocketChannel.class)</span><br><span class="line">        	 .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                     channel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelHandlerContextAdapter</span>() &#123;</span><br><span class="line">                         <span class="meta">@Override</span></span><br><span class="line">                         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ChannelRead</span><span class="params">(ChannelHandlerContext ctx,Object msg)</span> thorws Exception &#123;</span><br><span class="line">                             <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (Byte) msg;</span><br><span class="line">                             System.out.println(<span class="string">&quot;&gt;&gt; 接收到客户端发送数据：&quot;</span> + </span><br><span class="line">                                               buf,toString(StandardCharsets.UTF_8));</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;localhost&quot;</span>,<span class="number">8888</span>).channel();</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in)) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;&lt;&lt; 请输入要发送给服务端的内容&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line">            <span class="keyword">if</span>(text,isEmpty()) <span class="keyword">continue</span>;</span><br><span class="line">            channel.writeAndFlush(unPooled.wrappedBuffer(text.getBuffer()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="异步获得结果"   >
          <a href="#异步获得结果" class="heading-link"><i class="fas fa-link"></i></a><a href="#异步获得结果" class="headerlink" title="异步获得结果"></a>异步获得结果</h1>
      
        <h2 id="ChannelFuture"   >
          <a href="#ChannelFuture" class="heading-link"><i class="fas fa-link"></i></a><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h2>
      <p>Netty中的Channel相关操作都是异步进行的，并不是在当前线程同步执行，我们不能立即得到执行结果。所以想要得到结果就需要使用Future</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先看一下使用</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buff</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到客户端发送的数据：&quot;</span> + </span><br><span class="line">                      buff.toString(StandardCharsets.UTF_8));</span><br><span class="line">    </span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> ctx.writeAndFlush(Unpool.wrappedBuffer(<span class="string">&quot;已收到&quot;</span>.getBytes()));</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;任务完成状态：&quot;</span> + funture.isDone());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p><code>ChannelFuture</code>继承<code>Netty</code>自定义的<code>Future</code>，但是这个自定义的<code>Future</code>接口也是继承了<code>j.u.c</code>里面的<code>Future</code>接口。而我们也是主要讲解<code>ChannelFuture</code>。</p>
</blockquote>
<p>包括服务端启动也是返回的<code>ChannelFuture</code>：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.bind(<span class="number">8888</span>);</span><br><span class="line">System.out.println(future.isDone());<span class="comment">// false</span></span><br></pre></td></tr></table></div></figure>

<p>服务端启动比较慢，所以一开始直接获取<code>isDone</code>的结果会返回<code>false</code>。如果需要当服务端启动后我们才能进行下一步操作，相当于把异步恢复成同步，有两种方案</p>
<ul>
<li>方案一：使用<code>sync</code>方法</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.bind(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">future.sync();<span class="comment">// 让线程同步等待任务返回</span></span><br><span class="line"></span><br><span class="line">System.out.println(future.isDone());<span class="comment">// false</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>方案二：设置监听器</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.bind(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接添加监听器，当任务完成时自动执行，但是注意执行也是异步的，不是在当前线程</span></span><br><span class="line">future.addListener((ChannelFutureListener) channelFuture -&gt; </span><br><span class="line">                   System.out.println(<span class="string">&quot;我是服务端启动完成之后要做的事情！&quot;</span>));</span><br></pre></td></tr></table></div></figure>

<p><code>ChannelFuture</code>中定义了监听方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChannelFuture</span> <span class="keyword">extends</span> <span class="title class_">Future</span>&lt;Void&gt; &#123;</span><br><span class="line">    Channel <span class="title function_">channel</span><span class="params">()</span>;    <span class="comment">//我们可以直接获取此任务的Channel</span></span><br><span class="line">    ChannelFuture <span class="title function_">addListener</span><span class="params">(GenericFutureListener&lt;? extends </span></span><br><span class="line"><span class="params">                              Future&lt;? <span class="built_in">super</span> Void&gt;&gt; var1)</span>;  </span><br><span class="line">    <span class="comment">//当任务完成时，会直接执行GenericFutureListener的任务，注意执行的位置也是在EventLoop中</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isVoid</span><span class="params">()</span>;   <span class="comment">//返回类型是否为void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p><code>GenericFutureListener</code>是一个函数接口，只有一个<code>operationComplete</code>方法，可以使用Lambda表达式。而且，执行任务的线程在完成任务后就会执行事件监听里的任务（而不是在定义事件监听的线程中执行）。</p>
</blockquote>

        <h2 id="Promise"   >
          <a href="#Promise" class="heading-link"><i class="fas fa-link"></i></a><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2>
      <p>该接口支持手动设定成功和失败的结果：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此接口也是继承自Netty中的Future接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Promise</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">setSuccess</span><span class="params">(V var1)</span>;    <span class="comment">//手动设定成功</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">trySuccess</span><span class="params">(V var1)</span>;</span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">setFailure</span><span class="params">(Throwable var1)</span>;  <span class="comment">//手动设定失败</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryFailure</span><span class="params">(Throwable var1)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">setUncancellable</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//这些就和之前的Future是一样的了</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">addListener</span><span class="params">(GenericFutureListener&lt;? extends </span></span><br><span class="line"><span class="params">                           Future&lt;? <span class="built_in">super</span> V&gt;&gt; var1)</span>;</span><br><span class="line">    </span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">addListeners</span><span class="params">(GenericFutureListener&lt;? extends </span></span><br><span class="line"><span class="params">                            Future&lt;? <span class="built_in">super</span> V&gt;&gt;... var1)</span>;</span><br><span class="line">    </span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">removeListener</span><span class="params">(GenericFutureListener&lt;? extends </span></span><br><span class="line"><span class="params">                              Future&lt;? <span class="built_in">super</span> V&gt;&gt; var1)</span>;</span><br><span class="line">    </span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">removeListeners</span><span class="params">(GenericFutureListener&lt;? extends </span></span><br><span class="line"><span class="params">                               Future&lt;? <span class="built_in">super</span> V&gt;&gt;... var1)</span>;</span><br><span class="line">    </span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">syncUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>该接口也是可以获取异步执行结果情况</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> buf.toString(StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到客户端发送的数据：&quot;</span>+text);</span><br><span class="line">        </span><br><span class="line">        <span class="type">ChannelPromise</span> <span class="variable">promise</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultChannelPromise</span>(channel);</span><br><span class="line">        System.out.println(promise.isSuccess());</span><br><span class="line">        ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()), promise);</span><br><span class="line">        </span><br><span class="line">        promise.sync();  <span class="comment">//同步等待一下</span></span><br><span class="line">        System.out.println(promise.isSuccess());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></div></figure>




        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p>Netty源码之EventLoopGroup：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.zhiyi.zone/netty/EventLoopGroup.html#multithreadeventloopgroup" >https://www.zhiyi.zone/netty/EventLoopGroup.html#multithreadeventloopgroup</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>语雀·青空の霞光：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javase/ibx6ug#b7dc6f87" >https://www.yuque.com/qingkongxiaguang/javase/ibx6ug#b7dc6f87</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%20RPC%20%E5%AE%9E%E8%B7%B5-%E5%AE%8C/04%20%E4%BA%8B%E4%BB%B6%E8%B0%83%E5%BA%A6%E5%B1%82%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%20EventLoop%20%E6%98%AF%20Netty%20%E7%9A%84%E7%B2%BE%E9%AB%93%EF%BC%9F.md" >技术文章摘抄</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/12/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty%E6%A1%86%E6%9E%B6(2)-%E7%9B%B8%E5%85%B3%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/">Netty框架(2)--Channel通道</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-13</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="Netty基础代码"   >
          <a href="#Netty基础代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#Netty基础代码" class="headerlink" title="Netty基础代码"></a>Netty基础代码</h1>
      <p>我们先来看一下Netty搭建服务端和客户端一个简单的例子</p>
<p>服务端：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//使用NioEventLoopGroup实现类，创建BossGroup和WorkerGroup</span></span><br><span class="line">    <span class="comment">/** 其他的还有EpollEventLoopGroup，但是仅支持Linux，这是Netty基于Linux底层</span></span><br><span class="line"><span class="comment">    	Epoll单独编写的一套本地实现，没有使用NIO那套*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(), workerGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建服务端启动引导类</span></span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">    <span class="comment">//可链式</span></span><br><span class="line">    bootstrap</span><br><span class="line">            .group(bossGroup, workerGroup)   <span class="comment">//指定事件循环组</span></span><br><span class="line">            .channel(NioServerSocketChannel.class)   <span class="comment">//指定为NIO的ServerSocketChannel</span></span><br><span class="line">            .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;   </span><br><span class="line">                <span class="comment">//SocketChannel不是NIO里面的，是Netty的</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">                    channel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;   </span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                            <span class="comment">//ctx是上下文，msg是收到的消息，默认以ByteBuf形式（也可以是其他形式，后面再说）</span></span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;   <span class="comment">//类型转换一下</span></span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + </span><br><span class="line">                                               <span class="string">&quot; &gt;&gt; 接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                            <span class="comment">//通过上下文可以直接发送数据回去，注意要writeAndFlush才能让客户端立即收到</span></span><br><span class="line">                            ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="comment">//最后绑定端口，启动</span></span><br><span class="line">    bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>客户端：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">         <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已连接到服务端！&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入要发送给服务端的内容：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            <span class="keyword">if</span>(text.isEmpty()) <span class="keyword">continue</span>;</span><br><span class="line">            channel.write(ByteBuffer.wrap(text.getBytes()));</span><br><span class="line">            System.out.println(<span class="string">&quot;已发送！&quot;</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">            channel.read(buffer);   <span class="comment">//直接从通道中读取数据</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            System.out.println(<span class="string">&quot;收到服务器返回：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>服务端很多陌生的类，这就是我们之后要讲解的，客户端的代码应该很熟悉了。</p>
<p>服务端前两行代码，一个是创建bossGroup和workerGroup，另一个是创建服务端启动引导类ServerBootstrap。（bootstrap翻译为引导程序）。</p>
<blockquote>
<p>看后面的链式代码就知道，我们通过ServerBootstrap配置相关信息。比如设置group，channel，handler等。</p>
</blockquote>

        <h1 id="Channel通道"   >
          <a href="#Channel通道" class="heading-link"><i class="fas fa-link"></i></a><a href="#Channel通道" class="headerlink" title="Channel通道"></a>Channel通道</h1>
      <p>Netty的Channel没有直接使用NIO的Channel，通道支持IO操作，但是所有的IO操作都是<strong>异步</strong>的（Netty）。意味着任何IO调用都将立即返回，但不能保证请求的IO操作在调用时已经完成。它会返回一个ChannelFuture实例（在JUC里面我们就将结果关于这种异步获取结果的FutureTask类），该实例将在请求的IO操作成功，失败或取消时通知你。</p>
<p>关于<code>Channel</code>，在Netty中，还有<code>ChannelHandler</code>和<code>ChannelPipeline</code>两个组件。</p>
<ul>
<li>ChannelHandler负责Channel的逻辑处理，其实就是Reactor里面的Handler。</li>
<li>ChannelPipeline负责管理ChannelHandler，他是一个流水线容器，存储结构为双向链表。</li>
<li>从上面的代码可以看出，通过链式代码，我们不断将<code>ChannelInboundHandlerAdapter</code>（实现了ChannelHandler）加入到Pipe中</li>
</ul>
<blockquote>
<p>一个<code>Channel</code>包含一个<code>ChannelPipeline</code>，所有<code>ChannelHandler</code>都会顺序加入到<code>ChannelPipeline</code>中，创建<code>Channel</code>时会自动创建一个<code>ChannelPipeline</code>；每个<code>Channel</code>都会有一个<code>ChannelPipeline</code>，这个关联关系是永久性的。</p>
</blockquote>
<p>关系图如下：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/12/750be0a66f935589.jpg"></p>
<blockquote>
<p>其实<code>ChannelPipeline</code>维护的是由<code>ChannelHandlerContext</code>组成的双向链表，只是每一个<code>ChannelHandlerContext</code>又关联着一个<code>ChannelHandler</code>。</p>
</blockquote>
<p>我们现在来看一下源码</p>
<p><code>Channel</code>源码，里面方法比较多，这里我们只看几个重要的</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Channel</span> <span class="keyword">extends</span> <span class="title class_">AttributeMap</span>, ChannelOutboundInvoker, Comparable&lt;Channel&gt; &#123;</span><br><span class="line">    ChannelId <span class="title function_">id</span><span class="params">()</span>;   <span class="comment">//通道ID</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取此通道所属的EventLoop，因为一个Channel在它的</span></span><br><span class="line">    <span class="comment">// 生命周期内只能注册到一个EventLoop中</span></span><br><span class="line">    EventLoop <span class="title function_">eventLoop</span><span class="params">()</span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Channel是具有层级关系的，这里是返回父Channel</span></span><br><span class="line">    Channel <span class="title function_">parent</span><span class="params">()</span>;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//通道当前的相关状态</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isOpen</span><span class="params">()</span>;   </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRegistered</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isActive</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭通道，但是会用到ChannelFuture</span></span><br><span class="line">    ChannelFuture <span class="title function_">closeFuture</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//流水线,例子中我们就是通过pipeline拿到管道，</span></span><br><span class="line">    <span class="comment">//然后加入ChannelHandler</span></span><br><span class="line">    ChannelPipeline <span class="title function_">pipeline</span><span class="params">()</span>;   </span><br><span class="line">    </span><br><span class="line">     <span class="comment">//可以直接从Channel拿到ByteBufAllocator的实例，来分配ByteBuf</span></span><br><span class="line">    ByteBufAllocator <span class="title function_">alloc</span><span class="params">()</span>;  </span><br><span class="line">    Channel <span class="title function_">read</span><span class="params">()</span>;</span><br><span class="line">    Channel <span class="title function_">flush</span><span class="params">()</span>;   <span class="comment">//刷新，基操</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>其中<code>pipeline()</code>方法在例子中使用到了，我们再来看一下<code>ChannelHandler</code>。该接口定义了一些负责完成具体请求的方法，例子中使用到的<code>ChannelInboundHandlerAdapter</code>抽象类是<code>ChannelInboundHandler</code>的接口实现，用于处理入站数据（Inbound表示入站，Outbound表示出站），抽象类重写对应方法进行请求处理，这些方法会在合适的时间被调用。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;  </span><br><span class="line">      	<span class="comment">//ctx是上下文，msg是收到的消息，以ByteBuf形式</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;   <span class="comment">//类型转换一下</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()</span><br><span class="line">                           +<span class="string">&quot; &gt;&gt; 接收到客户端发送的数据：&quot;</span></span><br><span class="line">                           +buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过上下文可以直接发送数据回去，注意要writeAndFlush才能让客户端立即收到</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></div></figure>

<p>我们先看顶层接口<code>ChannelHandler</code>：只有一些流水线相关的回调方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChannelHandler</span> &#123;</span><br><span class="line">  	<span class="comment">//当ChannelHandler被添加到流水线中时调用</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handlerAdded</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">	<span class="comment">//当ChannelHandler从流水线中移除时调用</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handlerRemoved</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 还有一个过时方法，不管</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>看下一级接口<code>ChannelInboundHandler</code>：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ChannelInboundHandler用于处理入站相关事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChannelInboundHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelHandler</span> &#123;</span><br><span class="line">  	<span class="comment">/**当Channel已经注册到自己的EventLoop上时调用，前面我们说了，</span></span><br><span class="line"><span class="comment">    一个Channel只会注册到一个EventLoop上，注册到EventLoop后，</span></span><br><span class="line"><span class="comment">    这样才会在发生对应事件时被通知。*/</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">channelRegistered</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//从EventLoop上取消注册时</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">channelUnregistered</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">	<span class="comment">//当Channel已经处于活跃状态时被调用，此时Channel已经连接/绑定，并且已经就绪</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">	<span class="comment">//跟上面相反，不再活跃了，并且不在连接它的远程节点</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//当从Channel读取数据时被调用，可以看到数据被自动包装成了一个Object（默认是ByteBuf）</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext var1, Object var2)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//上一个读取操作完成后调用</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">	<span class="comment">//暂时不介绍</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext var1, Object var2)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">	<span class="comment">//当Channel的可写状态发生改变时被调用</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//出现异常时被调用</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext var1, Throwable var2)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>现在我们就可以看到，<code>ChannelInboundHandler</code>负责处理请求，是事件驱动的。上面用到的<code>ChannelInboundHandlerAdapter</code>实际上就是对这些方法实现的抽象类，相比直接用接口，我们可以只重写我们需要的方法，没有重写的方法会默认向流水线下一个<code>ChannelHandler</code>发送。</p>
<blockquote>
<p>与之对应的还有<code>ChannelOutboundHandler</code>，用于处理出站相关操作，此处不再讲解</p>
</blockquote>
<p>最后我们看一下<code>ChannelPipeline</code>，这个双向链表容器保存著<code>ChannelHandler</code>，里面的<code>ChannelHandler</code>顺序存储，从客户端发送过来的请求，入站会依次经过<code>ChannelHandler</code>，直到它被某一个<code>handler</code>完成请求，然后出站时会经过处理出站的<code>ChannelHandler</code>。</p>
<p>比如我们希望创建两个入站的<code>ChannelHandler</code>，一个用于接收请求并处理，一个用于处理当前接收请求过程中出现的异常。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">    	channel.pipeline()</span><br><span class="line">            .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                    System.out.println(<span class="string">&quot;接收到客户端发送数据：&quot;</span>+</span><br><span class="line">                                       buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                    <span class="comment">// 此处故意人为抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;我是异常&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx,Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;处理异常：&quot;</span> + cause);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>如果我们不在<code>ChannelHandler</code>重写对应方法，他就会默认传播到流水线下一个<code>ChannelHandler</code>。也有人为传递</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx,Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//通过ChannelHandlerContext来向下传递，ChannelHandlerContext</span></span><br><span class="line">    <span class="comment">//是在Handler添加进Pipeline中时就被自动创建的</span></span><br><span class="line">    ctx.fireExceptionCaught(cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>关于通道，最后我们看一下出站的<code>ChannelHandler</code>相关的机制</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">    channel.pipeline()   <span class="comment">//直接获取pipeline，然后添加两个Handler</span></span><br><span class="line">            .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                    System.out.println(<span class="string">&quot;1接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                    ctx.fireChannelRead(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                    System.out.println(<span class="string">&quot;2接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                    ctx.channel().writeAndFlush(<span class="string">&quot;伞兵一号卢本伟&quot;</span>);  <span class="comment">//这里我们使用channel的write</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .addLast(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;1号出站：&quot;</span>+msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .addLast(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;2号出站：&quot;</span>+msg);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//继续write给其他的出站Handler，不然到这里就断了</span></span><br><span class="line">                    ctx.write(msg);  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>重点就是按照顺序存储，但是第一个<code>ChannelOutbindHandlerAdapter</code>并没有<code>write</code>方法。这是因为当我们入站的<code>ChannelHandler</code>完成操作后（比如写请求，就需要有一个<code>ChannelHandler</code>调用<code>write</code>方法），就会从当前位置倒着找<code>ChannelOutbindHandler</code>，找到第一个，再调用。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/13/b7dc75cd969eca8c.jpg"></p>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p>知一码园：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.zhiyi.zone/netty/Channel.html" >https://www.zhiyi.zone/netty/Channel.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>Netty Channel组件作用：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.programminghunter.com/article/12712042451/" >https://www.programminghunter.com/article/12712042451/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>语雀·青空の霞光：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javase/ibx6ug#f443a934" >https://www.yuque.com/qingkongxiaguang/javase/ibx6ug#f443a934</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/09/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty%E6%A1%86%E6%9E%B6(1)-Netty%E5%9F%BA%E7%A1%80/">Netty框架(1)--Netty基础</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-13</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="NIO存在的问题"   >
          <a href="#NIO存在的问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#NIO存在的问题" class="headerlink" title="NIO存在的问题"></a>NIO存在的问题</h1>
      <p>之前我们写的代码，当客户端断开连接时（客户端运行结束），就会报错</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/09/90e8cc353264d4bf.jpg" alt="NIO存在的问题"></p>
<p>当我们的客户端主动与服务端断开连接时，会导致READ事件一直被触发，也就是说<code>selector.select()</code>会直接通过，并且是可读的状态，但是我们发现实际上读到是数据是一个空的（上面的图中在空轮询两次后抛出异常了，也有可能是无限的循环下去）所以这里我们得稍微处理一下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable()) &#123;</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">    <span class="comment">//这里我们需要判断一下，如果read操作得到的结果是-1，那么说明服务端已经断开连接了</span></span><br><span class="line">    <span class="keyword">if</span>(channel.read(buffer) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端已经断开连接了：&quot;</span>+channel.getRemoteAddress());</span><br><span class="line">        channel.close();   <span class="comment">//直接关闭此通道</span></span><br><span class="line">        <span class="keyword">continue</span>;   <span class="comment">//继续进行选择</span></span><br><span class="line">    &#125;</span><br><span class="line">    buffer.flip();</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到客户端数据：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">    channel.write(ByteBuffer.wrap(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>但是这里的弊端也很明显，断开的客户端连接会一直进行空轮询。</p>
<p>还有一个问题</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();  </span><br><span class="line">    <span class="comment">//由于底层epoll机制的问题，导致select方法可能会一直返回0，造成无限循环的情况。</span></span><br><span class="line">    System.out.println(<span class="string">&quot;监听到 &quot;</span>+count+<span class="string">&quot; 个事件&quot;</span>);</span><br><span class="line">    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br></pre></td></tr></table></div></figure>

<p>这个BUG也是由客户端主动断开连接导致的。</p>
<blockquote>
<p>这是JDK官方的BUG反馈</p>
<ol>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6670302" >JDK-6670302 : (se) NIO selector wakes up with 0 selected keys infinitely</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6403933" >JDK-6403933 : (se) Selector doesn’t block on Selector.select(timeout) (lnx)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
</ol>
</blockquote>
<p>JDK NIO API描述的Selector的selector方法会一直阻塞，直到IO事件到达或者超时，但是Linux平台上有时会出现问题，某些场景下select方法会直接返回，即使没有超时并且也没有IO事件到达。它会导致线程陷入死循环，让CPU上升到100%。直到现在JDK都没有完全解决该问题。</p>

        <h1 id="Netty框架"   >
          <a href="#Netty框架" class="heading-link"><i class="fas fa-link"></i></a><a href="#Netty框架" class="headerlink" title="Netty框架"></a>Netty框架</h1>
      <p>该框架API简单，开发门槛低；功能强大，内置多种编码解码功能。Java版本的Minecraft服务器就是使用Netty框架作为网络通信的基础</p>
<p>先导包</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.76.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h2 id="ByteBuf"   >
          <a href="#ByteBuf" class="heading-link"><i class="fas fa-link"></i></a><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h2>
      <p>Netty使用的缓冲区不是ByteBuffer，而是自定义的ByteBuf类其特点是：</p>
<ul>
<li><p>写操作完成后无需进行<code>flip()</code>翻转。</p>
</li>
<li><p>具有比ByteBuffer更快的响应速度。</p>
</li>
<li><p>动态扩容。</p>
</li>
</ul>
<p>内部数组实际的读取是两个指针在维护（读指针和写指针），进行读写操作，相应的指针就会移动，但是读指针不能超过写指针。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//创建初始容量为10的ByteBuf缓冲区，Unpooled是用于快速生成ByteBuf的工具类</span></span><br><span class="line">    <span class="comment">//Unpooled是池化的意思，ByteBuf有池化和非池化两种，区别在于对内存的复用</span></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;初始状态：&quot;</span>+Arrays.toString(buf.array()));</span><br><span class="line">    </span><br><span class="line">    buf.writeInt(-<span class="number">888888888</span>);   <span class="comment">//写入一个Int数据</span></span><br><span class="line">    System.out.println(<span class="string">&quot;写入Int后：&quot;</span>+Arrays.toString(buf.array()));</span><br><span class="line">    </span><br><span class="line">    buf.readShort();   <span class="comment">//无需翻转，直接读取一个short数据出来</span></span><br><span class="line">    System.out.println(<span class="string">&quot;读取Short后：&quot;</span>+Arrays.toString(buf.array()));</span><br><span class="line">    <span class="comment">//丢弃操作，会将当前的可读部分内容丢到最前面，并且读写指针向前移动丢弃的距离</span></span><br><span class="line">    buf.discardReadBytes();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;丢弃之后：&quot;</span>+Arrays.toString(buf.array()));</span><br><span class="line">    buf.clear();    <span class="comment">//清空操作，清空之后读写指针都归零</span></span><br><span class="line">    System.out.println(<span class="string">&quot;清空之后：&quot;</span>+Arrays.toString(buf.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>ByteBuf支持动态扩容，每次扩容都会x2，如果不希望扩容，可以在生成ByteBuf时指定maxCapacity</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// maxCapacity = 30</span></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.buffer(<span class="number">10</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></div></figure>

<p><strong>缓冲区的实现模式分为：堆缓冲区模式（数组实现），直接缓冲区模式（申请堆外内存），符合缓冲区模式。</strong> </p>
<p>想要创建直接缓冲区，直接调用</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.directBuffer(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拿不到数组，因为底层不是数组实现</span></span><br><span class="line">    System.out.println(Arrays.toString(buf.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>复合模式可以拼凑组合其他缓冲区，如果希望对两个缓冲区内容进行操作，不需要再单独创建一个新的缓冲区，而是直接将其进行拼接。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个复合缓冲区</span></span><br><span class="line"><span class="type">CompositeByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.compositeBuffer();</span><br><span class="line">buf.addComponent(Unpooled.copiedBuffer(<span class="string">&quot;abc&quot;</span>.getBytes()));</span><br><span class="line">buf.addComponent(Unpooled.copiedBuffer(<span class="string">&quot;def&quot;</span>.getBytes()));</span><br></pre></td></tr></table></div></figure>

<p>关于缓冲区，最后看一下Unpooled工具类是如何创建buffer的。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Unpooled</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteBufAllocator ALLOC;  <span class="comment">//内部是有一个ByteBufAllocator对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteOrder BIG_ENDIAN;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteOrder LITTLE_ENDIAN;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteBuf EMPTY_BUFFER;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title function_">buffer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ALLOC.heapBuffer();   <span class="comment">//缓冲区的创建操作是依靠ByteBufAllocator来进行的</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	...</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">static</span> &#123;   <span class="comment">//ALLOC在静态代码块中进行指定，实际上真正的实现类是UnpooledByteBufAllocator</span></span><br><span class="line">        ALLOC = UnpooledByteBufAllocator.DEFAULT;</span><br><span class="line">        BIG_ENDIAN = ByteOrder.BIG_ENDIAN;</span><br><span class="line">        LITTLE_ENDIAN = ByteOrder.LITTLE_ENDIAN;</span><br><span class="line">        EMPTY_BUFFER = ALLOC.buffer(<span class="number">0</span>, <span class="number">0</span>);   <span class="comment">//空缓冲区容量和最大容量都是0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> EMPTY_BUFFER <span class="keyword">instanceof</span> EmptyByteBuf : <span class="string">&quot;EMPTY_BUFFER must be an EmptyByteBuf.&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>ByteBufAllocator负责分配缓冲区，有两个具体的实现类：<code>UnpooledByteBufAllocator</code>和<code>PooledByteBufAllocator</code>。一个是非池化缓冲区生成器，另一个是池化缓冲区生成器。</p>
<blockquote>
<p>池化是将缓冲区通过设置内存池进行内存块复用，避免频繁的内存申请。尤其是在使用堆外内存时，避免多次重复通过底层malloc()函数系统调用申请内存造成的性能损失。</p>
</blockquote>

        <h2 id="零拷贝简介"   >
          <a href="#零拷贝简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#零拷贝简介" class="headerlink" title="零拷贝简介"></a>零拷贝简介</h2>
      <blockquote>
<p>此处对零拷贝做简单的讲解</p>
</blockquote>
<p>零拷贝是一种<strong>I&#x2F;O操作优化技术</strong>，可以快速高效地将数据从文件系统移动到网络接口，而不需要将其从内核空间复制到用户空间。</p>
<p>这里象征性复习一下内核空间与用户空间：</p>
<p>早期操作系统不区分用户与内核，但是程序往往会因为某些原因（误操作，代码没写对等）在访问任意内存空间时造成操作系统崩溃，比如清除操作系统的内存数据。根据CPU指令重要成都对指令进行分级：Ring0~Ring3（Linux只是用0和3）。Ring3只能访问用户空间（运行在用户态）Ring0访问任意空间（运行在内核态）。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/12/d342892940c2fa14.jpg"></p>
<p>比如创建一个线程，实际是要交给操作系统为我们分配，需要操作系统帮助我们完成系统调用，是内核在处理而不是程序（此时就是程序陷入内核态）。当操作系统完成分配，代码返回得到线程对象，之后又继续由程序操作（内核态转回了用户态）</p>
<p>而文件操作也是这样，传统使用IO，将磁盘数据发送到网络，流程如下</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/12/25957eee4e014389.jpg"></p>
<p>整个过程有四次拷贝数据，浪费时间，如果能让过用户空间，减少拷贝次数。</p>
<p>实现零拷贝，演示三种方案</p>
<ul>
<li>虚拟内存：内核空间和用户空间的虚拟地址指向同一个物理地址，相当于直接共用了一块区域</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/12/e6bc56bc0d9c3618.jpg"></p>
<ul>
<li>mmap&#x2F;write内存映射：将内核空间中的缓存直接映射到用户空间缓存，就是直接作为映射存在，当我们需要将数据发送到Socket缓冲区时，直接在内核空间中进行操作就行了</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/12/e67004f84f8769fb.jpg"></p>
<ul>
<li>sendfile方式：在Linux2.1开始，引入了sendfile方式来简化操作，我们可以直接告诉内核要把哪个文件数据拷贝拷贝到Socket上，直接在内核空间中一步到位</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/12/bf6615b7a8e70a35.jpg"></p>

        <h2 id="Netty工作模型"   >
          <a href="#Netty工作模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#Netty工作模型" class="headerlink" title="Netty工作模型"></a>Netty工作模型</h2>
      <p>使用主从Reactor模型，先看对比图</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/12/b66c2c0d915b3463.jpg"></p>
<p>Boss Group相当于主Reactor，处理客户端的连接，Worker Group相当于从Reactor，负责处理读写事件（的轮询，一定要注意，实际的读写操作是Handler负责处理）。两个Group都是使用EventLoop（事件循环）。</p>
<p>上图可能不太醒目，也可以看这张图</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/13/fc36cb17a20f7461.jpg"></p>
<blockquote>
<p>此处仅对工作模型简单介绍</p>
</blockquote>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.jianshu.com/p/da3accfbe310" >https://www.jianshu.com/p/da3accfbe310</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>青空の霞光：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javase/ibx6ug" >https://www.yuque.com/qingkongxiaguang/javase/ibx6ug</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/05/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(0)-Socket%E5%85%A5%E9%97%A8/">网络编程(0)--Socket详解</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-06</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h1>
      <p>该部分之所以为0，是因为在之后<code>NIO</code>，<code>AIO</code>的学习都会大量用到<code>Socket</code>的知识，所以为了更好的让读者阅读下去，这里开始对<code>Socket</code>做出一点补充。</p>
<p>客户端与服务器连接之后，通过对<code>Socket</code>对象的写入和读取进行通信。</p>
<p>连接过程：</p>
<ul>
<li>服务器实例化一个 <code>ServerSocket</code> 对象，表示通过服务器上的端口通信。</li>
<li>服务器调用 <code>ServerSocket</code> 类的 <code>accept() </code>方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。</li>
<li>服务器正在等待时，一个客户端实例化一个 <code>Socket</code> 对象，指定服务器名称和端口号来请求连接。</li>
<li><code>Socket</code> 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 <code>Socket</code> 对象能够与服务器进行通信。</li>
<li>在服务器端，<code>accept() </code>方法返回服务器上一个新的 <code>socket</code> 引用，该 <code>socket</code> 连接到客户端的 <code>socket</code>。</li>
</ul>
<p><code>TCP</code>是双向通信协议，服务器和客户端可以同时互相发消息。<strong>客户端的Socket的输出流就是服务端的输入流，客户端的输入流就是服务端的输出流</strong>。</p>

        <h1 id="相关实现类"   >
          <a href="#相关实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关实现类" class="headerlink" title="相关实现类"></a>相关实现类</h1>
      
        <h2 id="ServerSocket类"   >
          <a href="#ServerSocket类" class="heading-link"><i class="fas fa-link"></i></a><a href="#ServerSocket类" class="headerlink" title="ServerSocket类"></a>ServerSocket类</h2>
      <p>服务器应用程序通过该类获取端口（构造函数传入端口），并且监听客户端请求。</p>
<p>构造方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其他三个构造方法，从右至左依次减少一个参数</span></span><br><span class="line"><span class="comment">// 使用指定的端口、侦听 backlog 和要绑定到的本地 IP 地址创建服务器。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ServerSocket</span><span class="params">(<span class="type">int</span> port, <span class="type">int</span> backlog, InetAddress address)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></div></figure>

<p>相关方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取该Socket监听的端口</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLocalPort</span><span class="params">()</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 侦听并接受到此套接字的连接</span></span><br><span class="line"><span class="keyword">public</span> Socket <span class="title function_">accpet</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 将ServerSocket绑定到特定地址(IP地址和端口号)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(SocketAddress host,<span class="type">int</span> backlog)</span></span><br></pre></td></tr></table></div></figure>




        <h2 id="Socket类"   >
          <a href="#Socket类" class="heading-link"><i class="fas fa-link"></i></a><a href="#Socket类" class="headerlink" title="Socket类"></a>Socket类</h2>
      <p>客户端和服务端通信使用的套接字，客户端要获取一个<code>Socket</code>直接实例化，服务端通过<code>accept</code>方法返回值。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接到指定主机的指定端口号上</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Socket</span><span class="params">(String host, <span class="type">int</span> port)</span> </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 连接到指定IP地址的指定端口号</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Socket</span><span class="params">(InetAddress host, <span class="type">int</span> port)</span></span><br></pre></td></tr></table></div></figure>

<p>当 <code>Socket</code> 构造方法返回，并没有简单的实例化了一个 <code>Socket</code> 对象，它实际上会尝试连接到指定的服务器和端口。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将此套接字连接到服务器，并指定一个超时值。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(SocketAddress host, <span class="type">int</span> timeout)</span> <span class="keyword">throws</span> IOException</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回套接字连接的地址。</span></span><br><span class="line"><span class="keyword">public</span> InetAddress <span class="title function_">getInetAddress</span><span class="params">()</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 返回套接字连接的远程端口，本地端口是getLocalPort</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPort</span><span class="params">()</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取输入/输出流</span></span><br><span class="line"><span class="keyword">public</span> OutputStream <span class="title function_">getOutpurStream</span><span class="params">()</span>;</span><br></pre></td></tr></table></div></figure>




        <h2 id="InetAddress类"   >
          <a href="#InetAddress类" class="heading-link"><i class="fas fa-link"></i></a><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a>InetAddress类</h2>
      <p>该类表示互联网协议（IP），该类的核心方法，直接在IDE里面打出<code>get</code>即可。</p>

        <h1 id="示例"   >
          <a href="#示例" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例" class="headerlink" title="示例"></a>示例</h1>
      <p>客户端代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// 输出流，发送数据给服务端</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        out.write(s.getBytes());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其实也可以是输入流，无非就是接收来自服务器的数据</span></span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>服务端代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 也可以用其他借助装饰者类实现更多功能的类</span></span><br><span class="line">        in.read(arr);</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>其实服务端应该是<code>while</code>循环不断获取客户端传过来的连接。我们看到客户端和服务端可以传输数据，这也是IO流，比如服务端要获取客户端传过来的数据，就需要调用<code>read</code>方法，如果客户端那边数据没准备好，就会一直阻塞在这里。</p>
<p>客户端是一样的道理。既然存在阻塞，那么在设计的时候就存在同步异步问题，也就是之后涉及的NIO，AIO等知识。</p>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p>菜鸟教程：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.runoob.com/java/java-networking.html" >https://www.runoob.com/java/java-networking.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/04/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(5)-AIO%E5%9F%BA%E6%9C%AC%E8%AF%A6%E8%A7%A3/">网络编程(5)--AIO基本详解</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-04</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h1>
      <p>前面三种IO模型：阻塞式同步，非阻塞式同步，多路复用都是采用的应用主动询问操作系统。也就导致他们都会在执行<code>read</code>函数中阻塞住。</p>
<p>异步IO采用的是“订阅 - 通知”模式：应用程序向操作系统注册IO监听，然后继续做自己的事情，当操作系统发生IO事件，并且准备好数据后，再主动通知应用程序，触发相应的函数。</p>
<p>异步IO也是操作系统进行支持的，Windows系统提供的异步IO技术为<code>IOCP</code>（I&#x2F;O Completion Port，I&#x2F;O完成端口）。Linux使用的是<code>epoll</code>多路复用IO技术模拟异步IO。</p>

        <h1 id="Java对异步IO的支持"   >
          <a href="#Java对异步IO的支持" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java对异步IO的支持" class="headerlink" title="Java对异步IO的支持"></a>Java对异步IO的支持</h1>
      <p>通常我们使用线程池用于执行异步任务，提交任务的线程讲任务提交到线程池就可以立马返回，不必等到任务正在完成，等我们需要执行结果时，通过传递一个回调函数的方式，任务结束后调用这个函数（<a href="https://cecilia.cool/2022/08/24/Java/%E5%B9%B6%E5%8F%91/Java%E7%BA%BF%E7%A8%8B%E6%B1%A02-FutureTask/">FutureTask</a>）。</p>
<p>Java 中的异步 IO 也是一样的，都是由一个线程池来负责执行任务，然后使用回调或自己去查询结果。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/02/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(4)-NIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E8%AF%A6%E8%A7%A3/">网络编程(4)--IO多路复用详解</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-02</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-08</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h1>
      <p>关于多路复用（windows下使用select）的简单介绍已经在<strong>Unix IO模型</strong>和<strong>NIO基础详解</strong>中大致提到，并给出了代码实现。本文会对相关方法和模型进行详细讲解。</p>
<p>多路复用IO技术最适用的是“高并发”场景，所谓<strong>高并发是指1毫秒内至少同时有上千个连接请求准备好</strong>。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">try(ServerSocket server = new ServerSocket(8888)) &#123;</span><br><span class="line">    Socket s = server.accept();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;服务端收到连接&quot;);</span><br><span class="line"></span><br><span class="line">    BufferedReader reader = new BufferedReader(new InputStreamReader(s.getInputStream()));</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;服务端读取数据： &quot; + reader.readLine());</span><br><span class="line"></span><br><span class="line">    OutputStreamWriter write = new OutputStreamWriter(s.getOutputStream());</span><br><span class="line"></span><br><span class="line">    write.write(&quot;服务端已收到数据&quot;);</span><br><span class="line">    write.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(<span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8888</span>)) &#123;</span><br><span class="line">    <span class="type">OutputStreamWriter</span> <span class="variable">write</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(s.getOutputStream());</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">    write.write(<span class="string">&quot;客户端发送数据：xyz\n&quot;</span>);</span><br><span class="line">    write.flush();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;客户端发送数据&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(s.getInputStream()));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;客户端收到数据： &quot;</span>+reader.readLine());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="模型"   >
          <a href="#模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#模型" class="headerlink" title="模型"></a>模型</h1>
      
        <h2 id="传统IO模型"   >
          <a href="#传统IO模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#传统IO模型" class="headerlink" title="传统IO模型"></a>传统IO模型</h2>
      <p>一个<code>Server</code>对接N个客户端，在客户端连接之后，为每个客户端都分配一个执行线程。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/02/d6855af86b51f707.jpg" alt="传统IO模型"></p>
<p>从图中可以看出其特点：</p>
<ul>
<li>每个客户端连接到达之后，服务端会分配一个线程给该客户端，该线程会处理包括读取数据，解码，业务计算，编码，以及发送数据整个过程；</li>
<li>同一时刻，服务端的吞吐量与服务器所提供的线程数量是呈线性关系的。</li>
</ul>
<p>但是这也有很大问题：</p>
<ul>
<li><p>服务器并发量严重依赖于服务端能创建的线程数。</p>
</li>
<li><p>服务端在获取客户端连接，读取数据，以及写入数据的过程都是阻塞类型的，在网络状况不好的情况下，这将极大的降低服务器每个线程的利用率，从而降低服务器吞吐量。</p>
</li>
</ul>
<blockquote>
<p>如果每一个客户端都维持一个与登陆服务器的连接。那么服务器将<strong>维护</strong>多个和客户端的连接以出来和客户端的contnect 、read、write ，特别是对于长链接的服务，有多少个c端，就需要在s端维护同等的IO连接。这对服务器来说是一个很大的开销。</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端 -- 其实这里应该写死循环的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>)) &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> server.accept();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;服务端收到连接&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(s.getInputStream()));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;服务端读取数据： &quot;</span> + reader.readLine());</span><br><span class="line"></span><br><span class="line">            <span class="type">OutputStreamWriter</span> <span class="variable">write</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(s.getOutputStream());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 两边接收数据都是readLine，所以必须加换行符</span></span><br><span class="line">            write.write(<span class="string">&quot;服务端已收到数据\n&quot;</span>);</span><br><span class="line">            write.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8888</span>)) &#123;</span><br><span class="line">            <span class="type">OutputStreamWriter</span> <span class="variable">write</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(s.getOutputStream());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 两边接收数据都是readLine，所以必须加换行符</span></span><br><span class="line">            write.write(<span class="string">&quot;客户端发送数据：xyz\n&quot;</span>);</span><br><span class="line">            write.flush();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;客户端发送数据&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(s.getInputStream()));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;客户端收到数据： &quot;</span>+reader.readLine());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>你也可以试着使用通道和缓冲区实现，<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javase/kl68ty#dd93d714" >参考链接</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p>
</blockquote>

        <h2 id="I-x2F-O多路复用"   >
          <a href="#I-x2F-O多路复用" class="heading-link"><i class="fas fa-link"></i></a><a href="#I-x2F-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h2>
      <p>之前讲了I&#x2F;O多路复用的模型介绍大概，这里我们给出源码实现</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">         <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open())&#123;   <span class="comment">//开启一个新的Selector，这玩意也是要关闭释放资源的</span></span><br><span class="line">        serverChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">// 要使用选择器进行操作，必须使用非阻塞的方式，这样才不会像阻塞IO那样卡在accept()，</span></span><br><span class="line">        <span class="comment">// 而是直接通过，让选择器去进行下一步操作</span></span><br><span class="line">        serverChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将ServerChannel注册到选择器上，此时只有选择器只会监听这一个通道</span></span><br><span class="line">        <span class="comment">// 因为是ServerSocketChannel这里我们就监听accept就可以了，等待客户端连接</span></span><br><span class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;   <span class="comment">//无限循环等待新的用户网络操作</span></span><br><span class="line">            <span class="comment">//每次选择都可能会选出多个已经就绪的网络操作，没有操作时会暂时阻塞</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br><span class="line">            System.out.println(<span class="string">&quot;监听到 &quot;</span>+count+<span class="string">&quot; 个事件&quot;</span>);</span><br><span class="line">            <span class="comment">// 如果是第一次循环，拿到的事件SelectionKey绑定的通道都是ServerChannel</span></span><br><span class="line">            </span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="comment">//根据不同的事件类型，执行不同的操作即可</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 该事件绑定的通道就是ServerChannel</span></span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable()) &#123;  <span class="comment">//如果ServerSocketChannel已经做好准备处理Accept</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 我们现在知道了有一个客户端需要连接（之后可能会发送数据给服务端）</span></span><br><span class="line">                    <span class="comment">// 所以我们将客户端的通道初始化</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> serverChannel.accept();</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端已连接，IP地址为：&quot;</span>+channel.getRemoteAddress());</span><br><span class="line">                    <span class="comment">// 现在连接就建立好了，接着我们需要将连接也注册选择器</span></span><br><span class="line">                    channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    <span class="comment">//这样就在连接建立时完成了注册</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable()) &#123;    <span class="comment">//如果当前连接有可读的数据并且可以写，那么就开始处理</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    System.out.println(<span class="string">&quot;接收到客户端数据：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//直接向通道中写入数据就行</span></span><br><span class="line">                    channel.write(ByteBuffer.wrap(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                    <span class="comment">//别关，说不定用户还要继续通信呢</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//处理完成后，一定记得移出迭代器，不然下次还有</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面是关于服务器的代码，最主要的就是<code>SelectionKey</code>，它包含了监听事件注册时的通道，比如一开始我们将通道<code>ServerSocketChannel</code>注册到选择器，然后在<code>if</code>选择语句中拿到的<code>key</code>就包含<code>ServerSocket</code>。</p>
<p><code>SelectionKey</code>有一个<code>channel()</code>方法，使用时需要强转一下。因为第一个<code>if</code>已经有了<code>ServerSocketChannel</code>的引用，就没必要调用<code>cahnel()</code>。</p>
<p>之后的客户端代码就比较简单了</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个新的SocketChannel，通过通道进行通信</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">         <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已连接到服务端！&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;   <span class="comment">//咱给它套个无限循环，这样就能一直发消息了</span></span><br><span class="line">            System.out.println(<span class="string">&quot;请输入要发送给服务端的内容：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            <span class="comment">//直接向通道中写入数据，真舒服</span></span><br><span class="line">            channel.write(ByteBuffer.wrap(text.getBytes()));</span><br><span class="line">            System.out.println(<span class="string">&quot;已发送！&quot;</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">            channel.read(buffer);   <span class="comment">//直接从通道中读取数据</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            System.out.println(<span class="string">&quot;收到服务器返回：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>请读者将这部分代码弄清楚，不清楚就去查，下面给大家几篇写的比较好的博客</p>
<blockquote>
<p>田守枝Java技术博客（讲解细致，建议收藏）：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://www.tianshouzhi.com/api/tutorials/netty/318" >http://www.tianshouzhi.com/api/tutorials/netty/318</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>并发编程网（很短，推荐看一下）：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://ifeve.com/server-socket-channel/" >http://ifeve.com/server-socket-channel/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>CSDN（这篇博客我只看了前面几句话，提到了我忽略的点）：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/cold___play/article/details/106663776" >https://blog.csdn.net/cold___play/article/details/106663776</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>但是这个也存在问题：比如一个线程忙不过来（真实），所以之后的<code>Reactor</code>模型会使用到线程池。</p>

        <h2 id="单线程Reactor模型"   >
          <a href="#单线程Reactor模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#单线程Reactor模型" class="headerlink" title="单线程Reactor模型"></a>单线程Reactor模型</h2>
      <p><code>Reactor</code>模型主要是对服务器进行优化，首先我们抽象出两个组件</p>
<ul>
<li><code>Reactor</code>线程：负责响应IO事件，并分发到<code>Handler</code>处理器。新的事件包含连接建立就绪，读就绪，写就绪等。</li>
<li>Handler处理器：执行<strong>非阻塞</strong>的操作（因为<code>Selector</code>只有监听到了真正要执行的事件，才会将该事件交给<code>Handler</code>执行，所以不存在阻塞操作）。</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/07/315c775016584c9b.jpg" alt="图片源自青空の霞光"></p>
<p><code>JDK1.4</code>提供了一套非阻塞<code>IO</code>的<code>API</code>，本质是以<strong>事件驱动</strong>来处理网络事件的，<code>Reactor</code>是基于该<code>API</code>提出的一套<code>IO</code>模型。</p>
<p>该模型主要分为四个部分：客户端连接，Reactor，Acceptor，Handler。</p>
<p><code>Reactor</code>模型是以事件进行驱动的（应该已经很了解事件驱动了吧），其能够将接收客户端连接，+ 网络读和网络写，以及<strong>业务计算进行拆分</strong>，从而极大的提升处理效率；Reactor模型是异步<strong>非阻塞</strong>模型，工作线程在没有网络事件时可以处理其他的任务，而不用像传统IO那样必须阻塞等待。</p>
<blockquote>
<p><code>Acceptor</code>处理客户端新连接，并分派请求到处理器链（<code>Reactor</code>）</p>
</blockquote>
<p>下图是比较正经（难懂）的图。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/03/b23b2105c197fe2f.jpg" alt="Reactor模型"></p>
<p>我们先看一下<code>Handler</code>代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行非阻塞操作，请记住，read在这里也是非阻塞</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Handler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SocketChannel channel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">            channel.read(buffer);</span><br><span class="line">            buffer.flip();</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到客户端数据：&quot;</span>+</span><br><span class="line">                               <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">            channel.write(ByteBuffer.wrap(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>接着是<code>Acceptor</code>，非常快就能看完。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Acceptor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerSocketChannel serverChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Selector selector;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Acceptor</span><span class="params">(ServerSocketChannel serverChannel,Selector selector)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serverChannel = serverChannel;</span><br><span class="line">        <span class="built_in">this</span>.selector = selector;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> serverChannel.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端已连接，IP地址为：&quot;</span> + </span><br><span class="line">                              channel.getRemoteAddress());</span><br><span class="line">            channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 注册时，创建好对应的Handler，这样在Reactor中分发的时候就可以直接调用Handler</span></span><br><span class="line">            channel.register(selector,Selector.OP_READ,<span class="keyword">new</span> <span class="title class_">Handler</span>(channel));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>最后看一下<code>Reactor</code>的实现，这里的<code>dispatch</code>使用了<code>attachment</code>方法</p>
<blockquote>
<p>选择键支持将单个任意对象附加到某个键的操作。可通过<code>attach()</code>方法附加对象，然后通过<code>attachment()</code>方法获取该对象。我们在Acceptor和Handler都没有使用<code>attach</code>方法，而是在注册时绑定<code>SelectionKey key=channel.register(selector,SelectionKey.OP_READ,theObject);</code></p>
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reactor</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span>,Runnable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerSocketChannel serverChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Selector selector;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Reactor</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        serverChannel = ServerSocketChannel.open();</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Public <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8888</span>));</span><br><span class="line">            serverChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从这里可以看到，Reactor并不处理连接，而是将需要连接的</span></span><br><span class="line">            <span class="comment">// 事件交给acceptor处理</span></span><br><span class="line">            serverChannel.register(selector,SelectionKey.OP_ACCEP,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">Acceptor</span>(serverChannel,selector));</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br><span class="line">                System.out.println(<span class="string">&quot;监听到 &quot;</span> + count + <span class="string">&quot; 个事件&quot;</span>);</span><br><span class="line">                Set&lt;SelectionKey&gt; set = selector.selectionKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = set.iterator();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span>(iterator.hasnext()) &#123;</span><br><span class="line">                    <span class="comment">// 通过dispatch方法分发出去</span></span><br><span class="line">                    <span class="built_in">this</span>.dispatch(iterator.next());</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(selectionKey key)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">att</span>  <span class="operator">=</span> key.attachment();</span><br><span class="line">        <span class="keyword">if</span>(att <span class="keyword">instanceof</span> Runnable) &#123;</span><br><span class="line">            <span class="comment">// Handler和Acceptor都实现自Runnable接口，这里就统一调用一下</span></span><br><span class="line">            ((Runnable) att).run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        serverChannel.close();</span><br><span class="line">        selector.close();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<blockquote>
<p>需要注意的是，这是单线程模式，也就是说，Reactor和Hander都是处于一条线程执行。由于是单线程，只要有一个handler出现阻塞，其他的Client都会被阻塞，并且不能充分利用多核资源。所以单线程模型仅仅适用于handler中业务处理组件能快速完成的场景。</p>
</blockquote>
<p>所以整个流程图也可以这么画（其实这个图画的不准确，<code>client</code>应该指向<code>Reactor</code>，而且此处也省略了<code>dispatch</code>）。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/04/1fd0e8d34115ad66.jpg" alt="Reactor单线程模型"></p>

        <h2 id="多线程Reactor模型"   >
          <a href="#多线程Reactor模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#多线程Reactor模型" class="headerlink" title="多线程Reactor模型"></a>多线程Reactor模型</h2>
      <p>先看一下<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://space.bilibili.com/37737161/?spm_id_from=333.999.0.0" >青空の霞光</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>给的图</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/07/c06c6ae8afed08f1.jpg"></p>
<p>相关改进为：</p>
<ul>
<li>将<code>Handler</code>处理器的执行放入线程池，多线程进行业务处理。<strong>此时handler处理的是非阻塞任务</strong>。所以这个模型又叫做：<strong>业务处理与IO分离</strong>。</li>
<li>对于<code>Reactor</code>而言，仍然是单线程。</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/04/76186bdd3784f6b0.jpg" alt="Reactor多线程模型"></p>
<p>特点：</p>
<ul>
<li><p>有一个专门的NIO线程用于监听服务器，接收客户端的TCP连接请求以及网络读写事件的处理（可以看到<code>read</code>和<code>send</code>仍然是<code>Reactor</code>在处理）。</p>
</li>
<li><p>接收到连接之后，将该链接交给线程池，这些NIO线程负责消息的读取，解码，编码和发送。</p>
</li>
</ul>
<p>在绝大多数场景下，Reactor多线程模型可以满足性能需求，但是仅仅使用一个NIO线程负责监听和处理所有客户端连接同时还要负责处理网络读写可能会存在性能问题，比如<strong>百万客户端并发连接，或则服务端需要多客户端的握手信息进行安全认证，认证本身非常消耗性能</strong>。</p>
<p>代码：我们只需要修改一下<code>Handler</code>即可</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Handler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="comment">// 把线程池给安排了，10个线程</span></span><br><span class="line">    <span class="comment">// 真正项目开发，线程池一般是自定义的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">POOL</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SocketChannel channel;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            channel.read(buffer);</span><br><span class="line">            buffer.flip();</span><br><span class="line">            POOL.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;接收到客户端数据：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">                    channel.write(ByteBuffer.wrap(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="主从Reactor多线程模型"   >
          <a href="#主从Reactor多线程模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#主从Reactor多线程模型" class="headerlink" title="主从Reactor多线程模型"></a>主从Reactor多线程模型</h2>
      <p>先看一下简化图</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/07/bbcf85b18177c5c2.jpg"></p>
<p>之前的模型既要处理客户端连接，又要处理网络读写，但是网络读写在高并发情况下会成为系统的一个瓶颈。所以将<code>Reactor</code>拆分为<code>mainReactor</code>和<code>subReactor</code>。即使用线程池进行网络读写，只是用一个线程专门接收客户端连接。</p>
<ul>
<li><code>mainReactor</code>主要进行客户端连接的处理，处理完成之后将该链接交给<code>subReactor</code>处理客户端的网络读写。</li>
<li><code>subReactor</code>使用一个线程池来支撑，而其他业务操作也是用一个线程池。</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/04/f9e540e1a225450d.jpg" alt="主从Reactor模型"></p>
<p>通过这种方式，服务器的性能将会大大提升，在可见情况下，其基本上可以支持百万连接。如果想看具体的函数调用，可以看这篇：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/Jack__iT/article/details/107010486" >深入理解主从Reactor多线程模型</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p>
<p>这次改动比较多，我们首先设计一下从<code>Reactor</code>：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SubReactor作为从Reactor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubReactor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>, Closeable &#123;</span><br><span class="line">	<span class="comment">//每个从Reactor也有一个Selector</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Selector selector;</span><br><span class="line">	</span><br><span class="line">  	<span class="comment">//创建一个4线程的线程池，也就是四个从Reactor工作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">POOL</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SubReactor[] reactors = <span class="keyword">new</span> <span class="title class_">SubReactor</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">selectedIndex</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">//采用轮询机制，每接受一个新的连接，就轮询分配给四个从Reactor</span></span><br><span class="line">    <span class="keyword">static</span> &#123;   <span class="comment">//在一开始的时候就让4个从Reactor跑起来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reactors[i] = <span class="keyword">new</span> <span class="title class_">SubReactor</span>();</span><br><span class="line">                <span class="comment">// 一开就将从Reactor放到线程池中运行</span></span><br><span class="line">                POOL.submit(reactors[i]);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//轮询获取下一个Selector（Acceptor用）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title function_">nextSelector</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> reactors[selectedIndex].selector;</span><br><span class="line">        selectedIndex = (selectedIndex + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> selector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SubReactor</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;   <span class="comment">//启动后直接等待selector监听到对应的事件即可，其他的操作逻辑和Reactor一致</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &gt;&gt; 监听到 &quot;</span>+count+<span class="string">&quot; 个事件&quot;</span>);</span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.dispatch(iterator.next());</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(SelectionKey key)</span>&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">att</span> <span class="operator">=</span> key.attachment();</span><br><span class="line">        <span class="keyword">if</span>(att <span class="keyword">instanceof</span> Runnable) &#123;</span><br><span class="line">            ((Runnable) att).run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        selector.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>我们设计的<code>SubReactor</code>没有<code>ServerSocketChannel</code>，而是每个从<code>Reactor</code>都有一个<code>Selector</code>，在主<code>Reactor</code>中通过<code>nextSelector</code>静态方法轮流获得不同从<code>Reactor</code>的<code>Selector</code>。</p>
</blockquote>
<p>最后修改一下<code>Acceptor</code></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Acceptor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerSocketChannel serverChannel;   <span class="comment">//只需要一个ServerSocketChannel就行了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Acceptor</span><span class="params">(ServerSocketChannel serverChannel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serverChannel = serverChannel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> serverChannel.accept();   <span class="comment">//还是正常进行Accept操作，得到SocketChannel</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &gt;&gt; 客户端已连接，IP地址为：&quot;</span>+channel.getRemoteAddress());</span><br><span class="line">            channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> SubReactor.nextSelector();   <span class="comment">//选取下一个从Reactor的Selector</span></span><br><span class="line">            selector.wakeup();    <span class="comment">//在注册之前唤醒一下防止卡死</span></span><br><span class="line">            channel.register(selector, SelectionKey.OP_READ, <span class="keyword">new</span> <span class="title class_">Handler</span>(channel));  <span class="comment">//注意现在注册的是从Reactor的Selector</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>需要注意，不同的人设计在代码实现方面可能不同，重点是<code>Reactor</code>的思想，主<code>Reactor</code>处理连接（也就是调用<code>Acceptor</code>）将<code>SocketChannel</code>注册到选择器上（因为之后就要进行读写操作），此时这个连接之后的读写请求都会发送给从<code>Reactor</code>的选择器，这也就规避了主<code>Reactor</code>处理读写请求。但是最终去完成这个请求的还是<code>Handler</code>。</p>
</blockquote>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.modb.pro/db/50016" >理解Reactor模型</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>（这篇文章关于多线程Reactor的图有些不准确）</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/io/java-io-nio-select-epoll.html" >https://pdai.tech/md/java/io/java-io-nio-select-epoll.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/Jack__iT/article/details/107010486" >https://blog.csdn.net/Jack__iT/article/details/107010486</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>青空の霞光：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javase/kl68ty" >https://www.yuque.com/qingkongxiaguang/javase/kl68ty</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/logo.png" alt="avatar"></div><p class="sidebar-ov-author__text">You have lots more to work on</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">67</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">2</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">11</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh_tw" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Cyan</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.2.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.7.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.7.0"></script><script src="/js/stun-boot.js?v=2.7.0"></script><script src="/js/scroll.js?v=2.7.0"></script><script src="/js/header.js?v=2.7.0"></script><script src="/js/sidebar.js?v=2.7.0"></script></body></html>