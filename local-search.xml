<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>函数</title>
    <link href="/2022/08/04/Shell/%E5%87%BD%E6%95%B0/"/>
    <url>/2022/08/04/Shell/%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h1><p>格式</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 格式1</span><span class="token keyword">function</span> <span class="token function-name function">name</span> <span class="token punctuation">&#123;</span>commands<span class="token punctuation">&#125;</span><span class="token comment"># 格式2,更推荐使用</span><span class="token function-name function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>commands<span class="token punctuation">&#125;</span><span class="token comment"># 使用时只需要使用函数名即可--name</span></code></pre></div></figure><p>默认情况下，函数退出状态码是函数中最后一条命令返回的退出状态码，函数执行结束后，可以用标准变量<code>$?</code>来确定函数退出状态码。</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># return语句</span><span class="token function-name function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token builtin class-name">read</span> -p <span class="token string">"please input the value:"</span> value    <span class="token builtin class-name">return</span> <span class="token variable">$value</span><span class="token punctuation">&#125;</span></code></pre></div></figure><p>退出状态码在<code>0~255</code>，否则就会返回错误值</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token function-name function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token assign-left variable">var</span><span class="token operator">=</span><span class="token string">'abc'</span> <span class="token comment"># 会报错：line 5: return: abc: numeric argument required</span>    <span class="token builtin class-name">return</span> <span class="token variable">$var</span><span class="token punctuation">&#125;</span>fun<span class="token comment"># 如果中间有其他命令，$?就会被置0</span><span class="token builtin class-name">echo</span> <span class="token variable">$?</span></code></pre></div></figure><p>当然，如果希望从函数那得到一个任意对象，就像强类型语言那样<code>return</code>语句返回值可以用变量接收</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function-name function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token assign-left variable">value</span><span class="token operator">=</span><span class="token number">10</span><span class="token builtin class-name">echo</span> $<span class="token punctuation">[</span><span class="token variable">$value</span>*2<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token assign-left variable">reslut</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span>fun<span class="token variable">`</span></span> <span class="token comment">#或者是$(fun)</span></code></pre></div></figure><p>如此可以获得任何类型的函数输出，并将其保存在变量中。</p><h1 id="函数中使用变量"><a href="#函数中使用变量" class="headerlink" title="函数中使用变量"></a>函数中使用变量</h1><p><strong>传参：</strong></p><ul><li><code>bash shell</code> 会将函数当成一个小型脚本来对待，也就是说，可以传递参数，如同脚本一样。</li><li>如同脚本一样，对于传入参数，依旧是使用<code>$0,$1...</code>，<code>$#</code>是传入参数数量。<code>value=$(fun 10 15)</code>,参数直接写在后面即可。</li><li>由于函数使用特殊参数环境变量作为自己的参数值，因此他无法直接获取脚本在命令行获取的参数值。</li></ul><p><strong>处理变量：</strong></p><p>比较麻烦的就是变量的作用域。默认情况下，<strong>定义的变量都是全局变量</strong>，函数外定义的变量，函数内部也可以正常使用。函数内定义的变量函数外也可以使用。</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token function-name function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token assign-left variable">var</span><span class="token operator">=</span><span class="token number">10</span>    <span class="token builtin class-name">return</span> <span class="token variable">$var</span><span class="token punctuation">&#125;</span>fun<span class="token builtin class-name">echo</span> <span class="token variable">$var</span></code></pre></div></figure><p>函数内部使用的任何变量都可以被声明成局部变量，只需要加上<code>local</code>关键字即可。</p><p><code>local temp=$[$value + 2]</code>,在函数内使用<code>temp</code>，不会影响主体脚本的<code>temp</code>的值。</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">arr</span><span class="token operator">=</span><span class="token punctuation">(</span>one two three<span class="token punctuation">)</span></code></pre></div></figure><p>直接<code>$arr</code>只会显示<code>one</code>，使用格式为：<code>$&#123;arr[1]&#125;</code>,一次性全部显示，就是<code>$&#123;arr[*]&#125;</code>。</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token function-name function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token builtin class-name">local</span> <span class="token assign-left variable">arr</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1,2</span>,3,4<span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> <span class="token variable">$&#123;arr<span class="token punctuation">[</span>*<span class="token punctuation">]</span>&#125;</span>    <span class="token keyword">do</span>        <span class="token builtin class-name">echo</span> -n <span class="token variable">$i</span>   <span class="token keyword">done</span>   <span class="token builtin class-name">echo</span><span class="token punctuation">&#125;</span>fun<span class="token comment">#结果：1,2,3,4</span></code></pre></div></figure><h1 id="创建库"><a href="#创建库" class="headerlink" title="创建库"></a>创建库</h1><p>总有一些方法，我在很多脚本文件中都会使用，为了避免每个脚本文件都写一次，<code>bash shell</code>允许创建函数库文件，然后在多个脚本中引用。</p><p>我们在运行一个脚本文件时，当前的<code>shell</code>会创建一个新的<code>shell</code>运行</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ <span class="token function">cat</span> testfile<span class="token comment">#!/bin/bash</span><span class="token keyword">while</span> <span class="token assign-left variable">var</span><span class="token operator">=</span><span class="token number">10</span><span class="token keyword">do</span>        <span class="token assign-left variable">var</span><span class="token operator">=</span><span class="token number">10</span><span class="token keyword">done</span>cyan@cyan-virtual-machine:~/Templates$ ./testfile <span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token number">89708</span>cyan@cyan-virtual-machine:~/Templates$ <span class="token function">ps</span> --forest    PID TTY          TIME CMD  <span class="token number">88948</span> pts/1    00:00:00 <span class="token function">bash</span>  <span class="token number">89708</span> pts/1    00:00:08  <span class="token punctuation">\</span>_ testfile  <span class="token number">89710</span> pts/1    00:00:00  <span class="token punctuation">\</span>_ <span class="token function">ps</span></code></pre></div></figure><p><code>shell</code>函数仅仅在定义它的<code>shell</code>会内有效，所以如果在<code>shell</code>命令行界面的提示符下运行库函数脚本，<code>shell</code>会创建一个新的<code>shell</code>运行。这个<code>shell</code>会重新定义库函数，当其他脚本想用时，是不能的。</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> <span class="token builtin class-name">test</span><span class="token comment">#!/bin/bash</span>./funs_file<span class="token punctuation">..</span></code></pre></div></figure><p>哪怕在<code>test</code>中运行<code>funs_file</code>库文件，这些库函数，也只能在运行库文件的<code>shell</code>里面才会生效。</p><h2 id="source命令"><a href="#source命令" class="headerlink" title="source命令"></a>source命令</h2><p>该命令会在当前<code>shell</code>上下文执行命令，而不是创建一个新的<code>shell</code>，并且<code>source</code>命令有个快捷别名–点操作符. <code>./fun_file</code>。</p><p>编写一个脚本</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ <span class="token function">cat</span> testfile<span class="token comment">#!/bin/bash</span><span class="token assign-left variable">var</span><span class="token operator">=</span><span class="token number">10</span></code></pre></div></figure><p>如果不使用<code>source</code>命令，那么<code>var</code>对于当前<code>shell</code>是不可见的</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ ./testfilecyan@cyan-virtual-machine:~/Templates$ <span class="token builtin class-name">echo</span> <span class="token variable">$var</span></code></pre></div></figure><p>使用之后</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ <span class="token builtin class-name">.</span> ./testfilecyan@cyan-virtual-machine:~/Templates$ <span class="token builtin class-name">echo</span> <span class="token variable">$var</span><span class="token number">10</span></code></pre></div></figure><h1 id="终端使用函数"><a href="#终端使用函数" class="headerlink" title="终端使用函数"></a>终端使用函数</h1><p>格式</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 格式1，分号结尾</span><span class="token function-name function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>echo <span class="token string">"ok"</span><span class="token punctuation">;</span><span class="token builtin class-name">read</span> value<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment"># 格式2</span>  <span class="token function-name function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">></span> <span class="token builtin class-name">echo</span> <span class="token string">"adc"</span><span class="token operator">></span> <span class="token punctuation">&#125;</span></code></pre></div></figure><p>在<code>.bashrc</code>文件定义函数：函数定义放在一个特殊的位置，每次启动新<code>shell</code>都会由<code>shell</code>重新在<code>.bashrc</code>中定义的函数，甚至可以在自己写的脚本中直接使用。</p><p>关于<code>.bashrc</code>，就是个启动文件，<code>shell</code>启动时会执行一下。</p>]]></content>
    
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>控制脚本</title>
    <link href="/2022/08/04/Shell/%E6%8E%A7%E5%88%B6%E8%84%9A%E6%9C%AC/"/>
    <url>/2022/08/04/Shell/%E6%8E%A7%E5%88%B6%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p><code>Linux</code>利用信号与运行在系统中的进程进行通信，常见的<code>Linux</code>系统信号：</p><ul><li>1–<code>SIGHUP</code>–挂起进程</li><li>2–<code>SIGINT</code>–终止进程</li><li>3–<code>SIGQUIT</code>–停止进程</li><li>9–<code>SIGLIKILL</code>–无条件终止进程</li><li>15–<code>SIHTERM</code>–尽可能终止进程</li><li>17–<code>SIGSTOP</code>–无条件停止进程，但不是终止</li><li>18–<code>SIGTSTP</code>–停止或暂停进程，但不是终止</li><li>19–<code>SIGCONT</code>–继续运行停止的进程</li></ul><p><code>crtl+c</code>会生成<code>SIGINT</code>信号，停止<code>shell</code>当前运行的所有进程。<br><code>ctrl+z</code>会生成<code>SIGTSTP</code>信号，停止<code>shell</code>中运行的任何进程。</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~$ <span class="token function">sleep</span> <span class="token number">1000</span>^Z<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>+  Stopped                 <span class="token function">sleep</span> <span class="token number">1000</span>cyan@cyan-virtual-machine:~$ <span class="token function">ps</span> -lF S   <span class="token environment constant">UID</span>     PID    <span class="token environment constant">PPID</span>  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD<span class="token number">0</span> S  <span class="token number">1000</span>   <span class="token number">30447</span>   <span class="token number">30445</span>  <span class="token number">0</span>  <span class="token number">80</span>   <span class="token number">0</span> -  <span class="token number">3559</span> do_wai pts/0    00:00:00 <span class="token function">bash</span><span class="token number">0</span> T  <span class="token number">1000</span>   <span class="token number">33293</span>   <span class="token number">30447</span>  <span class="token number">0</span>  <span class="token number">80</span>   <span class="token number">0</span> -  <span class="token number">2789</span> do_sig pts/0    00:00:00 <span class="token function">sleep</span><span class="token number">0</span> R  <span class="token number">1000</span>   <span class="token number">33294</span>   <span class="token number">30447</span>  <span class="token number">0</span>  <span class="token number">80</span>   <span class="token number">0</span> -  <span class="token number">3623</span> -      pts/0    00:00:00 <span class="token function">ps</span></code></pre></div></figure><p><code>S</code>列中，<code>T</code>标志就是进程被暂停。使用<code>ps</code>获得希望杀死的进程的<code>PID</code>，使用<code>kill -9 PID</code>。</p><h2 id="trap命令"><a href="#trap命令" class="headerlink" title="trap命令"></a>trap命令</h2><p><code>trap</code>命令：允许指定<code>shell</code>脚本监看并从<code>shell</code>中拦截的<code>Linux</code>信号。如果脚本收到了<code>trap</code>命令中列出的信号，该信号不再由<code>shell</code>处理。而是本地处理。</p><p>其使用格式为：<code>trap commands signals</code>。</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token builtin class-name">trap</span> <span class="token string">"echo 'I have trapped ctrl-c'"</span> SIGINT<span class="token function">sleep</span> <span class="token number">1000</span></code></pre></div></figure><p>在睡眠期间使用<code>ctrl+c</code>就会打印这句话。</p><p>在很多程序中，想要实现程序正常运行结束或者外部发送信号退出，都会打印<code>Goodby...</code>，可以加上这句话</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">trap</span> <span class="token string">"echo 'Goodby...'"</span> Exit</code></pre></div></figure><p><code>trap</code>可以修改或是移除，其重点就是<strong>先到先占位</strong>，比如第一行设置了<code>trap</code>指令，在第20行修改或移除了该信号，那么第一行<code>trap</code>的只会在1~19行生效。</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 删除,单（双）短横线都可以</span><span class="token builtin class-name">trap</span> --SIGINT</code></pre></div></figure><h1 id="后台模式"><a href="#后台模式" class="headerlink" title="后台模式"></a>后台模式</h1><p>最开始就提到过，在运行脚本时加上<code>&amp;</code>，就能将进程置入后台。后台模式中，进程不会和终端会话上的<code>STDIN</code>，<code>STDOUT</code>，<code>STDERR</code>关联 。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p><code>shell</code>脚本的基本编程到此为止，之后我们会进入高级<code>shell</code>脚本编程，其中会涉及到函数，著名的流编辑器<code>sed</code>和<code>gawk</code>，以及正则表达式四个主要部分。然后就可以结束此次<code>Linux</code>与<code>shell</code>编程的学习了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>呈现数据</title>
    <link href="/2022/08/03/Shell/%E5%91%88%E7%8E%B0%E6%95%B0%E6%8D%AE/"/>
    <url>/2022/08/03/Shell/%E5%91%88%E7%8E%B0%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>之前关于标准输入，输出重定向的文章，我提到开始接触流，并且在文中讲解时使用也是以流来具体化重定向的作用，但是讲解的非常不严谨。本文相当于对重定向深入讲解，甚至可以自定义重定向。</p><h1 id="标准文件描述符"><a href="#标准文件描述符" class="headerlink" title="标准文件描述符"></a>标准文件描述符</h1><p><code>Linux</code>系统将每个对象当作文件处理（有句话就是一切皆文件），包括输入和输出，用文件描述符<strong>标识</strong>每个文件对象。文件描述符是一个<strong>非负整数</strong>，可以唯一表示会话中打开的文件。出于特殊目的，<code>bash shell</code>在每个进程，只保留了3个文件标识符(0,1,2)</p><ul><li><code>STDIN</code>–标准输<strong>入</strong>。对于终端界面，<strong>标准输入是键盘</strong>。<code>shell</code>从<code>STDIN</code>对应的键盘获得输入。使用输入重定向符号<code>&lt;</code>，<code>Linux</code>会使用重定向指定的文件来替换标准文件描述符，会读取文件并提取数据，如同是在键盘上键入的。</li><li><code>STDOUT</code>–标准输<strong>出</strong>。同标准输入类似，shell所有输出都会被定向到标准输出中，也就是显示器。</li><li><code>STDERR</code>–错误消息对于错误消息，<strong>也是重定向到显示器的</strong>，但是错误消息和一般标准输出是分开的。比如：<code>ls -l badfile &gt; test</code>，如果没有<code>badfile</code>就会报错，但是错误信息并没有给<code>test</code>。</li></ul><p>我们之前知道如何重定向标准输入和标准输出，现在讲解如何重定向错误信息。</p><ul><li>只重定向错误：将<code>STDERR</code>文件描述符的值<code>(2)</code>紧紧放在重定向符号前，<code>ls -al badfile 2&gt; test</code>。但是这种方法，如果该命令的输出既包含错误信息，也包含标准输出，那么标准输出还是会输出到屏幕中。</li><li>重定向错误和数据：我们肯定不希望重定向的数据和错误信息在同一文件中（难道你希望错误日志里面还给你保存几句莫名其妙的打印语句吗），所以必须使用两个重定向符号，需要在符号面前放上各自文件描述符值：<code>ls -al test test2 test3 badtest 2&gt; testSTDERR 1&gt; testSTDOUT</code>（其中<code>test*</code>文件都存在，<code>badtest</code>不存在）。   当然，也可以将数据和错误重定向到同一文件： <code>ll n_File bad_File new_File &amp;&gt; STD_ALL</code>。<code>bash shell</code>自动赋予了错误消息更高的优先级，方便集中浏览错误信息，也就是说，<code>ll A B C</code>中<code>B</code>文件不存在，那么输出时会优先输出关于<code>B</code>的错误信息。</li></ul><h1 id="脚本中的标准重定向输出和输入"><a href="#脚本中的标准重定向输出和输入" class="headerlink" title="脚本中的标准重定向输出和输入"></a>脚本中的标准重定向输出和输入</h1><p>对于三个标准文件描述符，一定要记住，使用<code>exec</code>命令时数字放在箭头左边。当数字出现在右边，要用<code>&amp;</code>符号。</p><h2 id="临时重定向"><a href="#临时重定向" class="headerlink" title="临时重定向"></a>临时重定向</h2><p>在脚本中生成错误消息，可以将单独的一行输出重定向到<code>STDERR</code>，不同的是，在脚本中，格式为<code>&gt;&amp;2</code>。<code>echo &quot;This is error&quot; &gt;&amp;2</code>，这样，该行就会指向<code>STDERR</code>的位置，也就类似于终端上的错误信息一样。</p><p>这种操作可以用于检测脚本运行时传入的选型或者参数是否正确，如果不正确就可以通过<code>&gt;&amp;2</code>来生成错误信息。</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> <span class="token builtin class-name">test</span><span class="token comment">#!/bin/bash</span><span class="token builtin class-name">echo</span> <span class="token string">"This is error"</span> <span class="token operator">></span><span class="token file-descriptor important">&amp;2</span><span class="token builtin class-name">echo</span> <span class="token string">"This is normal"</span><span class="token comment"># 运行脚本，并将脚本的错误信息重定向到result1文件中</span>./test <span class="token operator"><span class="token file-descriptor important">2</span>></span> result1This is normal<span class="token function">cat</span> result1This is an error</code></pre></div></figure><h2 id="永久重定向"><a href="#永久重定向" class="headerlink" title="永久重定向"></a>永久重定向</h2><p>上面的临时重定向，比如我一个脚本有很多行生成错误信息并需要重定向，而每一行都是用<code>&gt;&amp;2</code>太麻烦了，那么就可以使用<code>exec</code>命令来进行永久重定向。</p><p><code>exec</code>命令告诉<code>shell</code>在脚本中执行期间重定向某个特定文件描述符。</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">1</span>></span> STD_output_file<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token comment"># 那么脚本中该命令之下的所有标准输出都重定向到了STD_output_file中</span><span class="token comment"># 同理，改变标准输入，这对于从待处理文件中读取数据有很大帮助</span><span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span> STD_input_file</code></pre></div></figure><h1 id="自定义重定向"><a href="#自定义重定向" class="headerlink" title="自定义重定向"></a>自定义重定向</h1><p><code>Linux</code>系统本来每个进程都有<strong>9个</strong>文件描述符，3个标准，剩下6个都可以用于自定义，<strong>这6个可以任意作为输入还是输出</strong>。</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">6</span>></span> testout<span class="token builtin class-name">echo</span> <span class="token string">"This is a data"</span><span class="token operator">></span><span class="token file-descriptor important">&amp;6</span><span class="token comment"># 如果使用>>就是追加模式</span></code></pre></div></figure><p>如果你想恢复一个被重定向的文件描述符</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">3</span>></span><span class="token file-descriptor important">&amp;1</span>   <span class="token comment">#3指向1</span><span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">1</span>></span>testout<span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">1</span>></span><span class="token file-descriptor important">&amp;3</span></code></pre></div></figure><p>创建<strong>读写</strong>文件描述符</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">4</span>&lt;></span> testfile<span class="token comment"># 输入输出时，文件指针是共享的。同时注意>>的追加模式与该特性的使用</span></code></pre></div></figure><p>关闭文件描述符时，一般创建了新的输入输出文件描述符，脚本退出时，<code>shell</code>就会自动关闭它们。手动关闭：<code>exec 3&gt;&amp;-</code>。一旦关闭，就不能在写入&#x2F;读取数据，否则就会报错。</p><h1 id="lsof命令"><a href="#lsof命令" class="headerlink" title="lsof命令"></a>lsof命令</h1><p>网上给的知识有些凌乱，甚至有些错误，所以我会总结几篇文章，最后给一下参考。</p><p><code>lsof--list open files</code>，列出当前系统已经打开的所有文件，一般<code>lsof</code>命令位于<code>/usr/bin/losf</code>或者是<code>/usr/sbin/lsof</code>。因为终端运行时，会有很多文件被打开使用，如果直接使用<code>lsof</code>会出现很多结果，我们在使用时一定要灵活使用相关的选项来控制输出。</p><table><thead><tr><th align="center">选项</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-a</td><td align="center">对给的选项进行<strong>与</strong>运算</td></tr><tr><td align="center">-p<pid></td><td align="center">列出指定进程号所打开的文件</td></tr><tr><td align="center">-d&lt;文件号&gt;</td><td align="center">列出占用该文件号的文件</td></tr><tr><td align="center">+d&lt;目录&gt;</td><td align="center">列出目录下被打开的文件</td></tr><tr><td align="center">-c&lt;进程名&gt;</td><td align="center">列出指定进程所打开的文件</td></tr></tbody></table><p>根据上面的部分选项，我们使用一下该命令</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">lsof</span> -a -p <span class="token variable">$$</span> -d <span class="token number">0,1</span>,2COMMAND   PID <span class="token environment constant">USER</span>   FD   TYPE DEVICE SIZE/OFF NODE NAME<span class="token function">bash</span>    <span class="token number">29075</span> cyan    0u   CHR  <span class="token number">136,0</span>      0t0    <span class="token number">3</span> /dev/pts/0<span class="token function">bash</span>    <span class="token number">29075</span> cyan    1u   CHR  <span class="token number">136,0</span>      0t0    <span class="token number">3</span> /dev/pts/0<span class="token function">bash</span>    <span class="token number">29075</span> cyan    2u   CHR  <span class="token number">136,0</span>      0t0    <span class="token number">3</span> /dev/pts/0<span class="token comment"># 变量$$表示当前shell的pid</span><span class="token comment"># COMMAND:正在运行的命令名的前9个字符</span><span class="token comment"># FD:文件描述符号以及访问类型(r--读，w--写，u--读写)</span><span class="token comment"># TYPE:文件的类型(CHR--字符型，BLK--块型，DIR--目录，REG--常规文件)</span><span class="token comment"># NAME：文件描述符所使用的文件的完整路径名</span></code></pre></div></figure><p>现在编写一个简单的脚本<code>test</code>，本文主要是讲解文件描述符。</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">4</span>></span> four_data<span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token variable">$var</span> -eq <span class="token number">10</span><span class="token punctuation">]</span> <span class="token comment">#死循环</span><span class="token keyword">do</span><span class="token assign-left variable">var</span><span class="token operator">=</span><span class="token number">10</span><span class="token keyword">done</span></code></pre></div></figure><p>使用<code>&amp;</code>将该脚本置入后台运行：<code>./test&amp;</code></p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ ./test<span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token number">88214</span>cyan@cyan-virtual-machine:~/Templates$ <span class="token function">ps</span>    PID TTY          TIME CMD  <span class="token number">88084</span> pts/3    00:00:00 <span class="token function">bash</span>  <span class="token number">88214</span> pts/3    00:00:19 <span class="token builtin class-name">test</span>  <span class="token number">88218</span> pts/3    00:00:00 <span class="token function">ps</span></code></pre></div></figure><p>再使用<code>lsof</code>来查看使用了哪些文件描述符</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ <span class="token function">lsof</span> -a -p <span class="token number">88214</span> -d <span class="token number">4</span>COMMAND   PID <span class="token environment constant">USER</span>   FD   TYPE DEVICE SIZE/OFF   NODE NAME<span class="token builtin class-name">test</span>    <span class="token number">88214</span> cyan    4w   REG    <span class="token number">8,5</span>        <span class="token number">0</span> <span class="token number">935362</span> /home/cyan/Templates/four_data</code></pre></div></figure><p><code>-p 88214</code>是寻找进程为<code>pid=88214</code>的进程打开的文件，<code>-d 4</code>找到使用<code>4</code>文件描述符的文件，<code>-a</code>对<code>-p 88214</code> 和<code>-d 4</code>进行与运算。</p><p>所以，你也可以尝试以下命令</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">lsof</span> -p pid<span class="token comment"># 查看这个进程的文件到底占用了哪些描述符</span></code></pre></div></figure><p>完成案例讲解，将<code>test</code>的进程杀死</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ <span class="token function">kill</span> <span class="token number">88214</span>cyan@cyan-virtual-machine:~/Templates$ <span class="token function">ps</span>    PID TTY          TIME CMD  <span class="token number">88084</span> pts/3    00:00:00 <span class="token function">bash</span>  <span class="token number">88243</span> pts/3    00:00:00 <span class="token function">ps</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>+  Terminated              ./test</code></pre></div></figure><p><code>lsof</code>命令很强大，这里我们只是用来查看文件描述符，如果你想要深入了解，可以参考以下文章</p><blockquote><p>Linux 查看端口占用情况：<a href="https://www.runoob.com/w3cnote/linux-check-port-usage.html">https://www.runoob.com/w3cnote/linux-check-port-usage.html</a></p><p>lsof命令详解：<a href="https://www.cnblogs.com/klausage/p/14995042.html">https://www.cnblogs.com/klausage/p/14995042.html</a> （其实并不是很详细）</p><p>lsof入门：<a href="https://www.qieseo.com/162896.html">https://www.qieseo.com/162896.html</a></p></blockquote><h1 id="阻止命令输出"><a href="#阻止命令输出" class="headerlink" title="阻止命令输出"></a>阻止命令输出</h1><p><code>Linux</code>有一个文件叫<code>null(/dev/null)</code>，<code>shell</code>输出到<code>null</code>文件的任何数据都不会被保存，全部都被丢掉。所以，不希望后台输出错误信息时，<code>shell</code>发送电子邮件给进程属主的话，就将<code>STDERR</code>重定向到<code>null</code>。<code>null</code>文件可以快速清除现有文件中的数据而不需要删除文件再重新创建<code>cat /dev/null &gt; testfile</code>，类似于清空日志文件。哦，其实我个人更喜欢<code>echo &quot;&quot; &gt; testfile</code>。</p><h1 id="创建临时文件"><a href="#创建临时文件" class="headerlink" title="创建临时文件"></a>创建临时文件</h1><p><code>/tmp</code>目录是<code>Linux</code>用来存放不永久保留的文件，大部分<code>Linux</code>发行版配置了系统在启动时自动删除<code>/tmp</code>目录的所有文件。任何用户账户都有权限在<code>/tmp</code>读写。<br>单独<code>mktemp</code>命令可以在<code>/tmp</code>目录中创建一个唯一的临时文件。<code>shell</code>会创建该文件，但不是使用默认的<code>umask</code>，会将文件读和写权限分给属主，并将你设为属主。但是其他人没法访问(root除外)。</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ mktemp/tmp/tmp.thPVXNPVJp</code></pre></div></figure><p>也可以自定义文件名，但是会在当前目录下创建该文件</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># mktemp会用6个字符替换6个X，保证文件名唯一</span>cyan@cyan-virtual-machine:~/Templates$ mktemp test.XXXXXXtest.k5CvV0<span class="token comment"># 在脚本中，一般将创建的文件名保存在变量中</span><span class="token assign-left variable">filename</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>mktemp test.XXXXXX<span class="token variable">)</span></span></code></pre></div></figure><p>还可以使用选项</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 在/tmp下创建，返回全路径名</span>cyan@cyan-virtual-machine:~/Templates$ mktemp -t test.XXXXXX/tmp/test.LRNlpY<span class="token comment"># -d选项创建临时目录</span>cyan@cyan-virtual-machine:~/Templates$ mktemp -d dir.XXXXXXdir.Adr0Q6cyan@cyan-virtual-machine:~/Templates$ mktemp -d -t dir.XXXXXX/tmp/dir.H9rIut</code></pre></div></figure><h1 id="记录消息"><a href="#记录消息" class="headerlink" title="记录消息"></a>记录消息</h1><p><code>tee</code>命令：<br>    相当于管道的<code>T</code>型接头，将从<code>STDIN</code>过来的数据同时发送到<code>STDOUT</code>和<code>tee</code>命令行所指定的文件名：<code>tee testfile</code>。</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$  <span class="token function">date</span> <span class="token operator">|</span> <span class="token function">tee</span> testfile<span class="token number">2022</span>年 08月 03日 星期三 <span class="token number">15</span>:51:57 CSTcyan@cyan-virtual-machine:~/Templates$ <span class="token function">cat</span> testfile<span class="token number">2022</span>年 08月 03日 星期三 <span class="token number">15</span>:51:57 CST</code></pre></div></figure><p><code>tee</code>每次都会覆盖文件内容，<code>-a</code>选型是追加模式：<code>who | tee -a testfile</code>。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>下面脚本涉及<code>sql</code>语句，如果你不会，可以跳过。该脚本主要是从.csv文件中读取数据快速生成<code>sql</code>执行文件。</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment"># 文件名create_sql_file</span><span class="token assign-left variable">outfile</span><span class="token operator">=</span><span class="token string">'members.sql'</span> <span class="token comment"># 要输出的文件</span><span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span><span class="token string">','</span> <span class="token comment"># 重新定义分隔符</span><span class="token keyword">while</span> <span class="token builtin class-name">read</span> lname fname address city state <span class="token function">zip</span><span class="token keyword">do</span>    <span class="token function">cat</span> <span class="token operator">>></span> <span class="token variable">$outfile</span> <span class="token operator">&lt;&lt;</span> <span class="token string">EOFINSERT INTO members (lname,fname,address,city,state,zip) VALUES('<span class="token variable">$lname</span>','<span class="token variable">$fname</span>','<span class="token variable">$address</span>','<span class="token variable">$city</span>','<span class="token variable">$state</span>','<span class="token variable">$zip</span>')EOF</span><span class="token keyword">done</span> <span class="token operator">&lt;</span> <span class="token variable">$&#123;1&#125;</span> <span class="token comment"># read的标准输入重定向到$&#123;1&#125;文件。</span></code></pre></div></figure><p>直接使用<code>cat &lt;&lt; file</code>可以追加数据到文件中，然后使用<code>ctrl+d</code>结束。也可以使用<code>&lt;&lt; 结束符</code>，通过输入结束符来结束输入。</p><p>我们写一个<code>mebers.csv</code>数据</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ <span class="token function">cat</span> members.csvCyan,Jack,US,qiqo,iasui,iwahMike,Smith,Japen,isaui,uwif,ianas</code></pre></div></figure><p>然后运行脚本生成<code>sql</code>文件。</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ ./create_sql_file members.csvcyan@cyan-virtual-machine:~/Templates$ <span class="token function">cat</span> members.sqlINSERT INTO members <span class="token punctuation">(</span>lname,fname,address,city,state,zip<span class="token punctuation">)</span> VALUES<span class="token punctuation">(</span><span class="token string">'Cyan'</span>,<span class="token string">'Jack'</span>,<span class="token string">'US'</span>,<span class="token string">'qiqo'</span>,<span class="token string">'iasui'</span>,<span class="token string">'iwah'</span><span class="token punctuation">)</span>INSERT INTO members <span class="token punctuation">(</span>lname,fname,address,city,state,zip<span class="token punctuation">)</span> VALUES<span class="token punctuation">(</span><span class="token string">'Mike'</span>,<span class="token string">'Smith'</span>,<span class="token string">'Japen'</span>,<span class="token string">'isaui'</span>,<span class="token string">'uwif'</span>,<span class="token string">'ianas'</span><span class="token punctuation">)</span></code></pre></div></figure>]]></content>
    
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>处理用户输入</title>
    <link href="/2022/08/02/Shell/%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/"/>
    <url>/2022/08/02/Shell/%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>我们之前只是讲了脚本如何输出，也就是<code>echo</code>，本文会讲解脚本如何处理用户的输入。同时我们会涉及到另外一些变量的讲解。</p><h1 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h1><p>我们之前使用过许多命令，他们有些可以接收若干个参数，这其实是通过位置参数来实现的。</p><p><code>$0</code>是程序名，<code>$1~$9</code>是第<code>1~9</code>个参数，超过9时，就要使用<code>$&#123;&#125;</code>，比如<code>$&#123;10&#125;</code>，这样，就允许在运行时加入任意个参数。</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ <span class="token function">cat</span> tmp.txt<span class="token comment">#/bin/bash</span><span class="token builtin class-name">echo</span> <span class="token variable">$0</span><span class="token builtin class-name">echo</span> <span class="token variable">$1</span><span class="token builtin class-name">echo</span> <span class="token variable">$2</span>cyan@cyan-virtual-machine:~/Templates$ ./tmp.txt var1 var2./tmp.txtvar1var2</code></pre></div></figure><p><code>$0</code>是命令行输入的程序名，以绝对(相对)路径运行，<code>$0</code>就是绝对(相对)路径。该特性会对脚本造成不同程度的影响，所以可以使用<code>basename</code>命令，只会返回不包含路径的脚本名：<code>name=$(basename $0)</code>       ​<code>$()</code>是命令替换。<br>注：</p><ul><li>在位置参数使用时，有可能并没有输入这个参数，所以在使用前需要测试参数：<code>if [ -n &quot;$1&quot; ]</code>  测试变量是否存在,<strong>必须要加引号</strong>。</li><li><code>$#</code>是含有脚本运行时携带的命令行参数个数，<code>$@</code>包含所有参数，当作同一字符串多个独立单词，<code>$*</code>是同一字符串，所有参数看作一个单词。</li><li>位置变量中，想要将数字使用变量代替(比如<code>$1</code>)：<code>$(!var)</code>其中var值为1,<code>$&#123;!#&#125;</code>表示最后一个参数，<code>$&#123;&#125;</code>中不能使用<code>$</code>而是使用<code>!</code>代替。</li></ul><p>这几个参数的使用和上述例子差不多，此处不再赘述。</p><h1 id="移动变量"><a href="#移动变量" class="headerlink" title="移动变量"></a>移动变量</h1><p><code>shift</code>命令会默认将所有位置参数都向左移动一位，也就是<code>$1</code>的值变成了<code>$2</code>。<code>$0</code>的值始终不会变。使用shift是遍历位置参数的一个好方法</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash </span><span class="token comment"># demonstrating the shift command </span><span class="token builtin class-name">echo</span> <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">while</span> <span class="token punctuation">[</span> -n <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token punctuation">]</span> <span class="token keyword">do</span>  <span class="token builtin class-name">echo</span> <span class="token string">"Parameter #<span class="token variable">$count</span> = <span class="token variable">$1</span>"</span>  <span class="token assign-left variable">count</span><span class="token operator">=</span>$<span class="token punctuation">[</span> <span class="token variable">$count</span> + <span class="token number">1</span> <span class="token punctuation">]</span>  <span class="token builtin class-name">shift</span> <span class="token keyword">done</span> </code></pre></div></figure><p>也可以给shift传递一个参数，指明参数移动的距离。</p><h1 id="getopt命令"><a href="#getopt命令" class="headerlink" title="getopt命令"></a>getopt命令</h1><p>说实话，这部分当时书上讲得挺让我难受的，痛苦.jpg。</p><p><code>getopt</code>命令可以接受一系列任意形式的<strong>命令行选项和参数</strong>，并将它们转换成适当的格式。说白了，该函数就是用来<strong>解析</strong>命令行选项参数的。</p><p>使用：<code>getopt optstring parameters</code>。</p><p><code>optstring</code>定义了命令可以接受的命令行有效的<strong>选项字母</strong>（要分析的参数），在每个需要参数值的选项字母后面加一个冒号，其参数紧跟在选项后面或者隔一个空格；如果选项字母后面加了2个冒号，则参数和选项之间不能有空格。<code>getopt</code>会基于定义的<code>optstring</code>解析提供的参数。</p><p><code>paramters</code>是实际的参数列表。</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 举个例子</span>cyan@cyan-virtual-machine:~$ getopt ab:cd -a -b test1 -cd test2 test3 -a -b test1 -c -d -- test2 test3</code></pre></div></figure><p>上面例子可以看到，<code>optstring</code>是<code>ab:cd</code>，规定了命令可以接受的有效的选项<code>a,b,c,d</code>。<code>b</code>的后面有冒号，所以<code>-b</code>选项后面必须跟一个参数，例子中是<code>test1</code>。<code>-a -b test1 -cd test2 test3</code>是<code>parameters</code>，里面出现的选项不能是<code>optstring</code>之外的选项。</p><p>注意，它会自动将<code>-cd</code>选项分为两个单独的选项，并<strong>插入双破折号</strong>来分隔行中的额外参数。</p><p>为了帮你更好理解这个命令，我们会写一个脚本，但是在这之前，我希望你能知道<code>set</code>命令。该命令会将位置参数设置为固定的值</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ <span class="token function">cat</span> new_File<span class="token comment">#!/bin/bash</span><span class="token builtin class-name">echo</span> <span class="token variable">$1</span> <span class="token variable">$2</span> <span class="token variable">$3</span><span class="token builtin class-name">set</span> -- 参数1 参数2 参数3<span class="token builtin class-name">echo</span> <span class="token variable">$1</span> <span class="token variable">$2</span> <span class="token variable">$3</span>cyan@cyan-virtual-machine:~/Templates$ ./new_File para1 para2 para3para1 para2 para3参数1 参数2 参数3</code></pre></div></figure><p>现在写一个脚本</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment">#set -- 会将命令行参数替换成set命令的命令行值，挺重要的</span><span class="token comment">#-q可以去掉报错信息，$@是得到脚本后面跟着的参数（字符串形式,同一个字符串多个单词）</span><span class="token builtin class-name">set</span> -- <span class="token variable"><span class="token variable">$(</span>getopt -q ab:cd <span class="token string">"<span class="token variable">$@</span>"</span><span class="token variable">)</span></span><span class="token keyword">while</span> <span class="token punctuation">[</span> -n <span class="token variable">$1</span> <span class="token punctuation">]</span><span class="token keyword">do</span>    <span class="token keyword">case</span> <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token keyword">in</span>     -a<span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"Found the -a option"</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>    -b<span class="token punctuation">)</span> <span class="token assign-left variable">param</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$2</span>"</span>        <span class="token builtin class-name">echo</span> <span class="token string">"Found the -b option,with parameter value <span class="token variable">$param</span>"</span>        <span class="token builtin class-name">shift</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>    -c<span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"Found the -c option"</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>    --<span class="token punctuation">)</span> <span class="token builtin class-name">shift</span>        <span class="token builtin class-name">break</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>    *<span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$1</span> is not an option"</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token keyword">esac</span>    <span class="token builtin class-name">shift</span><span class="token keyword">done</span></code></pre></div></figure><p>所以，我们平时使用的命令的选项+参数，其原理差不多就是这样的（当然不排除更复杂的）。(⊙﹏⊙)，我觉得加上这个脚本例子，你应该很明白<code>getopt</code>到底是干什么的了吧。</p><h1 id="getopts命令"><a href="#getopts命令" class="headerlink" title="getopts命令"></a>getopts命令</h1><p>没错，我当时也很难受，费工夫理解<code>getopt</code>之后，又来一个。</p><p>该命令内建于<code>bash shell</code>，比<code>getopt</code>多了一些扩展功能。使用格式为：<code>getopts optstring variable</code><br><strong>每次只处理命令行一个参数</strong>，处理完所有参数后，就会退出并返回一个大于0的退出码。</p><ol><li>如果要想<code>getiopt -q</code>那样去掉错误信息，需要在<code>optstring</code>前加上一个冒号。</li><li><code>getopts</code>命令会将当前参数（选项）保存在命令行中定义的<code>variable</code>中</li><li><code>getopts</code>命令会用到两个环境变量。选项如果需要一个参数值，<code>OPTARG</code>环境变量就会保存这个值。<code>OPTIND</code>环境变量保存参数列表中<code>getopts</code>正在处理的参数位置。</li></ol><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token builtin class-name">echo</span> <span class="token string">"OPTIND的值为:<span class="token environment constant">$OPTIND</span>"</span><span class="token comment"># 根据第2点，当前选项会被保存在opt中</span><span class="token keyword">while</span> <span class="token builtin class-name">getopts</span> :ab:c opt<span class="token keyword">do</span>    <span class="token keyword">case</span> <span class="token string">"<span class="token variable">$opt</span>"</span> <span class="token keyword">in</span>    <span class="token comment"># 我写的是a而不是-a</span>        a<span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"Found the -a option"</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>        b<span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"Found the -b option,with value <span class="token variable">$OPTARG</span>"</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token comment"># 选项后的参数值</span>        c<span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"Found the -c option"</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>        *<span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"Unkown option:<span class="token variable">$opt</span>"</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token keyword">esac</span>    <span class="token builtin class-name">echo</span> <span class="token string">"OPTIND的值为:<span class="token environment constant">$OPTIND</span>"</span><span class="token keyword">done</span></code></pre></div></figure><p>如果我给的真实的参数列表为：</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ ./tmp.txt -a -btest1 -c test2 test3</code></pre></div></figure><p>得到的结果就是</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token environment constant">OPTIND</span>的值为:1Found the -a option<span class="token environment constant">OPTIND</span>的值为:2Found the -b option,with value test1<span class="token environment constant">OPTIND</span>的值为:3Found the -c option<span class="token environment constant">OPTIND</span>的值为:4</code></pre></div></figure><p>从该脚本中，我们看到了<code>getopts</code>如何根据两个系统变量进行参数控制的。我们不妨将脚本内容改一下</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token builtin class-name">echo</span> <span class="token string">"OPTIND的值为:<span class="token environment constant">$OPTIND</span>"</span><span class="token comment"># 根据第2点，当前选项会被保存在opt中</span><span class="token keyword">while</span> <span class="token builtin class-name">getopts</span> :ab:c opt<span class="token keyword">do</span>   <span class="token comment"># case "$opt" in</span>    <span class="token comment">#    a) echo "Found the -a option" ;;</span>    <span class="token comment">#    b) echo "Found the -b option,with value $OPTARG" ;; # 选项后的参数值</span>    <span class="token comment">#    c) echo "Found the -c option" ;;</span>    <span class="token comment">#   *) echo "Unkown option:$opt";;</span>    <span class="token comment">#esac</span>    <span class="token builtin class-name">echo</span> <span class="token variable">$opt</span>    <span class="token builtin class-name">echo</span> <span class="token string">"OPTIND的值为:<span class="token environment constant">$OPTIND</span>"</span><span class="token keyword">done</span></code></pre></div></figure><p>参数列表不变</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ ./tmp.txt -a -btest1 -c test2 test3<span class="token environment constant">OPTIND</span>的值为:1a<span class="token environment constant">OPTIND</span>的值为:2b<span class="token environment constant">OPTIND</span>的值为:3c<span class="token environment constant">OPTIND</span>的值为:4</code></pre></div></figure><p>在<code>opt=c</code>之后还进行了一次循环，此时opt应该是到了其他参数（<code>test2,test3</code>）那里，但是不会存储相应的值，<code>opt</code>只存储选项的值。</p><h1 id="read命令"><a href="#read命令" class="headerlink" title="read命令"></a>read命令</h1><p><code>read</code>命令用于获取用户输入：</p><ul><li><code>read name</code>输入的数据就会保存在<code>name</code>中。</li><li><code>read -p &quot;Please enter your age:&quot; age</code>， <code>-p</code>参数允许指定输入提示语句。</li><li><code>read -p &quot;Please enter your name:&quot; firstname lastname</code>可以指定多个变量，如果输入大于变量个数，就会将剩下的输入全部保存在最后一个变量中。</li><li>不指定保存变量时，会将输入保存在环境变量<code>REPLY</code>中。</li><li><code>read -t 5 age</code>设置超时选项，如果规定时间没有完成输入，就会继续执行,单位是秒。</li><li><code>read -n1 -p &quot;Please enter [Y/N] to continue:&quot; ans</code>，可以通过<code>-n</code>对输入长度进行限制,数字可以与选项<code>-n</code>一起使用。给的例子中并且只要按下单个字符后，不需要按回车就会继续执行。</li><li><code>read -s -p &quot;Please enter the password:&quot; passwd</code>，<code>-s</code>会让输入时数据隐藏。</li></ul><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment"># 从文件中读取，每次调用read命令就会读取一行文本，当文件没有内容时，read就会退出并返回非0退出状态码</span><span class="token comment"># 文件数据传给read，最常见的就是使用cat，将结果通过管道直接传给含有read命令的while命令</span><span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">1</span><span class="token function">cat</span> data.txt <span class="token operator">|</span> <span class="token keyword">while</span> <span class="token builtin class-name">read</span> line<span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token string">"Line <span class="token variable">$count</span>:<span class="token variable">$line</span>"</span>    <span class="token assign-left variable">count</span><span class="token operator">=</span>$<span class="token punctuation">[</span><span class="token variable">$count</span> + <span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">done</span><span class="token builtin class-name">echo</span> <span class="token string">"Finished proceessign the file"</span></code></pre></div></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>请多加练习。</p>]]></content>
    
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构建基本脚本(2)</title>
    <link href="/2022/08/01/Shell/%E6%9E%84%E5%BB%BA%E5%9F%BA%E6%9C%AC%E8%84%9A%E6%9C%AC(2)/"/>
    <url>/2022/08/01/Shell/%E6%9E%84%E5%BB%BA%E5%9F%BA%E6%9C%AC%E8%84%9A%E6%9C%AC(2)/</url>
    
    <content type="html"><![CDATA[<h1 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h1><p>在脚本中进行数学运算有很多种方式，你可以从下面选几种喜欢的</p><ul><li><code>exper</code>命令，支持基本的（逻辑、比较）运算符，对于有歧义的符号(如<code>*</code>)，需要用<code>\*</code>，<a href="https://www.runoob.com/linux/linux-comm-expr.html">传送门</a>。</li></ul><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># expr 表达式</span><span class="token function">expr</span> length “this is a test”<span class="token comment">#计算字串长度</span><span class="token function">expr</span> <span class="token number">14</span> % <span class="token number">9</span><span class="token comment">#整数运算</span><span class="token function">expr</span> <span class="token number">2</span> <span class="token punctuation">\</span>* <span class="token number">10</span><span class="token comment">#注意。参数和符号之间必须要有空格</span></code></pre></div></figure><ul><li><code>$[表达式]</code>，更加方便，符号不会出现歧义，但是只能整数运算。</li></ul><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">var1</span><span class="token operator">=</span>$<span class="token punctuation">[</span><span class="token number">1</span>+5<span class="token punctuation">]</span></code></pre></div></figure><ul><li><code>bc</code>计算器，实际上是一种编程语言，<code>-q</code>可以不显示<code>bash</code>计算器冗长的欢迎信息。浮点运算是由内建变量<code>scale</code>控制的，必须将这个值设置为计算结果希望保留的小数位数<code>scale</code>默认是0。</li></ul><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~$ <span class="token function">bc</span><span class="token comment"># 欢迎信息</span><span class="token function">bc</span> <span class="token number">1.07</span>.1Copyright <span class="token number">1991</span>-1994, <span class="token number">1997</span>, <span class="token number">1998</span>, <span class="token number">2000</span>, <span class="token number">2004</span>, <span class="token number">2006</span>, <span class="token number">2008</span>, <span class="token number">2012</span>-2017 Free Software Foundation, Inc.This is <span class="token function">free</span> software with ABSOLUTELY NO WARRANTY.For details <span class="token builtin class-name">type</span> `warranty<span class="token string">'.1+34319+42361cyan@cyan-virtual-machine:~$ bc -q21/37#内建变量不能在外面修改cyan@cyan-virtual-machine:~$ echo $scalecyan@cyan-virtual-machine:~$ bc -qscale=3 #进入bc修改内建变量21/37.000# 还有一种修改内建变量的方法，常用于脚本中，格式为echo "options;expression" | bccyan@cyan-virtual-machine:~$ echo '</span><span class="token number">21</span>/4<span class="token string">' | bc5cyan@cyan-virtual-machine:~$ echo '</span>scale<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token number">21</span>/4' <span class="token operator">|</span> <span class="token function">bc</span><span class="token number">5.2500</span></code></pre></div></figure><p>可见，通过管道，<code>bc</code>计算器还是挺好用的。再看一个输入重定向的例子</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~$ <span class="token function">cat</span> math.dat<span class="token assign-left variable">scale</span><span class="token operator">=</span><span class="token number">4</span><span class="token assign-left variable">var1</span><span class="token operator">=</span><span class="token number">1</span><span class="token assign-left variable">var2</span><span class="token operator">=</span><span class="token number">29</span><span class="token assign-left variable">var3</span><span class="token operator">=</span><span class="token number">5</span>var1/var3+var2cyan@cyan-virtual-machine:~$ <span class="token assign-left variable">result</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">bc</span> <span class="token operator">&lt;</span> math.dat<span class="token variable">)</span></span>cyan@cyan-virtual-machine:~$ <span class="token builtin class-name">echo</span> <span class="token variable">$result</span><span class="token number">29.2000</span></code></pre></div></figure><p>有一点你可以看到，我们在<code>bc</code>中使用变量没有加<code>$</code>符号。最后，你也可以试试<strong>内联输入重定向</strong>，我想，应该没什么问题吧？</p><h1 id="结构化语句"><a href="#结构化语句" class="headerlink" title="结构化语句"></a>结构化语句</h1><p>该部分我就直接给格式了，你记住了就会使用。</p><h2 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h2><p>我们如何对<code>if</code>中的条件进行判断？</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> condition1      <span class="token comment">#(退出状态码是0)   </span><span class="token keyword">then</span>    commands_1<span class="token keyword">elif</span> condition2<span class="token keyword">then</span>    commands_2<span class="token keyword">else</span>    commands_3<span class="token keyword">fi</span></code></pre></div></figure><p><code>condition</code>可以是一个命令的正确执行，也可以是字符串比较，数值比较，文件比较。</p><p>判断<code>condition</code>的命令为<code>test condtion</code>或者<code>[ condition ](必须有空格)</code>。同样的，如果有多个<code>condition</code>可以使用<code>&amp;&amp; , ||</code>。</p><p>举个例子</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ <span class="token function">cat</span> tmp.txt<span class="token assign-left variable">var</span><span class="token operator">=</span><span class="token number">100</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$var</span> -ge <span class="token number">10</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">[</span> <span class="token variable">$var</span> -le <span class="token number">190</span> <span class="token punctuation">]</span><span class="token keyword">then</span>    <span class="token builtin class-name">echo</span> <span class="token string">'执行if语句块'</span><span class="token keyword">else</span>    <span class="token builtin class-name">echo</span> <span class="token string">'执行else语句块'</span><span class="token keyword">fi</span>cyan@cyan-virtual-machine:~/Templates$ ./tmp.txt执行if语句块</code></pre></div></figure><p>再次声明，使用<code>[]</code>要加<strong>空格</strong>。</p><h2 id="比较方式"><a href="#比较方式" class="headerlink" title="比较方式"></a>比较方式</h2><p><strong>数值比较</strong>：<code>n1 -eq n2</code></p><table><thead><tr><th align="center">符号选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-eq</td><td align="center">equals(&#x3D;&#x3D;)</td></tr><tr><td align="center">-gt</td><td align="center">greater than(&gt;)</td></tr><tr><td align="center">-ge</td><td align="center">greater equals(&gt;&#x3D;)</td></tr><tr><td align="center">-lt</td><td align="center">less than(&lt;)</td></tr><tr><td align="center">-le</td><td align="center">less equals(&lt;&#x3D;)</td></tr><tr><td align="center">-ne</td><td align="center">not equals(!&#x3D;)</td></tr></tbody></table><p><code>if [ $val -gt 5]</code> ，注意，bash shell只能使用整数。</p><p><strong>字符串比较</strong>：</p><p>直接使用<code>=,!=,\&gt;,\&lt;</code>(大于小于，必须使用转义，否则就会被认为是重定向)。 在比较测试中，<strong>大写字母&lt;小写字母**，如<code>a&gt;z&gt;A</code>。而<code>sort</code>命令恰好相反，<code>sort</code>使用的是系统本地化语言设置中定义的排序顺序。对于英语，</strong>本地化设置指定在排序顺序中，小写字母出现在大写字母前**。</p><p> <code>-n</code>和<code>-z</code>可以检查一个变量是否含有数据(未被定义的变量默认长度为0)</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">if<span class="token punctuation">[</span> -n <span class="token variable">$val</span> <span class="token punctuation">]</span><span class="token comment">#如果val长度不为0，就执行then</span>if<span class="token punctuation">[</span> -z <span class="token variable">$val</span> <span class="token punctuation">]</span><span class="token comment">#如果val长度为0，就执行then，z--zero</span></code></pre></div></figure><p><strong>文件比较</strong>：</p><table><thead><tr><th align="center">符号选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-d file</td><td align="center">检查file是否存在并是一个目录(directory)</td></tr><tr><td align="center">-e file</td><td align="center">检查file是否存在(exits)</td></tr><tr><td align="center">-f file</td><td align="center">检查file是否存在并是否是一个文件</td></tr><tr><td align="center">-r file</td><td align="center">检查file是否存在并是否可读</td></tr><tr><td align="center">-s file</td><td align="center">检查file是否存在并是否非空</td></tr><tr><td align="center">-w file</td><td align="center">检查file是否存在并是否可写</td></tr><tr><td align="center">-x file</td><td align="center">检查file是否存在并是否可执行</td></tr><tr><td align="center">-G file</td><td align="center">检查file是否存在并且默认组与当前用户相同</td></tr><tr><td align="center">-O file</td><td align="center">检查file是否存在并是否并属当前用户所有</td></tr><tr><td align="center">file1 -nt file2</td><td align="center">检查file1是否比file2新</td></tr><tr><td align="center">file1 -ot file2</td><td align="center">检查file1是否比file2旧</td></tr></tbody></table><h3 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h3><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">case</span> variable <span class="token keyword">in</span>                            pattern1 <span class="token operator">|</span> pattern2<span class="token punctuation">)</span>    commands1<span class="token punctuation">;</span><span class="token punctuation">;</span>        pattern3<span class="token punctuation">)</span>   commands2<span class="token punctuation">;</span><span class="token punctuation">;</span>                         *<span class="token punctuation">)</span> defalut commands3<span class="token punctuation">;</span><span class="token punctuation">;</span>                      <span class="token keyword">esac</span>                                       <span class="token comment"># 例子</span><span class="token keyword">case</span> <span class="token environment constant">$USER</span> <span class="token keyword">in</span>Bob <span class="token operator">|</span> Mike<span class="token punctuation">)</span><span class="token builtin class-name">echo</span> <span class="token string">"Number one"</span><span class="token punctuation">;</span><span class="token punctuation">;</span>Cyan<span class="token punctuation">)</span>     <span class="token builtin class-name">echo</span> <span class="token string">"Cyan"</span><span class="token punctuation">;</span><span class="token punctuation">;</span>*<span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"Have not found"</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">esac</span>                                 </code></pre></div></figure><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token for-or-select variable">var</span> <span class="token keyword">in</span> list         <span class="token keyword">do</span>    commands                <span class="token keyword">done</span>                    <span class="token comment">#例子</span><span class="token keyword">for</span> <span class="token for-or-select variable">test</span> <span class="token keyword">in</span> Alabama Alaska Arizona Arkansas California<span class="token keyword">do</span><span class="token builtin class-name">echo</span> The state is <span class="token variable">$test</span><span class="token keyword">done</span></code></pre></div></figure><ul><li><p><code>$test</code>变量在剩余的<code>shell</code>脚本一直有效并且保持着最后一个变量的值(当然是可以修改的)</p></li><li><p><code>list</code>中单个元素出现了单引号，空格等，要么在这个单独变量外部直接再使用一对引号，要么直接使用<code>\</code>转义字符</p></li><li><p><code>list</code>的获取，也可以用<strong>命令的输出+命令替换</strong>：<code>for var in $(cat file)</code>，甚至是<code>/home/cyan/test/*</code>路径。当然，如果变量是文件名，要考虑文件名可能出现空格，那么在使用时就要使用引号：<code>&quot;$file&quot;</code>。</p></li></ul><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 模拟ls指令，打印指定目录下的所有文件（当然这里目录固定为home/cyan）</span><span class="token comment"># 如果想像ls 路径那样传参数，需要用到之后的知识</span>cyan@cyan-virtual-machine:~/Templates$ <span class="token function">cat</span> tmp.txt<span class="token comment">#/bin/bash</span><span class="token keyword">for</span> <span class="token for-or-select variable">file_name</span> <span class="token keyword">in</span> /home/cyan/*<span class="token keyword">do</span>        <span class="token builtin class-name">echo</span> <span class="token variable">$file_name</span><span class="token keyword">done</span>cyan@cyan-virtual-machine:~/Templates$ ./tmp.txt/home/cyan/Desktop/home/cyan/Documents/home/cyan/Downloads/home/cyan/Files/home/cyan/Music/home/cyan/OSIntroduction/home/cyan/Pictures/home/cyan/Public/home/cyan/shtool-2.0.8/home/cyan/shtool-2.0.8.tar.gz/home/cyan/snap/home/cyan/Templates/home/cyan/Videos/home/cyan/vmware-tools-distrib</code></pre></div></figure><ul><li>在<code>list</code>中，各个元素之间的分隔符是由<code>IFS</code>–内部字段分隔符决定的，一般会将<strong>空格，制表符，换行符</strong>作为默认字段分隔符如果想要更改分隔符，就必须在<code>shell</code>脚本<code>for</code>循环前面更改<code>IFS</code>。</li></ul><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ <span class="token function">cat</span> datajack bob cyan mikemary smithcyan@cyan-virtual-machine:~/Templates$ <span class="token function">cat</span> tmp.txt<span class="token comment">#/bin/bash</span><span class="token keyword">for</span> <span class="token for-or-select variable">name</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">`</span><span class="token function">cat</span> data<span class="token variable">`</span></span><span class="token keyword">do</span>        <span class="token builtin class-name">echo</span> <span class="token variable">$name</span><span class="token keyword">done</span><span class="token comment">#得到的结果</span>cyan@cyan-virtual-machine:~/Templates$ ./tmp.txtjackbobcyanmikemarysmith</code></pre></div></figure><p>这是因为<code>IFS</code>默认的是空格，制表符，换行符。在遇到第一个空格时，就已经分隔了。如果想要只以换行符为分隔符</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ <span class="token function">cat</span> tmp.txt<span class="token comment">#/bin/bash</span><span class="token assign-left variable">oldIFS</span><span class="token operator">=</span><span class="token environment constant">$IFS</span><span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span><span class="token string">$'<span class="token entity" title="\n">\n</span>'</span><span class="token keyword">for</span> <span class="token for-or-select variable">file_name</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">`</span><span class="token function">cat</span> data<span class="token variable">`</span></span><span class="token keyword">do</span>        <span class="token builtin class-name">echo</span> <span class="token variable">$file_name</span><span class="token keyword">done</span><span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span><span class="token variable">$oldIFS</span>cyan@cyan-virtual-machine:~/Templates$ ./tmp.txtjack bob cyan mikemary smith</code></pre></div></figure><p>C语言风格的for循环</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> <span class="token number">20</span><span class="token punctuation">;</span>i<span class="token operator">++</span> <span class="token punctuation">))</span></span> <span class="token comment"># i=$(expr $i+1)  i=$[$i + 1]   i=$(echo "scale=0;$i + 1" | bc)</span><span class="token keyword">do</span>    commands<span class="token keyword">done</span></code></pre></div></figure><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">while</span> <span class="token builtin class-name">test</span> conitions<span class="token keyword">do</span>    commands<span class="token keyword">done</span><span class="token comment"># test的替代物[]需要两边空格，而expr的替代物$[]不需要两边空格</span><span class="token comment"># while命令允许执行多个测试命令，但是只有最后一个测试命令的退出状态码会被用于决定什么时候结束循环</span><span class="token comment">#   比如：while [$var1 -ge 0]</span><span class="token comment">#               echo $var1</span><span class="token comment">#   就是一个死循环</span><span class="token comment">#注意，每个测试命令单独一行                </span></code></pre></div></figure><h2 id="until命令"><a href="#until命令" class="headerlink" title="until命令"></a>until命令</h2><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">until</span> <span class="token builtin class-name">test</span> commands<span class="token keyword">do</span>    commands<span class="token keyword">done</span><span class="token comment"># until语句，只有测试条件的退出码非0，才会执行循环中列出的命令。</span></code></pre></div></figure>]]></content>
    
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构建基本脚本(1)</title>
    <link href="/2022/08/01/Shell/%E6%9E%84%E5%BB%BA%E5%9F%BA%E6%9C%AC%E8%84%9A%E6%9C%AC(1)/"/>
    <url>/2022/08/01/Shell/%E6%9E%84%E5%BB%BA%E5%9F%BA%E6%9C%AC%E8%84%9A%E6%9C%AC(1)/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>之前在<code>shell</code>快速入门中已经讲了如何构建一个脚本，我们回顾一下：</p><ul><li>第一行要指定shell类型<code>#!/bin/bash</code>。</li><li>完成基本的脚本构建后，增加执行权限<code>chmod u+x 文件名(u是属主)</code>。</li><li>要取消<code>echo</code>的换行，就要使用<code>-n</code>参数<code>echo -n &quot;abcd&quot;</code>。</li><li>使用美元符号<code>$</code>来引用变量，如果想单纯使用这个符号，要加上转义符<code>\$</code>。</li><li>在脚本中自行设置变量时，&#x3D;之间不能有空格，不然shell会认为是命令而不是变量<code>var=100</code>。</li></ul><p>本文会接着介绍其他与脚本编程相关的知识。</p><h1 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h1><p><code>shell</code>脚本最有用的特性之一就是可以<strong>从命令输出中提取信息</strong>，请<code>get</code>关键词，<strong>命令输出</strong>和<strong>提取信息</strong>。</p><p>该特性有两种实现方式：</p><ul><li>使用反引号（就是<code>Tab</code>键上面那个）</li></ul><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#date命令可以得到当前时间cyan@cyan-virtual-machine:~/Templates$ cat new_File</span><span class="token number">214391248</span>cyan@cyan-virtual-machine:~/Templates$ <span class="token function">cat</span> new_File<span class="token number">214391248</span>cyan@cyan-virtual-machine:~/Templates$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token function">date</span><span class="token variable">`</span></span> <span class="token operator">></span> new_Filecyan@cyan-virtual-machine:~/Templates$ <span class="token function">cat</span> new_File<span class="token number">2022</span>年 08月 01日 星期一 <span class="token number">10</span>:42:33 CSTcyan@cyan-virtual-machine:~$ <span class="token assign-left variable">var</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">date</span><span class="token variable">`</span></span>cyan@cyan-virtual-machine:~$ <span class="token builtin class-name">echo</span> <span class="token variable">$var</span><span class="token number">2022</span>年 08月 01日 星期一 <span class="token number">10</span>:21:55 CST</code></pre></div></figure><ul><li>使用<code>$()</code>，有些<code>shell</code>不支持这种</li></ul><p></p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~$ <span class="token assign-left variable">var</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">date</span><span class="token variable">)</span></span>cyan@cyan-virtual-machine:~$ <span class="token builtin class-name">echo</span> <span class="token variable">$var</span><span class="token number">2022</span>年 08月 01日 星期一 <span class="token number">10</span>:23:19 CST</code></pre></div></figure><p>命令替换会创建一个子<code>shell</code>来运行对应命令，子<code>shell</code>是由运行脚本的<code>shell</code>创建的一个独立的子<code>shell</code>。因此，该子<code>shell</code>所执行的命令是无法使用脚本中所创建的变量的。在命令行提示符下使用路径.&#x2F;来运行命令，也会创建子<code>shell</code></p><p>关于<code>date</code>命令，你如果希望得到自己希望的格式化结果</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~$ <span class="token function">date</span> +%y-%m-%d<span class="token punctuation">\</span> %H:%M:%S<span class="token number">22</span>-08-01 <span class="token number">10</span>:25:33</code></pre></div></figure><h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><p>从这里开始，你就算接触流这个东西了，输入流输出流，<strong>重定向就是对流的方向重新定义</strong>（你现在可以这么理解）。</p><h2 id="标准输出重定向"><a href="#标准输出重定向" class="headerlink" title="标准输出重定向"></a>标准输出重定向</h2><p>举一个例子，<code>echo</code>将数据打印到屏幕上（标准输出流），那么我们可以对<code>echo</code>的流的方向重新<strong>指向</strong></p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ <span class="token function">cat</span> new_File<span class="token number">214391248</span>cyan@cyan-virtual-machine:~/Templates$ <span class="token function">cat</span> new_File<span class="token number">214391248</span>cyan@cyan-virtual-machine:~/Templates$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token function">date</span><span class="token variable">`</span></span> <span class="token operator">></span> new_Filecyan@cyan-virtual-machine:~/Templates$ <span class="token function">cat</span> new_File<span class="token number">2022</span>年 08月 01日 星期一 <span class="token number">10</span>:42:33 CST</code></pre></div></figure><p>从上面代码可以看到，<code>echo</code>通过<code>&gt;</code>符号，将输出重定向到<code>new_File</code>这个文件里面了。并且<strong>先清空文件原本内容</strong>。</p><p><code>command &gt;&gt; outputfile</code>  是追加模式。</p><h2 id="标准输入重定向"><a href="#标准输入重定向" class="headerlink" title="标准输入重定向"></a>标准输入重定向</h2><p>将文件内容重定向到命令：<code>command &lt; inputfile</code></p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># wc命令可以对数据文本进行计数：文本行数  文本字数  文本字节数</span>cyan@cyan-virtual-machine:~/Templates$ <span class="token function">wc</span> <span class="token operator">&lt;</span> new_File <span class="token number">1</span>  <span class="token number">6</span> <span class="token number">43</span></code></pre></div></figure><p>这里有个需要注意的地方就是，<code>&lt;</code>是改变标准输出（屏幕），<code>&gt;</code>是改变标准输入（键盘）。<strong>重定向不是代替参数，而是改变标准输入输出</strong>。</p><p>比如以下命令就不行</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token operator">&lt;</span> new_File</code></pre></div></figure><p><code>echo</code>的使用格式是<code>echo 参数</code>，重定向不能替代参数。</p><p><code>wc</code>后面接收的可以是标准输入</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ <span class="token function">wc</span>line1line2      <span class="token number">2</span>       <span class="token number">2</span>      <span class="token number">12</span> <span class="token comment"># 使用ctrl+d结束命令并统计</span></code></pre></div></figure><h2 id="内联重定向"><a href="#内联重定向" class="headerlink" title="内联重定向"></a>内联重定向</h2><blockquote><p>可以参考：<a href="https://blog.csdn.net/qq_38156104/article/details/110375889">https://blog.csdn.net/qq_38156104/article/details/110375889</a></p></blockquote><p>替换文件为文本，数据流向命令：<code>command &lt;&lt; 特殊字符</code></p><p>数据的开始和结束文本标记要一致。本质就是将开始符和结束符之间的数据传给命令</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ <span class="token function">wc</span> <span class="token operator">&lt;&lt;</span>EOF<span class="token operator">></span> <span class="token number">123</span><span class="token operator">></span> <span class="token number">4142</span><span class="token operator">></span> EOF<span class="token number">2</span> <span class="token number">2</span> <span class="token number">9</span></code></pre></div></figure><h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p>一个命令的<strong>标准输出</strong>作为另一个命令的标准输入</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">rpm</span> -qa <span class="token operator">></span> rpm.list<span class="token function">sort</span> <span class="token operator">&lt;</span> rpm.list</code></pre></div></figure><p><code>rpm</code>命令通过<code>RedHat</code>包管理系统(<code>RPM</code>)对系统上安装的软件包进行管理。配合<code>-qa</code>选项使用时，会生成已安装包的列表，尽管不会排序。(虽然我在终端执行上面两个命令没啥反应)</p><p>重定向在命令之间数据传输比较繁琐，使用管道 <code>|</code> 解决。</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">command</span> <span class="token operator">|</span> <span class="token builtin class-name">command</span></code></pre></div></figure><p>为了更好了解管道，我写了一个<code>c</code>程序，文件为<code>test.c</code>。</p><figure><div class="code-wrapper"><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/time.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">struct</span> <span class="token class-name">timeval</span> start<span class="token punctuation">,</span>end<span class="token punctuation">;</span>        <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"./tmp"</span><span class="token punctuation">,</span>O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> bf<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>                <span class="token function">gettimeofday</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>start<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>bf<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">gettimeofday</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>end<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//printf("%s",bf);</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>end<span class="token punctuation">.</span>tv_usec <span class="token operator">-</span> start<span class="token punctuation">.</span>tv_usec<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre></div></figure><p>在<code>linux</code>中可以用<code>cat</code>查看，如果在后面接上<code>sort</code>命令</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> test.c <span class="token operator">|</span> <span class="token function">sort</span></code></pre></div></figure><p>其输出结果为</p><figure><div class="code-wrapper"><pre class="language-c" data-language="c"><code class="language-c">        <span class="token punctuation">&#123;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token keyword">char</span> bf<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token function">gettimeofday</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>end<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">gettimeofday</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>start<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/time.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>        <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"./tmp"</span><span class="token punctuation">,</span>O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>end<span class="token punctuation">.</span>tv_usec <span class="token operator">-</span> start<span class="token punctuation">.</span>tv_usec<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//printf("%s",bf);</span>                <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>bf<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">timeval</span> start<span class="token punctuation">,</span>end<span class="token punctuation">;</span></code></pre></div></figure>]]></content>
    
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux文件权限</title>
    <link href="/2022/07/31/Shell/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/"/>
    <url>/2022/07/31/Shell/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux安全性"><a href="#Linux安全性" class="headerlink" title="Linux安全性"></a>Linux安全性</h1><p><code>Linux</code>安全系统核心是用户账户，用户账户通过创建用户时分配的用户<code>ID(UID)</code>来跟踪。<code>/etc/password</code>文件将用户的登录名匹配到对应的<code>UID</code>的值<br><code>root</code>账户是<code>Linux</code>管理员，固定分配给的<code>UID</code>是0。<code>Linux</code>会为各种各样的功能创建不同的用户账户，这些账户不是真正的用户，而是系统账户，是系统上运行各种服务进程访问资源用的特殊账户。所有运行在后台的服务都需要用一个系统用户账户登录到Linux系统上！！<strong>在意识到安全问题之前</strong>，许多服务都用<code>root</code>登陆，如果其中一个服务被攻陷，<code>root</code>权限就会被入侵。</p><p><code>/etc/shadow</code>文件，该文件记录各个账户之间密码记录。该文件只有<code>root</code>才有权限操作，所以如果我们不是<code>root</code>用户登录，就需要使用<code>sudo</code>命令。</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~$ <span class="token function">sudo</span> <span class="token function">cat</span> /etc/shadow<span class="token punctuation">[</span>sudo<span class="token punctuation">]</span> password <span class="token keyword">for</span> cyan:root:<span class="token operator">!</span>:18999:0:99999:7:::<span class="token comment"># 其他信息就不展示了</span></code></pre></div></figure><p>每一行就是一个用户，分为九个字段，分别是:<a href="https://blog.csdn.net/sherlockmj/article/details/106786520">参考文章传送门</a> </p><ul><li>与<code>/etc/passwd</code>文件中对应的登录名。</li><li><strong>加密后</strong>的密码，也就是说，你不能直接看到这个密码。</li><li>自上次修改密码后过去的天数，上面的<code>root</code>是18999，就是从1970.1.1不断累加得到的时间，可以使用命令 <code>date -d &quot;1970-01-01 18999 days&quot;</code>查看具体时间。</li><li>最小修改时间间隔，该字段规定了从第 3 字段（最后一次修改密码的日期）起，<strong>多长时间之内不能修改密码</strong>。如果是 0，则密码可以随时修改；如果是 10，则代表密码修改后 10 <strong>天</strong>之内不能再次修改密码。</li><li>密码有效期，默认值为 99999，也就是273年。</li><li>密码需要变更前的警告天数，当账户密码有效期快到时，系统会发出警告信息给此账户，提醒用户 “再过 n 天你的密码就要过期了，请尽快重新设置你的密码！”。</li><li>密码过期后的宽限天数，过期后，在宽限天数内还是可以登录。</li><li>账号失效时间，该字段通常被使用在具有收费服务的系统中。</li><li>最后一个，保留，还没有使用。</li></ul><h1 id="添加新用户"><a href="#添加新用户" class="headerlink" title="添加新用户"></a>添加新用户</h1><p>使用<code>useradd</code>命令，可以一次性创建新用户账户及设置用户<code>HOME</code>目录结构。<code>useradd</code>命令使用系统默认值以及命令行参数设置用户账户。</p><p>系统默认值被设置在<code>/etc/default/useradd</code>，可以使用<code>useradd -D</code>检查默认值</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~$ <span class="token function">useradd</span> -D<span class="token assign-left variable">GROUP</span><span class="token operator">=</span><span class="token number">100</span><span class="token comment"># 新用户被添加到GID=100的公共组</span><span class="token assign-left variable"><span class="token environment constant">HOME</span></span><span class="token operator">=</span>/home<span class="token comment"># 新的home目录位于/home/loginname</span><span class="token assign-left variable">INACTIVE</span><span class="token operator">=</span>-1<span class="token comment"># 密码过期后不会被禁用</span><span class="token assign-left variable">EXPIRE</span><span class="token operator">=</span><span class="token comment"># 未设置过期日期</span><span class="token assign-left variable"><span class="token environment constant">SHELL</span></span><span class="token operator">=</span>/bin/sh<span class="token assign-left variable">SKEL</span><span class="token operator">=</span>/etc/skel<span class="token comment"># 将/etc/skel目录下内容复制到用户的home下</span><span class="token assign-left variable">CREATE_MAIL_SPOOL</span><span class="token operator">=</span>no<span class="token comment"># 是否为该用户在mail目录下创建一个接受邮件的文件</span></code></pre></div></figure><p>上述的系统默认值是可以更改的，在<code>useradd</code>时，加入参数进行更改</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">-b  default_home    <span class="token comment"># 更改默认的创建用户HOME目录的位置</span>-e  expirtion_date  <span class="token comment"># 更改默认的新账户的过期日期</span>-f  inactive        <span class="token comment"># 更改默认的新用户从密码过期到账户被禁用的天数</span>-g  group           <span class="token comment"># 更改默认的组名称或GID</span>-s  shell           <span class="token comment"># 更改默认登录shell</span></code></pre></div></figure><h1 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h1><p><code>userdel</code>命令，默认情况下只会删除<code>/etc/passwd</code>文件中的用户信息，而不会删除系统中属于该账户的任何文件，<code>userdel -r</code>会删除用户的HOME目录以及邮件目录。</p><h1 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h1><p><code>usermod,chsh,chfn,chage</code>这几个指令要用到再自己百度，平时用不到，隔不了多久就会忘记。</p><h1 id="Linux组"><a href="#Linux组" class="headerlink" title="Linux组"></a>Linux组</h1><p>linux通过将具有相同特性的用户划归为一个组，可以大大简化用户的管理，方便用户之间文件的共享。任何一个用户都至少属于一个组，这个组称为初始组，可以同时属于多个附加组。用户不仅拥有初始组的权限，还拥有附加组的权限。</p><p>在<code>/etc/group</code>文件中，包含系统上用到的每个组的信息，4个字段：<strong>组名:组密码:GID:属于该组的用户列表</strong></p><p>用户列表中某些组没有列出用户，并不代表没有成员，只是加入了成员，不会出现在该文件中。</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 创建组</span><span class="token function">groupadd</span> 组名<span class="token comment"># 后期将成员加入到指定组</span><span class="token function">usermod</span> -G 组名 成员名</code></pre></div></figure><h1 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h1><p>在本系列第一篇文章中，为了运行一个新建脚本，需要使用<code>chmod u+x 文件名</code>。查看一个文件，我们可以使用<code>ll</code></p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ lltotal <span class="token number">16</span>drwxr-xr-x  <span class="token number">2</span> cyan cyan <span class="token number">4096</span> <span class="token number">7</span>月  <span class="token number">30</span> <span class="token number">19</span>:09 ./drwxr-xr-x <span class="token number">21</span> cyan cyan <span class="token number">4096</span> <span class="token number">7</span>月  <span class="token number">30</span> <span class="token number">19</span>:09 <span class="token punctuation">..</span>/-rw-rw-r--  <span class="token number">1</span> cyan cyan    <span class="token number">0</span> <span class="token number">7</span>月  <span class="token number">28</span> <span class="token number">15</span>:50 new_File-rwxrw-r--  <span class="token number">1</span> cyan cyan   <span class="token number">49</span> <span class="token number">7</span>月  <span class="token number">30</span> <span class="token number">19</span>:09 test*-rwxrw-r--  <span class="token number">1</span> cyan cyan   <span class="token number">31</span> <span class="token number">7</span>月  <span class="token number">29</span> <span class="token number">16</span>:18 test_1.sh*</code></pre></div></figure><p>得到的结果中，第一位有些是<code>d</code>，有些是<code>-</code>。第一个代表了文件(-)&#x2F;目录(d)&#x2F;链接(l)&#x2F;字符型设备(c)&#x2F;块设备(b)&#x2F;网络设备(n)。</p><p>后面一共是9位，每3位为一个部分（分别表示rwx），这<strong>三个部分</strong>依次属于<strong>文件属主（创建文件的用户）</strong>，<strong>属组成员</strong>，<strong>其他用户</strong>权限。</p><p>目录或者文件一开始创建时，会授予默认权限，默认权限与<code>umask</code>值有关。三个用户权限（<strong>三个部分</strong>）各自占用一个八进制位（0-7），一个部分的权限从<code>&#39;---&#39;</code>到<code>&#39;rwx&#39;</code>在八进制位中表示为<code>0-7</code>，如<code>rw-</code>就是6。三个部分合在一个，就是<code>000-777</code>，也就是<code>---------到rwxrwxrwx</code>。</p><p><code>umask</code>命令用于<strong>设置</strong>创建文件或是目录的<strong>默认权限</strong>，我们先在终端输入<code>umask</code>命令</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ <span class="token builtin class-name">umask</span>0002<span class="token comment"># 你的终端可能会输出0022，我好像是在环境文件做过持久化更改（有点记不清了）</span></code></pre></div></figure><p>第一位是一个关于特殊权限的位，可以暂时不管。后面三个与默认权限有关。</p><p>对于文件而言，默认的最大权限就是<code>666</code>，也就是<code>rw-rw-rw-</code>，目录的默认最大权限是<code>777</code>。如果你学过计算机网络，你会知道<strong>掩码</strong>这个东西。这里就是，最大默认权限<strong>减去</strong>掩码就会得到文件（目录）创建时赋予的权限。</p><p>比如我的掩码<code>umask=0002</code>，那么创建文件时，<code>666-002=664</code>，得到的权限就是<code>rw-rw-r--</code></p><p>验证一下</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ <span class="token function">touch</span> tmp.txtcyan@cyan-virtual-machine:~/Templates$ ll tmp.txt-rw-rw-r-- <span class="token number">1</span> cyan cyan <span class="token number">0</span> <span class="token number">7</span>月  <span class="token number">31</span> <span class="token number">21</span>:30 tmp.txtcyan@cyan-virtual-machine:~/Templates$ <span class="token builtin class-name">umask</span>0002</code></pre></div></figure><p>这里有一篇<a href="https://blog.51cto.com/u_15127673/2803517">文章</a>参考。</p><h1 id="更改权限"><a href="#更改权限" class="headerlink" title="更改权限"></a>更改权限</h1><p>通过<code>chmod</code>命令，可以修改文件的权限</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># chmod 3位八进制权限码 文件名</span>cyan@cyan-virtual-machine:~/Templates$ <span class="token function">chmod</span> <span class="token number">777</span> tmp.txtcyan@cyan-virtual-machine:~/Templates$ ll tmp.txt-rwxrwxrwx <span class="token number">1</span> cyan cyan <span class="token number">0</span> <span class="token number">7</span>月  <span class="token number">31</span> <span class="token number">21</span>:30 tmp.txt*</code></pre></div></figure><p>如果你只是想改变某一部分（属主，组内用户，其他用户）的权限，可以使用</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> u+x 文件名 <span class="token comment"># 属主增加执行权限</span><span class="token function">chmod</span> g-rx 文件名 <span class="token comment"># 组内用户减少</span><span class="token function">chmod</span> <span class="token assign-left variable">o</span><span class="token operator">=</span>rwx 文件名 <span class="token comment"># 其他用户的权限为rwx</span><span class="token comment"># 举例</span>cyan@cyan-virtual-machine:~/Templates$ <span class="token function">chmod</span> g-rx tmp.txtcyan@cyan-virtual-machine:~/Templates$ ll tmp.txt-rwx-w-rwx <span class="token number">1</span> cyan cyan <span class="token number">0</span> <span class="token number">7</span>月  <span class="token number">31</span> <span class="token number">21</span>:30 tmp.txt*<span class="token comment"># 说明</span><span class="token comment"># u:表示用户(属主)  g:表示组  o:表示其他  a:表示所有</span><span class="token comment"># +:增加  -:减少  =:赋值</span></code></pre></div></figure>]]></content>
    
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>B+树索引的使用</title>
    <link href="/2022/07/31/Database/MySQL/B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/31/Database/MySQL/B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文主要讲解索引的具体工作原理以及代价，如何正确的建立索引才能使查询变快。在阅读本文前，请一定保证对之前更新的内容（B+树索引）理解明白。</p><p>现在我们先创建一个表，之后方便举例</p><figure><div class="code-wrapper"><pre class="language-mysql" data-language="mysql"><code class="language-mysql">create table single_table (    id int not null auto_increment    key1 varchar(100),    key2 int    key3 varchar(100),    key_part1 varchar(100),    key_part2 varchar(100),    key_part3 varchar(100),    common_field varchar(100),    primary key(id),    key idx_key1(key1),    unique key uk_key2(key2),    key idx_key3(key3),    key idx_key_part(key_part1,key_part2,key_part3)) engine&#x3D;InnoDB character set&#x3D;utf8; </code></pre></div></figure><h1 id="简化B-树示意图"><a href="#简化B-树示意图" class="headerlink" title="简化B+树示意图"></a>简化B+树示意图</h1><p>我们知道，B+树的非叶子节点是目录项，它是为了定位下一层节点，直到在叶子节点找到对应的记录。其查询算法的本质还是在每个页中使用<strong>二分查找</strong>找到下一层对应的页。那么我们不如将B+树直接简化，只剩下叶子节点。</p>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解shell</title>
    <link href="/2022/07/30/Shell/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3shell/"/>
    <url>/2022/07/30/Shell/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3shell/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>以下是维基百科对<code>shell</code>的定义</p><blockquote><p>普通意义上的shell就是可以接受用户输入命令的程序，Unix操作系统下的shell既是用户交互的界面，也是控制系统的脚本语言。</p></blockquote><p>所以我们可以理解，当你打开终端时，其实就是启动了一个<code>shell</code>，<code>shell</code>有很多种，如<code>bash,zsh,csh</code>等。</p><p>在<code>/etc/passwd</code>中列出了当前用户默认的<code>shell</code>：</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:/etc$ <span class="token function">cat</span> <span class="token function">passwd</span>root:x:0:0:root:/root:/bin/bash<span class="token punctuation">..</span>.cyan:x:1000:1000:cyan,,,:/home/cyan:/bin/bash<span class="token punctuation">..</span>.mysql:x:127:133:MySQL Server,,,:/nonexistent:/bin/false</code></pre></div></figure><p>我们只看部分，可以看到使用的是<code>bash shell</code>。</p><h1 id="父子shell"><a href="#父子shell" class="headerlink" title="父子shell"></a>父子shell</h1><p>系统一开始启动的<code>shell</code>是父<code>shell</code>，在此基础上启动其他<code>shell</code>或是使用命令<code>/bin/bash</code>，被称为子<code>shell</code>。当前进程下的<code>shell</code>，在生成子<code>shell</code>进程时，父进程的部分环境被复制到子<code>shell</code>中。</p><p>结合<code>ps -f / ps --forest</code> 命令我们可以查看当前<code>shell</code>的关系</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 首先进入终端，然后使用bash开启一个新的shell</span>cyan@cyan-virtual-machine:/$ <span class="token function">bash</span><span class="token comment"># 使用ps -f查看当前shell，在18:42打开终端（父shell，PID=67792），在18:49调用bash，进入子</span><span class="token comment"># shell(PID=69555,PPID=67792,PPID--Parent PID)</span>cyan@cyan-virtual-machine:/$ <span class="token function">ps</span> -f<span class="token environment constant">UID</span>          PID    <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMDcyan       <span class="token number">67792</span>   <span class="token number">67791</span>  <span class="token number">0</span> <span class="token number">18</span>:42 pts/1    00:00:00 -bashcyan       <span class="token number">69555</span>   <span class="token number">67792</span>  <span class="token number">0</span> <span class="token number">18</span>:49 pts/1    00:00:00 <span class="token function">bash</span>cyan       <span class="token number">69562</span>   <span class="token number">69555</span>  <span class="token number">0</span> <span class="token number">18</span>:49 pts/1    00:00:00 <span class="token function">ps</span> -f</code></pre></div></figure><p>这么看不是很形象，可以使用<code>--forest</code>选项</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:/$ <span class="token function">ps</span> --forest    PID TTY          TIME CMD  <span class="token number">67792</span> pts/1    00:00:00 <span class="token function">bash</span>  <span class="token number">69555</span> pts/1    00:00:00  <span class="token punctuation">\</span>_ <span class="token function">bash</span>  <span class="token number">69564</span> pts/1    00:00:00      <span class="token punctuation">\</span>_ <span class="token function">ps</span></code></pre></div></figure><p>这里很明显<code>PID=69555</code>的<code>bash</code>是<code>PID=67792</code>的<code>bash</code>的子<code>shell</code>。可是更下面为什么还有个<code>ps</code>，这是后话。</p><h1 id="进程列表"><a href="#进程列表" class="headerlink" title="进程列表"></a>进程列表</h1><p>如果你想一次性执行一系列命令，而不是执行一个输入一个，就可以在命令之间使用分号</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:/$ <span class="token builtin class-name">pwd</span><span class="token punctuation">;</span><span class="token function">ls</span><span class="token punctuation">;</span><span class="token builtin class-name">cd</span> /etc<span class="token punctuation">;</span><span class="token builtin class-name">pwd</span><span class="token punctuation">;</span>/ <span class="token comment">#第一个pwd指令结果</span>bin   cdrom  etc   lib    lib64   lost+found  mnt  proc  run   snap  swapfile  tmp  varboot  dev    home  lib32  libx32  media       opt  root  sbin  srv   sys       usr/etc <span class="token comment"># 第二个pwd指令结果</span></code></pre></div></figure><p>还有一种方式就是使用<strong>进程列表</strong>，需要将这些命令加入括号中，<code>(pwd;ls;cd /etc;pwd;ps -f)</code>。这样会<strong>创建一个子shell来执行对应命令</strong>，其实进程列表是一种命令分组。</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ <span class="token function">ls</span><span class="token punctuation">;</span><span class="token function">ps</span> --forest<span class="token punctuation">;</span>new_File  <span class="token builtin class-name">test</span>  test_1.sh    PID TTY          TIME CMD  <span class="token number">67792</span> pts/1    00:00:00 <span class="token function">bash</span>  <span class="token number">69654</span> pts/1    00:00:00  <span class="token punctuation">\</span>_ <span class="token function">ps</span>  cyan@cyan-virtual-machine:~/Templates$ <span class="token punctuation">(</span>ls<span class="token punctuation">;</span><span class="token function">ps</span> --forest<span class="token punctuation">)</span>new_File  <span class="token builtin class-name">test</span>  test_1.sh    PID TTY          TIME CMD  <span class="token number">67792</span> pts/1    00:00:00 <span class="token function">bash</span>  <span class="token number">69641</span> pts/1    00:00:00  <span class="token punctuation">\</span>_ <span class="token function">bash</span>  <span class="token number">69643</span> pts/1    00:00:00      <span class="token punctuation">\</span>_ <span class="token function">ps</span></code></pre></div></figure><p>很明显，<code>（ls;ps --forest)</code>是在子<code>shell</code>中运行的。</p><p>其实，也可以通过查看环境变量<code>BASH_SUBSHELL</code>查看子shell是否创建，该环境变量返回子shell的个数。</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ <span class="token punctuation">(</span>echo <span class="token variable">$BASH_SUBSHELL</span><span class="token punctuation">)</span><span class="token number">1</span></code></pre></div></figure><p>另一种进程分组：<code>&#123; pwd;ls;cd ~; &#125;</code>花括号+末尾分号，但是<strong>不会创建子shell</strong>,需要注意的是，<strong>花括号与命令和分号之间存在空格</strong>。</p><blockquote><p>退出一个<code>shell</code>需要使用<code>exit</code>，要是使用<code>exit</code>时出现：<code>logout There are stopped jobs.</code>，说明这个子<code>shell</code>中还存在<code>stopped</code>的进程，可以通过<code>kill -9 pid</code>强制杀死进程。</p></blockquote><p>为了使读者对这个问题有更好的认识，现在编写以下脚本</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment">#脚本文件名test</span><span class="token assign-left variable">val</span><span class="token operator">=</span><span class="token number">10</span><span class="token comment"># 很明显，这是一个死循环</span><span class="token keyword">while</span> <span class="token assign-left variable">val</span><span class="token operator">=</span><span class="token number">10</span><span class="token keyword">do</span>        <span class="token assign-left variable">val</span><span class="token operator">=</span><span class="token number">10</span><span class="token keyword">done</span></code></pre></div></figure><p>然后进入子<code>shell</code>执行该脚本，你会看到脚本在不断循环而不会结束，此时使用<code>ctrl+z</code>挂起这个线程</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ <span class="token function">bash</span>cyan@cyan-virtual-machine:~/Templates$ ./test^Z<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>+  Stopped                 ./test</code></pre></div></figure><p>现在你就退不出子<code>shell</code>了，试试<code>exit</code>语句</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ <span class="token builtin class-name">exit</span><span class="token builtin class-name">exit</span>There are stopped jobs.cyan@cyan-virtual-machine:~/Templates$ <span class="token function">ps</span>    PID TTY          TIME CMD  <span class="token number">67792</span> pts/1    00:00:00 <span class="token function">bash</span>  <span class="token number">69675</span> pts/1    00:00:00 <span class="token function">bash</span>  <span class="token number">69681</span> pts/1    00:00:01 <span class="token builtin class-name">test</span>  <span class="token number">69683</span> pts/1    00:00:00 <span class="token function">ps</span>cyan@cyan-virtual-machine:~/Templates$ <span class="token builtin class-name">exit</span><span class="token builtin class-name">exit</span>There are stopped jobs.</code></pre></div></figure><p>很明显，<code>exit</code>没有让你退出子<code>shell</code>，我们看到<code>test</code>进程的<code>PID</code>为69681</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ <span class="token function">kill</span> -9 <span class="token number">69681</span>cyan@cyan-virtual-machine:~/Templates$ <span class="token function">ps</span>    PID TTY          TIME CMD  <span class="token number">67792</span> pts/1    00:00:00 <span class="token function">bash</span>  <span class="token number">69675</span> pts/1    00:00:00 <span class="token function">bash</span>  <span class="token number">69689</span> pts/1    00:00:00 <span class="token function">ps</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>+  Killed                  ./testcyan@cyan-virtual-machine:~/Templates$ <span class="token builtin class-name">exit</span><span class="token builtin class-name">exit</span></code></pre></div></figure><p>哦~有没有觉得自己一下子学了很多东西。</p><h1 id="后台模式"><a href="#后台模式" class="headerlink" title="后台模式"></a>后台模式</h1><p>在命令后使用<code>&amp;</code>,将其置入后台模式，并且可以用<code>ps / jobs</code> 来显示后台作业信息。<code>jobs</code>命令可以显示出当前运行在后台模式中的所有用户的进程。</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ <span class="token function">sleep</span> <span class="token number">1000</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token number">69698</span>cyan@cyan-virtual-machine:~/Templates$ <span class="token function">jobs</span> -l<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>+ <span class="token number">69698</span> Running                 <span class="token function">sleep</span> <span class="token number">1000</span> <span class="token operator">&amp;</span></code></pre></div></figure><p>1是作业号，<code>shell</code>中运行的每个进程被称为作业。后显示作业状态以及命令，-l显示命令PID。使用&amp;将命令置入后台不会创建子<code>shell</code>。</p><p>你应该知道为什么要将命令执行置入后台，假设你有一个一直在循环的脚本，如果这个脚本不执行完，那你就不能输入其他命令。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>会后台生成子<code>shell</code>，子<code>shell</code>执行指令</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ coproc <span class="token function">sleep</span> <span class="token number">10</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token number">69704</span>cyan@cyan-virtual-machine:~/Templates$ <span class="token function">ps</span> --forest    PID TTY          TIME CMD  <span class="token number">67792</span> pts/1    00:00:00 <span class="token function">bash</span>  <span class="token number">69706</span> pts/1    00:00:00  <span class="token punctuation">\</span>_ <span class="token function">ps</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>+  Done                    coproc COPROC <span class="token function">sleep</span> <span class="token number">10</span></code></pre></div></figure><p>当然也可以和进程列表一起使用，还可以命名</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">coproc My_Job <span class="token punctuation">(</span>ls<span class="token punctuation">;</span><span class="token function">sleep</span> <span class="token number">10</span><span class="token punctuation">)</span></code></pre></div></figure><p>My_Job是进程的名字，默认是COPROC。协程coproc与进程列表一起使用，会产生嵌套子shell。<strong>需要牢记的是，生成子shell的成本不低</strong>。</p><h1 id="内建命令"><a href="#内建命令" class="headerlink" title="内建命令"></a>内建命令</h1><p>现在不想更这个，鸽一下</p>]]></content>
    
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux环境变量</title>
    <link href="/2022/07/29/Shell/Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <url>/2022/07/29/Shell/Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在了解<code>Linux</code>的环境变量前，我们先了解一下变量。</p><p>在脚本中使用以下代码</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ <span class="token function">cat</span> <span class="token builtin class-name">test</span><span class="token comment">#!/bin/bash</span><span class="token assign-left variable">val</span><span class="token operator">=</span><span class="token number">10</span><span class="token keyword">while</span> <span class="token builtin class-name">echo</span> val<span class="token keyword">do</span>        <span class="token builtin class-name">echo</span> <span class="token string">" testing... "</span><span class="token keyword">done</span><span class="token comment">#会循环打印：</span><span class="token comment">#val</span><span class="token comment">#testing...</span></code></pre></div></figure><p>在脚本中我们直接定义一个变量，该怎么用呢？直接在终端定义变量，此时变量是什么？</p><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p>划分为局部和全局变量，局部变量只对创建他们的shell可见，<strong>系统环境变量基本都是大写字母</strong>，区别于普通用户的环境变量，查看全局变量可以使用命令<code>env </code>或者<code>printenv</code>。</p><p>查看单个变量的值：<code>printenv $HOME</code>或者<code>echo $HOME</code>。这里给出几个常见的系统环境变量</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ <span class="token builtin class-name">echo</span> <span class="token environment constant">$HOME</span>/home/cyancyan@cyan-virtual-machine:~/Templates$ <span class="token builtin class-name">echo</span> <span class="token environment constant">$PATH</span>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bincyan@cyan-virtual-machine:~/Templates$ <span class="token builtin class-name">echo</span> <span class="token environment constant">$SHELL</span>/bin/bash</code></pre></div></figure><p>你可以把变量前面的美元符号<code>$</code>看作取值，在变量前加上<code>$</code>可以区分它到底是变量还是字符串。</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ <span class="token builtin class-name">echo</span> <span class="token environment constant">$SHELL</span>/bin/bashcyan@cyan-virtual-machine:~/Templates$ <span class="token builtin class-name">echo</span> <span class="token environment constant">SHELL</span><span class="token environment constant">SHELL</span></code></pre></div></figure><p>我们要定义自己的变量，直接定义即可</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 通过cat命令查看test文件内容</span>cyan@cyan-virtual-machine:~/Templates$ <span class="token function">cat</span> <span class="token builtin class-name">test</span><span class="token comment">#!/bin/bash</span><span class="token assign-left variable">val</span><span class="token operator">=</span><span class="token number">10</span><span class="token builtin class-name">echo</span> val<span class="token comment"># 自定义变量value</span>cyan@cyan-virtual-machine:~/Templates$ <span class="token assign-left variable">value</span><span class="token operator">=</span>./test<span class="token comment">#尝试使用value来运行./test</span>cyan@cyan-virtual-machine:~/Templates$ valuevalue: <span class="token builtin class-name">command</span> not found<span class="token comment">#尝试使用value的值来运行./test，但是打印出来的不是10，而是val</span>cyan@cyan-virtual-machine:~/Templates$ <span class="token variable">$value</span>val<span class="token comment">#可见，在脚本中，变量前也需要使用$</span></code></pre></div></figure><p>看到这里你应该对变量有了大概的了解。<code>$</code>相当于取出变量的值，想要定义一个变量，直接定义即可。但是这里有个<strong>致命的坑</strong>，我们平时写代码，为了有较高的可读性，一般在变量和<code>=</code>以及值之间都会加上<strong>空格</strong>，但是这在终端里面是致命的错误</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ val <span class="token operator">=</span> <span class="token number">10</span>Command <span class="token string">'val'</span> not found, did you mean:  <span class="token builtin class-name">command</span> <span class="token string">'pal'</span> from deb pal <span class="token punctuation">(</span><span class="token number">0.4</span>.3-8.1build4<span class="token punctuation">)</span>  <span class="token builtin class-name">command</span> <span class="token string">'cal'</span> from deb bsdmainutils <span class="token punctuation">(</span><span class="token number">11.1</span>.2ubuntu3<span class="token punctuation">)</span>  <span class="token builtin class-name">command</span> <span class="token string">'vala'</span> from deb valac-bin <span class="token punctuation">(</span><span class="token number">0.48</span>.6-0ubuntu1<span class="token punctuation">)</span>  <span class="token builtin class-name">command</span> <span class="token string">'fal'</span> from deb dnet-progs <span class="token punctuation">(</span><span class="token number">2</span>.65build2<span class="token punctuation">)</span>  <span class="token builtin class-name">command</span> <span class="token string">'vax'</span> from deb simh <span class="token punctuation">(</span><span class="token number">3.8</span>.1-6<span class="token punctuation">)</span>  <span class="token builtin class-name">command</span> <span class="token string">'al'</span> from deb mono-devel <span class="token punctuation">(</span><span class="token number">6.8</span>.0.105+dfsg-2<span class="token punctuation">)</span>  <span class="token builtin class-name">command</span> <span class="token string">'vam'</span> from deb vim-addon-manager <span class="token punctuation">(</span><span class="token number">0.5</span>.10<span class="token punctuation">)</span>  <span class="token builtin class-name">command</span> <span class="token string">'pval'</span> from deb snacc <span class="token punctuation">(</span><span class="token number">1.3</span>.1-7build2<span class="token punctuation">)</span>  <span class="token builtin class-name">command</span> <span class="token string">'vl'</span> from deb atfs <span class="token punctuation">(</span><span class="token number">1</span>.4pl6-14<span class="token punctuation">)</span>Try: <span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token operator">&lt;</span>deb name<span class="token operator">></span></code></pre></div></figure><p>因为加上空格，<code>shell</code>（我的是<code>bash</code>）就会认为，你的<code>val</code>（变量名）是一个命令，空格后面的是该命令的参数。而<code>shell</code>没有找到<code>val</code>这个命令就会报错。</p><p>其实随着之后的学习，你会越来越理解<code>Linux</code>中各种设计的巧妙，我们调用的一个又一个命令（大部分），说穿了其实是一个又一个可执行文件，如果你之前在给<code>IDEA</code>，<code>VsCode</code>这些工具配置环境变量时好好了解过到底为什么需要环境变量，那么你很清楚我刚才在说什么。</p><p>对于局部环境变量，bash并没有什么指令可以单独显示，<code>set</code>命令会显示为某个特定进程设置的所有环境变量，输出时会按照字母顺序排序</p><h2 id="设置用户定义变量"><a href="#设置用户定义变量" class="headerlink" title="设置用户定义变量"></a>设置用户定义变量</h2><p>上面已经讲得差不多了，这里再给出几个需要注意的点</p><ul><li>如果变量的值中含有空格，请使用用单（双）引号，<code>val = &quot;hello world&quot;</code>。</li><li>定义用户变量，请坚持使用<strong>小写</strong>字母。</li><li>变量名，等号，值之间不能有空格。</li></ul><h2 id="设置全局环境变量"><a href="#设置全局环境变量" class="headerlink" title="设置全局环境变量"></a>设置全局环境变量</h2><p>我们之前直接创建的变量是局部变量，对其他<code>shell</code>（父子<code>shell</code>）是不可见得。</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~/Templates$ <span class="token assign-left variable">var</span><span class="token operator">=</span><span class="token number">10</span>cyan@cyan-virtual-machine:~/Templates$ <span class="token function">bash</span>cyan@cyan-virtual-machine:~/Templates$ <span class="token builtin class-name">echo</span> <span class="token variable">$var</span>cyan@cyan-virtual-machine:~/Templates$ <span class="token builtin class-name">exit</span><span class="token builtin class-name">exit</span>cyan@cyan-virtual-machine:~/Templates$ <span class="token builtin class-name">echo</span> <span class="token variable">$var</span><span class="token number">10</span></code></pre></div></figure><p>关于父子<code>shell</code>，我不会在这篇文章过多讲解，你要是求知心切，<a href="https://baidu.com/">传送门</a>。</p><p>你现在可以这么理解，<code>bash shell</code>也是一个程序，我们打开终端时，<code>bash</code>也启动了，既然<code>bash</code>是程序，那我们在终端也可以运行<code>bash</code>，这样我们就处于<strong>子shell</strong>，<strong>父子shell</strong>使用不同的内存空间，所以在<strong>父shell</strong>创建的局部变量对<strong>子shell</strong>是不可见的。</p><p>创建全局环境变量的方法：先创建局部环境变量，再导出到全局变量</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">var</span><span class="token operator">=</span><span class="token string">'global'</span><span class="token builtin class-name">export</span> <span class="token string">'global'</span> <span class="token comment">#export就是导出命令，也可以直接导出：export var=global</span></code></pre></div></figure><p>在<strong>子shell</strong>中修改全局变量不会影响<strong>父shell</strong>中该变量的值。根据该性质，在<strong>子shell</strong>中设置全局变量是没有意义的，因为其设置的值，根本不传给父shell。</p><h2 id="删除环境变量"><a href="#删除环境变量" class="headerlink" title="删除环境变量"></a>删除环境变量</h2><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">unset</span> var</code></pre></div></figure><p>解释：</p><ul><li>使用<code>unset</code>指令，可以直接删除变量，不需要加$。$的本质是，得到环境变量的值！</li><li><code>printenv</code>指定了，传入的参数就是一个环境变量（自定义变量不行），可以直接使用。</li><li>在子shell中对全局变量的修改无能反映到父shell，哪怕是删除</li></ul><h2 id="设置PATH环境变量"><a href="#设置PATH环境变量" class="headerlink" title="设置PATH环境变量"></a>设置PATH环境变量</h2><p><code>PATH</code>环境变量定义了用于进行命令和程序查找的目录。</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">cyan@cyan-virtual-machine:~$ <span class="token builtin class-name">echo</span> <span class="token environment constant">$PATH</span>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</code></pre></div></figure><ul><li>如果命令或程序位置没有包含在<code>PATH</code>中，如果不使用路径，<code>shell</code>是没法找到并运行的。就像上一篇文章，我们必须使用<code>./test.sh</code>才能运行该文件，使用<code>test.sh</code>是不行的。</li><li>短暂的修改<code>PATH</code>命令就是：<code>PATH=$PATH:.</code>，一般加<code>.</code>就是包含当前目录，当然也可以加其他路径。这种修改，在<code>exit</code>后会失效。</li></ul><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看当前文件夹下文件</span>cyan@cyan-virtual-machine:~/Templates$ <span class="token function">ls</span>new_File  <span class="token builtin class-name">test</span>  test_1.sh<span class="token comment"># 查看文件test_1.sh脚本内容--打印Hello World</span>cyan@cyan-virtual-machine:~/Templates$ <span class="token function">cat</span> test_1.sh<span class="token comment">#!/bin/bash</span><span class="token builtin class-name">echo</span> <span class="token string">"Hello World"</span><span class="token comment"># 希望直接使用这个脚本名作为命令</span>cyan@cyan-virtual-machine:~/Templates$ test_1.shtest_1.sh: <span class="token builtin class-name">command</span> not found<span class="token comment"># 将当前目录加到PATH中</span>cyan@cyan-virtual-machine:~/Templates$ <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span>:.cyan@cyan-virtual-machine:~/Templates$ test_1.shHello World</code></pre></div></figure><p>如果你还没明白，可以参考以下这个（我觉得和我讲的差不多）<a href="http://www.manongjc.com/detail/24-braxhrzgczfkpwt.html">如何理解PATH</a>。如果还是不懂，真拿你没办法，就再给个 <a href="https://baidu.com/">真正的传送门</a>。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>关于如何持久化创建一个环境变量，这涉及到修改一些系统文件，文件权限以及<code>shell</code>进程的一些知识，之后再说吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo搭建博客指南</title>
    <link href="/2022/07/29/Tools/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%8C%87%E5%8D%97/"/>
    <url>/2022/07/29/Tools/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用Hexo+Github搭建博客，因为涉及到部分插件或者安装包的下载，<del>建议使用魔法上网</del>。</p><blockquote><p>推荐文章：<a href="https://zhuanlan.zhihu.com/p/26625249">https://zhuanlan.zhihu.com/p/26625249</a></p><p>推荐视频：<a href="https://www.bilibili.com/video/BV1mU4y1j72n?spm_id_from=333.337.search-card.all.click&amp;vd_source=5acf5a7b23d28e7633e5a9b381c57c42">https://www.bilibili.com/video/BV1mU4y1j72n?spm_id_from=333.337.search-card.all.click&amp;vd_source=5acf5a7b23d28e7633e5a9b381c57c42</a></p></blockquote><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="下载Node-js"><a href="#下载Node-js" class="headerlink" title="下载Node.js"></a>下载Node.js</h2><p>简单的说 Node.js 就是运行在服务端的 JavaScript。Node.js 是一个基于 <a href="https://developers.google.com/v8/">Chrome V8</a> 引擎的 <strong>JavaScript 运行环境</strong>。Node.js 使用了一个事件驱动、非阻塞式 I&#x2F;O 的模型，使其轻量又高效。Node.js 的包管理器 <a href="https://www.npmjs.com/">npm</a>，是全球最大的开源库生态系统。</p><p>官网下载:<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p><p>安装完成后，可以通过命令行查看：<code>node -v</code>显示安装版本，<code>npm -v</code>显示npm版本。新版的Node.js已自带npm，安装Node.js时会一起安装，<strong>npm的作用就是对Node.js依赖的包进行管理，也可以理解为用来安装&#x2F;卸载Node.js需要的东西。</strong> </p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>npm在安装node.js需要的依赖时，会默认放在C盘<code>C:|Users|用户名\AppData\Roaming\npm</code>，所以此处我们需要手动设置npm安装的全局模块所在的路径，以及缓存cache得路径。</p><p>在nodejs文件夹下创建node_cache,node_global即可。</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/29/90aec5c64426e20a.png" alt="image-20220729144241266"></p><p>拿到相应的路径，在终端执行以下命令：</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> config <span class="token builtin class-name">set</span> prefix <span class="token string">"S:\DevTools\Nodejs<span class="token entity" title="\n">\n</span>ode_global"</span><span class="token function">npm</span> config <span class="token builtin class-name">set</span> cache <span class="token string">"S:\DevTools\Nodejs<span class="token entity" title="\n">\n</span>ode_cache"</span></code></pre></div></figure><p>然后再配置环境变量，先配置系统变量</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/29/b18f9f922882f863.png" alt="image-20220729144419380"></p><p>然后再配置用户变量中的path，之前的值为： <code>C:\Users\Cyan\AppData\Roaming\npm</code>，将其改为下面的值</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/29/71d161b1f67a1e9f.png" alt="image-20220729144448110"></p><h2 id="下载Git"><a href="#下载Git" class="headerlink" title="下载Git"></a>下载Git</h2><p>不多说</p><h2 id="下载Hexo"><a href="#下载Hexo" class="headerlink" title="下载Hexo"></a>下载Hexo</h2><p>在终端执行命令</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-cli --location<span class="token operator">=</span>global</code></pre></div></figure><p>如果下载失败，错误信息显示权限不足，那么请使用管理员身份运行cmd。</p><p>下载完成后，使用<code>hexo -v</code>查看hexo 版本</p><h2 id="Github相关操作"><a href="#Github相关操作" class="headerlink" title="Github相关操作"></a>Github相关操作</h2><p>下面操作以我的Github为例进行讲解。</p><h3 id="建立仓库"><a href="#建立仓库" class="headerlink" title="建立仓库"></a>建立仓库</h3><p>我的Github的昵称是<code>Cyan-N</code>，所以要建立一个仓库叫做：<code>Cyan-N.github.io</code>。<strong>后缀名统一，前面必须是账号的昵称</strong>。</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/29/87a0634c1fc7f4b2.png" alt="image-20220729144929165"></p><h3 id="生成ssh密钥"><a href="#生成ssh密钥" class="headerlink" title="生成ssh密钥"></a>生成ssh密钥</h3><p>随便进入文件夹，然后右键进入 <code>Git Bash Here</code>，调用命令：<code>ssh-keygen -t rsa -C &quot;邮箱&quot;</code>，<strong>此时不要关闭Git</strong>。然后就会在 <code>C:\Users\Cyan\.ssh</code>里面生成<code>id_rsa</code>和<code>id_rsa.pub</code>文件，记事本进入<code>id_rsa.pub</code>，<code>ctrl+a，ctrl+c</code>复制全部指令。</p><p>在<code>Github</code>中，进入<code>setting-&gt;SSH and GPG keys</code>创建<code>SSH Key</code>，<code>title</code>随便取，然后在<code>key</code>中粘贴刚才复制的内容。然后在刚才的Git界面输入以下命令：<code>ssh -T git@github.com</code>。测试ssh是否绑定成功。</p><p>再次强调，<code>Github</code>是国外网站，会抽风。</p><h1 id="使用Hexo"><a href="#使用Hexo" class="headerlink" title="使用Hexo"></a>使用Hexo</h1><h2 id="生成本地网页"><a href="#生成本地网页" class="headerlink" title="生成本地网页"></a>生成本地网页</h2><p>找一个文件夹，用于存放你的博客文件，此处我命名为Blog。然后在这个界面中 <code>Git Bash Here</code>。其实建议以管理员身份运行<code>Git</code>。然后输入命令：<code>hexo init</code>用于初始化。</p><p><code>hexo s</code>用于启动服务，此时会弹出一个网址，就可以通过浏览器来查看，<code>ctrl+c</code>关闭本地服务器，就不能再访问了。</p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>在存放博客文件的文件夹，找到_config.yml文件，在最后面修改为下面代码：</p><figure><div class="code-wrapper"><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># Deployment</span><span class="token comment">## Docs: https://hexo.io/docs/one-command-deployment</span><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> git  <span class="token key atrule">repository</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//github.com/Cyan<span class="token punctuation">-</span>N/Cyan<span class="token punctuation">-</span>N.github.io.git <span class="token comment">#此处就是仓库地址</span>  <span class="token key atrule">branch</span><span class="token punctuation">:</span> main</code></pre></div></figure><h2 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h2><p>在存放博客文件的文件夹，进入Git，这里还是建议管理员身份。执行命令：<code>npm install hexo-deployer-git --save</code>安装Git部署插件。</p><p>然后执行：<code>hexo g</code>生成网页文件，再执行：<code>hexo d</code>提交到Github上，这一步可能会连接超时，多试几次。</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>现在你已经完成了博客的搭建，你可以通过访问你的仓库地址，就是<strong>修改配置</strong>里面的那个网址来访问你的博客。其实还有一些我没有讲，比如域名替换和https使用，更换主题，通过修改主题中的_config.yml实现个性化博客。</p><p>还神起爪子啊，个人赶门去搜一哈（翻译：还愣着干什么，自己马上去搜一下）</p>]]></content>
    
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell快速入门</title>
    <link href="/2022/07/28/Shell/shell%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2022/07/28/Shell/shell%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文及后续文章都是基于<code>bash shell</code>讲解，<code>Linux</code>发行版本为<code>Ubuntu</code>。本文指导读者快速入门<code>shell</code>脚本编程而刻意模糊化其他基本概念，本系列于<code>2022-07-28</code>开始更新，每天更新一个小节，直到结束，主要是讲解<code>shell</code>编程，其中也会涉及到相关的<code>Linux</code>知识。</p><p>整个<code>shell</code>系列不会讲解如何安装双系统，也不会讲解如何安装虚拟机以及<code>Linux</code>相关版本的镜像文件。如果你需要相关的虚拟机和Linux的安装视频，我推荐这个：</p><blockquote><p><a href="https://www.bilibili.com/video/BV18U4y1W7av?spm_id_from=333.999.0.0&amp;vd_source=5acf5a7b23d28e7633e5a9b381c57c42">https://www.bilibili.com/video/BV18U4y1W7av?spm_id_from=333.999.0.0&amp;vd_source=5acf5a7b23d28e7633e5a9b381c57c42</a></p></blockquote><p>B站关注<strong>Micro_Frank</strong>。</p><h1 id="ssh连接Ubuntu"><a href="#ssh连接Ubuntu" class="headerlink" title="ssh连接Ubuntu"></a>ssh连接Ubuntu</h1><p>我不是很喜欢在虚拟机里面使用命令行，所以就在外部通过终端来访问虚拟机上的<code>Ubuntu</code>。</p><ul><li>在<code>Ubuntu</code>中使用命令<code>ifcofig</code>查看系统<code>IP</code>地址。</li></ul><p><img src="https://s3.bmp.ovh/imgs/2022/07/28/e434cc286d6c0917.png" alt="image-20220728152200134"></p><p>当然，有可能使用了<code>ipconfig</code>查不到<code>IP</code>地址，那么请使用<code>sudo dhclient ens33</code>命令，具体你可以百度。</p><ul><li>在自己桌面使用<code>win+r</code>，输入<code>cmd</code>。使用<code>ssh</code>连接：<code>ssh 用户名@IP地址</code>。</li></ul><p><img src="https://s3.bmp.ovh/imgs/2022/07/28/573c6233451b027a.png" alt="image-20220728152655411"></p><p>之前因为某些原因，我的<code>Ubuntu</code>修改过<code>ssh</code>连接的端口号，所以在连接时需要通过<code>-p</code>选项来指定端口号。如果你没有改过，就不需要指定了。</p><h1 id="下载Vim"><a href="#下载Vim" class="headerlink" title="下载Vim"></a>下载Vim</h1><p><code>Vim</code>是一个超级强大的编辑器，我也不是很熟练，主要就是用的少。</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">vim</span></code></pre></div></figure><p>我已经下载过了，就不截图了，实在不会你就去百度。</p><h1 id="创建脚本文件"><a href="#创建脚本文件" class="headerlink" title="创建脚本文件"></a>创建脚本文件</h1><p>作为学习使用，我建议你先创建一个文件夹用来存放你平时写的练习脚本，文件名可以叫<code>Shell_Files</code>，随便你啦。</p><ul><li>进入你刚才创建的文件夹：<code>cd Shell_Files</code>。</li><li>创建一个文件：<code>touch test_1</code>，不需要跟后缀。文件后缀的作用无非就是打开这个文件的方式（你现在可以这么理解），也可以跟<code>sh</code>后缀，比如<code>touch test_1.sh</code>。</li><li>使用<code>vim</code>来编写脚本程序：<code>vim test_1.sh</code>。进入到编辑界面后，请不要乱动键盘，你现在并没有处于编辑模式。敲击<code>i</code>键进入<code>insert</code>模式，你就可以编辑了，你可以输入以下代码</li></ul><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token assign-left variable">val</span><span class="token operator">=</span><span class="token number">10</span><span class="token keyword">while</span> <span class="token builtin class-name">echo</span> <span class="token string">""</span><span class="token keyword">do</span>        <span class="token builtin class-name">echo</span> <span class="token string">" testing... "</span><span class="token keyword">done</span></code></pre></div></figure><p>在<code>shell</code>中，<code>#</code>后面跟的是注释，但是在编写脚本时，你必须加上第一行的注释来指定你要是用的<code>shell</code>，你不会以为<code>shell</code>里面只有<code>bash</code>吧？第二行是定义一个变量（弱类型语言），<code>while</code>里面应该跟上判断条件，条件为<code>true</code>继续执行，为<code>false</code>结束执行。但是<code>echo</code>是自动换行的<strong>打印语句</strong>，所以<strong>成功执行</strong>了<code>echo &quot;&quot;</code>，<code>while</code>里面就判断为<code>true</code>。然后执行<code>echo &quot;testing... &quot;</code>。</p><p>代码编写完后，敲击<code>Esc</code>，再输入冒号，再输入<code>wq</code>，<code>w</code>是<code>write</code>，<code>q</code>是<code>quit</code>。回车，即可保存退出。同学，我劝你不要乱点啊🐶。</p><h1 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h1><p>一般来说，你刚创建的文件只有读<code>r</code>和写<code>w</code>的权限，并没有执行<code>x</code>该文件的权限。请按顺序调用以下命令：</p><ul><li><code>chmod u+x test_1.sh</code>，该命令为脚本文件赋予可执行的权限，其实到这里，你的脚本文件就可以执行了。</li><li><code>touch new_file</code>创建一个新的文件，该文件只有读和写的权限</li><li><code>ll</code>，其实该命令就是<code>ls -al</code>的简写。</li></ul><p><img src="https://s3.bmp.ovh/imgs/2022/07/28/2a7d3da1cb4c1b84.png" alt="image-20220728155413986"></p><p>从上图可以看出，下面两个可执行文件（绿色）比<code>new_File</code>多了一个<code>x</code>，这其实就是执行权限。</p><h1 id="运行脚本文件"><a href="#运行脚本文件" class="headerlink" title="运行脚本文件"></a>运行脚本文件</h1><p>运行文件，只需要执行以下命令</p><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">./test_1.sh</code></pre></div></figure><p>其中<code>./</code>表示当前目录下，<code>test_1.sh</code>是指定文件名。为什么非要加<code>./</code>呢？我明明已经在当前目录下了，能不能直接使用<code>test_1.sh</code>来运行呢？可以，这个涉及到环境变量，这是后话，nice，又挖一个坑，你要是求知心切，就去百度吧。</p><p>哦，你想要停下你的脚本运行，使用<code>ctrl+c</code>即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>B+树索引</title>
    <link href="/2022/07/28/Database/MySQL/B-%E6%A0%91%E7%B4%A2%E5%BC%95/"/>
    <url>/2022/07/28/Database/MySQL/B-%E6%A0%91%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>我们使用sql语句查询某条记录时</p><figure><div class="code-wrapper"><pre class="language-mysql" data-language="mysql"><code class="language-mysql">select * from 表名 where 列名 &#x3D; xxx;</code></pre></div></figure><p><code>where</code>后面跟着的是查询条件，我们之前学的，页中的记录是根据主键排序的（如果没有主键，就根据不能为NULL的唯一的数据排序，如果这样的属性也没有，就按照<code>row_id</code>排序）。</p><p>那么在没有创建索引的情况下，如果我们的查询条件是根据主键查询，那么在页中就可以通过二分查找快速获取数据，但是如果<code>where</code>后面跟着的是一个非主键属性，那么在页中就只能从<code>Infimum</code>到<code>Supremum</code>一条一条的<strong>顺序查找</strong>，<strong>一下子就慢很多</strong>。</p><p>所以我们必须找到一种高效的搜索方法——索引。</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>先建一个表，后面方便演示例子。</p><figure><div class="code-wrapper"><pre class="language-mysql" data-language="mysql"><code class="language-mysql">create table index_demo (    c1 int,    c2 int,    c3 char(1)，    primary key (c1)) row_format &#x3D; COMPACT;</code></pre></div></figure><p>我们知道，一个页默认只有16KB，存储的记录是有限的，所以一个表往往需要很多个页，<strong>页之间的记录也必须保持顺序</strong>，也就是说，<strong>页A的记录主键值必须大于上一个页的记录主键值，小于下一页的记录的主键值</strong>（当然，这里面不包含<code>Infimum</code>和<code>Supremum</code>）。</p><p>前文讲页结构时，<code>File Header</code>中对于页号的规定使得<strong>数据页之间连成双向链表</strong>，我们期望为快速定位记录所在的数据页而建立一个别的目录，该目录实现：</p><ul><li>下一个数据页的记录的主键 &gt; 上一个数据页记录的主键。</li></ul><p>为了实现这个状态，存在<strong>页分裂</strong>的机制。假设上一个页已经满了，最后一条记录主键是100，现在又加入一条记录，主键为90。那么新加入的这条记录就会放到该页末尾，主键为100的记录会被分到新的一个页。</p><ul><li>给所有页建立一个<strong>目录项</strong></li></ul><p>此处是关于页的目录其实对于页的查找也是二分（就是根据页目录，之前的槽<code>Slot</code>是关于记录的<code>Page Directory</code>）。<strong>每个页对应一个目录项</strong>，每个<strong>目录项</strong>包括两部分：<strong>页的最小主键值</strong>+<strong>页号</strong><code>page_no</code>。插入记录时，根据主键值，在所有<strong>目录项</strong>下进行二分查找，找到合适的页后，根据页中的<code>Page Directory</code>进行二分查找，然后页分裂（如果有的话）。最重要的就是，这个目录就叫——<strong>索引</strong>。</p><h2 id="简单的索引方案"><a href="#简单的索引方案" class="headerlink" title="简单的索引方案"></a>简单的索引方案</h2><p>为了实现通过<strong>目录项</strong>来进行二分查找，我们也要<strong>管理目录项</strong>，使其在增删改查时保持有序，所以也把它们放在页中进行管理，这种记录就是<strong>目录项记录</strong><code>record_type = 1</code>（你还记得<code>record_type</code>为0，2，3时是什么意思吗）,该记录也就只有主键值和页号，<strong>当然头信息也是存在的</strong>，因为只有主键值（如果不是变长字段或变长字符集），所以没有变长字段长度列表，也没有NULL列表。</p><p>不断累积，目录项页也存在目录项，这样的目录项又被放进新的目录项页（只不过在上一层），不断向上递归，形成B+树。</p><p>说了那么多，不看图总是懵逼的。</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/28/f4fdab5241230111.png" alt="image-20220728104845461"></p><p>这个图画的我难受。。。。</p><p>上图为了简略，一个记录的内容我只画了：<code>record_type</code>+<code>next_record</code>+<code>c1</code>+<code>c2</code>+<code>c3</code>。</p><p>从图中可以看出，我们真正的记录是放在B+树中的叶子节点，存放目录项记录的都是内节点。</p><p><code>Page Header</code>里面有个属性就是<code>PAGE_LEVEL</code>表示该页在B+树中的层级。其实我们谈索引，什么对某个属性A创建索引，其实就是创建以A排序的B+树（当然，这么说不准确，B+树内容不同，但是你可以这么理解）。我们一开始创建表，指定<code>c1</code>为主键，那么我们插入记录时，<code>InnoDB</code>就会维护上图的B+树，使其有序。如果我们创建关于<code>c2</code>的索引，我们就会得到一个关于<code>c2</code>排序的B+树。</p><blockquote><p>索引的B+树和真正的主键的B+树有什么不同，之后讲到回表你就懂了</p></blockquote><h2 id="索引种类"><a href="#索引种类" class="headerlink" title="索引种类"></a>索引种类</h2><p><strong>聚簇索引</strong>：在InnoDB中，聚簇索引就是数据的存储方式，所有记录都存在叶子节点，“索引即数据，数据即索引”</p><p>二级索引：聚簇索引只有在搜索条件为主键时才能发挥作用，如果以其他列为搜索条件，就要创建关于他们的索引（B+树）才行，这就是二级索引。假设对<code>c2</code>创建索引，该二级索引B+树的叶子节点的记录存储的就是<strong>c2+主键值</strong>。当我们在二级索引中找到对应的<code>c2</code>，我们就可以拿到对应的主键值，然后<strong>再去聚簇索引中找到真正完整的数据，这就是回表</strong>。二级索引之所以不存储完整的记录，<strong>那肯定是为了节省空间啊</strong>。</p><p>联合索引：其本质就是二级索引，因为有时我们会这么查询</p><figure><div class="code-wrapper"><pre class="language-mysql" data-language="mysql"><code class="language-mysql">select * from index_demo where c2 &#x3D; 1 and c3 &#x3D; &#39;1&#39;;</code></pre></div></figure><p>所以我们此时就要创建关于<code>c2,c3</code>的联合索引。</p><p>一个索引的根页面，一旦被创建，其页号就不会改变。一开始是没有数据的，每当存在数据插入，都是在这个根节点下插入</p><h1 id="sql语句"><a href="#sql语句" class="headerlink" title="sql语句"></a>sql语句</h1><figure><div class="code-wrapper"><pre class="language-mysql" data-language="mysql"><code class="language-mysql"># key和index是同义词，随便指定一个即可create table 表名 (    各个列信息    (key|index) 索引名 (要指定的列))alter table 表名 add (key|index) 索引名 (要指定的列)# 删除索引alter table drop (index|key) 索引名</code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>InnoDB页结构</title>
    <link href="/2022/07/26/Database/MySQL/InnoDB%E9%A1%B5%E7%BB%93%E6%9E%84/"/>
    <url>/2022/07/26/Database/MySQL/InnoDB%E9%A1%B5%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前说过，页是InnoDB<strong>管理磁盘空间</strong>的基本单位，一个页的大小基本上是16KB。MySQL规定一页至少存两条记录。我们从客户端写入表中的记录会被存在页中，其实还有一种记录，它存在于B+树的非叶子节点的页中，其头信息中的<code>record_type=1</code>。</p><p>目前你只需理解，页中存储的记录要么是我们从客户端写入的真实的记录<code>record_type=0</code>。这样的页称为<strong>索引页</strong>；另一个是B+树非叶子节点的目录项记录<code>record_type=1</code>。</p><h2 id="页结构"><a href="#页结构" class="headerlink" title="页结构"></a>页结构</h2><p>本节内容主要是就要了解页的大致结构和其存储记录的方式，下图为一个页的基本结构。</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/26/55c753f812c612e5.png" alt="image-20220726110822415"></p><p>之后我们会对其中的结构一 一讲解。但是直接给出很多概念会让你失去阅读兴趣，所以我们先看一下记录怎么在页中存储。</p><h2 id="记录在页中的存储"><a href="#记录在页中的存储" class="headerlink" title="记录在页中的存储"></a>记录在页中的存储</h2><p>请看上图的<code>User Records</code>和<code>Free Space</code>，我们的记录就存放在<code>User Records</code>，如果<code>User Records</code>的空间不够了，就向<code>Free Space</code>去申请空间。所以一个页刚开始创建的时候，是没有<code>User Records</code>的。当<code>Free Space</code>全部被<code>User Record</code>代替时，该页就满了。恭喜，页结构七个概念你已经懂了两个。</p><p>我们的记录在<code>User Record</code>里面是一条一条摆放进去的，但是我现在要提一下一条记录里的<strong>头信息</strong>（你不会已经忘了什么是头信息了吧，不会吧，不会吧）。</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/26/81205e50ebf500f5.png" alt="image-20220725112044762"></p><p><code>record_type</code>可以是，0–普通记录，1–B+树非叶子节点的目录项记录，2–Infimum，3–supremum。请看页结构图，红色区域就是<code>Infimum,supremum</code>，也就是说，每个页固定都有这两条记录，他们代表所有记录中的最小记录（链表头节点）以及所有记录中的最大记录（链表尾节点），<strong>尽管它们没有主键值，但它们就是最小和最大。</strong>这两条记录没有实际内容，但这是规定！这样每次查询记录时，都能从一个固定的起点查询。</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/26/986c7070b2da0836.png" alt="image-20220726131306378"></p><p><code>User Record</code>里面的记录排列紧密，一条紧接另一条。这个其实就是堆，<code>heap_no</code>就是该记录在堆中的相对位置。比如我顺序写入了a,b,c三条记录，它们的<code>heap_no</code>就是2，3，4。至于0和1，它们是<code>Infimum,supremum</code>的<code>heap_no</code>值。其实从图就可以看出，<code>Infimum,supremum</code>在<code>User_record</code>上面。</p><h3 id="next-record的计算"><a href="#next-record的计算" class="headerlink" title="next_record的计算"></a>next_record的计算</h3><p>很好，进入到了喜闻乐见的计算环节，我会尽量让你懂的。</p><p><code>next_record</code>不就是指向下一条记录嘛，那它指向下一条记录的那个部位呢？我们知道，头信息右边是默认添加数据（就是row_id,trx_id,roll_pointer)，接着是真实信息。</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/26/e4c3645b69edae43.png" alt="image-20220726115106879"></p><p><code>next_record</code>指向的是下一条记录的真实信息，其实存储的是一个以字节为单位的偏移量。比如第四条记录的<code>next_record=-111</code>,就是指从第四条记录的真实数据的地址开始，上前找111个字节就是下一条记录的真实数据的地址。</p><p>所以，页中的记录因为<code>next_record</code>而形成了链表，在插入新的记录时，InnoDB始终维护链表中节点的从小到大的顺序（维护顺序当然是为了二分查找）。</p><p>为了让读者感受一下<code>next_record</code>的计算过程，我们创建一个表玩一下</p><figure><div class="code-wrapper"><pre class="language-mysql" data-language="mysql"><code class="language-mysql">create table test_next_record (c1 int,    c2 int,    c3 varchar(10000),    primary key (c1)) character set acsii,row_format&#x3D;COMPACT；#使用 ascii字符集，一个字符用一个字节表示 #插入一条数据insert into test_next_record values(1,100,&#39;aaaa&#39;);</code></pre></div></figure><p>那么在页中实际是这个样子的</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/26/71735b9e7f52f0b7.png" alt="image-20220726130854616"></p><p><code>Infimum</code>中的41是如何计算的：<code>Infimum</code>8字节<code>+Supremum</code>整条记录13字节+变长字段1字节+NULL值列表1字节+头信息5字节+<code>trx_id</code>6字节+<code>roll_pointer</code>7字节&#x3D;41字节。</p><p><code>next_record</code>指向真实信息和头信息中间，这个位置刚刚好，向左是NULL值列表（逆序存放）和变长字段长度列表（逆序存放），向右是真实信息。逆序可以使得记录中靠前的字段和它们对应的字段长度列表在内存中靠得更近，可能会<strong>提高缓存命中率</strong>。</p><h2 id="File-Header"><a href="#File-Header" class="headerlink" title="File Header"></a>File Header</h2><p>校验和：对于一个很长的字符串，通过算法计算出比较短的值代表这个长字符串，这个值就是校验和。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_SPACE_OR_CHKSUM</td><td>(4Byte)空间或校验和，MySQL版本低于4.0.14时，该属性表示本页面所在的<strong>表空间ID</strong>；之后的版本表示页的<strong>校验和</strong></td></tr><tr><td>FIL_PAGE_OFFSET</td><td><strong>页号</strong>，对于页号的分配，并不是连续的，也就是说<strong>使用的页在磁盘上可能并不挨着（当然是尽可能挨着）</strong></td></tr><tr><td>FIL_PAGE_PREV</td><td>上页的页号</td></tr><tr><td>FIL_PAGE_NEXT</td><td>下页的页号（形成双向链表）</td></tr><tr><td>FIL_PAGE_TYPE</td><td><strong>页的类型</strong></td></tr><tr><td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td><td>页属于哪个表空间</td></tr><tr><td>FIL_PAGE_LSN</td><td>页面被最后修改时对应的LSN（Log Sequence Number，日志序列号）</td></tr></tbody></table><p>表格中内容看起来比较多，但是梳理一下就很清晰。</p><p>首先，MySQL具有良好的健壮性，比如内存中的页<strong>正在</strong>被刷新到磁盘中，但是此时突然断电了，导致刷新时只刷了一部分。我们就需要使用校验和来判断一个页是否被完整的刷新到磁盘中，这个在<code>File Trailer</code>部分会讲解到。</p><p>其实，B+树的节点就是页，页与页之间形成一个多叉树的同时，同一层的节点又形成双向链表。</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/26/d5d6dec569020c94.png" alt="image-20220726112224302"></p><p>这样，我们就记住了中间三个属性。最后的<code>FIL_PAGE_TYPE</code>表示页的类型，肯定啊，MySQL这么大，肯定不可能只有1种页。</p><h2 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h2><p>现在记录通过<code>next_record</code>连成了一个有序单向链表，对链表使用二分查找过程大致如下：</p><ul><li>将记录分为若干组，每个组最大的那个记录，其<code>n_owned</code>表示该组记录数。</li><li>将每组最大记录的地址偏移量拿出来，按顺序排列在<code>Page Dierctory</code>中。</li><li>这些偏移量被称为槽–<code>slot</code>，每个槽位2字节，<code>Page Dierctory</code>就是由若干个槽组成。</li><li>你可以把一个个顺序排列的槽看作一个数组，槽对应的记录越小，就越接近<code>File Trailer</code>。</li></ul><p>关键的问题是怎么分组，机制为：</p><ul><li>对于<code>Infimum</code>记录所在的分组，只能有一条记录。即最靠近<code>File Trailer</code>的槽始终是<code>Infimum</code>。</li><li>对于<code>supermum</code>记录所在的分组，可以有1~8条记录。</li><li>其余组只能有4~8条记录，如果组中记录大于8条，会4,5分为两组，并生成一个新的<code>slot</code>。</li><li>每次插入一条记录，该记录都会从页目录中寻找对应记录的主键值比待插入记录主键值大且差值最小的<code>slot</code>（然后找到前一个槽A，A对应的记录开始遍历插入即可）</li></ul><p>配合这种机制，哪怕记录插入表中，记录在每个槽中也会保持有序，并且每个组中记录的主键逐渐紧凑。</p><p>下图省略了记录之间的连接：</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/27/350085bbd3bc62f9.png" alt="image-20220727133511829"></p><p>上图相当于是：<code>slot_0=Infimum</code>，<code>slot_1=4</code>，<code>slot_2=Supremum</code>。假设要查询记录7，就相当于在数组<code>[Min,4,Max]</code>里面进行二分查找，最后找到4，记录4的下一条记录就是槽2的组的记录，就相当于遍历槽2的组，直到找到目标记录。</p><h2 id="Page-Header"><a href="#Page-Header" class="headerlink" title="Page Header"></a>Page Header</h2><p>总共56字节，该结构是存储数据页中记录的状态信息，比如页中的记录数，<code>Free Space</code>的偏移量，页目录有多少个槽等。下图只是部分结构，没有写完，记不住问题也不大，但是看到这里，下面的部分属性你肯定很熟悉。</p><table><thead><tr><th>属性</th><th>长度</th><th>描述</th></tr></thead><tbody><tr><td>PAGE_HEAP_TOP</td><td>2Byte</td><td>还未使用的空间的最小地址，向后走就是Free Space</td></tr><tr><td>PAGE_N_HEAP</td><td>2Byte</td><td>第1位表示是否为紧凑型记录，剩余的15位表示本页的堆中的记录（包括Infimumu,supermum和已删除记录）</td></tr><tr><td>PAGE_FREE</td><td>2Byte</td><td>垃圾链表头节点对应记录在页面中的偏移量</td></tr><tr><td>PAGE_GARBAGE</td><td>2Byte</td><td>已删除记录占用的字节数</td></tr><tr><td>PAGE_DIRECTION</td><td>2Byte</td><td>记录插入的方向，向后是right</td></tr><tr><td>PAGE_N_DIRECTION</td><td>2Byte</td><td>记录连续插入同一个方向的记录条数，当插入方向不同时，马上重置刷新</td></tr><tr><td>PAGE_N_RECS</td><td>2Byte</td><td>该页用户记录的数量（不包括Infimumu,supermum和已删除记录）</td></tr><tr><td>PAGE_MAX_TRX_ID</td><td>8Byte</td><td>修改当前页的最大事务id，该值仅在二级索引页面中定义</td></tr><tr><td>PAGE_LEVEL</td><td>2Byte</td><td>2Byte,该页在B+树中的层级</td></tr></tbody></table><h1 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h1><p>在<code>File Header</code>提到过校验和。如果页从内存刷新到磁盘中断电了，导致之刷新了一部分到磁盘中该怎么办？<code>File Trailer</code>就是为了<strong>检验</strong>一个页是否刷新完整（至于如何恢复，那就的学到日志那才知道了）</p><p>该部分由8个字节组成：</p><ul><li>前四个字节代表页的校验和，该部分与<code>File Header</code>的校验和相对应。 <strong>每次</strong>页在内存中发生<strong>修改</strong>时，在刷新前就要把校验和算出来。以页A（假设校验和为1）刚从磁盘读到内存为例，修改之后校验和为2，那么此时磁盘中的页A和内存中的页A校验和不一样。刷新到磁盘时，<code>File Header</code>的磁盘先被刷新到磁盘中，如果断电导致<code>File Trailer</code>的校验和没有刷新进去，那么磁盘中的<code>File Header</code>与<code>File  trailer</code>的校验和就不一样。</li><li>后四个字节是页面最后被修改时对应的LSN的后4个字节，与<code>File Header</code>相对应，也是检验页完整性。</li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote><p>本文总结于《从根上理解MySQL》第五章p72-p89，作者：小孩子4919。对于有能力或者兴趣的读者，鄙人强烈推荐这本书，如果您能够通过正规渠道购买，支持作者，支持正版，支持每一颗热爱技术的心，我将感激不尽。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC原子类</title>
    <link href="/2022/07/25/Java/%E5%B9%B6%E5%8F%91/JUC%E5%8E%9F%E5%AD%90%E7%B1%BB/"/>
    <url>/2022/07/25/Java/%E5%B9%B6%E5%8F%91/JUC%E5%8E%9F%E5%AD%90%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h1><h2 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h2><p>使用<code>synchronized</code>和<code>ReentrantLock</code> </p><h2 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h2><p>互斥同步最主要的问题是<strong>线程阻塞和唤醒所带来的性能问题</strong>，因此这种同步也称为阻塞同步。</p><p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>我们希望在并发的过程中，先进行操作，如果没有其他线程争用共享数据，那么操作就成功了，否则就采取补偿措施。这种基于冲突检测的乐观的操作许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p><p><strong>乐观锁</strong>需要操作和冲突检测这两个步骤具备原子性，这里的原子性不能够使用互斥同步来保证，只能靠<strong>硬件</strong>来完成。硬件支持的原子性操作最典型的是: <strong>比较并交换</strong>(Compare-and-Swap，CAS)。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p><h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><p>该类是整数原子类，其中很多方法都使用了Unsafe类的CAS操作，以<code>incrementAndGet()</code>为例</p><figure><div class="code-wrapper"><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//AtomicInteger类的increment()方法</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//Unsafe类的getAndInt(Object var1,long var2,int var4)方法</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token keyword">int</span> var4<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//var1指示对象内存地址，var2指示该字段相对对象内存地址的偏移，var4是要加的数值</span>    <span class="token keyword">int</span> var5<span class="token punctuation">;</span><span class="token comment">//step1</span>    <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//通过var1,var2拿到旧值,step2</span>        var5 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIntVolatile</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">,</span> var5<span class="token punctuation">,</span> var5 <span class="token operator">+</span> var4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//进行CAS操作，比较期望的旧值var5和当前内存的值是否相同。进行相加操作</span>        <span class="token keyword">return</span> var5<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre></div></figure><p>上述代码中，<code>step1</code>和<code>step2</code>以及<code>step2-&gt;step3</code>过程都可能出现并发问题，有可能<code>step2</code>拿到<code>var5</code>之后，那片内存的值又被修改，于是<code>while</code>条件中的CAS操作返回<code>false</code>，继续循环，不断冲突检测，直到将数加到内存中。</p><h3 id="ABA"><a href="#ABA" class="headerlink" title="ABA"></a>ABA</h3><p>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</p><p>J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的<strong>版本</strong>来保证 CAS 的正确性。在变量前加上版本号，每次变量更新的时候把版本加1，那么<code>A-&gt;B-&gt;A</code>就会变成<code>1A-&gt;2B-&gt;3A</code>，从前是比较期望的旧值和当前值，现在多比较一个版本号（compareAndSet方法），更新时两个一起更新。</p><p><strong>大部分情况下 ABA 问题不会影响程序并发的正确性</strong>，如果需要解决 ABA 问题，<strong>改用传统的互斥同步可能会比原子类更高效</strong>。</p><h2 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h2><p>涉及线程池，暂不加讲解</p><h1 id="CAS-1"><a href="#CAS-1" class="headerlink" title="CAS"></a>CAS</h1><p>上文已经提到CAS大概是什么，直译就是对比交换，是一条CPU的<strong>原子指令</strong>，CAS是靠硬件实现的，JVM只是封装了汇编调用，那些AtomicInteger类便是使用了这些封装后的接口。</p><p>因为CAS操作时原子性的，所以多线程并发使用CAS更新数据时不用锁。类似sql中的条件更新一样：update set id&#x3D;3 from table where id&#x3D;2。因为单条sql执行具有原子性，如果有多个线程同时执行此sql语句，只有一条能更新成功（就是最后一个执行的那个）。</p><p>CAS方式为乐观锁，synchronized为悲观锁。因此使用 CAS 解决并发问题通常情况下性能更优。</p><p>问题：</p><ul><li><p>ABA问题上文已经说了，此处不再赘述</p></li><li><p>不断循环其实就是自旋，自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p></li><li><p>只能保证一个共享变量的原子操作，多了就可以用锁</p></li></ul><h1 id="Unsafe类详解"><a href="#Unsafe类详解" class="headerlink" title="Unsafe类详解"></a>Unsafe类详解</h1><p>Unsafe是位于<code>sun.misc</code>包下的一个类，主要提供一些用于执行<strong>低级别</strong>、<strong>不安全</strong>操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。</p><p>该类的构造方法是私有的，只有通过反射才能拿到其实例化对象</p><figure><div class="code-wrapper"><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//Unsafe构造方法私有，不能被实例化，通过反射获得对象</span>    <span class="token class-name">Field</span> f <span class="token operator">=</span> <span class="token class-name">Unsafe</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"theUnsafe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    f<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Unsafe</span> unsafe <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Unsafe</span><span class="token punctuation">)</span> f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre></div></figure><p>Unsafe类提供的API大致可分为：内存操作，CAS，Class相关，对象操作，线程调度，系统信息获取，内存屏障，数组操作。</p><p>通过查看源码，其实Unsafe只提供三种CAS方法</p><figure><div class="code-wrapper"><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//paramObject1:int字段所在的对象，paramLong：该字段在该对象中的偏移量，paramObject2：期望的旧值，paramObject3：要更新的值</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> paramObject1<span class="token punctuation">,</span> <span class="token keyword">long</span> paramLong<span class="token punctuation">,</span> <span class="token class-name">Object</span> paramObject2<span class="token punctuation">,</span> <span class="token class-name">Object</span> paramObject3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> paramObject<span class="token punctuation">,</span> <span class="token keyword">long</span> paramLong<span class="token punctuation">,</span> <span class="token keyword">int</span> paramInt1<span class="token punctuation">,</span> <span class="token keyword">int</span> paramInt2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token class-name">Object</span> paramObject<span class="token punctuation">,</span> <span class="token keyword">long</span> paramLong1<span class="token punctuation">,</span> <span class="token keyword">long</span> paramLong2<span class="token punctuation">,</span> <span class="token keyword">long</span> paramLong3<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div></figure><p>这几个都是<code>native</code>方法，由C++代码实现，都位于<code>unsafe.cpp</code>文件中</p><figure><div class="code-wrapper"><pre class="language-c++" data-language="c++"><code class="language-c++">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))  &#x2F;&#x2F;之前的代码展示我们看到，CAS函数是放在while循环中的，也就是说，返回值是一个布尔值。  UnsafeWrapper(&quot;Unsafe_CompareAndSwapInt&quot;);  oop p &#x3D; JNIHandles::resolve(obj);  &#x2F;&#x2F;该函数要更新的是一个jint,所以要先根据对象引用+偏移量得到其地址，也就是对应的指针  jint* addr &#x3D; (jint *) index_oop_from_field_offset_long(p, offset);  &#x2F;&#x2F;很明显，Atomic::cmpxhg才是进行CAS操作（比较+替换）的那一步，x是即将更新的值，e是期望的旧值  return (jint)(Atomic::cmpxchg(x, addr, e)) &#x3D;&#x3D; e;UNSAFE_END</code></pre></div></figure><p>当然，Unsafe类还提供了许多硬件级别的操作</p><figure><div class="code-wrapper"><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 获取给定的 paramField 的内存地址偏移量</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">long</span> <span class="token function">staticFieldOffset</span><span class="token punctuation">(</span><span class="token class-name">Field</span> paramField<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 分配内存</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">long</span> <span class="token function">allocateMemory</span><span class="token punctuation">(</span><span class="token keyword">long</span> paramLong<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 扩充内存</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">long</span> <span class="token function">reallocateMemory</span><span class="token punctuation">(</span><span class="token keyword">long</span> paramLong1<span class="token punctuation">,</span> <span class="token keyword">long</span> paramLong2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 释放内存</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">freeMemory</span><span class="token punctuation">(</span><span class="token keyword">long</span> paramLong<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取数组第一个元素的偏移地址</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">arrayBaseOffset</span><span class="token punctuation">(</span><span class="token class-name">Class</span> paramClass<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div></figure><blockquote><p>关于Unsafe类的更多知识，可以参考美团技术团队的文章：<a href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html">Java魔法类：Unsafe应用解析</a> </p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>InnoDB行格式存储记录</title>
    <link href="/2022/07/25/Database/MySQL/InnoDB%E8%A1%8C%E6%A0%BC%E5%BC%8F%E5%AD%98%E5%82%A8%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/07/25/Database/MySQL/InnoDB%E8%A1%8C%E6%A0%BC%E5%BC%8F%E5%AD%98%E5%82%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>MySQL服务器中负责对表中数据进行读取和写入工作的部分是<strong>存储引擎</strong>，而服务器支持不同类型的存储引擎，如InnoDB，MyISAM，MEMORY等。<strong>真实数据在不同存储引擎的存放格式可能不同</strong>。因为InnoDB现在是MySQL默认的存储引擎，所以会介绍其相关特性。</p><p>在MySQL中，表中的一行数据被称为一条记录，记录保存在页中，页组成B+树，通过二分查找迅速找到记录。如果你还看不太懂，也没太大关系，这句话只是想告诉你InnoDB存储数据的本质。</p><h1 id="InnoDB页"><a href="#InnoDB页" class="headerlink" title="InnoDB页"></a>InnoDB页</h1><p>数据库会频繁发生数据的读取和写入，这就像操作系统的文件系统一样，会发生大量的与磁盘的交互。但是从磁盘中直接读写数据非常慢，也就是说数据库不可能每次读写数据都直接和磁盘交互，所以就将数据分为若干个页，<strong>以页作为磁盘与内存之间交互的基本单位</strong>，其实页的本质也就是一个固定大小的内存。</p><p>InnoDB中的页大小一般是16KB，也就是说，一次从磁盘中读取的数据最少是16KB，每次将内存中的数据刷新到磁盘中最少也是16KB。</p><figure><div class="code-wrapper"><pre class="language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; show variables like &#39;innodb_page_size&#39;;+------------------+-------+| Variable_name    | Value |+------------------+-------+| innodb_page_size | 16384 |+------------------+-------+1 row in set, 1 warning (0.00 sec)# 16 * 1024 &#x3D; 16384#该系统变量不能在服务器运行时修改。</code></pre></div></figure><h1 id="InnoDB行格式"><a href="#InnoDB行格式" class="headerlink" title="InnoDB行格式"></a>InnoDB行格式</h1><p><strong>一条记录的存放格式被称为为行格式或者记录格式</strong>，InnoDB目前有四种行格式：<code>COMPACT</code>，<code>REDUNDANT</code>，<code>DYNAMIC</code>，<code>COMPRESSED</code>。</p><figure><div class="code-wrapper"><pre class="language-mysql" data-language="mysql"><code class="language-mysql"># 指定行格式create table 表名 (列信息) row_format&#x3D;行格式名alter table 表名 row_format&#x3D;行格式</code></pre></div></figure><h2 id="COMPACT行格式"><a href="#COMPACT行格式" class="headerlink" title="COMPACT行格式"></a>COMPACT行格式</h2><p><img src="https://s3.bmp.ovh/imgs/2022/07/25/49b544009f43872c.png" alt="image-20220725103902849"></p><h3 id="变长字段长度列表"><a href="#变长字段长度列表" class="headerlink" title="变长字段长度列表"></a>变长字段长度列表</h3><p>我们先创建一个表，用于之后的示例讲解</p><figure><div class="code-wrapper"><pre class="language-mysql" data-language="mysql"><code class="language-mysql">create table record_format_demo (t1 varchar(10),    t2 varchar(256),    t3 varchar(20) not null) character set &#x3D; ascii row_format &#x3D; COMPACT;</code></pre></div></figure><p>变长字段指的就是varchar(10)这种，不能预先确定存储的数据的大小。在InnoDB读取数据时，如果是一个确定大小的数据，那么就能根据其大小确定偏移量从而读取出正确的数据，但是变长数据是不确定的，所以就需要保存这个变长字段（不为NULL）的长度，来告诉InnoDB这个数据的大小。</p><p>所以变长字段占用的存储空间分为两部分：</p><ul><li>真正的数据内容</li><li>该数据占用的字节数</li></ul><p>在COMPACT行格式中，所有变长字段的真实数据占用字节数都存放在记录的开头位置(十六进制，各字段长度之间没有空格)，从而形成一个变长字段长度列表。各字段占用<strong>字节数</strong>按列的顺序逆序存放，是逆序存放！</p><p>有时用于表示长度的数据，需要占据不止一个字节。比如某一变长字段占字节<code>n=700</code>,那么就需要用到多个字节来表示<code>n</code>，<strong>因为一个字节哪怕加上符号位也表示不了n</strong>。关于使用几个字节，InnoDB有属于自己的规则，此处引入<code>W，M，L</code>三个符号：</p><ul><li><p>W：假设某个<strong>字符集</strong>中最多需要<code>W</code>字节表示一个字符(也就是<code>show charset;</code> 中的<code>MaxLen</code>列)</p></li><li><p>M：对于变长类型<code>VARCHAR(M)</code>来说，这种类型表示能存储最多<strong>M个字符</strong>(是字符，不是字节)，所以该类型最多能存储<code>M*W</code>个字节</p></li><li><p>L：该变长字段<strong>实际存储</strong>的字符数占用的字节数是L</p></li></ul><p>InnoDB在读取记录变长字段长度列表时，<strong>会先查看表结构</strong>，如果某个字段允许存储最大字节数<code>M*W&lt;=255</code>，就认为只是用1字节表示真实数据占用的字节数。</p><p>如果<code>M*W &gt; 255</code>:</p><ul><li>若<code>L &lt;= 127</code> 使用1字节</li><li>若<code>L &gt; 127</code>  使用2字节</li></ul><blockquote><p>255是1个字节（无符号整型）能表示的最大数，即8位全为1，2^8-1&#x3D;255。</p><p>127是1个字节（有符号整型）能表示的最大数，即最高位0，其他7位为1，2^7-1&#x3D;127</p></blockquote><p>该规则主要就是用于区分长度列表中，当<code>M*W &gt; 255</code>时，一个字节到底是一个单独的字段长度**（L &lt;&#x3D; 127）**，还是半个字段长度**（L &gt; 127)**。设计者使用该字节的第一个二进制位作为标志位：如果该字节的第一个位是0，该字节就是一个单独的字段长度，这也就是0~127的第一位都是0。如果第一位为1，那么该字节就是半个字段长度。</p><blockquote><p>其实可以设定，只要M*W &gt; 255 就使用两个字节存储变长字段长度。之所以分的这么细，是想要节省空间，设计者的良苦用心可见一斑</p></blockquote><p>如果某个字段占用字节特别多，InnoDB可能会把该字段的值的一部分数据存放到<strong>溢出页</strong>中，变长度列表只记录留在本页中的数据长度，<br>所以<strong>2字节表示变长字段长度是完全足够的</strong>。同时，长度列表只有在<strong>有必要存在时</strong>，才会存在（存在不为NULL的变长字段）</p><p>对于<code>CHAR(M)</code>而言，如果使用的<strong>字符集</strong>是变长编码字符集，那么该属性也会被加入到变长列表中，并且长度为<code>M*W</code>(该字符集的MaxLen&#x3D;W)。</p><h3 id="NULL值列表"><a href="#NULL值列表" class="headerlink" title="NULL值列表"></a>NULL值列表</h3><p>COMPACT把一条记录的值为NULL的统一管理起来，存储到NULL列表中。处理过程：</p><ul><li>统计表中允许储存NULL的列有哪些(比如主键和NOT NULL会被排除)</li><li>如果表中所有列都不能存储NULL，那么NULL值列表也就不存在。否则将每个允许存储NULL的列对应一个二进制位，位按照列的顺序<strong>逆序</strong>排列，位值为1时，代表该列的值为NULL</li><li>MySQL规定NULL列表必须用整数个字节的位表示，不足高位补0</li></ul><blockquote><p>为什么是逆序之后会提到，先不要着急。</p></blockquote><h3 id="记录头信息"><a href="#记录头信息" class="headerlink" title="记录头信息"></a>记录头信息</h3><p>记录头信息由固定的5个字节（40bit）组成，用于描述记录的一些信息</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/25/75ddfe7a3d59a65d.png" alt="image-20220725112044762"></p><p>​各二进制位的详细信息</p><table><thead><tr><th align="center">名称</th><th align="center"></th></tr></thead><tbody><tr><td align="center">预留位1</td><td align="center">没有使用</td></tr><tr><td align="center">预留位2</td><td align="center">没有使用</td></tr><tr><td align="center">deleted_flag</td><td align="center">标记该记录是否被删除</td></tr><tr><td align="center">min_rec_flag</td><td align="center">B+树的每层非叶子节点中最小目录项记录会添加该标记</td></tr><tr><td align="center">n_owned</td><td align="center">页面中记录会被分为多个组，每个组最大的那个记录作为“大哥”，“大哥“的该标志位会记录组中记录条数</td></tr><tr><td align="center">heap_no</td><td align="center">当前记录在页面堆中的相对位置，记录紧密排列的结构称为堆，前面的记录该值小，后面的值更大</td></tr><tr><td align="center">record_type</td><td align="center">当前记录类型，0–普通记录，1–B+树非叶子节点的目录项记录，2–Infimum，3–supremum</td></tr><tr><td align="center">next_record</td><td align="center">表示下一条记录的相对位置</td></tr></tbody></table><p>这么多，看不懂无所谓，现在记不住无所谓。</p><p>解释：</p><ul><li>deleted_flag中，0表示没有删除，1表示已经删除。尽管一条记录被标志为删除，但是并不会马上从表中移除，<strong>这是避免移除后要重新排列其他记录，造成性能损耗</strong>。所以这些被标志删除的记录，会组成一个垃圾链表，这些空间又被称为可重用空间，如我新插入的记录，垃圾链表中某一个节点（记录）放得下，就会将新纪录覆盖的那条被标志为删除的记录。</li><li>next_record向我们表明记录会被排列成链表，链表是个好东西。</li><li>record_type表示记录的四种类型，在目前知晓的查询算法中，二分查找已非常优秀的，所以在MySQL中大量使用了二分查找。那么就涉及到记录之间的大小比较，一般是通过键值比较大小。规定<code>record_type=2</code>的记录是所有记录中最小的，<code>record_type=3</code>的记录是所有记录中最大的。这两个记录实际不存储任何真实数据，但是它们分别是记录链表中的起点和终点，非常重要。<code>record_type=1</code>暂时不需要知道。之后会讲解</li></ul><h3 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h3><p>我需要提醒一下，标题中的记录都是名词，不是动词。</p><p>对于表来说，记录的真实数据除了我们自己设定的数据（比如<code>name=&#39;cyan&#39;</code>之类的），MySQL还会为每个记录默认地添加一些列(也称为<strong>隐藏列</strong>)。</p><p>​MySQL为每个记录默认添加的列</p><table><thead><tr><th align="center">列名</th><th align="center">是否必需</th><th align="center">占用空间</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">row_id</td><td align="center">非必需</td><td align="center">6字节</td><td align="center">行ID，唯一标识一条记录</td></tr><tr><td align="center">trx_id</td><td align="center">必需</td><td align="center">6字节</td><td align="center">事务ID</td></tr><tr><td align="center">roll_pointer</td><td align="center">必需</td><td align="center">7字节</td><td align="center">回滚指针，形成版本链</td></tr></tbody></table><p>其实上述列名都是大写！并且这三列数据位于额外信息和真实数据中间</p><p>解释：</p><ul><li>row_id是唯一表示一条记录。如果在创建表时没有指定主键或者没有<strong>不能为NULL的唯一属性</strong>，反正就是，没有一个属性能够唯一表示一条记录，那么row_id就会被添加。</li><li>trx_id与事务有关，暂时不需要了解</li><li>roll_pointer是回滚指针，为了方便大家理解，这里不那么准确的讲，MySQL支持回滚操作，也就是说我们改动一条记录后，如果想要回滚到上一个版本，就需要保存上一个版本的数据，那么roll_pointer就是指向上一个版本（改动前）的内存。</li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote><p>本文总结于《从根上理解MySQL》第四章p55-p63，作者：小孩子4919。对于有能力或者兴趣的读者，鄙人强烈推荐这本书，如果您能够通过正规渠道购买，支持作者，支持正版，支持每一颗热爱技术的心，我将感激不尽。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符集与比较规则</title>
    <link href="/2022/07/24/Database/MySQL/%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/"/>
    <url>/2022/07/24/Database/MySQL/%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>计算机中存储的实际上是二进制数据，想要存储字符串，就要建立字符与二进制数据的映射关系。将字符映射为二进制数据的过程叫做<strong>编码</strong>，将二进制数据映射为字符的过程就是<strong>解码</strong>。</p><p>为了容易记忆，你需要知道，解码就是把看不懂的数据（二进制数据）解析为看得懂的数据（字符）。</p><p>因为每个字符实际上是二进制数据，所以他们是可以比较大小的，由此衍生出比较规则。以最经典的ASCII字符集为例，该字符集一共收录<strong>128个字符</strong>，<strong>每个字符由一个字节保存</strong>。字符<strong>a</strong>的二进制编码为<code>1100001</code>，字符<strong>b</strong>的二进制编码为<code>1100010</code>，通过比较就可以看出<code>a&gt;b</code>。</p><p>需要记住几种重要的字符集：</p><ul><li>GBK字符集：在字符范围上对GB2312字符集进行扩充，编码方式兼容GB2312字符集。记住其应用广泛即可</li><li>UTF-8字符集：几乎收录各国（地区）使用的字符，并且在不断扩充。使用变长编码方式，一个字符需要使用1~4个字节</li></ul><p>其实UTF-8只是Unicode字符集的一种<strong>编码方案</strong>，其他的还有UTF-16（2或4字节编码一个字符），UTF-32（4字节）。</p><h1 id="MySQL支持的字符集与比较规则"><a href="#MySQL支持的字符集与比较规则" class="headerlink" title="MySQL支持的字符集与比较规则"></a>MySQL支持的字符集与比较规则</h1><h2 id="utf8mb3和utf8mb4"><a href="#utf8mb3和utf8mb4" class="headerlink" title="utf8mb3和utf8mb4"></a>utf8mb3和utf8mb4</h2><p>我们平常使用的字符一般用 1~3 个字节就可以表示，在MySQL中，<strong>字符集表示一个字符所用的最大字节数会影响系统存储和性能</strong>（比如一条记录中变长数据的存储，之后的文章会讲到）。</p><p>总之，你需要记住的是UTF-8使用 1-4 个字节存储方式有点浪费，所以就有了utf8mb3。</p><ul><li>utf8mb3：阉割版的UTF-8字符集，使用1~3个字节表示一个字符。</li><li>utf8mb4：就是UTF-8字符集，使用1~4个字节。</li></ul><p>在MySQL中，<strong>utf8是utf8mb3的别名</strong>。同时，在MySQL8.0中，utf8mb4被极大优化，成为了默认的字符集。</p><h2 id="字符集的查看"><a href="#字符集的查看" class="headerlink" title="字符集的查看"></a>字符集的查看</h2><figure><div class="code-wrapper"><pre class="language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; show charset;+----------+---------------------------------+---------------------+--------+| Charset  | Description                     | Default collation   | Maxlen |+----------+---------------------------------+---------------------+--------+| big5     | Big5 Traditional Chinese        | big5_chinese_ci     |      2 || dec8     | DEC West European               | dec8_swedish_ci     |      1 || cp850    | DOS West European               | cp850_general_ci    |      1 || hp8      | HP West European                | hp8_english_ci      |      1 || utf8     | UTF-8 Unicode                   | utf8_general_ci     |      3 |+----------+---------------------------------+---------------------+--------+</code></pre></div></figure><p>命令 <code>show (character set | charset) [like 匹配模式];</code> （<code>[]</code>里的内容可以省略）</p><p><code>Maxlen</code>表示该字符集最多需要几个字节表示一个字符。</p><p>​<strong>表1  常用字符集与Maxlen</strong> </p><table><thead><tr><th align="center">Charset</th><th align="center">Maxlen</th></tr></thead><tbody><tr><td align="center">ascii</td><td align="center">1</td></tr><tr><td align="center">latin1</td><td align="center">1</td></tr><tr><td align="center">gb2312</td><td align="center">2</td></tr><tr><td align="center">gbk</td><td align="center">2</td></tr><tr><td align="center">utf8</td><td align="center">3</td></tr><tr><td align="center">utf8mb4</td><td align="center">4</td></tr></tbody></table><p><code>Default collation</code>表示默认的比较规则，<strong>一个字符集可能对应多种比较规则</strong>。</p><figure><div class="code-wrapper"><pre class="language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; show collation like &#39;utf8\_%&#39;;+--------------------------+---------+-----+---------+----------+---------+| Collation                | Charset | Id  | Default | Compiled | Sortlen |+--------------------------+---------+-----+---------+----------+---------+| utf8_general_ci          | utf8    |  33 | Yes     | Yes      |       1 || utf8_bin                 | utf8    |  83 |         | Yes      |       1 || utf8_unicode_ci          | utf8    | 192 |         | Yes      |       8 || utf8_icelandic_ci        | utf8    | 193 |         | Yes      |       8 || utf8_latvian_ci          | utf8    | 194 |         | Yes      |       8 || utf8_romanian_ci         | utf8    | 195 |         | Yes      |       8 || utf8_slovenian_ci        | utf8    | 196 |         | Yes      |       8 || utf8_polish_ci           | utf8    | 197 |         | Yes      |       8 || utf8_estonian_ci         | utf8    | 198 |         | Yes      |       8 || utf8_spanish_ci          | utf8    | 199 |         | Yes      |       8 || utf8_swedish_ci          | utf8    | 200 |         | Yes      |       8 || utf8_turkish_ci          | utf8    | 201 |         | Yes      |       8 || utf8_czech_ci            | utf8    | 202 |         | Yes      |       8 || utf8_danish_ci           | utf8    | 203 |         | Yes      |       8 || utf8_lithuanian_ci       | utf8    | 204 |         | Yes      |       8 || utf8_slovak_ci           | utf8    | 205 |         | Yes      |       8 || utf8_spanish2_ci         | utf8    | 206 |         | Yes      |       8 || utf8_roman_ci            | utf8    | 207 |         | Yes      |       8 || utf8_persian_ci          | utf8    | 208 |         | Yes      |       8 || utf8_esperanto_ci        | utf8    | 209 |         | Yes      |       8 || utf8_hungarian_ci        | utf8    | 210 |         | Yes      |       8 || utf8_sinhala_ci          | utf8    | 211 |         | Yes      |       8 || utf8_german2_ci          | utf8    | 212 |         | Yes      |       8 || utf8_croatian_ci         | utf8    | 213 |         | Yes      |       8 || utf8_unicode_520_ci      | utf8    | 214 |         | Yes      |       8 || utf8_vietnamese_ci       | utf8    | 215 |         | Yes      |       8 || utf8_general_mysql500_ci | utf8    | 223 |         | Yes      |       1 |+--------------------------+---------+-----+---------+----------+---------+27 rows in set (0.00 sec)</code></pre></div></figure><p>命令：<code>show collation [like 匹配模式];</code> </p><p>从命名中可以看出有些与地域有关系，如<code>utf8_spanish_ci</code>是西班牙语的比较规则，<code>utf8_polish_ci</code>则是波兰语的比较规则。</p><p>​<strong>表2  比较规则后缀英文释义及描述</strong> </p><table><thead><tr><th align="center">后缀</th><th align="center">英文释义</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">_ai</td><td align="center">accent insensitive</td><td align="center">不区分重音</td></tr><tr><td align="center">_as</td><td align="center">accent sensitive</td><td align="center">区分重音</td></tr><tr><td align="center">_ci</td><td align="center">case insensitive</td><td align="center">不区分大小写</td></tr><tr><td align="center">_cs</td><td align="center">case(大小写) sensitive</td><td align="center">区分大小写</td></tr><tr><td align="center">_bin</td><td align="center">binary</td><td align="center">以二进制方式比较</td></tr></tbody></table><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>MySQL有四个级别的字符集和比较规则，分别是服务器级别，数据库级别，表级别，列级别。下面解释如何设置和查看不同级别的字符集和比较规则。</p><h3 id="服务器级别"><a href="#服务器级别" class="headerlink" title="服务器级别"></a>服务器级别</h3><p>MySQL提供两个变量来表示服务器级别的字符集和比较规则。</p><p>​<strong>表3  服务器对应的系统变量</strong></p><table><thead><tr><th align="center">系统变量</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">character_set_server</td><td align="center">服务器级别的字符集</td></tr><tr><td align="center">collation_server</td><td align="center">服务器级别的比较规则</td></tr></tbody></table><p>相关命令</p><figure><div class="code-wrapper"><pre class="language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; show variables like &#39;%_server&#39;;+----------------------+-------------------+| Variable_name        | Value             |+----------------------+-------------------+| character_set_server | latin1            || collation_server     | latin1_swedish_ci |+----------------------+-------------------+2 rows in set, 1 warning (0.00 sec)</code></pre></div></figure><p>如果想要修改这两个系统变量，需要通过启动选项或者使用set语句修改 <code>set global/session varName = value</code>（如果看不懂命令，之后的文章会提到<code>global/session</code>）</p><h3 id="数据库级别"><a href="#数据库级别" class="headerlink" title="数据库级别"></a>数据库级别</h3><p>字符集和比较规则在创建和修改数据库时可以指定该数据库的字符集和比较规则</p><figure><div class="code-wrapper"><pre class="language-mysql" data-language="mysql"><code class="language-mysql">create database 数据库名[[default] character set 字符集名称][[default] collation 比较规则名称]alter database 数据库名[[default] character set 字符集名称][[default] collation 比较规则名称]</code></pre></div></figure><p>数据库级别也有两个系统变量，当我们使用<code>use</code>语句选择一个数据库时，这两个系统变量的值就是该数据库的字符集和比较规则。<strong>如果没有选择数据库，它们的值和服务器级别的系统变量值相同</strong>。</p><p>​<strong>表4  数据库对应的系统变量</strong> </p><table><thead><tr><th align="center">系统变量</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">character_set_database</td><td align="center">当前数据库的字符集</td></tr><tr><td align="center">collation_databased</td><td align="center">当前数据库的比较规则</td></tr></tbody></table><p>我们不能通过修改这两个系统变量的值来改变当前数据库的字符集和比较规则。</p><figure><div class="code-wrapper"><pre class="language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; show variables like &#39;%_server&#39;;+----------------------+-------------------+| Variable_name        | Value             |+----------------------+-------------------+| character_set_server | latin1            || collation_server     | latin1_swedish_ci |+----------------------+-------------------+2 rows in set, 1 warning (0.00 sec)mysql&gt; create database test;Query OK, 1 row affected (0.01 sec)mysql&gt; use test;Database changedmysql&gt; show variables like &#39;%_database&#39;;+------------------------+-------------------+| Variable_name          | Value             |+------------------------+-------------------+| character_set_database | latin1            || collation_database     | latin1_swedish_ci || skip_show_database     | OFF               |+------------------------+-------------------+3 rows in set, 1 warning (0.00 sec)</code></pre></div></figure><p>可以看到，如果<strong>在创建数据库时没有指定字符集和比较规则，就会使用服务器级别的字符集和比较规则</strong>。</p><h3 id="表级别"><a href="#表级别" class="headerlink" title="表级别"></a>表级别</h3><p>表级别和数据库级别差不多，都是在创建，修改表时可以修改表的字符集和比较规则，如果没有在创建表时指明其字符集和比较规则，就会使用当前数据库的字符集和比较规则。</p><figure><div class="code-wrapper"><pre class="language-mysql" data-language="mysql"><code class="language-mysql">create table t(col varchar(10)) character set utf8,collate utf8_general_ci;alter table t character set utf8;</code></pre></div></figure><p>表查看比较规则</p><figure><div class="code-wrapper"><pre class="language-mysql" data-language="mysql"><code class="language-mysql"># 使用\G是将输出结果旋转90度输出，方便观看mysql&gt; show table status from test like &#39;t&#39; \G;*************************** 1. row ***************************           Name: t         Engine: InnoDB        Version: 10     Row_format: Dynamic           Rows: 0 Avg_row_length: 0    Data_length: 16384Max_data_length: 0   Index_length: 0      Data_free: 0 Auto_increment: NULL    Create_time: 2022-07-24 17:44:59    Update_time: NULL     Check_time: NULL      Collation: utf8_general_ci #比较规则       Checksum: NULL Create_options:        Comment:1 row in set (0.00 sec)ERROR:No query specified</code></pre></div></figure><p>可以看到，表<code>t</code>的比较规则为<code>utf8_general_ci</code>，则字符集为 <code>utf8</code>（为什么知道比较规则之后就知道了字符集，请继续看）。</p><h3 id="列级别"><a href="#列级别" class="headerlink" title="列级别"></a>列级别</h3><p>同一个表中，不同列也可以有不同的比较规则。</p><figure><div class="code-wrapper"><pre class="language-mysql" data-language="mysql"><code class="language-mysql">create table 表名(列名 字符串类型 [character set 字符集名称] [collate 比较规则名称],    其他列....);alter table 表名 modify 列名 [character set 字符集名称] [collate 比较规则名称];</code></pre></div></figure><p>需要注意的是，<strong>对于任何一个级别</strong>，存在两条修改规则：</p><ul><li>只修改字符集，则比较规则将会变为修改后的字符集默认的比较规则。</li><li>只修改比较规则，则字符集会变为比较规则对应的字符集。</li></ul><p>如果想要同时修改字符集和比较规则，他们两个一定要适配，比如下列命令</p><figure><div class="code-wrapper"><pre class="language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; alter table t character set utf8 collate utf8mb4_general_ci;ERROR 1253 (42000): COLLATION &#39;utf8mb4_general_ci&#39; is not valid for CHARACTER SET &#39;utf8&#39;</code></pre></div></figure><p>报错信息为比较规则<code>utf8mb4_general_ci</code>对于字符集<code>utf8</code>是无效的，所以，我们知道了一个表的比较规则，一般也就知道了其字符集。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote><p>本文总结于《从根上理解MySQL》第三章p32-p43，作者：小孩子4919。对于有能力或者兴趣的读者，鄙人强烈推荐这本书，如果您能够通过正规渠道购买，支持作者，支持正版，支持每一颗热爱技术的心，我将感激不尽。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LockSupport</title>
    <link href="/2022/07/21/Java/%E5%B9%B6%E5%8F%91/LockSupport/"/>
    <url>/2022/07/21/Java/%E5%B9%B6%E5%8F%91/LockSupport/</url>
    
    <content type="html"><![CDATA[<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="实例字段"><a href="#实例字段" class="headerlink" title="实例字段"></a>实例字段</h2><p>静态变量保存Thread指定的字段的内存偏移量</p><figure><div class="code-wrapper"><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LockSupport</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Hotspot implementation via intrinsics API</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>Unsafe</span> UNSAFE<span class="token punctuation">;</span>        <span class="token comment">//下面属性都是获取内存偏移地址</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> parkBlockerOffset<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> SEED<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> PROBE<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> SECONDARY<span class="token punctuation">;</span>            <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            UNSAFE <span class="token operator">=</span> <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>Unsafe</span><span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> tk <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>                        <span class="token comment">//获取Thread的指定字段的内存偏移地址</span>            parkBlockerOffset <span class="token operator">=</span> UNSAFE<span class="token punctuation">.</span>objectFieldOffset                <span class="token punctuation">(</span>tk<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"parkBlocker"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            SEED <span class="token operator">=</span> UNSAFE<span class="token punctuation">.</span>objectFieldOffset                <span class="token punctuation">(</span>tk<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"threadLocalRandomSeed"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            PROBE <span class="token operator">=</span> UNSAFE<span class="token punctuation">.</span>objectFieldOffset                <span class="token punctuation">(</span>tk<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"threadLocalRandomProbe"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            SECONDARY <span class="token operator">=</span> UNSAFE<span class="token punctuation">.</span>objectFieldOffset                <span class="token punctuation">(</span>tk<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"threadLocalRandomSecondarySeed"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre></div></figure><p>LockSupport的构造方法被private修饰，不能在外部实例化。</p><h2 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h2><h3 id="park-x2F-unpark"><a href="#park-x2F-unpark" class="headerlink" title="park&#x2F;unpark"></a>park&#x2F;unpark</h3><p>从源码可知，LockSupport的park和unpark都是基于sun.misc.Unsafe实现，sun.misc.Unsafe对于这两个函数相关的定义为</p><figure><div class="code-wrapper"><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> isAbsolute<span class="token punctuation">,</span> <span class="token keyword">long</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">unpark</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> thread<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div></figure><p>park中的第一个参数isAbsolute，表示第二个参数是绝对时间（isAbsolute&#x3D;&#x3D;true）还是相对时间（false），绝对时间的单位是毫秒，相对时间的单位是纳秒，其本质都是传入一个long的字段。</p><p>简单地说，park的作用就是让一个线程进入等待队列，当time是0时，就是无限等待，直到其他线程调用unpark。</p><figure><div class="code-wrapper"><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NoSuchFieldException</span><span class="token punctuation">,</span> <span class="token class-name">IllegalAccessException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//Unsafe构造方法私有，不能被实例化，通过反射获得对象</span>        <span class="token class-name">Field</span> f <span class="token operator">=</span> <span class="token class-name">Unsafe</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"theUnsafe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Unsafe</span> unsafe <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Unsafe</span><span class="token punctuation">)</span> f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//绝对时间，单位为毫秒</span>       <span class="token class-name">Thread</span> t1 <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"park绝对时间测试，单位毫秒"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            unsafe<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"绝对时间测试结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"park相对时间测试，单位纳秒"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            unsafe<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span><span class="token number">300000000L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"相对时间测试结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre></div></figure><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p><code>LockSupport.park()</code>和<code>LockSupport.unpark()</code>用于指定线程的等待和唤醒</p><figure><div class="code-wrapper"><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeUnit</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">LockSupport</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"main线程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程开始运行..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//线程进入阻塞</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程阻塞结束..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        t<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"t线程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//主线程先休眠两秒，保证另一个线程一定先执行LockSupport.park()</span>        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre></div></figure><p>在<code>main</code>函数中的<code>LockSupport.unpark()</code>一行代码打断点，选择下栏的Debug-&gt;Layout setting-&gt;Frames查看t线程的状态（WAIT）</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/24/576db05114ca5c7d.png" alt="image-20220724125734871"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><blockquote><p>Java全栈知识体系：<a href="https://pdai.tech/md/java/thread/java-thread-x-lock-LockSupport.html">https://pdai.tech/md/java/thread/java-thread-x-lock-LockSupport.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sychronized详解</title>
    <link href="/2022/07/21/Java/%E5%B9%B6%E5%8F%91/sychronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2022/07/21/Java/%E5%B9%B6%E5%8F%91/sychronized%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="sychronized用法"><a href="#sychronized用法" class="headerlink" title="sychronized用法"></a>sychronized用法</h1><h1 id="sychronized原理"><a href="#sychronized原理" class="headerlink" title="sychronized原理"></a>sychronized原理</h1>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
