<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.7.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.7.0" type="image/png" sizes="32x32"><meta name="description" content="我始终勇往直前，百折不回...">
<meta property="og:type" content="website">
<meta property="og:title" content="慕青的日记">
<meta property="og:url" content="https://cecilia.cool/page/3/index.html">
<meta property="og:site_name" content="慕青的日记">
<meta property="og:description" content="我始终勇往直前，百折不回...">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Cyan">
<meta name="twitter:card" content="summary"><title>慕青的日记 | Cyan</title><link ref="canonical" href="https://cecilia.cool/page/3/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.7.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">慕青的日记</div><div class="header-banner-info__subtitle">Cyan</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/04/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(5)-AIO%E5%9F%BA%E6%9C%AC%E8%AF%A6%E8%A7%A3/">网络编程(5)--AIO基本详解</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-04</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h1>
      <p>前面三种IO模型：阻塞式同步，非阻塞式同步，多路复用都是采用的应用主动询问操作系统。也就导致他们都会在执行<code>read</code>函数中阻塞住。</p>
<p>异步IO采用的是“订阅 - 通知”模式：应用程序向操作系统注册IO监听，然后继续做自己的事情，当操作系统发生IO事件，并且准备好数据后，再主动通知应用程序，触发相应的函数。</p>
<p>异步IO也是操作系统进行支持的，Windows系统提供的异步IO技术为<code>IOCP</code>（I&#x2F;O Completion Port，I&#x2F;O完成端口）。Linux使用的是<code>epoll</code>多路复用IO技术模拟异步IO。</p>

        <h1 id="Java对异步IO的支持"   >
          <a href="#Java对异步IO的支持" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java对异步IO的支持" class="headerlink" title="Java对异步IO的支持"></a>Java对异步IO的支持</h1>
      <p>通常我们使用线程池用于执行异步任务，提交任务的线程讲任务提交到线程池就可以立马返回，不必等到任务正在完成，等我们需要执行结果时，通过传递一个回调函数的方式，任务结束后调用这个函数（<a href="https://cecilia.cool/2022/08/24/Java/%E5%B9%B6%E5%8F%91/Java%E7%BA%BF%E7%A8%8B%E6%B1%A02-FutureTask/">FutureTask</a>）。</p>
<p>Java 中的异步 IO 也是一样的，都是由一个线程池来负责执行任务，然后使用回调或自己去查询结果。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/02/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(4)-NIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E8%AF%A6%E8%A7%A3/">网络编程(4)--IO多路复用详解</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-02</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-08</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h1>
      <p>关于多路复用（windows下使用select）的简单介绍已经在<strong>Unix IO模型</strong>和<strong>NIO基础详解</strong>中大致提到，并给出了代码实现。本文会对相关方法和模型进行详细讲解。</p>
<p>多路复用IO技术最适用的是“高并发”场景，所谓<strong>高并发是指1毫秒内至少同时有上千个连接请求准备好</strong>。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">try(ServerSocket server = new ServerSocket(8888)) &#123;</span><br><span class="line">    Socket s = server.accept();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;服务端收到连接&quot;);</span><br><span class="line"></span><br><span class="line">    BufferedReader reader = new BufferedReader(new InputStreamReader(s.getInputStream()));</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;服务端读取数据： &quot; + reader.readLine());</span><br><span class="line"></span><br><span class="line">    OutputStreamWriter write = new OutputStreamWriter(s.getOutputStream());</span><br><span class="line"></span><br><span class="line">    write.write(&quot;服务端已收到数据&quot;);</span><br><span class="line">    write.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(<span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8888</span>)) &#123;</span><br><span class="line">    <span class="type">OutputStreamWriter</span> <span class="variable">write</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(s.getOutputStream());</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">    write.write(<span class="string">&quot;客户端发送数据：xyz\n&quot;</span>);</span><br><span class="line">    write.flush();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;客户端发送数据&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(s.getInputStream()));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;客户端收到数据： &quot;</span>+reader.readLine());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="模型"   >
          <a href="#模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#模型" class="headerlink" title="模型"></a>模型</h1>
      
        <h2 id="传统IO模型"   >
          <a href="#传统IO模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#传统IO模型" class="headerlink" title="传统IO模型"></a>传统IO模型</h2>
      <p>一个<code>Server</code>对接N个客户端，在客户端连接之后，为每个客户端都分配一个执行线程。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/02/d6855af86b51f707.jpg" alt="传统IO模型"></p>
<p>从图中可以看出其特点：</p>
<ul>
<li>每个客户端连接到达之后，服务端会分配一个线程给该客户端，该线程会处理包括读取数据，解码，业务计算，编码，以及发送数据整个过程；</li>
<li>同一时刻，服务端的吞吐量与服务器所提供的线程数量是呈线性关系的。</li>
</ul>
<p>但是这也有很大问题：</p>
<ul>
<li><p>服务器并发量严重依赖于服务端能创建的线程数。</p>
</li>
<li><p>服务端在获取客户端连接，读取数据，以及写入数据的过程都是阻塞类型的，在网络状况不好的情况下，这将极大的降低服务器每个线程的利用率，从而降低服务器吞吐量。</p>
</li>
</ul>
<blockquote>
<p>如果每一个客户端都维持一个与登陆服务器的连接。那么服务器将<strong>维护</strong>多个和客户端的连接以出来和客户端的contnect 、read、write ，特别是对于长链接的服务，有多少个c端，就需要在s端维护同等的IO连接。这对服务器来说是一个很大的开销。</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端 -- 其实这里应该写死循环的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>)) &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> server.accept();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;服务端收到连接&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(s.getInputStream()));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;服务端读取数据： &quot;</span> + reader.readLine());</span><br><span class="line"></span><br><span class="line">            <span class="type">OutputStreamWriter</span> <span class="variable">write</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(s.getOutputStream());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 两边接收数据都是readLine，所以必须加换行符</span></span><br><span class="line">            write.write(<span class="string">&quot;服务端已收到数据\n&quot;</span>);</span><br><span class="line">            write.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8888</span>)) &#123;</span><br><span class="line">            <span class="type">OutputStreamWriter</span> <span class="variable">write</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(s.getOutputStream());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 两边接收数据都是readLine，所以必须加换行符</span></span><br><span class="line">            write.write(<span class="string">&quot;客户端发送数据：xyz\n&quot;</span>);</span><br><span class="line">            write.flush();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;客户端发送数据&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(s.getInputStream()));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;客户端收到数据： &quot;</span>+reader.readLine());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>你也可以试着使用通道和缓冲区实现，<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javase/kl68ty#dd93d714" >参考链接</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p>
</blockquote>

        <h2 id="I-x2F-O多路复用"   >
          <a href="#I-x2F-O多路复用" class="heading-link"><i class="fas fa-link"></i></a><a href="#I-x2F-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h2>
      <p>之前讲了I&#x2F;O多路复用的模型介绍大概，这里我们给出源码实现</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">         <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open())&#123;   <span class="comment">//开启一个新的Selector，这玩意也是要关闭释放资源的</span></span><br><span class="line">        serverChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">// 要使用选择器进行操作，必须使用非阻塞的方式，这样才不会像阻塞IO那样卡在accept()，</span></span><br><span class="line">        <span class="comment">// 而是直接通过，让选择器去进行下一步操作</span></span><br><span class="line">        serverChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将ServerChannel注册到选择器上，此时只有选择器只会监听这一个通道</span></span><br><span class="line">        <span class="comment">// 因为是ServerSocketChannel这里我们就监听accept就可以了，等待客户端连接</span></span><br><span class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;   <span class="comment">//无限循环等待新的用户网络操作</span></span><br><span class="line">            <span class="comment">//每次选择都可能会选出多个已经就绪的网络操作，没有操作时会暂时阻塞</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br><span class="line">            System.out.println(<span class="string">&quot;监听到 &quot;</span>+count+<span class="string">&quot; 个事件&quot;</span>);</span><br><span class="line">            <span class="comment">// 如果是第一次循环，拿到的事件SelectionKey绑定的通道都是ServerChannel</span></span><br><span class="line">            </span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="comment">//根据不同的事件类型，执行不同的操作即可</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 该事件绑定的通道就是ServerChannel</span></span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable()) &#123;  <span class="comment">//如果ServerSocketChannel已经做好准备处理Accept</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 我们现在知道了有一个客户端需要连接（之后可能会发送数据给服务端）</span></span><br><span class="line">                    <span class="comment">// 所以我们将客户端的通道初始化</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> serverChannel.accept();</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端已连接，IP地址为：&quot;</span>+channel.getRemoteAddress());</span><br><span class="line">                    <span class="comment">// 现在连接就建立好了，接着我们需要将连接也注册选择器</span></span><br><span class="line">                    channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    <span class="comment">//这样就在连接建立时完成了注册</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable()) &#123;    <span class="comment">//如果当前连接有可读的数据并且可以写，那么就开始处理</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    System.out.println(<span class="string">&quot;接收到客户端数据：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//直接向通道中写入数据就行</span></span><br><span class="line">                    channel.write(ByteBuffer.wrap(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                    <span class="comment">//别关，说不定用户还要继续通信呢</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//处理完成后，一定记得移出迭代器，不然下次还有</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面是关于服务器的代码，最主要的就是<code>SelectionKey</code>，它包含了监听事件注册时的通道，比如一开始我们将通道<code>ServerSocketChannel</code>注册到选择器，然后在<code>if</code>选择语句中拿到的<code>key</code>就包含<code>ServerSocket</code>。</p>
<p><code>SelectionKey</code>有一个<code>channel()</code>方法，使用时需要强转一下。因为第一个<code>if</code>已经有了<code>ServerSocketChannel</code>的引用，就没必要调用<code>cahnel()</code>。</p>
<p>之后的客户端代码就比较简单了</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个新的SocketChannel，通过通道进行通信</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">         <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已连接到服务端！&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;   <span class="comment">//咱给它套个无限循环，这样就能一直发消息了</span></span><br><span class="line">            System.out.println(<span class="string">&quot;请输入要发送给服务端的内容：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            <span class="comment">//直接向通道中写入数据，真舒服</span></span><br><span class="line">            channel.write(ByteBuffer.wrap(text.getBytes()));</span><br><span class="line">            System.out.println(<span class="string">&quot;已发送！&quot;</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">            channel.read(buffer);   <span class="comment">//直接从通道中读取数据</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            System.out.println(<span class="string">&quot;收到服务器返回：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>请读者将这部分代码弄清楚，不清楚就去查，下面给大家几篇写的比较好的博客</p>
<blockquote>
<p>田守枝Java技术博客（讲解细致，建议收藏）：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://www.tianshouzhi.com/api/tutorials/netty/318" >http://www.tianshouzhi.com/api/tutorials/netty/318</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>并发编程网（很短，推荐看一下）：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://ifeve.com/server-socket-channel/" >http://ifeve.com/server-socket-channel/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>CSDN（这篇博客我只看了前面几句话，提到了我忽略的点）：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/cold___play/article/details/106663776" >https://blog.csdn.net/cold___play/article/details/106663776</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>但是这个也存在问题：比如一个线程忙不过来（真实），所以之后的<code>Reactor</code>模型会使用到线程池。</p>

        <h2 id="单线程Reactor模型"   >
          <a href="#单线程Reactor模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#单线程Reactor模型" class="headerlink" title="单线程Reactor模型"></a>单线程Reactor模型</h2>
      <p><code>Reactor</code>模型主要是对服务器进行优化，首先我们抽象出两个组件</p>
<ul>
<li><code>Reactor</code>线程：负责响应IO事件，并分发到<code>Handler</code>处理器。新的事件包含连接建立就绪，读就绪，写就绪等。</li>
<li>Handler处理器：执行<strong>非阻塞</strong>的操作（因为<code>Selector</code>只有监听到了真正要执行的事件，才会将该事件交给<code>Handler</code>执行，所以不存在阻塞操作）。</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/07/315c775016584c9b.jpg" alt="图片源自青空の霞光"></p>
<p><code>JDK1.4</code>提供了一套非阻塞<code>IO</code>的<code>API</code>，本质是以<strong>事件驱动</strong>来处理网络事件的，<code>Reactor</code>是基于该<code>API</code>提出的一套<code>IO</code>模型。</p>
<p>该模型主要分为四个部分：客户端连接，Reactor，Acceptor，Handler。</p>
<p><code>Reactor</code>模型是以事件进行驱动的（应该已经很了解事件驱动了吧），其能够将接收客户端连接，+ 网络读和网络写，以及<strong>业务计算进行拆分</strong>，从而极大的提升处理效率；Reactor模型是异步<strong>非阻塞</strong>模型，工作线程在没有网络事件时可以处理其他的任务，而不用像传统IO那样必须阻塞等待。</p>
<blockquote>
<p><code>Acceptor</code>处理客户端新连接，并分派请求到处理器链（<code>Reactor</code>）</p>
</blockquote>
<p>下图是比较正经（难懂）的图。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/03/b23b2105c197fe2f.jpg" alt="Reactor模型"></p>
<p>我们先看一下<code>Handler</code>代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行非阻塞操作，请记住，read在这里也是非阻塞</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Handler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SocketChannel channel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">            channel.read(buffer);</span><br><span class="line">            buffer.flip();</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到客户端数据：&quot;</span>+</span><br><span class="line">                               <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">            channel.write(ByteBuffer.wrap(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>接着是<code>Acceptor</code>，非常快就能看完。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Acceptor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerSocketChannel serverChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Selector selector;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Acceptor</span><span class="params">(ServerSocketChannel serverChannel,Selector selector)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serverChannel = serverChannel;</span><br><span class="line">        <span class="built_in">this</span>.selector = selector;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> serverChannel.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端已连接，IP地址为：&quot;</span> + </span><br><span class="line">                              channel.getRemoteAddress());</span><br><span class="line">            channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 注册时，创建好对应的Handler，这样在Reactor中分发的时候就可以直接调用Handler</span></span><br><span class="line">            channel.register(selector,Selector.OP_READ,<span class="keyword">new</span> <span class="title class_">Handler</span>(channel));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>最后看一下<code>Reactor</code>的实现，这里的<code>dispatch</code>使用了<code>attachment</code>方法</p>
<blockquote>
<p>选择键支持将单个任意对象附加到某个键的操作。可通过<code>attach()</code>方法附加对象，然后通过<code>attachment()</code>方法获取该对象。我们在Acceptor和Handler都没有使用<code>attach</code>方法，而是在注册时绑定<code>SelectionKey key=channel.register(selector,SelectionKey.OP_READ,theObject);</code></p>
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reactor</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span>,Runnable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerSocketChannel serverChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Selector selector;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Reactor</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        serverChannel = ServerSocketChannel.open();</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Public <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8888</span>));</span><br><span class="line">            serverChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从这里可以看到，Reactor并不处理连接，而是将需要连接的</span></span><br><span class="line">            <span class="comment">// 事件交给acceptor处理</span></span><br><span class="line">            serverChannel.register(selector,SelectionKey.OP_ACCEP,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">Acceptor</span>(serverChannel,selector));</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br><span class="line">                System.out.println(<span class="string">&quot;监听到 &quot;</span> + count + <span class="string">&quot; 个事件&quot;</span>);</span><br><span class="line">                Set&lt;SelectionKey&gt; set = selector.selectionKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = set.iterator();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span>(iterator.hasnext()) &#123;</span><br><span class="line">                    <span class="comment">// 通过dispatch方法分发出去</span></span><br><span class="line">                    <span class="built_in">this</span>.dispatch(iterator.next());</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(selectionKey key)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">att</span>  <span class="operator">=</span> key.attachment();</span><br><span class="line">        <span class="keyword">if</span>(att <span class="keyword">instanceof</span> Runnable) &#123;</span><br><span class="line">            <span class="comment">// Handler和Acceptor都实现自Runnable接口，这里就统一调用一下</span></span><br><span class="line">            ((Runnable) att).run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        serverChannel.close();</span><br><span class="line">        selector.close();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<blockquote>
<p>需要注意的是，这是单线程模式，也就是说，Reactor和Hander都是处于一条线程执行。由于是单线程，只要有一个handler出现阻塞，其他的Client都会被阻塞，并且不能充分利用多核资源。所以单线程模型仅仅适用于handler中业务处理组件能快速完成的场景。</p>
</blockquote>
<p>所以整个流程图也可以这么画（其实这个图画的不准确，<code>client</code>应该指向<code>Reactor</code>，而且此处也省略了<code>dispatch</code>）。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/04/1fd0e8d34115ad66.jpg" alt="Reactor单线程模型"></p>

        <h2 id="多线程Reactor模型"   >
          <a href="#多线程Reactor模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#多线程Reactor模型" class="headerlink" title="多线程Reactor模型"></a>多线程Reactor模型</h2>
      <p>先看一下<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://space.bilibili.com/37737161/?spm_id_from=333.999.0.0" >青空の霞光</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>给的图</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/07/c06c6ae8afed08f1.jpg"></p>
<p>相关改进为：</p>
<ul>
<li>将<code>Handler</code>处理器的执行放入线程池，多线程进行业务处理。<strong>此时handler处理的是非阻塞任务</strong>。所以这个模型又叫做：<strong>业务处理与IO分离</strong>。</li>
<li>对于<code>Reactor</code>而言，仍然是单线程。</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/04/76186bdd3784f6b0.jpg" alt="Reactor多线程模型"></p>
<p>特点：</p>
<ul>
<li><p>有一个专门的NIO线程用于监听服务器，接收客户端的TCP连接请求以及网络读写事件的处理（可以看到<code>read</code>和<code>send</code>仍然是<code>Reactor</code>在处理）。</p>
</li>
<li><p>接收到连接之后，将该链接交给线程池，这些NIO线程负责消息的读取，解码，编码和发送。</p>
</li>
</ul>
<p>在绝大多数场景下，Reactor多线程模型可以满足性能需求，但是仅仅使用一个NIO线程负责监听和处理所有客户端连接同时还要负责处理网络读写可能会存在性能问题，比如<strong>百万客户端并发连接，或则服务端需要多客户端的握手信息进行安全认证，认证本身非常消耗性能</strong>。</p>
<p>代码：我们只需要修改一下<code>Handler</code>即可</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Handler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="comment">// 把线程池给安排了，10个线程</span></span><br><span class="line">    <span class="comment">// 真正项目开发，线程池一般是自定义的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">POOL</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SocketChannel channel;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            channel.read(buffer);</span><br><span class="line">            buffer.flip();</span><br><span class="line">            POOL.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;接收到客户端数据：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">                    channel.write(ByteBuffer.wrap(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="主从Reactor多线程模型"   >
          <a href="#主从Reactor多线程模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#主从Reactor多线程模型" class="headerlink" title="主从Reactor多线程模型"></a>主从Reactor多线程模型</h2>
      <p>先看一下简化图</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/07/bbcf85b18177c5c2.jpg"></p>
<p>之前的模型既要处理客户端连接，又要处理网络读写，但是网络读写在高并发情况下会成为系统的一个瓶颈。所以将<code>Reactor</code>拆分为<code>mainReactor</code>和<code>subReactor</code>。即使用线程池进行网络读写，只是用一个线程专门接收客户端连接。</p>
<ul>
<li><code>mainReactor</code>主要进行客户端连接的处理，处理完成之后将该链接交给<code>subReactor</code>处理客户端的网络读写。</li>
<li><code>subReactor</code>使用一个线程池来支撑，而其他业务操作也是用一个线程池。</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/04/f9e540e1a225450d.jpg" alt="主从Reactor模型"></p>
<p>通过这种方式，服务器的性能将会大大提升，在可见情况下，其基本上可以支持百万连接。如果想看具体的函数调用，可以看这篇：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/Jack__iT/article/details/107010486" >深入理解主从Reactor多线程模型</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p>
<p>这次改动比较多，我们首先设计一下从<code>Reactor</code>：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SubReactor作为从Reactor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubReactor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>, Closeable &#123;</span><br><span class="line">	<span class="comment">//每个从Reactor也有一个Selector</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Selector selector;</span><br><span class="line">	</span><br><span class="line">  	<span class="comment">//创建一个4线程的线程池，也就是四个从Reactor工作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">POOL</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SubReactor[] reactors = <span class="keyword">new</span> <span class="title class_">SubReactor</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">selectedIndex</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">//采用轮询机制，每接受一个新的连接，就轮询分配给四个从Reactor</span></span><br><span class="line">    <span class="keyword">static</span> &#123;   <span class="comment">//在一开始的时候就让4个从Reactor跑起来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reactors[i] = <span class="keyword">new</span> <span class="title class_">SubReactor</span>();</span><br><span class="line">                <span class="comment">// 一开就将从Reactor放到线程池中运行</span></span><br><span class="line">                POOL.submit(reactors[i]);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//轮询获取下一个Selector（Acceptor用）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title function_">nextSelector</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> reactors[selectedIndex].selector;</span><br><span class="line">        selectedIndex = (selectedIndex + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> selector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SubReactor</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;   <span class="comment">//启动后直接等待selector监听到对应的事件即可，其他的操作逻辑和Reactor一致</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &gt;&gt; 监听到 &quot;</span>+count+<span class="string">&quot; 个事件&quot;</span>);</span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.dispatch(iterator.next());</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(SelectionKey key)</span>&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">att</span> <span class="operator">=</span> key.attachment();</span><br><span class="line">        <span class="keyword">if</span>(att <span class="keyword">instanceof</span> Runnable) &#123;</span><br><span class="line">            ((Runnable) att).run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        selector.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>我们设计的<code>SubReactor</code>没有<code>ServerSocketChannel</code>，而是每个从<code>Reactor</code>都有一个<code>Selector</code>，在主<code>Reactor</code>中通过<code>nextSelector</code>静态方法轮流获得不同从<code>Reactor</code>的<code>Selector</code>。</p>
</blockquote>
<p>最后修改一下<code>Acceptor</code></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Acceptor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerSocketChannel serverChannel;   <span class="comment">//只需要一个ServerSocketChannel就行了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Acceptor</span><span class="params">(ServerSocketChannel serverChannel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serverChannel = serverChannel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> serverChannel.accept();   <span class="comment">//还是正常进行Accept操作，得到SocketChannel</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &gt;&gt; 客户端已连接，IP地址为：&quot;</span>+channel.getRemoteAddress());</span><br><span class="line">            channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> SubReactor.nextSelector();   <span class="comment">//选取下一个从Reactor的Selector</span></span><br><span class="line">            selector.wakeup();    <span class="comment">//在注册之前唤醒一下防止卡死</span></span><br><span class="line">            channel.register(selector, SelectionKey.OP_READ, <span class="keyword">new</span> <span class="title class_">Handler</span>(channel));  <span class="comment">//注意现在注册的是从Reactor的Selector</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>需要注意，不同的人设计在代码实现方面可能不同，重点是<code>Reactor</code>的思想，主<code>Reactor</code>处理连接（也就是调用<code>Acceptor</code>）将<code>SocketChannel</code>注册到选择器上（因为之后就要进行读写操作），此时这个连接之后的读写请求都会发送给从<code>Reactor</code>的选择器，这也就规避了主<code>Reactor</code>处理读写请求。但是最终去完成这个请求的还是<code>Handler</code>。</p>
</blockquote>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.modb.pro/db/50016" >理解Reactor模型</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>（这篇文章关于多线程Reactor的图有些不准确）</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/io/java-io-nio-select-epoll.html" >https://pdai.tech/md/java/io/java-io-nio-select-epoll.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/Jack__iT/article/details/107010486" >https://blog.csdn.net/Jack__iT/article/details/107010486</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>青空の霞光：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javase/kl68ty" >https://www.yuque.com/qingkongxiaguang/javase/kl68ty</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/01/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(3)-NIO%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/">网络编程(3)--NIO基础详解</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-01</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-07</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h1>
      <p><code>BIO</code>是阻塞的，如果没有多线程，<code>BIO</code>就需要一直占用<code>CPU</code>，而<code>NIO</code>则是非阻塞<code>IO</code>，<code>NIO</code>在获取连接或者请求时，即使没有取得连接和数据，也不会阻塞程序。NIO的服务器实现模式为一个线程可以处理多个请求。</p>
<p><code>I/O</code> 与 <code>NIO</code> 最重要的区别是数据打包和传输的方式，<code>I/O</code> 以流的方式处理数据，而 <code>NIO </code>以块的方式处理数据。</p>
<p>面向流的 <code>I/O</code> 一次处理一个字节数据: 一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 <code>I/O</code> 通常相当慢。</p>

        <h1 id="相关知识"   >
          <a href="#相关知识" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h1>
      
        <h2 id="通道"   >
          <a href="#通道" class="heading-link"><i class="fas fa-link"></i></a><a href="#通道" class="headerlink" title="通道"></a>通道</h2>
      <p>通道（<code>Channel</code>接口）是对流的模拟，既可以用来进行读操作，又可以用来进行写操作。</p>
<p>通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 <code>InputStream</code> 或者 <code>OutputStream</code> 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。</p>
<p><code>NIO</code>中常用的<code>Channel</code>有：</p>
<ul>
<li><p>FileChannel: 从文件中读写数据；</p>
</li>
<li><p>DatagramChannel: 通过 UDP 读写网络中数据；</p>
</li>
<li><p>SocketChannel: 通过 TCP 读写网络中数据；</p>
</li>
<li><p>ServerSocketChannel: 可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</p>
</li>
</ul>
<p>我们先看一下<code>Channel</code>内部代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Channel</span> <span class="keyword">extends</span> <span class="title class_">Closeable</span> &#123;</span><br><span class="line">    <span class="comment">//通道是否处于开启状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOpen</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为通道开启也需要关闭，所以实现了Closeable接口，所以这个方法懂的都懂</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><img src="https://s3.bmp.ovh/imgs/2022/09/06/a30745dcd72b9009.jpg" alt="通道接口结构"></p>
<p>最后整合为<code>ByteChannel</code>接口</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ByteChannel</span> <span class="keyword">extends</span> <span class="title class_">ReadableByteChannel</span>, WritableByteChannel&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>我们对比一下不使用通道和使用通道</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用通道</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// 将System.in作为输入流</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> System.in;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = in.read(data)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;data = &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(data,<span class="number">0</span>,1en));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用通道</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    <span class="type">ReadableByteChannel</span> <span class="variable">readChannel</span> <span class="operator">=</span> Channels.newChannel(Syetem.in);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 将通道中的数据写到缓冲区，缓冲区最多一次装10个</span></span><br><span class="line">        readChannel.read(buffer);</span><br><span class="line">        </span><br><span class="line">        buffer.flip();<span class="comment">// 翻转缓冲区</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(),<span class="number">0</span>,buffer.remaining()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="FileChannel"   >
          <a href="#FileChannel" class="heading-link"><i class="fas fa-link"></i></a><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h4>
      <p>通道一个重要的特点就是能够双向传输数据。但是<code>FileInputStream</code>得到的通道只能输入，<code>FileOutputStream</code>得到的通道只能输出。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>();</span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> in.getChannel();</span><br></pre></td></tr></table></div></figure>

<p>我们可以通过<code>RandomAccessFile</code>创建通道</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      通过RandomAccessFile进行创建，注意后面的mode有几种：</span></span><br><span class="line"><span class="comment">      r        以只读的方式使用</span></span><br><span class="line"><span class="comment">      rw   读操作和写操作都可以</span></span><br><span class="line"><span class="comment">      rws  每当进行写操作，同步的刷新到磁盘，刷新内容和元数据</span></span><br><span class="line"><span class="comment">      rwd  每当进行写操作，同步的刷新到磁盘，刷新内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//这里设定为支持读写，这样创建的通道才能具有这些功能</span></span><br><span class="line">    <span class="keyword">try</span>(<span class="type">RandomAccessFile</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);  </span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> f.getChannel())&#123;   <span class="comment">//通过RandomAccessFile创建一个通道</span></span><br><span class="line">        channel.write(ByteBuffer.wrap(<span class="string">&quot;伞兵二号马飞飞准备就绪！&quot;</span>.getBytes()));</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//注意读取也是从现在的位置开始</span></span><br><span class="line">        System.out.println(<span class="string">&quot;写操作完成之后文件访问位置：&quot;</span>+channel.position());  </span><br><span class="line">        channel.position(<span class="number">0</span>);  <span class="comment">//需要将位置变回到最前面，这样下面才能从文件的最开始进行读取</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">        channel.read(buffer);</span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>除了基本的读写操作，也可以对文件进行截断：<code>channel.truncate(20)</code>。就只会保留前20个字节</p>
</blockquote>
<p>示例：文件拷贝</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在缓冲区也有文件复制的案例，但是此处我们直接使用写好的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">       <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.txt&quot;</span>)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">inChannel</span> <span class="operator">=</span> in.getChannel();</span><br><span class="line">        inChannel.transfer(<span class="number">0</span>,inChannel.size(),out.getChannel());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 也可以反向操作</span></span><br><span class="line">        out.getChannel().transfer(inChannel,<span class="number">0</span>,inChannel.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="文件锁FileLock"   >
          <a href="#文件锁FileLock" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件锁FileLock" class="headerlink" title="文件锁FileLock"></a>文件锁FileLock</h4>
      <p>我们可以创建一个跨进程文件锁来防止多个进程之间的文件争抢操作（注意这里是进程，不是线程）FileLock是文件锁，它能保证同一时间只有一个进程（程序）能够修改它，或者都只可以读，这样就解决了多进程间的同步文件，保证了安全性。但是需要注意的是，它进程级别的，不是线程级别的，他可以解决多个进程并发访问同一个文件的问题，但是它不适用于控制同一个进程中多个线程对一个文件的访问。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">Channel</span> <span class="operator">=</span> f.getChannel();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上锁：对0~6个字节上锁，false表示独占锁，其他进程连读都不可以</span></span><br><span class="line">    <span class="type">FileLock</span> <span class="variable">lock</span> <span class="operator">=</span> channel.getLock(<span class="number">0</span>,<span class="number">6</span>,<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以：channel.getLock(0,channel.size(),false);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    lock.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>为了快速讲完这部分内容，笔者简化了一些细节</p>
<blockquote>
<p>独占锁如果出现了交叉部分，也会被阻塞（人之常情嘛）。共享锁就是将参数设置为true。还有一个<code>trylock</code>的方法，它会尝试去获得锁，如果失败就返回<code>null</code>（这让我想起<code>AQS</code>里面的<code>tryAccquire</code>方法）。</p>
</blockquote>

        <h2 id="缓冲区"   >
          <a href="#缓冲区" class="heading-link"><i class="fas fa-link"></i></a><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2>
      <p>发送给通道的所有数据都必须首先放到缓冲区中，从通道读取的任何数据都要先读到缓冲区。不会直接对通道进行读写数据，而是要先经过缓冲区。</p>
<p>缓冲区实质上是一个<strong>数组</strong>，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读&#x2F;写进程。</p>
<p>缓冲区状态变量：</p>
<ul>
<li><code>capacity</code>: 最大容量；</li>
<li><code>position</code>: 当前已经读写的字节数；</li>
<li><code>limit</code>: 还可以读写的字节数。</li>
</ul>
<p>常见的缓冲区有（都是<code>Buffer</code>抽象类的子类）：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
</ul>

        <h3 id="相关方法"   >
          <a href="#相关方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h3>
      
        <h4 id="获取对象"   >
          <a href="#获取对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#获取对象" class="headerlink" title="获取对象"></a>获取对象</h4>
      <p>这里以<code>IntBuffer</code>为例，我们想要获得一个<code>IntBuffer</code>的实例化对象，需要调用<code>allocate</code>方法或者<code>wrap</code>方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.申请容量为10的int缓冲区</span></span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">buffer1</span> <span class="operator">=</span> IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.将现有数组直接转换为缓冲区</span></span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> IntBuffer,wrap(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 看一下内部两个方法的相关实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IntBuffer <span class="title function_">allocate</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeapIntBuffer</span>(capacity, capacity);   </span><br><span class="line">    <span class="comment">// 这里也能说明HeapIntBuffer是IntBuffer子类</span></span><br><span class="line">  	<span class="comment">//HeapIntBuffer是在堆内存中存放数据，本质上就数组，一会我们可以在深入看一下</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IntBuffer <span class="title function_">wrap</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> wrap(array, <span class="number">0</span>, array.length);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IntBuffer <span class="title function_">wrap</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> offset, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">//创建了一个新的HeapIntBuffer对象，并且给了初始数组以及截取的起始位置和长度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeapIntBuffer</span>(array, offset, length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException x) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这里涉及到一个新的类，我们先看一下总体的类结构</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/06/2c96523c4e767ff8.jpg" alt="类结构"></p>
<p>我们看一下两个类的构造方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IntBuffer构造方法</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span>[] hb;                  <span class="comment">// 只有在堆缓冲区实现时才会使用</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> offset;</span><br><span class="line"><span class="type">boolean</span> isReadOnly;                 <span class="comment">// 只有在堆缓冲区实现时才会使用</span></span><br><span class="line"></span><br><span class="line">IntBuffer(<span class="type">int</span> mark, <span class="type">int</span> pos, <span class="type">int</span> lim, <span class="type">int</span> cap, <span class="type">int</span>[] hb, <span class="type">int</span> offset)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">super</span>(mark, pos, lim, cap);  <span class="comment">//调用Buffer类的构造方法</span></span><br><span class="line">    <span class="built_in">this</span>.hb = hb;    <span class="comment">//hb就是真正我们要存放数据的数组，堆缓冲区底层其实就是这么一个数组</span></span><br><span class="line">    <span class="built_in">this</span>.offset = offset;   <span class="comment">//起始偏移位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HeapIntBuffer构造方法</span></span><br><span class="line">HeapIntBuffer(<span class="type">int</span>[] buf, <span class="type">int</span> off, <span class="type">int</span> len) &#123; </span><br><span class="line">    <span class="built_in">super</span>(-<span class="number">1</span>, off, off + len, buf.length, buf, <span class="number">0</span>);  </span><br><span class="line">  	<span class="comment">//mark是标记，off是当前起始下标位置，off+len是最大下标位置，</span></span><br><span class="line">    <span class="comment">//buf.length是底层维护的数组真正长度，buf就是数组，最后一个0是起始偏移位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="写操作"   >
          <a href="#写操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h4>
      <p><code>Buffer</code>中所有的<code>put</code>函数。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> IntBuffer <span class="title function_">put</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定位置插入数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> IntBuffer <span class="title function_">put</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> i)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接将src全部插入缓冲区，但是不能超过缓冲区大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> IntBuffer <span class="title function_">put</span><span class="params">(<span class="type">int</span>[] src)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接存放数组中的内容，同上，但是可以指定存放一段范围</span></span><br><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">put</span><span class="params">(<span class="type">int</span>[] src, <span class="type">int</span> offset, <span class="type">int</span> length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接存放另一个缓冲区中的内容</span></span><br><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">put</span><span class="params">(IntBuffer src)</span>; </span><br></pre></td></tr></table></div></figure>

<p>我们看做简单的<code>put</code>源码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">put</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    hb[ix(nextPutIndex())] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将i的值加上我们之前设定的offset偏移量值，但是默认是0（非0的情况后面会介绍）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">ix</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i + offset;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nextPutIndex</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> position;    <span class="comment">//获取Buffer类中的position位置（一开始也是0）</span></span><br><span class="line">    <span class="keyword">if</span> (p &gt;= limit)    <span class="comment">//位置肯定不能超过底层数组最大长度，否则越界</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BufferOverflowException</span>();</span><br><span class="line">    position = p + <span class="number">1</span>;   <span class="comment">//获取之后会使得Buffer类中的position+1</span></span><br><span class="line">    <span class="keyword">return</span> p;   <span class="comment">//返回当前的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>如果将<code>offset</code>看为0，那么整个函数就是在数组<code>hb</code>的<code>position</code>位置加入元素</p>
<p>示例：快速复制文件</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fastCopy</span><span class="params">(String src, String dist)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获得源文件的输入字节流 */</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取输入字节流的文件通道 */</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fcin</span> <span class="operator">=</span> fin.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取目标文件的输出字节流 */</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dist);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取输出字节流的通道 */</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fcout</span> <span class="operator">=</span> fout.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为缓冲区分配 1024 个字节 */</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从输入通道中读取数据到缓冲区中 */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> fcin.read(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* read() 返回 -1 表示 EOF */</span></span><br><span class="line">        <span class="keyword">if</span> (r == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 切换读写 */</span></span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 把缓冲区的内容写入输出文件中 */</span></span><br><span class="line">        fcout.write(buffer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 清空缓冲区 */</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>我们可以看一下整个<code>buffer</code>的状态变化，此处我们假设大小为8字节</p>
<p>①新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit &#x3D; capacity &#x3D; 8。capacity 变量不会改变，下面的讨论会忽略它。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/01/77fb2a16735a25dc.jpg" alt="buffer变化1"></p>
<p>② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 移动设置为 5，limit 保持不变。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/01/6df58dfb355cd5fd.jpg" alt="buffer变化2"></p>
<p>③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/01/fc7668224747f135.jpg" alt="buffer变化3"></p>
<p>④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/01/e41dc8148e004937.jpg" alt="buffer变化4"></p>
<p>⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/01/34a021e1ad767087.jpg" alt="buffer变化5"></p>
<blockquote>
<p>为什么缓冲区在写之后读需要使用<code>flip</code>函数呢？我们从图中看出<code>flip</code>之后会将Position置为0。从读到写不需要翻转（如果是覆盖写的话）</p>
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">flip</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//修改limit值，当前写到哪里，下次读的最终位置就是这里</span></span><br><span class="line">    limit = position;    </span><br><span class="line">    position = <span class="number">0</span>;    <span class="comment">//position归零</span></span><br><span class="line">    mark = -<span class="number">1</span>;    <span class="comment">//标记还原为-1，但是现在我们还没用到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>我们通过<code>put</code>方法来深入理解一下<code>flip</code>。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">put</span><span class="params">(IntBuffer src)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(src == <span class="built_in">this</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span>(isReadOnly())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReadOnlyBufferException</span>();</span><br><span class="line">    <span class="comment">// 非常重要，在这里就是确定src的元素个数</span></span><br><span class="line">    <span class="comment">// 你现在是读src，你应该将src转换为读状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> src.remaining();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(n &gt; remaining())</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BufferOverflowException</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        put(src.get());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p><code>remaining()</code>在读缓冲区时的结果期望是缓冲区数据个数，在写缓冲区时的结果期望是缓冲区的剩余容量。</p>
</blockquote>
<p>为什么我要强调期望呢？因为如果不恰当使用<code>flip</code>，得到的结果就不是期望值。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">remaining</span><span class="params">()</span> &#123;  <span class="comment">//计算并获取当前缓冲区的剩余空间</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rem</span> <span class="operator">=</span> limit - position;   <span class="comment">//最大容量减去当前位置，就是剩余空间</span></span><br><span class="line">    <span class="keyword">return</span> rem &gt; <span class="number">0</span> ? rem : <span class="number">0</span>;  <span class="comment">//没容量就返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>如果是写缓冲区，<code>limit-position</code>就是剩余容量；使用<code>flip</code>之后，<code>limit-position</code>就是缓冲区包含的数据个数。所以，<code>flip</code>的本质就是通过改变<code>limit</code>和<code>position</code>的值来改变二者之差的含义。·</p>

        <h4 id="读操作"   >
          <a href="#读操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h4>
      <p>为什么我们需要翻转操作，因为我们读写数据都是依托于<code>position</code>定位的。写入&#x2F;读取（<code>get()</code>方法）都会使<code>position</code>加一。如果超出范围抛出异常。</p>
<p>当然也可以用<code>get(i)</code>来指定读取第<code>i</code>个元素。</p>
<p>看一下有哪些重载的<code>get</code>方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;<span class="comment">// 只有这个方法不会改变position</span></span><br><span class="line"><span class="keyword">public</span> IntBuffer <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span>[] dst)</span>;<span class="comment">// 实际是调用下面那个方法</span></span><br><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">get</span><span class="params">(<span class="type">int</span>[] dst,<span class="type">int</span> offset,<span class="type">int</span> length)</span>;</span><br></pre></td></tr></table></div></figure>

<p>我们也可以使用<code>array()</code>方法直接返回<code>hb</code>数组。但是这直接将<code>hb</code>底层数组暴露在外面，所有修改都会生效在缓冲区。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span>[] array() &#123;</span><br><span class="line">    <span class="keyword">if</span> (hb == <span class="literal">null</span>)   <span class="comment">//为空那说明底层不是数组实现的，肯定就没法转换了</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    <span class="keyword">if</span> (isReadOnly)   <span class="comment">//只读也是不让直接取出的，因为一旦取出去岂不是就能被修改了</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReadOnlyBufferException</span>();</span><br><span class="line">    <span class="keyword">return</span> hb;   <span class="comment">//直接返回hb</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>最后，缓冲区还有一个<code>mark</code>操作，类似原理在缓冲流已经讲过了，此处不加赘述。当然缓冲区还有其他一些操作，这里笔者觉得不宜写太多，建议就是遇到了不懂就去浏览器搜。</p>
<p>只读缓冲区：<code>HeapIntBufferR</code>是<code>HeapIntBuffer</code>的子类，初始化为</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> IntBuffer.wrap(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line"><span class="type">IntBuffer</span> <span class="variable">readBuffer</span> <span class="operator">=</span> buffer.asReadOnlyBuffer();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">asReadOnlyBuffer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//注意这里并不是直接创建了HeapIntBuffer，而是HeapIntBufferR，并且直接复制的hb数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeapIntBufferR</span>(hb,    </span><br><span class="line">                                 <span class="built_in">this</span>.markValue(),</span><br><span class="line">                                 <span class="built_in">this</span>.position(),</span><br><span class="line">                                 <span class="built_in">this</span>.limit(),</span><br><span class="line">                                 <span class="built_in">this</span>.capacity(),</span><br><span class="line">                                 offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="选择器"   >
          <a href="#选择器" class="heading-link"><i class="fas fa-link"></i></a><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2>
      <p>这个其实就是<strong>Unix IO模型</strong>讲到的多路复用，<code>NIO</code>实现了<code>IO</code>多路复用中的Reactor模型，一个线程使用一个选择器Selector通过轮询的方式去监听多个通道<code>Channel</code>上的事件，从而让一个线程就可以处理多个事件。</p>
<p>通过配置监听的通道Channel为非阻塞，那么当Channel上的IO事件未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它Channel，找到IO事件已经到达的Channel执行。</p>
<blockquote>
<p>只有套接字Channel才能配置非阻塞，而FileChannel不能（FileChannel配置非阻塞也没有意义）。</p>
</blockquote>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/01/c631fb000c1a9630.jpg" alt="选择器"></p>

        <h3 id="创建选择器"   >
          <a href="#创建选择器" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建选择器" class="headerlink" title="创建选择器"></a>创建选择器</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br></pre></td></tr></table></div></figure>


        <h3 id="通道注册到选择器"   >
          <a href="#通道注册到选择器" class="heading-link"><i class="fas fa-link"></i></a><a href="#通道注册到选择器" class="headerlink" title="通道注册到选择器"></a>通道注册到选择器</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ssChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">ssChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">ssChannel.register(selector,SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></div></figure>

<p>通道配置必须为非阻塞模式，最后一行代码需要指定注册的具体事件</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在SelectionKey中定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_READ</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_WRITE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_CONNECT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_ACCEPT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></div></figure>


        <h3 id="监听事件"   >
          <a href="#监听事件" class="heading-link"><i class="fas fa-link"></i></a><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> selector.select();</span><br></pre></td></tr></table></div></figure>

<p>使用 <code>select()</code> 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。</p>

        <h3 id="获取到达的事件"   >
          <a href="#获取到达的事件" class="heading-link"><i class="fas fa-link"></i></a><a href="#获取到达的事件" class="headerlink" title="获取到达的事件"></a>获取到达的事件</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; leys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="事件循环"   >
          <a href="#事件循环" class="heading-link"><i class="fas fa-link"></i></a><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3>
      <p>一次<code>select()</code>调用不能处理所有事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> selector.select();</span><br><span class="line">    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line">    <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        keyIterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="套接字-NIO-实例"   >
          <a href="#套接字-NIO-实例" class="heading-link"><i class="fas fa-link"></i></a><a href="#套接字-NIO-实例" class="headerlink" title="套接字 NIO 实例"></a>套接字 NIO 实例</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建选择器</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将通道注册到选择器上（设置非阻塞）</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        ssChannel.register(selector,SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> ssChannel.socket();</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">        serverSocket.bind(address);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">ssChannel1</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 雾浮起为每个新连接创建一个SocketChannel</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sChannel</span> <span class="operator">=</span> ssChannel1.accept();</span><br><span class="line">                    sChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 该连接主要用于从客户端读取数据</span></span><br><span class="line">                    sChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable()) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    System.out.println(readDataFromSocketChannel(sChannel));</span><br><span class="line">                    sChannel.close();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">readDataFromSocketChannel</span><span class="params">(SocketChannel sChannel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sChannel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span>(n == -<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> buffer.limit();</span><br><span class="line">            <span class="type">char</span>[] dst = <span class="keyword">new</span> <span class="title class_">char</span>[limit];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; limit;i++) &#123;</span><br><span class="line">                dst[i] = (<span class="type">char</span>)buffer.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            data.append(dst);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>客户端</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        out.write(s.getBytes());</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="参考文章"   >
          <a href="#参考文章" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/io/java-io-nio.html" >https://pdai.tech/md/java/io/java-io-nio.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>语雀（青空の霞光）：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javase/kl68ty#e4f52ebc" >https://www.yuque.com/qingkongxiaguang/javase/kl68ty#e4f52ebc</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-nio/index.html" >Java NIO Tutorial  (opens new window)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://tech.meituan.com/nio.html" >Java NIO 浅析  (opens new window)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" >IBM: NIO 入门  (opens new window)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>Eckel B, 埃克尔, 昊鹏, 等. Java 编程思想 [M]. 机械工业出版社, 2002.</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" >IBM: NIO 入门  (opens new window)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html" >IBM: 深入分析 Java I&#x2F;O 的工作机制  (opens new window)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/index.htm" >IBM: 深入分析 Java 中的中文编码问题  (opens new window)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html" >IBM: Java 序列化的高级认识  (opens new window)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://blog.csdn.net/shimiso/article/details/24990499" >NIO 与传统 IO 的区别  (opens new window)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://stg-tud.github.io/sedc/Lecture/ws13-14/5.3-Decorator.html#mode=document" >Decorator Design Pattern  (opens new window)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://labojava.blogspot.com/2012/12/socket-multicast.html" >Socket Multicast</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://juejin.cn/post/6974191624331100174" >https://juejin.cn/post/6974191624331100174</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/08/31/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(2)-BIO%E8%AF%A6%E8%A7%A3/">网络编程(2)--BIO详解</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-08-31</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="重要概念"   >
          <a href="#重要概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h1>
      <ul>
<li><code>阻塞IO</code> 和 <code>非阻塞IO</code></li>
</ul>
<p>这两个概念是<code>程序级别</code>的。主要描述的是程序请求操作系统IO操作后，如果IO资源没有准备好，那么程序该如何处理的问题: 前者等待；后者继续执行(并且使用线程一直轮询，直到有IO资源准备好了)。</p>
<p>程序级别的差异表现在开发人员如何编写代码来实现不同功能。</p>
<ul>
<li><code>同步IO</code> 和 <code>非同步IO</code></li>
</ul>
<p>这两个概念是<code>操作系统级别</code>的。主要描述的是操作系统在收到程序请求IO操作后，如果IO资源没有准备好，该如何响应程序的问题: 前者不响应，直到IO资源准备好以后；后者返回一个标记(好让程序和自己知道以后的数据往哪里通知)，当IO资源准备好以后，再用事件机制返回给程序。</p>

        <h1 id="传统的BIO通信简介"   >
          <a href="#传统的BIO通信简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#传统的BIO通信简介" class="headerlink" title="传统的BIO通信简介"></a>传统的BIO通信简介</h1>
      <p>我们这里讲的<code>IO</code>是以套接字为数据载体的<code>BS</code>架构层面，以前大多数网络通信是阻塞模式：</p>
<ul>
<li><p>客户端向服务器端发出请求后，客户端会一直等待(不会再做其他事情)，直到服务器端返回结果或者网络出现问题。</p>
</li>
<li><p>服务器端同样的，当在处理某个客户端A发来的请求时，另一个客户端B发来的请求会等待，直到服务器端的这个处理线程完成上一个处理。</p>
</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/08/31/079d2509a6ab9a23.jpg" alt="BS示意图"></p>
<p>尽管可以使用多线程，主线程接收请求，其他线程来处理请求。但是仍然存在局限，数据报文的接收仍然需要一个一个的来，并且在<code>Linux</code>系统中，可以创建的线程是有限的。每个线程都是较大的资源消耗，<code>JVM</code>创建一个线程时，回味起分配堆栈空间，默认为<code>128K</code>。如果应用程序大量使用长连接，线程不会关闭，系统资源消耗容易失控（此处可以联想QQ，如果不发消息，该线程也会被占用）。</p>

        <h1 id="代码实践"   >
          <a href="#代码实践" class="heading-link"><i class="fas fa-link"></i></a><a href="#代码实践" class="headerlink" title="代码实践"></a>代码实践</h1>
      <p>我们通过<code>socket</code>模拟<code>BIO</code>的实现逻辑</p>
<p>建立<code>Server</code>，建立<code>ServerSocket</code>对象，绑定端口，等待连接，如果连接成功就新建一个线程去处理连接</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">server</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Socket socket=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//绑定端口</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>();</span><br><span class="line">            serverSocket.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 死循环一直等待客户端发送请求</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="comment">//等待连接  阻塞</span></span><br><span class="line">                System.out.println(<span class="string">&quot;等待连接&quot;</span>);</span><br><span class="line">                socket = serverSocket.accept();</span><br><span class="line">                System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">                <span class="comment">//连接成功后新开一个线程去处理这个连接</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;等待读取数据&quot;</span>);</span><br><span class="line">                            <span class="comment">//等待读取数据    阻塞</span></span><br><span class="line">                            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> socket.getInputStream().read(bytes);</span><br><span class="line">                            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,length));</span><br><span class="line">                            System.out.println(<span class="string">&quot;数据读取成功&quot;</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>建立<code>Client</code>–客户端代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Socket socket= <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8080</span>);</span><br><span class="line">            socket.getOutputStream().write(<span class="string">&quot;一条数据&quot;</span>.getBytes());</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>从代码可以看到，当服务端接收到一个客户端请求时，会新开一个线程来执行任务，在<code>IO</code>时会被阻塞。从前面我们对各种<code>IO</code>讲解时知道，<code>read</code>方法，如果<code>IO</code>没有准备好，就会阻塞。不论是阻塞IO，非阻塞IO，多路复用，信号驱动，都会在<code>read</code>方法存在阻塞的情况。</p>
<p>如果操作系统没有发现有套接字从指定的端口X来，那么操作系统就会等待。这样<code>serverSocket.accept()</code>方法就会一直等待。这就是为什么<code>accept()</code>方法为什么会阻塞: 它内部的实现是使用的操作系统级别的同步IO。</p>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p>掘金：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://juejin.cn/post/6974191624331100174" >https://juejin.cn/post/6974191624331100174</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>Java全栈知识体系：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/io/java-io-bio.html" >https://pdai.tech/md/java/io/java-io-bio.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/08/30/Java/%E5%B9%B6%E5%8F%91/Java%E7%BA%BF%E7%A8%8B%E6%B1%A01-%E7%9B%B8%E5%85%B3%E7%B1%BB%E7%BB%93%E6%9E%84/">Java线程池(1)--相关类结构</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-08-30</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-08-30</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="类结构关系图"   >
          <a href="#类结构关系图" class="heading-link"><i class="fas fa-link"></i></a><a href="#类结构关系图" class="headerlink" title="类结构关系图"></a>类结构关系图</h1>
      <p><img src="https://s3.bmp.ovh/imgs/2022/08/30/d1bcfa7989f8d9ea.jpg" alt="UML类图"></p>

        <h1 id="接口"   >
          <a href="#接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#接口" class="headerlink" title="接口"></a>接口</h1>
      
        <h2 id="Excutor"   >
          <a href="#Excutor" class="heading-link"><i class="fas fa-link"></i></a><a href="#Excutor" class="headerlink" title="Excutor"></a>Excutor</h2>
      <blockquote>
<p><code>Executor</code>接口提供一种将任务提交从任务运行分离开来的方法。通常使用 <code>Executor</code> 而不是显式地创建线程。</p>
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>一般来说，任务提交给<code>Excutor</code>，任务不会在提交线程中运行，而是交给其他线程</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>但是<code>Excutor</code>也不是严格异步，最简单的情况下，<code>Excutor</code>可以在调用者线程中立即运行提交的任务</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DirectExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        r.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>其实就是看实现类如何编写代码。<strong>Executor</strong>的主要作用：提供了一种显示创建线程的方式。</p>
<ul>
<li><code>JDK1.5</code>之前的方式：<code>Thread</code> + <code>Runnable</code></li>
<li><code>Executor</code>提供的的方式：<code>Executor</code> + <code>Runnable</code></li>
</ul>

        <h2 id="ExecutorService"   >
          <a href="#ExecutorService" class="heading-link"><i class="fas fa-link"></i></a><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2>
      <blockquote>
<p><code>ExecutorService</code>继承自<code>Executor</code>接口，<code>ExecutorService</code>提供了<strong>管理终止</strong>的方法，以及可为跟踪一个或多个异步任务执行状况而生成 <code>Future</code> 的方法。 可以关闭 <code>ExecutorService</code>，这将导致其停止接受新任务。关闭后，执行程序将最后终止，这时没有任务在执行，也没有任务在等待执行，并且无法提交新任务。</p>
</blockquote>
<p>详细讲解就是：</p>
<ul>
<li><strong>ExecutorService接口</strong>是一个<strong>执行器</strong>，它可以终止任务。</li>
<li><strong>ExecutorService接口</strong>还提供了返回<strong>Future接口</strong>的方法，这个方法可以用于追踪一个或多个异步任务的执行情况。</li>
<li><strong>ExecutorService</strong>可以手动关闭，这种操作会导致它拒绝新的任务。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不再接受新任务，允许之前已经提交的方法执行完毕，然后再关闭执行器</span></span><br><span class="line">shutdown();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻止正在等待的任务开启，并且会试图停止正在执行的任务，然后关闭执行器。</span></span><br><span class="line">shutdownNow();</span><br></pre></td></tr></table></div></figure>

<p><code>ExecutorService</code>还有一个重要的方法：<code>submit()</code>。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);	</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span>;</span><br></pre></td></tr></table></div></figure>

<p>这表示<code>ExecutorService</code>可以接收<code>Runnable</code>，也可以接收<code>Callable&lt;T&gt;</code>。</p>
<p>下面给一个简单的示例</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//newCachedThreadPool就是一个线程池</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ExecutorService通过submit提交任务</span></span><br><span class="line">    executorService.submit(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--- ExecutorService begin.&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;--- ExecutorService end.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--- ExecutorService is interrupted.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>其他一些重要方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在线程池服务执行shutdown()或者shutdownNow()方法之后，所有的任务是否已经完成</span></span><br><span class="line"><span class="comment">// 如果没有执行shutdown()或者shutdownNow()方法，则永远返回false</span></span><br><span class="line">executorService.isTerminated();</span><br><span class="line"></span><br><span class="line"><span class="comment">//阻塞等待所有的任务终止</span></span><br><span class="line"><span class="comment">//如果等待时间超时，则返回false</span></span><br><span class="line"><span class="comment">//如果当前线程被interrupt，则抛出InterruptedException异常</span></span><br><span class="line"><span class="comment">//如果线程池了执行shutdown()或者shutdownNow()方法，并且所有的任务都已经完成，则返回true</span></span><br><span class="line"><span class="comment">//如果线程池未执行shutdown()或者shutdownNow()方法，则永远返回false</span></span><br><span class="line">executorService.awaitTermination(<span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></div></figure>




        <h2 id="ScheduledExecutorService"   >
          <a href="#ScheduledExecutorService" class="heading-link"><i class="fas fa-link"></i></a><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h2>
      <p>从<code>Scheduled</code>可以看出与定时有关。可以在<strong>给定延时</strong>之后调度任务，也可以根据指定的周期调度任务。</p>
<ul>
<li><strong>schedule()方法</strong>可以创建含有<strong>延时(delays)<strong>变量的任务，然后返回一个可以用于</strong>取消</strong>或<strong>检查运行状态</strong>的<strong>Future对象</strong>。如果<code>delays&lt;=0</code>，则会立即执行。</li>
<li><strong>scheduleAtFixedRate()方法</strong>和<strong>scheduleWithFixedDelay()方法</strong>可以创建并运行<strong>定期运行</strong>的任务。</li>
</ul>
<p>详细方法说明：</p>
<p>1.<code>schedule(Runnable command,long delay, TimeUnit unit)</code>：</p>
<ul>
<li>在一定延时(delay)之后，运行Runnable任务。</li>
<li>此任务只运行一次。</li>
</ul>
<p>2.<code>schedule(Callable callable,long delay, TimeUnit unit)</code>：</p>
<ul>
<li>在一定延时(delay)之后，运行Callable任务。</li>
<li>此任务只运行一次。</li>
</ul>
<p>3.<code>scheduleWithFixedDelay(Runnable command,long initialDelay,long delay,TimeUnit unit)</code>：</p>
<ul>
<li>在一定延时(initialDelay)之后，开始周期性的运行Runnable任务。</li>
<li>周期性：上一次任务执行完成之后，等待一段时间(delay)，然后开始下一次任务。</li>
</ul>
<p>4.<code>scheduleAtFixedRate(Runnable command,long initialDelay,long period,TimeUnit unit)</code>：</p>
<ul>
<li>在一定延时(initialDelay)之后，开始周期性的运行Runnable任务。</li>
<li>周期性：每过一段时间(period)，就开始运行一次Runnable任务。</li>
<li>如果任务的执行时间大于等待周期(period)：上一次任务执行完成之后，立即开始下一次任务。也就是说：每过一段时间(任务执行时间)，就开始运行一次Runnable任务。</li>
</ul>

        <h2 id="AbstractExecutorService"   >
          <a href="#AbstractExecutorService" class="heading-link"><i class="fas fa-link"></i></a><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h2>
      <blockquote>
<p><code>AbstractExecutorService</code>继承自<code>ExecutorService</code>接口，其提供 <code>ExecutorService</code> 执行方法的默认实现。此类使用 <code>newTaskFor()</code> 返回的 RunnableFuture 实现 <code>submit</code>、<code>invokeAny</code> 和 <code>invokeAll</code> 方法，默认情况下，<code>RunnableFuture</code> 是此包中提供的 <code>FutureTask</code> 类。</p>
</blockquote>
<p><code>invokeAny()</code>是调用<strong>newTaskFor()方法对任务进行了包装为RunnableFuture对象</strong>，然后调用了<strong>本对象的execute()方法提交任务</strong>，并返回异步计算结果对象。</p>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p>Java全栈知识体系：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/thread/java-thread-x-juc-overview.html" >https://pdai.tech/md/java/thread/java-thread-x-juc-overview.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>Executor接口学习笔记：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/hanchao5272/article/details/79829407" >https://blog.csdn.net/hanchao5272/article/details/79829407</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>ExecutorService接口学习笔记：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/hanchao5272/article/details/79830245" >https://blog.csdn.net/hanchao5272/article/details/79830245</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>ScheduleExecutorService接口学习笔记：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/hanchao5272/article/details/79834744" >https://blog.csdn.net/hanchao5272/article/details/79834744</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>简书：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.jianshu.com/p/7418bedd520f" >https://www.jianshu.com/p/7418bedd520f</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/08/29/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(1)-Unix%20IO%E6%A8%A1%E5%9E%8B/">网络编程(1)--Unix IO模型</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-08-29</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-07</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="I-x2F-O模型"   >
          <a href="#I-x2F-O模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#I-x2F-O模型" class="headerlink" title="I&#x2F;O模型"></a>I&#x2F;O模型</h1>
      <p>Unix包含物种<code>IO</code>模型，分别是：阻塞<code>IO</code>、非阻塞<code>IO</code>、<code>IO</code>多路复用、信号驱动<code>IO</code>、异步<code>IO</code>。和Java的<code>IO</code>模型有下列对应（不严格）</p>
<div class="table-container"><table>
<thead>
<tr>
<th>Java-IO模型</th>
<th>Unix-IO模型</th>
</tr>
</thead>
<tbody><tr>
<td>BIO</td>
<td>阻塞式IO</td>
</tr>
<tr>
<td>NIO</td>
<td>IO多路复用</td>
</tr>
<tr>
<td>AIO</td>
<td>异步IO</td>
</tr>
</tbody></table></div>

        <h2 id="内核态与用户态"   >
          <a href="#内核态与用户态" class="heading-link"><i class="fas fa-link"></i></a><a href="#内核态与用户态" class="headerlink" title="内核态与用户态"></a>内核态与用户态</h2>
      <p>我们将文件从磁盘加载到内存中。操作系统是怎么做的？</p>
<ul>
<li>进程陷入内核态，通过系统调用执行文件阅读。</li>
<li>系统调用结束后，返回用户态。<br>所以Unix的五种IO模型的不同指出，就是这两个步骤的处理流程不同。</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/08/29/263fe8ccf6ac446f.jpg" alt="内核态与用户态"></p>
<p>详细可以参考这篇文章：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039774784" >从根上理解用户态与内核态</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p>

        <h2 id="阻塞式I-x2F-O"   >
          <a href="#阻塞式I-x2F-O" class="heading-link"><i class="fas fa-link"></i></a><a href="#阻塞式I-x2F-O" class="headerlink" title="阻塞式I&#x2F;O"></a>阻塞式I&#x2F;O</h2>
      <p>应用进程被阻塞，知道数据复制到应用进程缓冲区才返回。应该注意到，在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，因此不消耗 <code>CPU</code> 时间，这种模型的执行效率会比较高。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/08/29/2a980fa2571b2c21.jpg" alt="阻塞式I/O"></p>

        <h2 id="非阻塞式-I-x2F-O"   >
          <a href="#非阻塞式-I-x2F-O" class="heading-link"><i class="fas fa-link"></i></a><a href="#非阻塞式-I-x2F-O" class="headerlink" title="非阻塞式 I&#x2F;O"></a>非阻塞式 I&#x2F;O</h2>
      <p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I&#x2F;O 是否完成，这种方式称为轮询(<code>polling</code>)。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/08/29/84ce0bff467e53e2.jpg" alt="非阻塞式IO模型"></p>

        <h2 id="I-x2F-O-多路复用"   >
          <a href="#I-x2F-O-多路复用" class="heading-link"><i class="fas fa-link"></i></a><a href="#I-x2F-O-多路复用" class="headerlink" title="I&#x2F;O 多路复用"></a>I&#x2F;O 多路复用</h2>
      <blockquote>
<p>I&#x2F;O多路复用是指用一个线程检查多个文件描述符（Socket）的状态。</p>
</blockquote>
<p>类似与非阻塞，只不过轮询不是由用户线程去执行，而是由内核去轮询，内核监听程序监听到数据准备好后，调用内核函数复制数据到用户态。<code>select</code>系统调用（poll，充当代理类的角色，不断轮询注册到它这里的所有需要<code>IO</code>的文件描述符，有结果时，把结果告诉被代理的<code>recvfrom</code>函数，再去拿数据。</p>
<p>一个线程可以对多个<code>IO</code>端口进行监听，当<code>socket</code>有读写事件时分发到<strong>具体的线程</strong>进行处理。模型如下所示：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/08/29/934a13f46855bf91.jpg" alt="多路复用"></p>
<p>我们着重讲解一下多路复用，这在之后讲解<code>Reactor</code>模型会用到。传统的<code>I/O</code>有个很大的缺点就是，为每一个客户端连接都准备一个线程，如果客户端是长连接（如果客户端还不发送数据，服务端线程会一直阻塞在<code>read</code>那里），线程也就要一直维护。随着这样的客户端连接越来越多，就会导致服务器资源耗尽。一个客户端会有很多种<strong>状态</strong>：读写，解码，编码，连接等，我们通过<code>Selector</code>选择器轮询这些客户端，只有客户端在对应的状态才会创建线程进行处理（比如真正开始读写才会创建线程执行，当然，这些由线程池维护）。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/07/4d3abcf790e05c9b.jpg"></p>
<p>关于复用的几个系统调用（看不懂就算了）：</p>

        <h3 id="select"   >
          <a href="#select" class="heading-link"><i class="fas fa-link"></i></a><a href="#select" class="headerlink" title="select"></a>select</h3>
      <blockquote>
<p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p>
</blockquote>

        <h3 id="poll"   >
          <a href="#poll" class="heading-link"><i class="fas fa-link"></i></a><a href="#poll" class="headerlink" title="poll"></a>poll</h3>
      <blockquote>
<p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p>
</blockquote>

        <h3 id="epoll"   >
          <a href="#epoll" class="heading-link"><i class="fas fa-link"></i></a><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3>
      <blockquote>
<p>epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。</p>
</blockquote>

        <h2 id="信号驱动-I-x2F-O"   >
          <a href="#信号驱动-I-x2F-O" class="heading-link"><i class="fas fa-link"></i></a><a href="#信号驱动-I-x2F-O" class="headerlink" title="信号驱动 I&#x2F;O"></a>信号驱动 I&#x2F;O</h2>
      <p>应用进程使用 <code>sigaction</code> 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 <code>SIGIO</code> 信号，应用进程收到之后在信号处理程序中调用 <code>recvfrom</code> 将数据从内核复制到应用进程中。</p>
<p>相比于非阻塞式 <code>I/O</code> 的轮询方式，信号驱动 <code>I/O</code> 的 <code>CPU</code> 利用率更高。</p>
<p>缺点：信号 <code>I/O</code> 在大量 <code>IO</code> 操作时可能会因为信号队列溢出导致没法通知。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/08/29/d11f190edcb68560.jpg"></p>

        <h2 id="异步I-x2F-O"   >
          <a href="#异步I-x2F-O" class="heading-link"><i class="fas fa-link"></i></a><a href="#异步I-x2F-O" class="headerlink" title="异步I&#x2F;O"></a>异步I&#x2F;O</h2>
      <p>在上面四种<code>I/O</code>模型中我们看到，进程在调用<code>recvfrom</code>到处理数据报时都会被阻塞，而异步<code>I/O</code>做到了真正的非阻塞。异步<code>I/O</code>也是依靠信号通知，但是通知的时候并不是数据报准备好了，而是<code>I/O</code>操作已经完成。</p>
<p>主进程只负责做自己的事情，等<code>IO</code>操作完成(数据成功从内核缓存区复制到应用程序缓冲区)时通过回调函数对数据进行处理。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/08/29/a4dae8581b870ade.jpg"></p>
<p>相对于同步<code>IO</code>，异步<code>IO</code>不是顺序执行。用户进程进行<code>aio_read</code>系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到<code>socket</code>数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。<code>IO</code>两个阶段，进程都是非阻塞的。</p>
<p>要实现真正的异步 <code>I/O</code>，操作系统需要做大量的工作。目前 <code>Windows</code> 下通过 <code>IOCP</code> 实现了真正的异步 <code>I/O</code>。</p>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p>Java全栈知识体系：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/io/java-io-model.html" >https://pdai.tech/md/java/io/java-io-model.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>Stevens W R, Fenner B, Rudoff A M. UNIX network programming[M]. Addison-Wesley Professional, 2004.</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/linux/library/l-async/" >Boost application performance using asynchronous I&#x2F;O  (opens new window)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365683(v=vs.85).aspx" >Synchronous and Asynchronous I&#x2F;O  (opens new window)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000003063859" >Linux IO 模式及 select、poll、epoll 详解  (opens new window)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://daniel.haxx.se/docs/poll-vs-select.html" >poll vs select vs event-based  (opens new window)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://www.ulduzsoft.com/2014/01/select-poll-epoll-practical-difference-for-system-architects/" >select &#x2F; poll &#x2F; epoll: practical difference for system architects  (opens new window)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://juejin.cn/post/6844904041412214798#" >unix 网络编程 第一卷</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://juejin.cn/post/6844903728718462990" >五种IO模型介绍和对比</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/43933717" >一文读懂高性能网络编程中的I&#x2F;O模型</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   href="https://link.juejin.cn/?target=https://www.jianshu.com/p/dfd940e7fca2" >聊聊IO多路复用之select、poll、epoll详解</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/08/29/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/IO(4)-%E5%B8%B8%E8%A7%81%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/">IO(4)--常见类的使用</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-08-29</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="IO常见类"   >
          <a href="#IO常见类" class="heading-link"><i class="fas fa-link"></i></a><a href="#IO常见类" class="headerlink" title="IO常见类"></a>IO常见类</h1>
      <p>Java 的 <code>I/O</code> 大概可以分成以下几类:</p>
<ul>
<li>磁盘操作: File</li>
<li>字节操作: InputStream 和 OutputStream</li>
<li>字符操作: Reader 和 Writer</li>
<li>对象操作: Serializable</li>
<li>网络操作: Socket</li>
</ul>
<p>像<code>FileInputStream</code>这样的类都是字节操作的子类，不算入常见类讲解，之后会对这些子类单独开坑。</p>

        <h1 id="文件流"   >
          <a href="#文件流" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h1>
      
        <h2 id="File类"   >
          <a href="#File类" class="heading-link"><i class="fas fa-link"></i></a><a href="#File类" class="headerlink" title="File类"></a>File类</h2>
      <p><code>File</code> 类可以用于表示文件和目录的信息，但是它不表示文件的内容。不能访问文件内容本身，需要通过输入输出流进行访问。访问路径可以是绝对&#x2F;相对路径。相对路径是由系统属性<code>user.dir</code>指定，即为Java VM所在路径。</p>
<p>可以递归列出目录下所有文件</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">listAllFiles</span><span class="params">(File dir)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">null</span> || !dir.exists()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dir.isFile()) &#123;</span><br><span class="line">        System.out.println(dir.getName());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (File file : dir.listFiles()) &#123;</span><br><span class="line">        listAllFiles(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><code>File</code>类中大部分方法都是判断类的方法，返回一个<code>boolean</code>值，方法体简单，此处不会过多讲解，详细全面的方法可以参考<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/" >Java8 API文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p>
<ul>
<li><code>public void deleteOnExit()</code>：在VM关闭的时候，删除该文件或者目录，不像<code>delete()</code>方法一调用就删除。一般用于临时文件比较合适。</li>
<li><code>public boolean renameTo(File dest)</code>：重命名此File对象所对应的文件或目录，如果重命名成功，则返回true；否则，返回false。</li>
<li><code>public boolean setReadOnly()</code>：设置此File对象为只读权限。</li>
<li><code>public boolean setWritable(boolean writable, boolean ownerOnly)</code>：写权限设置，<code>writable</code>如果为<code>true</code>，允许写访问权限；如果为<code>false</code>，写访问权限是不允许的。<code>ownerOnly</code>如果为<code>true</code>，则写访问权限仅适用于所有者；否则它适用于所有人。</li>
<li><code>public boolean setWritable(boolean writable)</code>： 底层实现是：通过<code>setWritable(writable, true)</code>实现，默认是仅适用于文件或目录所有者。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">setWritable</span><span class="params">(<span class="type">boolean</span> writable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> setWritable(writable, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同样的，还有setReadable，setExecutable方法</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li><code>public static File createTempFile(String prefix, String suffix, File directory)</code>：在指定的临时文件目录<code>directort</code>中，创建一个临时空文件。可以直接使用File类来调用，使用给定前缀、系统生成的随机数以及给定后缀作为文件名。<code>prefix</code>至少3字节长。如果<code>suffix</code>设置为<code>null</code>，则默认后缀为<code>.tmp</code>。</li>
<li><code>public String[] list()</code>：列出<code>File</code>对象的所有子文件名和路径名，返回的是<code>String</code>数组。</li>
</ul>

        <h3 id="文件过滤器"   >
          <a href="#文件过滤器" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件过滤器" class="headerlink" title="文件过滤器"></a>文件过滤器</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:testDir&quot;</span>);</span><br><span class="line">        String[] nameArr = file.list(((dir, name) -&gt; name.endsWith(<span class="string">&quot;.doc&quot;</span>)));</span><br><span class="line">        <span class="keyword">for</span> (String name : nameArr) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这里的<code>list</code>函数接收一个Lambda表达式，其方法如下</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] list(FilenameFilter filter) &#123;</span><br><span class="line">    String names[] = list();</span><br><span class="line">    <span class="keyword">if</span> ((names == <span class="literal">null</span>) || (filter == <span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> names;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; v = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 将符合条件的文件加入到返回值中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; names.length ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filter.accept(<span class="built_in">this</span>, names[i])) &#123;</span><br><span class="line">            v.add(names[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[v.size()]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FilenameFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File dir, String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="字节流相关"   >
          <a href="#字节流相关" class="heading-link"><i class="fas fa-link"></i></a><a href="#字节流相关" class="headerlink" title="字节流相关"></a>字节流相关</h2>
      <p>这里介绍关于<code>InputStream</code>和<code>OutputStream</code>最简单的使用</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(File in,File out)</span> &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(in);</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(out);</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">Byte</span>[<span class="number">20</span>*<span class="number">1024</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>((<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> input.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        output.write(buffer,<span class="number">0</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="字符流相关"   >
          <a href="#字符流相关" class="heading-link"><i class="fas fa-link"></i></a><a href="#字符流相关" class="headerlink" title="字符流相关"></a>字符流相关</h2>
      <p>最简单的使用，逐行输出文本</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(File in)</span> &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">filReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">    <span class="type">BufferReader</span> <span class="variable">bufferReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReaderBuffer</span>(fileReader);</span><br><span class="line">    String line;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>((line = bufferReader.readLine() != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 装饰者模式使得 BufferedReader 组合了一个 Reader 对象</span></span><br><span class="line">    <span class="comment">// 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法</span></span><br><span class="line">    <span class="comment">// 因此只要一个 close() 调用即可</span></span><br><span class="line">    bufferedReader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="序列化"   >
          <a href="#序列化" class="heading-link"><i class="fas fa-link"></i></a><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2>
      <p>一般为了将一个对象存储到文件中，我们可以使用<code>Json</code>，也可以使用序列化，<strong>序列化就是将一个对象转换成字节序列，方便存储和传输</strong>。你可以将需要存储的对象（多个）放在一个<code>list</code>或者<code>map</code>集合中，然后再通过序列化将集合放入文件中（但是你打开文件里面是乱码，不像<code>Json</code>可以清晰的看到保存的实际内容）。</p>
<p>相关方法：</p>
<ul>
<li>序列化: ObjectOutputStream.writeObject()</li>
<li>反序列化: ObjectInputStream.readObject()</li>
</ul>
<p>看看最基本的使用</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>(<span class="number">123</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">objectFile</span> <span class="operator">=</span> <span class="string">&quot;file/a1&quot;</span>;</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(objectFile));</span><br><span class="line">    objectOutputStream.writeObject(a1);</span><br><span class="line">    objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(objectFile));</span><br><span class="line">    <span class="type">A</span> <span class="variable">a2</span> <span class="operator">=</span> (A) objectInputStream.readObject();</span><br><span class="line">    objectInputStream.close();</span><br><span class="line">    System.out.println(a2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> String y;</span><br><span class="line"></span><br><span class="line">    A(<span class="type">int</span> x, String y) &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;x = &quot;</span> + x + <span class="string">&quot;  &quot;</span> + <span class="string">&quot;y = &quot;</span> + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>不会对静态变量进行序列化，因为序列化只是<strong>保存对象的状态</strong>，静态变量属于类的状态。对于非静态属性，也可以使用<code>transient</code>关键字，该关键字可以避免被修饰属性序列化。</p>
<p>例如<code>ArrayList</code>中存储数据的数组 <code>elementData</code> 是用 <code>transient</code> 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></div></figure>

<p><code>ArrayList</code>中实现了<code>writeObject</code>和<code>readObject</code></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> java.io.IOException&#123;</span><br><span class="line">        <span class="comment">// 防止序列化期间有修改</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 写出非transient非static属性（会写出size属性）</span></span><br><span class="line">    	<span class="comment">// ArrayList不可能只有一个数组需要序列化吧</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写出大小作为与clone（）行为兼容的容量</span></span><br><span class="line">        s.writeInt(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//依次写出元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            s.writeObject(elementData[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果有修改，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>一般地，只要实现了Serializable接口即可自动序列化，<code>writeObject()</code>和<code>readObject()</code>是为了自己控制序列化的方式，这两个方法必须声明为<code>private</code>，在<code>java.io.ObjectStreamClass#getPrivateMethod()</code>方法中通过反射获取到<code>writeObject()</code>这个方法。</p>
<p><code>readObject</code>同理</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 声明为空数组</span></span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入非transient非static属性（会读取size属性）</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入元素个数，没什么用，只是因为写出的时候写了size属性，读的时候也要按顺序来读</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 计算容量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> calculateCapacity(elementData, size);</span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">        <span class="comment">// 检查是否需要扩容</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依次读取元素到数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="缓冲流"   >
          <a href="#缓冲流" class="heading-link"><i class="fas fa-link"></i></a><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h1>
      <p>缓冲流也分输入流和输出流，字节流和字符流。使用方法大同小异，这里以缓冲流的字节输入流<code>BufferedInputStream</code>为例讲解。</p>
<p>构造方法：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(in);</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Buffer size &lt;= 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    buf = <span class="keyword">new</span> <span class="title class_">byte</span>[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(in, DEFAULT_BUFFER_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>一般接收的参数可以是<code>FileInputStream</code>，如果你了解<strong>装饰者模式</strong>，就会对这种设计非常熟悉。</p>
<p>缓冲流的出现主要是<code>FileInputStream</code>这样的文件类都是直接和硬盘进行交互，但是磁盘的随机读取是十分消耗时间的。我们可以假设这么一种情况：一般我们使用<code>FileInputstream</code>时，都会在外界定义一个数组，然后循环调用<code>read</code>函数将磁盘中的数据读到数组中。但是这有一个问题，我们假设定义的数组很小，那么要将磁盘中的数据全部都出来就需要调用多次<code>read</code>方法。假设循环第一次调用<code>read</code>方法，磁盘将磁头定位到相应位置（这个过程对于CPU来说非常慢），然后转动磁盘进行顺序读取。此时电脑中其他程序也需要访问磁盘中的数据，那么磁盘又需要重新转动磁头定位到磁盘中相应的位置进行数据读取。到了后面的循环调用<code>read</code>，由于磁头并不在第一次<code>read</code>读取到的磁盘区域，所以磁头又要重新定位……</p>
<p>所以缓冲流就是将我们定义的那个数组放到类里面进行封装，同时提供一些其他便于使用的方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span></span><br></pre></td></tr></table></div></figure>

<p><code>read</code>对外提供的方法没有变化，只是说返回的结果不一定是从硬盘中直接读取的，也可能是从缓冲数组返回的。</p>
<p>这里着重讲一下<code>mark</code>方法和<code>reset</code>方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mark方法能够在当前位置打一个标记，之后再次调用reset方法，&quot;指针就会回到标记处&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">mark</span><span class="params">(<span class="type">int</span> readlimit)</span> &#123;</span><br><span class="line">    marklimit = readlimit;</span><br><span class="line">    markpos = pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    getBufIfOpen(); <span class="comment">// Cause exception if closed</span></span><br><span class="line">    <span class="keyword">if</span> (markpos &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Resetting to invalid mark&quot;</span>);</span><br><span class="line">    pos = markpos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>方法的实现很简单，只是设置了几个变量的值，所以我们需要看一下<code>BufferedInputStream</code>相关的变量设计</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓冲数组</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="type">byte</span> buf[];</span><br><span class="line"></span><br><span class="line"><span class="comment">// mark方法最多保存的字节</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> marklimit;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记位置</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="variable">markpos</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组中存储的数据个数</span></span><br><span class="line"><span class="comment">// 源码注释为缓冲数组中最后一个有效的元素的下标+1</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前读取到数组中的位置</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> pos;</span><br></pre></td></tr></table></div></figure>

<p>我们可以思考一下，如果没有<code>mark</code>和<code>reset</code>方法（以及相关的属性都没有），那么关于缓冲的设计，无非就是当<code>(pos==buff.length)</code>时将<code>pos</code>设为0，然后重新读一组数组覆盖<code>buff</code>数组。</p>
<p>再复杂一点就是，有次读取也许并不会将数组填满（这很正常，比如磁盘中数组不足以填满缓冲数组），假设长度为10，有可能读了9个数据进去，此时<code>count=9</code>。那么我们在重新覆盖数组前，应该先判断一下<code>pos&gt;=count</code>这个条件。</p>
<p>所以我们来看一下<code>read</code>源码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &gt;= count) &#123;<span class="comment">// 数组中所有数据都被读取了</span></span><br><span class="line">        fill();<span class="comment">// 重新填入数据</span></span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= count) <span class="comment">// 如果重新填入数据都pos仍然大于count，说明没有数据了</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反正就是返回读到的元素</span></span><br><span class="line">    <span class="keyword">return</span> getBufIfOpen()[pos++] &amp; <span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>如果我们不考虑<code>mark</code>方法的实现，那么<code>fill()</code>应该这么实现</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fill</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">     <span class="type">byte</span>[] buffer = getBufIfOpen();<span class="comment">// 获取缓冲数组</span></span><br><span class="line"> 	pos = <span class="number">0</span>;</span><br><span class="line">    count = pos;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取数据到缓冲数组中</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> getInIfOpen().read(buffer, pos, buffer.length - pos);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>) &#123;<span class="comment">// 读取到数据</span></span><br><span class="line">        count += n;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果没有数据了，fill结束时pos和count都是0，在read中就返回-1</span></span><br></pre></td></tr></table></div></figure>

<p>但是如果要考虑mark标记，我们就不能随意覆盖标记，我们先举一种极端的情况</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bI</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(in,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        bI.mark(<span class="number">40</span>);<span class="comment">// 我们允许打上标记后，如果进行了&gt;40次read，reset可能会失效</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">20</span>;i++) &#123;</span><br><span class="line">            bI.read();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bI.reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面的代码，我们只设置了缓冲区数组大小为4，但是mark的参数是40，我们在reset处打断点查看一下变量</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/05/0b2154c97cf6a393.jpg" alt="mark参数"></p>
<p>显然mark参数会影响数组大小（其实是赋值给<code>marklimit</code>，然后在<code>fill</code>中扩容的），但是代码注释中我也写了是可能会失效，<code>BufferedInputStream</code>你可以理解为是尽力在维护保存这个标记，如果mark的参数<code>k</code>很小，也就是使用者能够容忍在额外调用了<code>k</code>次<code>read</code>后<code>reset</code>会失效的，但是如果缓冲数组能够在读取了<code>k</code>次后还能保存标记位，它是会去保存的。所以我们就需要看一下<code>fill</code>原本完整的代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fill</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = getBufIfOpen();</span><br><span class="line">    <span class="comment">// markpos &lt; 0说明没有调用过mark，也就是不考虑mark的情况</span></span><br><span class="line">    <span class="keyword">if</span> (markpos &lt; <span class="number">0</span>)</span><br><span class="line">        pos = <span class="number">0</span>;           </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pos &gt;= buffer.length)  <span class="comment">// no room left in buffer -- 需要扩容</span></span><br><span class="line">        <span class="keyword">if</span> (markpos &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="comment">// 将markpos到末尾的数据都重新复制到数组前面的位置</span></span><br><span class="line">            <span class="comment">// 此时不用管marklimit,因为现在是调用reset一定能回到标志处</span></span><br><span class="line">            <span class="comment">// 这就是上面所说的尽量保存标记位</span></span><br><span class="line">            <span class="comment">// 你可以想想，如果marklimit很小，但是数组仍会保存这个标记位</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> pos - markpos;</span><br><span class="line">            System.arraycopy(buffer, markpos, buffer, <span class="number">0</span>, sz);</span><br><span class="line">            pos = sz;</span><br><span class="line">            markpos = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buffer.length &gt;= marklimit) &#123;<span class="comment">// 此时markpos一定为0</span></span><br><span class="line">            <span class="comment">// 哪怕尽量保存，当markpos不断前移，直到为0时，就不能再保存了</span></span><br><span class="line">            <span class="comment">// 所以此时就会失效</span></span><br><span class="line">            <span class="comment">// 所以你会看到，当marklimit很小时，会出现两种情况</span></span><br><span class="line">            <span class="comment">// 1.如果数组很大很大，失效就会出现得更晚（其实次数就是length）</span></span><br><span class="line">            <span class="comment">// 2.如果数组很小（但是依然&gt;=marklimit),失效也会很早（次数其实也是length）</span></span><br><span class="line">            markpos = -<span class="number">1</span>;   </span><br><span class="line">            pos = <span class="number">0</span>;       </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buffer.length &gt;= MAX_BUFFER_SIZE) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>(<span class="string">&quot;Required array size too large&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果我们设置的marklimit很大很大，超过了length</span></span><br><span class="line">            <span class="comment">// 那么数组就应该迎合使用者，哪怕对数组扩容也要在marklimit失效前保存标记位</span></span><br><span class="line">            <span class="comment">// 这里采用的是二倍扩容</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nsz</span> <span class="operator">=</span> (pos &lt;= MAX_BUFFER_SIZE - pos) ?</span><br><span class="line">                pos * <span class="number">2</span> : MAX_BUFFER_SIZE;</span><br><span class="line">            <span class="keyword">if</span> (nsz &gt; marklimit)</span><br><span class="line">                nsz = marklimit;</span><br><span class="line">            <span class="type">byte</span> nbuf[] = <span class="keyword">new</span> <span class="title class_">byte</span>[nsz];</span><br><span class="line">            System.arraycopy(buffer, <span class="number">0</span>, nbuf, <span class="number">0</span>, pos);</span><br><span class="line">            <span class="keyword">if</span> (!bufUpdater.compareAndSet(<span class="built_in">this</span>, buffer, nbuf)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Stream closed&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            buffer = nbuf;</span><br><span class="line">        &#125;</span><br><span class="line">    count = pos;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> getInIfOpen().read(buffer, pos, buffer.length - pos);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        count = n + pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>差不多缓冲流就是这样了，在装饰者模式下，实现简单易懂。</p>

        <h1 id="转换流"   >
          <a href="#转换流" class="heading-link"><i class="fas fa-link"></i></a><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h1>
      <p>假设我们只拿到了<code>FileInputStream</code>，却希望使用字符流，这里还是需要借助装饰者模式</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">InputStreamReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">        System.out.println((<span class="type">char</span>) reader.reader());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通的字符流是：Reader reader = new FileReader();</span></span><br></pre></td></tr></table></div></figure>

<p><code>writer</code>是差不多的，不再赘述。</p>

        <h1 id="打印流"   >
          <a href="#打印流" class="heading-link"><i class="fas fa-link"></i></a><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h1>
      <p>平时使用的<code>System.out</code>就是打印流<code>PrnitStream</code>，该类也继承了<code>FilterOutputStream</code>类。存在自动帅那些机制，当向打印流中写入一个字节数组后自动调用<code>flush</code>方法。内部不会抛出异常，而是使用<code>checkError()</code>方法进行错误检查。他能格式化任意类型并以字符串的形式写入到输出流中。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(Strin[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">PrintStream</span> <span class="variable">stream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">        stream.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p>掘金：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://juejin.cn/post/6844904126858428424#heading-6" >https://juejin.cn/post/6844904126858428424#heading-6</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>ArrayList是如何实现序列化的：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43561507/article/details/109439693" >https://blog.csdn.net/qq_43561507/article/details/109439693</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>Java全栈知识体系：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/io/java-io-basic-usage.html" >https://pdai.tech/md/java/io/java-io-basic-usage.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/08/29/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/IO(3)-OutputStream%E6%BA%90%E7%A0%81/">IO(3)--OutputStream源码</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-08-29</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="类结构"   >
          <a href="#类结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h1>
      <p><img src="https://s3.bmp.ovh/imgs/2022/08/29/e599d6a89199aff1.jpg" alt="UML"></p>

        <h1 id="源码解析"   >
          <a href="#源码解析" class="heading-link"><i class="fas fa-link"></i></a><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1>
      <p>我们已经分析了<code>InputStream</code>，这两个很相似，一个<code>read</code>对应一个<code>write</code>，也是使用了装饰者模式，这里直接给出源码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SOutputStream</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span>, Flushable &#123;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指定的字节写入输出流</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指定的byte数组的字节全部写入输出流</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span> b[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        write(b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指定的byte数组中从偏移量off开始的len个字节写入输出流</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((off &lt; <span class="number">0</span>) || (off &gt; b.length) || (len &lt; <span class="number">0</span>) ||</span><br><span class="line">                   ((off + len) &gt; b.length) || ((off + len) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; len ; i++) &#123;</span><br><span class="line">            write(b[off + i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新输出流，并强制写出所有缓冲的输出字节</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭输出流，并释放与该流有关的所有资源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/08/27/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/IO(2)-InputStream%E6%BA%90%E7%A0%81/">IO(2)--InputStream源码</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-08-27</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h1>
      <p>在阅读本文之前，请先看完上一篇文章中<code>IO</code>的类设计使用了装饰者模式。<code>InputStream</code>表示输入，是指外界对程序进行数据的输入。它是一个抽象类，即表示所有字节输入流实现类的基类。它的作用就是抽象地表示所有从不同数据源产生输入的类。</p>

        <h1 id="核心方法"   >
          <a href="#核心方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h1>
      <p><code>InputStream</code>的三个<code>read</code>是最核心的方法（<strong>JDK8</strong>），分别是</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取下一个字节的数据，如果没有则返回-1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[])</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> read(b, <span class="number">0</span>, b.length);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 具体实现之后分析</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span></span><br></pre></td></tr></table></div></figure>

<p>在<strong>JDK9</strong>和<strong>JDK11</strong>又新增了其他几个方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK9新增：读取 InputStream 中的所有剩余字节，调用readNBytes(Integer.MAX_VALUE)方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] readAllBytes()</span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK11更新：读取 InputStream 中的剩余字节的指定上限大小的字节内容；此方法会一直阻塞，直到读取了请求的字节数、检测到流结束或引发异常为止。此方法不会关闭输入流。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] readNBytes(<span class="type">int</span> len)</span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK9新增：从输入流读取请求的字节数并保存在byte数组中； 此方法会一直阻塞，直到读取了请求的字节数、检测到流结束或引发异常为止。此方法不会关闭输入流。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">readNBytes</span><span class="params">(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// JDK9新增：读取 InputStream 中的全部字节并写入到指定的 OutputStream 中</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">transferTo</span><span class="params">(OutputStream out)</span></span><br></pre></td></tr></table></div></figure>

<p>其他的重要方法之后会在源码讲解提到。</p>

        <h1 id="源码解析"   >
          <a href="#源码解析" class="heading-link"><i class="fas fa-link"></i></a><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1>
      <p><code>InputStream</code>有几个重要的属性</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当使用skip方法时，最大的buffer size大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SKIP_BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的buffer size（JDK8没有该属性）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">8192</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于一些VM在数组中保留一些头字，所以尝试分配较大的阵列可能会导致</span></span><br><span class="line"><span class="comment">// OutOfMemoryError（请求的阵列大小超过VM限制）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_BUFFER_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></div></figure>

<p><code>read(byte b[], int off, int len)</code>方法：因为代码比较简单，读者可以自行在<code>IDE</code>中查看，这里给出流程图</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/08/27/03f2dc59b76e0b13.jpg" alt="read方法"></p>
<p><code>readNBytes(int len)</code>方法：代码较长，但是都比较简单</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取 InputStream 中的剩余字节的指定上限大小的字节内容；此方法会一直阻塞，</span></span><br><span class="line"><span class="comment">// 直到读取了请求的字节数、检测到流结束或引发异常为止。此方法不会关闭输入流。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] readNBytes(<span class="type">int</span> len) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 边界检查</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;len &lt; 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;<span class="type">byte</span>[]&gt; bufs = <span class="literal">null</span>; <span class="comment">// 缓存每次读取到的内容放到bufs，最后组装成result</span></span><br><span class="line">    <span class="type">byte</span>[] result = <span class="literal">null</span>; <span class="comment">// 最后读取到的内容</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> len; <span class="comment">// 剩余字节长度</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化缓存数组</span></span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[Math.min(remaining, DEFAULT_BUFFER_SIZE)];</span><br><span class="line">        <span class="type">int</span> <span class="variable">nread</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取到结束为止，结束条件：要么buf被读满，要么remaining==0</span></span><br><span class="line">        <span class="keyword">while</span> ((n = read(buf, nread,</span><br><span class="line">                         Math.min(buf.length - nread, remaining))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nread += n; </span><br><span class="line">            remaining -= n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (MAX_BUFFER_SIZE - total &lt; nread) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>(<span class="string">&quot;Required array size too large&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            total += nread;</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">                result = buf;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bufs == <span class="literal">null</span>) &#123;</span><br><span class="line">                    bufs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    bufs.add(result);</span><br><span class="line">                &#125;</span><br><span class="line">                bufs.add(buf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果读不到内容（返回-1）或者没有剩余的字节，则跳出循环</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (n &gt;= <span class="number">0</span> &amp;&amp; remaining &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bufs == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.length == total ?</span><br><span class="line">            result : Arrays.copyOf(result, total);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组装最后的result</span></span><br><span class="line">    result = <span class="keyword">new</span> <span class="title class_">byte</span>[total];</span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    remaining = total;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">byte</span>[] b : bufs) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> Math.min(b.length, remaining);</span><br><span class="line">        System.arraycopy(b, <span class="number">0</span>, result, offset, count);</span><br><span class="line">        offset += count;</span><br><span class="line">        remaining -= count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>从这两个方法可以看出，<code>InputStream</code>最核心的就是<code>read()</code>方法，子类如何实现该方法决定了子类的作用。所以类似其他的<code>int readNBytes(byte[],int,int)</code>之类的，其实现都很简单。</p>
<p>关于<code>read(byte[],int,int)</code>和<code>readNBytes(byte[],int,int)</code>的区别：</p>
<ul>
<li><code>read(byte[], int, int)</code>是尝试读到最多<code>len</code>个<code>bytes</code>，但是<strong>读取到的内容长度可能是小于len</strong>的。</li>
<li><code>readNBytes(byte[], int, int)</code> 会一直（<code>while</code>循环）查找直到<code>stream</code>尾为止。</li>
</ul>
<p>这里需要注意的是<code>skip</code>方法的实现</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳过指定个数的字节不读取</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">remaining</span> <span class="operator">=</span> n;</span><br><span class="line">    <span class="type">int</span> nr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">int</span>)Math.min(MAX_SKIP_BUFFER_SIZE, remaining);</span><br><span class="line">    <span class="type">byte</span>[] skipBuffer = <span class="keyword">new</span> <span class="title class_">byte</span>[size];</span><br><span class="line">    <span class="keyword">while</span> (remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        nr = read(skipBuffer, <span class="number">0</span>, (<span class="type">int</span>)Math.min(size, remaining));</span><br><span class="line">        <span class="keyword">if</span> (nr &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        remaining -= nr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n - remaining;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><code>skip</code>方法不是说在数据源中跳过<code>n</code>个字节然后再使用<code>read</code>读取，而是将这<code>n</code>个字节读到一个缓存数组中，方法结束后该数组又会被回收，但是文件指针在数据源中的位置确实移动了<code>n</code>个字节。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">int</span>)Math.min(MAX_SKIP_BUFFER_SIZE, remaining);</span><br></pre></td></tr></table></div></figure>

<p>这行代码决定了跳过字节数是有限制的，最多是<code>2048</code>个字节。</p>
<p><code>transferTo</code>方法：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK9新增：读取 InputStream 中的全部字节并写入到指定的 OutputStream 中</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">transferTo</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    Objects.requireNonNull(out, <span class="string">&quot;out&quot;</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">transferred</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[DEFAULT_BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> read;</span><br><span class="line">    <span class="keyword">while</span> ((read = <span class="built_in">this</span>.read(buffer, <span class="number">0</span>, DEFAULT_BUFFER_SIZE)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        out.write(buffer, <span class="number">0</span>, read);</span><br><span class="line">        transferred += read;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> transferred;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p>Java全栈知识体系：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/io/java-io-basic-code-inputstream.html" >https://pdai.tech/md/java/io/java-io-basic-code-inputstream.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>并发编程网：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://ifeve.com/java-io-%E4%B9%8B-inputstream%E6%BA%90%E7%A0%81/" >http://ifeve.com/java-io-%E4%B9%8B-inputstream%E6%BA%90%E7%A0%81/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>stackoverflow：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://stackoverflow.com/questions/53754387/java-read-vs-readnbytes-of-the-inputstream-instance" >https://stackoverflow.com/questions/53754387/java-read-vs-readnbytes-of-the-inputstream-instance</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/08/26/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/IO(1)-%E5%88%86%E7%B1%BB/">Java IO(1)--分类</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-08-26</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h1>
      <p>为了分类方便和知识的连贯性，这里就将IO的部分（关于文件流的操作）也放到网络编程的<code>Tags</code>里面。真正的网络编程大概就是从<code>Socket</code>那一块开始讲解，接着就是缓冲区，通道以及NIO的各种详解。</p>

        <h1 id="传输方式"   >
          <a href="#传输方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h1>
      <p>分为字节流和字符流：<code>字节</code>是个计算机看的，<code>字符</code>才是给人看的。</p>
<p>字节流主要是<code>InputStream</code>和<code>OutputStream</code>派生出来的一些列类。字符流主要<code>Reader</code>和<code>Writer</code>派生出来的类。</p>

        <h2 id="字节流和字符流区别"   >
          <a href="#字节流和字符流区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#字节流和字符流区别" class="headerlink" title="字节流和字符流区别"></a>字节流和字符流区别</h2>
      <ul>
<li><p>字节流读取单个字节，字符流读取单个字符(一个字符根据编码的不同，对应的字节也不同，如 UTF-8 编码中文汉字是 3 个字节，GBK编码中文汉字是 2 个字节。)</p>
</li>
<li><p>字节流用来处理二进制文件(图片、MP3、视频文件)，字符流用来处理文本文件(可以看做是特殊的二进制文件，使用了某种编码，人可以阅读)。</p>
</li>
</ul>

        <h2 id="编码与解码"   >
          <a href="#编码与解码" class="heading-link"><i class="fas fa-link"></i></a><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h2>
      <p>编码是将字符转为字节，解码是将字节组合成字符。编码和解码过程使用不同的编码方式那么就出现了乱码。</p>
<p>Java 使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。</p>

        <h1 id="数据操作"   >
          <a href="#数据操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h1>
      <p>分类大致看下表</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">对应类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">文件</td>
<td align="center">FileInputStream,FileOutputStream,FileReader,FileWriter</td>
</tr>
<tr>
<td align="center">数组</td>
<td align="center">ByteArrayInputStream,ByteArrayOutputStream,CharArrayReader、CharArrayWriter</td>
</tr>
<tr>
<td align="center">管道</td>
<td align="center">PipedInputStream、PipedOutputStream、PipedReader、PipedWriter</td>
</tr>
<tr>
<td align="center">基本数据类型</td>
<td align="center">DataInputStream、DataOutputStream</td>
</tr>
<tr>
<td align="center">缓冲</td>
<td align="center">BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter</td>
</tr>
<tr>
<td align="center">打印</td>
<td align="center">PrintStream、PrintWriter</td>
</tr>
<tr>
<td align="center">对象序列化反序列化</td>
<td align="center">ObjectInputStream、ObjectOutputStream</td>
</tr>
<tr>
<td align="center">转换</td>
<td align="center">InputStreamReader、OutputStreamWriter</td>
</tr>
</tbody></table></div>

        <h1 id="设计模式"   >
          <a href="#设计模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1>
      <p><code>IO</code>使用了<a href="https://cecilia.cool/2022/08/24/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B-%E8%A3%85%E9%A5%B0/">装饰者模式</a>，以<code>InputStream</code>为例：</p>
<ul>
<li><p><code>InputStream</code>是抽象组件。</p>
</li>
<li><p><code>FileInputStream</code>是<code>InputStream</code>子类，为具体组件，提供字节流的输入操作。</p>
</li>
<li><p><code>FilterInputStream</code>属于抽象装饰者，提供额外功能</p>
</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/08/26/f54be56eb22c08b8.jpg" alt="IO使用装饰者模式"></p>
<p>实例化一个具有缓存功能的字节流对象时，只需要在 <code>FileInputStream</code> 对象上再套一层 <code>BufferedInputStream</code> 对象即可。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fileInputStream);</span><br></pre></td></tr></table></div></figure>




        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/io/java-io-basic-category.html" >https://pdai.tech/md/java/io/java-io-basic-category.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/2/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/logo.png" alt="avatar"></div><p class="sidebar-ov-author__text">You have lots more to work on</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">69</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">2</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">11</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh_tw" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Cyan</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.2.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.7.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.7.0"></script><script src="/js/stun-boot.js?v=2.7.0"></script><script src="/js/scroll.js?v=2.7.0"></script><script src="/js/header.js?v=2.7.0"></script><script src="/js/sidebar.js?v=2.7.0"></script></body></html>