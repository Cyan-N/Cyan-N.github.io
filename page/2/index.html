<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.7.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.7.0" type="image/png" sizes="32x32"><meta name="description" content="我始终勇往直前，百折不回...">
<meta property="og:type" content="website">
<meta property="og:title" content="慕青的日记">
<meta property="og:url" content="https://cecilia.cool/page/2/index.html">
<meta property="og:site_name" content="慕青的日记">
<meta property="og:description" content="我始终勇往直前，百折不回...">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Cyan">
<meta name="twitter:card" content="summary"><title>慕青的日记 | Cyan</title><link ref="canonical" href="https://cecilia.cool/page/2/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.7.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">慕青的日记</div><div class="header-banner-info__subtitle">Cyan</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/01/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">网络协议</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-01</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-01</span></span></div></header><div class="post-body"><div class="post-excerpt"><blockquote>
<p>整个网络协议与工具线路参照pdai的<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/develop/protocol/dev-protocol-overview.html" >Java全栈知识体系</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>学习，前半部分关于计算机网络的知识，padi也是直接使用了博客园的博主<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://home.cnblogs.com/u/googny/" >桂城老托尼</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>关于《计算机网络第五版》（谢希仁）的<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/googny/p/3682280.html" >读书笔记</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，在学习期间，作者也会参考《计算机网络-自顶向下方法》进行内容补充。</p>
</blockquote>

        <h1 id="计算机网络基础"   >
          <a href="#计算机网络基础" class="heading-link"><i class="fas fa-link"></i></a><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h1>
      <blockquote>
<p>如果学计算机网络觉得看文字过于枯燥，可以看一下中科大的<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1JV411t7ow/?spm_id_from=333.337.search-card.all.click&vd_source=5acf5a7b23d28e7633e5a9b381c57c42" >郑烇老师</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>的计算机网络的课。</p>
</blockquote>

        <h2 id="因特网概述"   >
          <a href="#因特网概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#因特网概述" class="headerlink" title="因特网概述"></a>因特网概述</h2>
      <p>一个网络可能由光纤，路由器，计算机（包括服务器）等组成，本质上就是结点和链路的组成。而<strong>因特网则是把许多网络连接在一起</strong>。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/01/4851be18068b1041.jpg"></p>
<p>组成：</p>
<ul>
<li>边缘部分：由所有连接在因特网的主机组成，这些主机又叫做端系统(end system)。</li>
<li>核心部分：大量网络和连接这些网络的<strong>路由器</strong>组成，为边缘部分提供服务的。</li>
</ul>
<p>计算机通信方式：</p>
<ul>
<li>客户服务器方式–C&#x2F;S方式，一般是客户端发起通信，否则服务端不知道客户端IP。</li>
<li>对等方式–P2P方式（Peer-to-Peer），两个主机都运行了对等连接软件，可以平等，对等连接通信。</li>
</ul>
<p>因特网中的核心部分最复杂，起特殊作用的是路由器（Router），实现分组交换。比如某一主机现需要发送一段较长的数据，发送时就会将这段数据分为一个个的分组，加上首部（事实上，我们说一个分组时，已经认为其包含了首部）。首部包含了一些有用的信息，比如这个分组实际承载的数据多大，目标地址等。</p>
<p>分组交换网中的结点交换机根据收到的分组的首部中的地址信息，把分组转发到下一个结点交换机。用这样的存储转发方式，最后分组就能到达最终目的地。接收端收到分组后剥去首部还原成报文。最后，在接收端把收到的数据恢复成为原来的报文。</p>

        <h2 id="路由器"   >
          <a href="#路由器" class="heading-link"><i class="fas fa-link"></i></a><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2>
      <p>路由器处理分组过程：</p>
<ul>
<li>把收到的分组先放入缓存（暂时存储）；</li>
<li>查找转发表，找出到某个目的地址应从哪个端口转发；</li>
<li>把分组送到适当的端口转发出去。</li>
</ul>
<blockquote>
<p>请区分好路由器和主机的区别，尽管都是因特网的节点，但是它们是不一样的。</p>
</blockquote>
<p>分组交换也存在许多问题，比如许多节点在经过同一个路由器分组转发时，需要排队，会造成一定时延，分组的首部也造成一定开销。</p>
<blockquote>
<p>除了分组交换，还有电路交换，在发送信息前，双方必须建立一条连接，路径上的交换机都将为该连接维护状态，并且预留了带宽，数据能够以恒定速率发送。</p>
</blockquote>
<p>对比：</p>
<p>早期面向终端的计算机网络是<strong>以单个主机为中心的星形网</strong>，各终端通过通信线路共享昂贵的中心主机的硬件和软件资源。分组交换网则是以网络为中心，主机都处在网络的外围。</p>

        <h2 id="网络分类"   >
          <a href="#网络分类" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络分类" class="headerlink" title="网络分类"></a>网络分类</h2>
      <p>不同作用范围：</p>
<ul>
<li>广域网 WAN（Wide Area Network），手机端移动设备是通过蜂窝网提供商运营的基站来发送和接收分组。用于仅需位于基站的数万米范围。</li>
<li>局域网 LAN（Local Area Network)，个人热点就是局域网，称为wlan–无线局域网（Wireless），WiFi是基于IEEEE 802.11技术的无线LAN接入，用户必须在接入点几十米范围内。</li>
<li>城域网 MAN</li>
<li>个人区域网 PAN</li>
</ul>
<p>根据使用者也可以分为公用网和专用网。</p>
<blockquote>
<p>重点需要提的是接入网AN（Access），由ISP–Internet Service Provider提供，起到让用户域因特网连接的桥梁作用。每个ISP自身就是一个由多台分组交换机和多段通信链路组成的网络。</p>
</blockquote>
<p>分组交换机除了路由器和链路层交换机，后者通常用于接入网，路由器用于网络核心中。</p>

        <h2 id="相关术语"   >
          <a href="#相关术语" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2>
      <p><strong>带宽</strong>：数字信道所能传送的最<strong>高数据率</strong>，单位是<strong>比特每秒b&#x2F;s</strong>。</p>
<p><strong>吞吐量</strong>：单位时间内通过某个网络（信道，接口）的数据量。</p>
<p><strong>传输时延（发送时延 ）</strong>：  发送数据时，数据块从结点进入到传输媒体所需要的时间。从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间，<strong>发送时延&#x3D;数据块长度&#x2F;带宽</strong>。</p>
<p><strong>传播时延</strong>  电磁波在信道中需要传播一定的距离而花费的时间，<strong>传播时延&#x3D;信道长度&#x2F;信号在信道上的传播速率</strong>。</p>
<p>处理时延和排队时延比较简单，跟路由器有关。</p>

        <h2 id="体系结构"   >
          <a href="#体系结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2>
      <p>经常使用的TCP&#x2F;IP协议是四层体系结构：应用层，运输层，网际层，网络接口层。和ISO折中之后，采用一种五层协议的体系结构：应用层，运输层，网络层，数据链路层，物理层。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/01/cd33ff3621dde413.jpg"></p>
<blockquote>
<p>还有UDP，这种传输协议不能对数据做出任何保证，即使在传播过程中出现丢失，比特突变，都不会做任何弥补措施，一般用于实时媒体软件，比如直播（数据丢了就丢了，无所谓）。</p>
</blockquote>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/googny/p/3682280.html" >https://www.cnblogs.com/googny/p/3682280.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>《计算机网络自顶向下》第一章</p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/29/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88(1)-PriorityQueue/">Java集合(1)--PriorityQueue</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-29</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-29</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="其他集合"   >
          <a href="#其他集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#其他集合" class="headerlink" title="其他集合"></a>其他集合</h1>
      <p>因为像ArrayList，LinkedList之类的容器比较简单，此处不会过多解释，只会列出一些需要注意的点。</p>
<p><strong>ArrayList</strong>：</p>
<ul>
<li>ArrayList为了效率没有实现同步，有需求的情况下需要自己实现。</li>
<li>向ArrayList中加入元素（add）时，都会进行容量检查，扩容都会交给grow方法。</li>
<li><code>remove</code>函数中，删除中间某一个元素会导致后面的元素向前移动，需要将最后一个位置赋为null（为了让GC起作用）。</li>
<li><code>tirmToSize()</code>，将数组容量修改为当前元素个数大小；<code>indexOf()</code>与<code>lastIndexOf()</code><br>就是获取元素第一次&#x2F;最后一次出现的index。</li>
<li><code>modCount</code>是指集合创建以来修改的次数，他保证在迭代器循环中，如果出现集合的修改就停止迭代。</li>
</ul>
<p><strong>LinkedList</strong>：</p>
<ul>
<li>LinkedList可以考虑作为栈&#x2F;队列，Java官方不建议使用Stack。但是ArrayDeque是栈或者队列的<br>首选，性能更好。</li>
<li>LinkedList没有哑节点，当链表为空的时候first和last都指向null。</li>
</ul>
<p><strong>ArrayDeque</strong>：</p>
<ul>
<li><p><code>Deque</code>是”double ended queue”, 表示双向的队列，英文读作”deck”.。</p>
</li>
<li><p>ArrayDeque是非线程安全的，不允许加入null。</p>
</li>
</ul>

        <h1 id="PriorityQueue"   >
          <a href="#PriorityQueue" class="heading-link"><i class="fas fa-link"></i></a><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h1>
      <p>优先队列保证每次取出的元素都是队列中最小的（构造时可以传入比较器<code>Comparator</code>，所以想要每次取出都是最大的，只需要反过来即可）。</p>
<p>PriorityQueue不允许放入<code>null</code>元素，<strong>内部通过数组实现小根堆</strong>，小根堆抽象上可以理解为完全二叉树。</p>
<p>数组映射完全二叉树的算数关系为：</p>
<ul>
<li><code>leftNode = ParentNode*2 + 1</code> </li>
<li><code>rightNode = ParentNode*2 + 2</code> </li>
<li><code>ParentNode = (node - 1)/2</code></li>
</ul>
<blockquote>
<p><em>PriorityQueue</em>的<code>peek()</code>和<code>element</code>操作是常数时间，<code>add()</code>, <code>offer()</code>, 无参数的<code>remove()</code>以及<code>poll()</code>方法的时间复杂度都是*log(N)*。</p>
</blockquote>
<p><code>add()</code>和<code>remove()</code>失败后就会抛出异常，而<code>offer()</code>和<code>poll()</code>就是返回<code>false</code>。</p>

        <h2 id="小根堆解析"   >
          <a href="#小根堆解析" class="heading-link"><i class="fas fa-link"></i></a><a href="#小根堆解析" class="headerlink" title="小根堆解析"></a>小根堆解析</h2>
      <p>此处不讲解PriorityQueue源码，而是理解小根堆的维护流程</p>
<p><strong>加入节点</strong>：队列只允许从队尾加入元素，大致流程如下图。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/29/a2497ab926b94de8.jpg"></p>
<p>删除节点：</p>
<ul>
<li>优先队列出队操作会导致根节点被删除，此时需要将最后一个节点放到根节点的位置在进行下降调整。</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/29/0681d1a809288d78.jpg"></p>
<ul>
<li>如果是其他关于小根堆的删除，当删除节点是尾节点时，直接删除即可。</li>
<li>当节点在中间，我们就只看以该节点尾根节点的子树，将数组最后一个节点移到当前节点，再调整。</li>
</ul>

        <h1 id="小根堆代码"   >
          <a href="#小根堆代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#小根堆代码" class="headerlink" title="小根堆代码"></a>小根堆代码</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟小根堆的增加</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>[] minHeap ,<span class="type">int</span> size , <span class="type">int</span> val)</span> &#123;</span><br><span class="line">      <span class="comment">// 假设参数合法，数组不出现越界</span></span><br><span class="line">      <span class="keyword">if</span>(size == <span class="number">0</span>) &#123; minHeap[size++] = val;<span class="keyword">return</span>;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当前父节点,index是当前val位于的位置</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (size - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>,index = size;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(minHeap[p] &gt; val) &#123;</span><br><span class="line">          minHeap[index] = minHeap[p];</span><br><span class="line">          <span class="keyword">if</span>(p == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">          index = p;</span><br><span class="line">          p = (p-<span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      minHeap[p] = val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span>[] minHeap , <span class="type">int</span> size , <span class="type">int</span> index)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(size-<span class="number">1</span> == index) &#123;minHeap[size] = -<span class="number">1</span>;<span class="keyword">return</span>;&#125;<span class="comment">// 假设-1为null</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/** 小根堆是完全二叉树，左节点下标为奇数，右节点为偶数</span></span><br><span class="line"><span class="comment">          一直向下找右节点直到到达最后一层，在倒数第二层会出现</span></span><br><span class="line"><span class="comment">          1） 该层不存在右孩子</span></span><br><span class="line"><span class="comment">          2） 该层存在右孩子</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      minHeap[index] = minHeap[--size];</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>,r = l + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 权值大的节点向下沉</span></span><br><span class="line">      <span class="keyword">while</span>(l &lt; size &amp;&amp; r &lt; size) &#123;</span><br><span class="line">          <span class="keyword">if</span>(minHeap[l] &lt; minHeap[index]) &#123;</span><br><span class="line">              minHeap[index] = minHeap[l];</span><br><span class="line">              index = l;</span><br><span class="line">              l = (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;r = l + <span class="number">1</span>; </span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minHeap[r] &lt; minHeap[index]) &#123;</span><br><span class="line">              minHeap[index] = minHeap[r];</span><br><span class="line">              index = r;</span><br><span class="line">              l = (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;r = l + <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 如果当前节点小于左右子节点，则完成</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(l &lt; size &amp;&amp; minHeap[l] &lt; minHeap[index]) &#123;</span><br><span class="line">          minHeap[index] = minHeap[l];</span><br><span class="line">          minHeap[l] = -<span class="number">1</span>;</span><br><span class="line">      &#125; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://www.cnblogs.com/CarpenterLee/p/5488070.html" >http://www.cnblogs.com/CarpenterLee/p/5488070.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/collection/java-collection-PriorityQueue.html" >https://pdai.tech/md/java/collection/java-collection-PriorityQueue.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/28/Docker/Docker(7)-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/">Docker(7)--资源管理</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-28</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="容器控制操作"   >
          <a href="#容器控制操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#容器控制操作" class="headerlink" title="容器控制操作"></a>容器控制操作</h1>
      <blockquote>
<p>补充一些Docker的命令，对于这种单纯的命令查看，建议直接看菜鸟教程。</p>
</blockquote>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器，退出：ctrl+P，ctrl+Q；终止容器运行的程序：ctrl+C</span></span><br><span class="line">docker attach 容器ID/名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行命令，这里执行的是bash，并开启一个可输入终端</span></span><br><span class="line">docker exec -it 容器ID/名称 bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">（假设容器可以执行java），就相当于让容器执行java -version</span></span><br><span class="line">docker exec 容器ID/名称 java -version</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许容器处理善后再停止运行</span></span><br><span class="line">docker kill 容器ID/名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接强制停止容器</span></span><br><span class="line">docker stop 容器ID/名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动容器（一般是容器被stop之后）</span></span><br><span class="line">docker start 容器ID/名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启容器</span></span><br><span class="line">docker restart 容器ID/名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">暂停容器(unpause--取消暂停)</span></span><br><span class="line">docker pause 容器ID/名称</span><br></pre></td></tr></table></div></figure>




        <h1 id="物理资源管理"   >
          <a href="#物理资源管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#物理资源管理" class="headerlink" title="物理资源管理"></a>物理资源管理</h1>
      <ul>
<li>内存分配：</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -m 50M --memory-swap=100M nagocoler/springboot-test:1.0</span><br></pre></td></tr></table></div></figure>

<p><code>-m</code>对容器的物理内存的限制，<code>--memory-swap</code>对内存和交换分区总和的限制。默认都是-1，即没有任何限制。如果仅指定<code>-m</code>，那么交换内存的限制也为<code>-m</code>指定的参数。</p>
<ul>
<li>CPU进行限额：</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line">docker run -c 1024 ubuntu</span><br><span class="line">docker run -c 512 ubuntu</span><br></pre></td></tr></table></div></figure>

<p>对CPU的分配只有多容器才生效，默认是1024，如果CPU不紧张，依然可以使用全部CPU资源。</p>
<blockquote>
<p>通过Ubuntu命令：<code>sudo apt install stress</code>在容器中下载压力测试工具来看一下进程分配权重对进程获得CPU资源的影响。</p>
</blockquote>
<p>还可以限制容器使用CPU：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --cpuset-cpus=1 ubuntu</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>选项后面的值不是CPU的数量，而是CPU的“编号”，即这个容器只用1这个CPU，所以指定两个CPU时也可以这样：<code>docker run -it --cpuset-cpus=0,1 ubuntu</code>。</p>
</blockquote>
<p>命令<code>--cpus</code>来限制使用CPU资源数（个数）：<code>docker run -it --cpus=1 ubuntu</code>。</p>

        <h1 id="容器监控"   >
          <a href="#容器监控" class="heading-link"><i class="fas fa-link"></i></a><a href="#容器监控" class="headerlink" title="容器监控"></a>容器监控</h1>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats</span><br></pre></td></tr></table></div></figure>

<p>可以实时对容器的各项状态进行监控，包括内存使用、CPU占用、网络I&#x2F;O、磁盘I&#x2F;O等信息。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/28/2e4f267ce01df490.jpg"></p>
<p><code>top</code>命令可以查看容器进程：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器ID/名称</span><br></pre></td></tr></table></div></figure>

<p>对于容器监管，也有页面版本的，官方<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://docs.portainer.io/start/install/server/docker/linux" >下载教程</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，此处不过多讲解。</p>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/zwhkpi/kq6rlg" >https://www.yuque.com/qingkongxiaguang/zwhkpi/kq6rlg</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-start-stop-restart-command.html" >https://www.runoob.com/docker/docker-start-stop-restart-command.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/27/Docker/Docker(6)-%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%AE%A1%E7%90%86/">Docker(6)--数据卷管理</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-27</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="数据卷"   >
          <a href="#数据卷" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h1>
      <blockquote>
<p>基于分层机制，在容器中操作的文件都是在最顶层进行，这也导致容器的销毁会导致数据丢失。通过数据卷可以实现数据共享和持久化。</p>
</blockquote>

        <h2 id="文件挂载"   >
          <a href="#文件挂载" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件挂载" class="headerlink" title="文件挂载"></a>文件挂载</h2>
      <p>Linux根目录以外的文件想要被访问，就需要将其关联到根目录下的某个目录实现，这种关联就叫挂载，目录就是挂载点，解除关联就是卸载。</p>
<blockquote>
<p>最直接的就是读取U盘的文件，如果没有挂载操作，就只能在图形化界面使用U盘，在命令行找不到的。</p>
</blockquote>
<p>进行挂载时建议重新创建一个文件夹，如果使用了系统文件夹（etc之类的），挂载操作会使得原有目录中文件被隐藏，可能会导致系统崩溃。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount 设备号 挂载点目录</span><br><span class="line"></span><br><span class="line">umount 挂载点目录</span><br></pre></td></tr></table></div></figure>




        <h2 id="容器持久化"   >
          <a href="#容器持久化" class="heading-link"><i class="fas fa-link"></i></a><a href="#容器持久化" class="headerlink" title="容器持久化"></a>容器持久化</h2>
      <blockquote>
<p>我们可以让容器将文件保存到宿主主机上，这样就算容器销毁，文件也会在宿主主机上保留，下次创建容器时，依然可以从宿主主机上读取到对应的文件。</p>
</blockquote>
<p>在宿主机创建需要挂载到容器的目录：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">随便创建点文件表示有内容</span></span><br><span class="line">vim test/hello.txt</span><br></pre></td></tr></table></div></figure>

<p>将test目录挂载到容器的某个目录上</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v ~test:/root/test ubuntu</span><br></pre></td></tr></table></div></figure>

<p>此时在容器中就可以访问宿主主机的文件，对挂载目录的文件进行编辑，就相当于编辑宿主主机的数据。在容器中创建文件，宿主主机也会创建相应文件。</p>
<blockquote>
<p>在容器中删除文件，不会影响主机的文件。</p>
</blockquote>
<p>可以部署Nginx，在宿主主机上保存前端页面，然后将这个前端页面目录挂载到Nignx容器上，这样Nginx镜像有升级，容器需要删除重新创建也不会影响前端页面。</p>
<p>我们这里使用的前端模板是<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://bootstrapmade.com/" >Arsha</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>（如何将文件传到linux上待会讲）。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /win_data/Arsha:/usr/share/nginx/html/ -p 80:80 -d nginx</span><br></pre></td></tr></table></div></figure>

<p>将解压出来的目录挂载到Nginx的默认站点目录<code>/usr/share/nginx/html/</code>，因为挂在后位于顶层，会替代镜像原有的文件。</p>
<p>进入容器将Nginx服务启动：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>在windos浏览器中输入<code>IP:80</code>，即可访问nginx服务，如果访问超时，可能是linux80端口被其他进程占用，最简单的就是重启一下linux，再启动nginx。</p>
</blockquote>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/28/72cd9dda6c186381.jpg"></p>
<p>如果在挂载时没有指定宿主主机的目录，Docker就会自动创建一个新的文件夹，并且会将容器中对应路径下的内容拷贝到这个自动创建的目录中，最后挂在到容器中，这种就是由Docker管理的数据卷了。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /root/abc ubuntu</span><br></pre></td></tr></table></div></figure>

<p>要查看Docker将文件放在了宿主机哪个位置</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器名字/ID</span><br></pre></td></tr></table></div></figure>

<p>主要是看Mount这个部分</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/28/efea66dac14a3326.jpg"></p>
<p>Docker支持从宿主主机复制文件到容器中（或者容器复制文件到宿主主机）</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 主机文件 容器名/ID:文件夹路径</span><br></pre></td></tr></table></div></figure>




        <h3 id="win文件传输到Linux"   >
          <a href="#win文件传输到Linux" class="heading-link"><i class="fas fa-link"></i></a><a href="#win文件传输到Linux" class="headerlink" title="win文件传输到Linux"></a>win文件传输到Linux</h3>
      <blockquote>
<p>如果linux装在虚拟机上，虚拟机安装了VMwareTools后，一般可以实现文件直接从win拖动到虚拟机系统里面，但是有时候抽风又不能拖动。也可以将文件放到U盘里面，然后U盘挂载到Linux上，再将文件移动到Linux其他文件夹里面使用。（无语的是我这U盘挂载也出了问题）</p>
</blockquote>
<p>这里讲通过pscp，命令行传输文件。</p>
<ul>
<li>在Linux中设置好root的密码：<code>sudo passwd</code>。在根目录下创建<code>win_data</code>文件夹（名字其实随便）</li>
<li>修改<code>sshd_config</code>文件，参考这篇文章：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/xuliangxing/p/7428737.html" >https://www.cnblogs.com/xuliangxing/p/7428737.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li>在windos下载好需要的文件</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/28/29425736a49aebd9.jpg"></p>
<ul>
<li>下载pscp：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html" >https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li>将<code>pscp.exe</code>放在C:\Windows\System32文件夹下</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/28/0879d6517d9f457d.jpg"></p>
<ul>
<li>在C:Windows\System32下打开命令行，输入：</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp 下载文件路径 root@IP:/win_data</span><br></pre></td></tr></table></div></figure>

<p>输入密码后就可以传输了，这里必须要使用root，使用一般用户的话，权限不够会拒绝访问。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/28/6d1d04a4f34aac95.jpg"></p>
<ul>
<li>最后在<code>/win_data</code>目录里解压压缩包就可以使将其挂载到nginx上了</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo unzip Arsha.zip</span><br></pre></td></tr></table></div></figure>




        <h2 id="容器数据共享"   >
          <a href="#容器数据共享" class="heading-link"><i class="fas fa-link"></i></a><a href="#容器数据共享" class="headerlink" title="容器数据共享"></a>容器数据共享</h2>
      <blockquote>
<p>容器与容器之间的数据共享</p>
</blockquote>
<p>一般思路是在宿主主机上创建公告目录，让需要共享的容器挂载到这个公共目录。也可以创建一个容器专门用于存放数据，即数据卷容器。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v ~/test:/root/test --name=data_test ubuntu</span><br><span class="line">docker run -it --volumes-from data_test ubuntu</span><br></pre></td></tr></table></div></figure>

<p>使用<code>--volumes-from</code>指定另一个容器，数据卷容器挂载的内容，在当前容器也存在，就算数据卷容器被删除，也不会影响这边，本质上还是让两个容器挂载了同样的目录实现数据共享。</p>
<p>还可以将数据完全放到容器中，通过构建一个容器将打包好的数据分享给其他容器</p>
<figure class="highlight dockerfile"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> data.tar.gz /usr/share/nginx/html</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /usr/share/nginx/html</span></span><br></pre></td></tr></table></div></figure>

<p>指令ADD，它跟COPY命令类似，也可以复制文件到容器中，但是它可以自动对压缩文件进行解压，这里只需要将压缩好的文件填入即可，后面的VOLUME指令就像我们使用<code>-v</code>参数一样，会创建一个挂载点在容器中</p>
<p>然后构建</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t 镜像名 .</span><br></pre></td></tr></table></div></figure>

<p>通过这个镜像创建按出来的容器，我们就可以使用了（假设容器名是ubuntu_test）</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80 --volumes-from=ubuntu_test -d nginx</span><br></pre></td></tr></table></div></figure>


        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p>Linux文件挂载：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://haicoder.net/linux/linux-file-mount.html" >https://haicoder.net/linux/linux-file-mount.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.bbsmax.com/A/gVdnOKP8zW/" >https://www.bbsmax.com/A/gVdnOKP8zW/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>修改sshd_config文件：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/xuliangxing/p/7428737.html" >https://www.cnblogs.com/xuliangxing/p/7428737.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>前端模板：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://bootstrapmade.com/" >https://bootstrapmade.com/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/24/Docker/Docker(5)-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/">Docker(5)--网络配置</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-27</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="Docker默认网桥"   >
          <a href="#Docker默认网桥" class="heading-link"><i class="fas fa-link"></i></a><a href="#Docker默认网桥" class="headerlink" title="Docker默认网桥"></a>Docker默认网桥</h1>
      <p>安装Docker服务会默认创建一个 docker0 网桥，它在内核层连通了其他的物理或虚拟网卡，这就<strong>将所有容器和本地主机都放到同一个物理网络</strong>。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/26/6cd3d7a5835ed737.jpg"></p>
<p>容器有三种网络类型，分别是<code>bridge</code>,<code>host</code>,<code>none</code>，创建容器时默认是<code>bridge</code>。我们可以使用命令查看</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></div></figure>

<p>先创建一个容器再来讲解</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu</span><br><span class="line"></span><br><span class="line">apt update</span><br><span class="line">apt install net-tools iputils-ping curl</span><br></pre></td></tr></table></div></figure>

<p><img src="https://s3.bmp.ovh/imgs/2022/09/26/30f79fa9a2b0bfe5.jpg"></p>
<p>可以看到这个容器的<code>IP</code>是<code>172.17.0.3</code>。该ubuntu容器启动时没有指定网络类型，默认就是<code>bridge</code>，我们看一下<code>bridge</code>的网络</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cyan@w2d:~$ docker network inspect bridge</span><br></pre></td></tr></table></div></figure>

<p>看关键部分</p>
<figure class="highlight json"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;Config&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Subnet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.17.0.0/16&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Gateway&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.17.0.1&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>我的终端倒是没有显示Gateway网关，这个其实就是docker0的IP，我们创建的容器默认就是通过docker0桥接宿主机的网络。</p>
</blockquote>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/26/726c5b32968c34d6.jpg"></p>

        <h2 id="创建容器"   >
          <a href="#创建容器" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2>
      <p>Docker在创建一个容器的时候，会执行如下操作：</p>
<ul>
<li><p>创建一对虚拟接口&#x2F;网卡，也就是veth pair，分别放到本地主机和新容器中；</p>
</li>
<li><p>本地主机一端桥接到默认的 docker0 或指定网桥上，并具有一个唯一的名字，如 vethxxxxx；</p>
</li>
<li><p>容器一端放到新容器中，并修改名字作为 eth0，这个网卡&#x2F;接口只在容器的名字空间可见；</p>
</li>
<li><p>从网桥可用地址段中（也就是与该bridge对应的network）获取一个空闲地址分配给容器的 eth0，并配置默认路由到桥接网卡 vethxxxx。</p>
</li>
</ul>
<blockquote>
<p>如果不指定–network，创建的容器默认都会挂到 docker0 上，使用本地主机上 docker0 接口的 IP 作为所有容器的默认网关</p>
</blockquote>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/26/324896ddff4fdafc.jpg"></p>

        <h1 id="网络类型"   >
          <a href="#网络类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络类型" class="headerlink" title="网络类型"></a>网络类型</h1>
      
        <h2 id="默认网络类型"   >
          <a href="#默认网络类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#默认网络类型" class="headerlink" title="默认网络类型"></a>默认网络类型</h2>
      <p>之前使用<code>docker network ls</code>查看三种网络类型，有<code>bridge</code>，<code>host</code>，<code>none</code>。，使用<code>--network</code>可以指定网络</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --network=none ubuntu</span><br></pre></td></tr></table></div></figure>

<ul>
<li><strong>none网络</strong>：只有一个本地环回网络，通过<code>ifconfig</code>查看，只有一个本地环回<code>lo</code>网络设备：</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/26/ba906a10862142e3.jpg"></p>
<p>在这种网络模式下，容器无法连接到互联网：比如，<code>ping</code>不通，纯纯单机运行。</p>
<ul>
<li><strong>bridger网络</strong>：容器默认使用的网络类型，上文我们已经讲了，此处不再赘述。</li>
<li><strong>host网络</strong>：当容器连接到此网络，会共享宿主主机的网络，网络配置是完全一样。</li>
</ul>

        <h2 id="自定义网络类型"   >
          <a href="#自定义网络类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#自定义网络类型" class="headerlink" title="自定义网络类型"></a>自定义网络类型</h2>
      <p>Docker默认提供三种网络驱动：<code>bridge</code>、<code>overlay</code>、<code>macvlan</code>，不同的驱动对应着不同的网络设备驱动，实现的功能也不一样，比如bridge类型的，其实就和我们前面介绍的桥接网络是一样的。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create --driver bridge test</span><br></pre></td></tr></table></div></figure>

<p>这就是本文最开始的<code>ifconfig</code>多显示了一个网络设备，不同网络之间的通信是相互隔离的，无法进行通信，比如我们有一个在默认网络类型的ubuntu容器，有一个在test网络下的ubuntu容器，后者的网关是<code>172.18.0.1</code>，容器IP为<code>172.18.0.2</code>，在前者中想要执行命令：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 172.18.0.2</span><br></pre></td></tr></table></div></figure>

<p>会失败，想要实现通信，需要将前者连接到另一个容器所属的网络下：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect test(网络类型) 容器ID/名称</span><br></pre></td></tr></table></div></figure>

<p>此时容器就可以互相通信。Docker的DNS服务器可以不需要指定容器IP，比如有两个可以互相通信的容器，在启动时分别用<code>--name</code>指定名称，通信时就可以使用名称而不是IP（就像有一个DNS一样将名字解析成IP）</p>
<p>两个容器也可以共享一个网络设备，即两个容器共同使用一个IP地址，只需要在创建时指定：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name=test02 --network=container:test02 ubuntu</span><br></pre></td></tr></table></div></figure>

<p>两个容器的IP地址和网卡的Mac地址是完全一样的，它们的网络现在是共享状态，此时在容器中访问，localhost，既是自己也是别人。</p>
<p>可以在容器1中，安装Nginx，然后再容器2中访问：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install -y systemctl nginx</span><br><span class="line">systemctl start nginx</span><br></pre></td></tr></table></div></figure>

<p>访问到另一个容器中的Nginx服务器。</p>
<blockquote>
<p>另外两种类型的网络用于多主机通信，多主机通信会使用物理交换机，不同主机的网卡连接到同一台交换机，就相当于各自网桥在同一物理网络了。</p>
</blockquote>

        <h2 id="容器外部网络"   >
          <a href="#容器外部网络" class="heading-link"><i class="fas fa-link"></i></a><a href="#容器外部网络" class="headerlink" title="容器外部网络"></a>容器外部网络</h2>
      <p>在默认的三种的网络下，只有共享模式和桥接模式可以连接到外网，共享模式实际上就是直接使用宿主主机的网络设备连接到互联网，这里主要来看一下桥接模式。</p>
<blockquote>
<p>桥接模式容器发送数据包时，关键部分就是NAT(Netwirk Address Translation)，将地址进行转换，再利用宿主主机的IP地址发送数据包出去。</p>
</blockquote>
<p>比如我们要访问互联网上的某个资源，要和服务器进行通信，那么就需要将数据包发送出去，同时服务器也要将数据包发送回来，我们可以知道服务器的IP地址，也可以直接去连接，因为服务器的IP地址是暴露在互联网上的，但是我们的局域网就不一样了，它仅仅局限在我们的家里，比如我们连接了家里的路由器，可以得到一个IP地址，但是你会发现，这个IP公网是无法直接访问到我们的，因为这个IP地址仅仅是一个局域网的IP地址，俗称内网IP。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/27/dab39643f8e2041e.jpg"></p>
<p>这里就借助了NAT在帮助我们与互联网上的服务器进行通信，通过NAT，可以实现将局域网的IP地址，映射为对应的公网IP地址，而NAT设备一端连接外网，另一端连接内网的所有设备，当我们想要与外网进行通信时，就可以将数据包发送给NAT设备，由它来将数据包的源地址映射为它在外网上的地址，这样服务器就能够发现它了，能够直接与它建立通信。当服务器发送数据回来时，也是直接交给NAT设备，然后再根据地址映射，转发给对应的内网设备（当然由于公网IP地址有限，所以一般采用IP+端口结合使用的形式ANPT）。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/27/e05a018b5df6da55.jpg"></p>
<p>用百度查出来的IP和在命令行使用<code>ipconfig(windows)</code>查出来的不一样，前者是NAT设备的公网地址。</p>
<p>Docker中，内网数据包想要发送到互联网上的流程为：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/27/e4ebfbc4ba947097.jpg"></p>
<p>单纯依靠NAT，只有主动与外界联系时，外界才知道我们。但是如果容器中部署了一些服务，需要外界主动连接容器的服务，就需要使用端口映射配置。</p>
<blockquote>
<p>外界连接，只知道linux的IP而不知道容器的IP，就需要通过端口映射访问。端口映射可以将容器需要对外提供服务的端口映射到宿主主机的端口上，这样，当外部访问到宿主主机的对应端口时，就会直接转发给容器内映射的端口了。</p>
</blockquote>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先部署一个nginx服务</span></span><br><span class="line">docker run -d -p 80:80 nginx</span><br></pre></td></tr></table></div></figure>

<p><code>-p</code>参数是进行端口映射配置，规则为<code>宿主端口:容器端口</code>，其实关于端口映射之前的文章已经讲过了。</p>
<p>然后在浏览器中输入：<code>Linux IP:80</code>即可访问nignx服务。</p>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/devops/docker/docker-07-network.html" >https://pdai.tech/md/devops/docker/docker-07-network.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/zwhkpi/kq6rlg#67fb97ea" >https://www.yuque.com/qingkongxiaguang/zwhkpi/kq6rlg#67fb97ea</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.it1352.com/2052892.html" >https://www.it1352.com/2052892.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/24/Docker/Docker(4)-webapp%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/">Docker(4)--webapp应用实例</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-24</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h1>
      <p>本文通过web应用展示主机如何与wen容器之间通信，为后续讲解网络提供基础。</p>

        <h1 id="web的运行与访问"   >
          <a href="#web的运行与访问" class="heading-link"><i class="fas fa-link"></i></a><a href="#web的运行与访问" class="headerlink" title="web的运行与访问"></a>web的运行与访问</h1>
      
        <h2 id="运行"   >
          <a href="#运行" class="heading-link"><i class="fas fa-link"></i></a><a href="#运行" class="headerlink" title="运行"></a>运行</h2>
      <blockquote>
<p>找到一个webapp镜像即可。</p>
</blockquote>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull training/webapp</span><br></pre></td></tr></table></div></figure>

<p>下载完成后查看</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images | grep webapp</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>我们需要跑一下这个webapp里面的app.py文件，其实就是hello world</p>
</blockquote>
<p>启动webapp</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P training/webapp python app.py</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p><code>-d</code>：让容器在后台运行</p>
<p><code>-P</code>：将容器内部使用的网络端口映射到主机上</p>
</blockquote>
<p>查看一下</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cyan@w2d:~$ docker ps</span><br><span class="line">CONTAINER ID          PORTS                                   </span><br><span class="line">e7a994ce697c     0.0.0.0:49153-&gt;5000/tcp, :::49153-&gt;5000/tcp  </span><br></pre></td></tr></table></div></figure>

<p>这里因为界面显示不够，我就只保留了ID和端口号的相关信息。</p>

        <h2 id="访问"   >
          <a href="#访问" class="heading-link"><i class="fas fa-link"></i></a><a href="#访问" class="headerlink" title="访问"></a>访问</h2>
      <p>上文端口号的解读是：Docker开放5000端口（Python Flask默认端口）映射到主机端口49153.</p>
<p>所以我们可以从49153这个端口来访问这个界面</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nltp | grep 49153</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p><code>netstat</code>命令用于显示网络状态</p>
</blockquote>
<p>在命令行：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl localhost:49153</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者在浏览器上访问，ip是虚拟机-Ubuntu的ip</span></span><br></pre></td></tr></table></div></figure>

<p><img src="https://s3.bmp.ovh/imgs/2022/09/24/1d9b4aa085083f9e.jpg"></p>
<p>容器映射到主机的端口是随机的，但是可以用-P选项来指定端口</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P 5001:500 training/webapp python app.py</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>如果浏览器访问不上，把镜像删了重新下载试试，反正是可以的</p>
</blockquote>

        <h1 id="其他功能"   >
          <a href="#其他功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h1>
      <blockquote>
<p>反正都是命令，快速过一下</p>
</blockquote>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器(映射)端口</span></span><br><span class="line">docker port ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志</span></span><br><span class="line">docker logs ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器进程</span></span><br><span class="line">docker top</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查应用底层信息，返回JSON文件记录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">容器配置和状态信息</span></span><br><span class="line">docker inspect ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止应用容器</span></span><br><span class="line">docker stop ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启容器</span></span><br><span class="line">docker restart/start ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除容器,-f就是强制删除，一般容器删除需要</span> </span><br><span class="line">docker rm ID</span><br></pre></td></tr></table></div></figure>




        <h2 id="容器互联"   >
          <a href="#容器互联" class="heading-link"><i class="fas fa-link"></i></a><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2>
      <blockquote>
<p>删除所有不再使用的容器：<code>docker container prune</code>。</p>
</blockquote>
<p>创建数据库容器：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name db training/postgres</span><br></pre></td></tr></table></div></figure>

<p>db容器与web容器建立互联关系</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P 5001:5000 --name web --link db:db training/webapp python app.py</span><br></pre></td></tr></table></div></figure>

<p><code>--link</code>参数格式为 <code>--link name:alias</code>，其中 name 是要链接的容器的名称，alias 是这个连接的别名。</p>
<p>容器之间的连接信息的查看有两种方式：</p>
<ul>
<li>查看环境变量：</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">webapp已经运行起来了,假设其名字为web</span></span><br><span class="line">docker exec -it web /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">====&gt;，这里假设ID是1cbc9aeba2a8</span></span><br><span class="line">root@1cbc9aeba2a8:/opt/webapp# env</span><br><span class="line">DB_NAME=/web/db</span><br><span class="line">DB_PORT_5432_TCP_ADDR=172.17.0.2</span><br><span class="line">DB_PORT=tcp://172.17.0.2:5432</span><br><span class="line">DB_PORT_5432_TCP=tcp://172.17.0.2:5432</span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">PWD=/opt/webapp</span><br><span class="line">DB_PORT_5432_TCP_PORT=5432</span><br><span class="line">SHLVL=1</span><br><span class="line">HOME=/root</span><br><span class="line">DB_PORT_5432_TCP_PROTO=tcp</span><br><span class="line">DB_ENV_PG_VERSION=9.3</span><br><span class="line">_=/usr/bin/env</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>DB_ 开头的环境变量是供 web 容器连接 db 容器使用，前缀采用大写的连接别名。<strong>只有在建立连接之后才会有，没有建立连接是没有这几个变量的</strong>。</p>
</blockquote>
<ul>
<li>hosts文件</li>
</ul>
<p>除了环境变量，Docker 还添加 host 信息到父容器的 <code>/etc/hosts</code> 的文件。下面是父容器 web 的 hosts 文件</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@1cbc9aeba2a8:/opt/webapp# cat /etc/hosts</span><br><span class="line">127.0.0.1       localhost</span><br><span class="line">::1     localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0 ip6-localnet</span><br><span class="line">ff00::0 ip6-mcastprefix</span><br><span class="line">ff02::1 ip6-allnodes</span><br><span class="line">ff02::2 ip6-allrouters</span><br><span class="line">172.17.0.2      db d992e3c761e0</span><br><span class="line">172.17.0.3      1cbc9aeba2a8</span><br><span class="line">root@1cbc9aeba2a8:/opt/webapp#</span><br></pre></td></tr></table></div></figure>

<p>这里有 2 个 hosts:</p>
<ul>
<li>第一个, <code>172.17.0.2 db d992e3c761e0</code> 表示 db 容器的 ip, ID和Name</li>
<li>第二个，<code>172.17.0.3 1cbc9aeba2a8</code> 表示 web 容器的 ip, ID</li>
</ul>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p>netstat命令：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-netstat.html?ivk_sa=1024320u" >https://www.runoob.com/linux/linux-comm-netstat.html?ivk_sa=1024320u</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>Java全栈知识体系：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/devops/docker/docker-03-basic-web-app.html" >https://pdai.tech/md/devops/docker/docker-03-basic-web-app.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/22/Docker/Docker(3)-%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E4%B8%8E%E5%8F%91%E5%B8%83/">Docker(3)--镜像构建与发布</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-22</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-24</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="构建镜像"   >
          <a href="#构建镜像" class="heading-link"><i class="fas fa-link"></i></a><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h1>
      <p>有些冷门的软件不在远程仓库里，此时就需要手动安装。我们以Ubuntu的base镜像中安装Java环境，并将其打包成新的镜像（这个新的镜像就是一个包含Java环境的Ubuntu系统镜像）。</p>
<p>拉取启动Ubuntu：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu</span><br><span class="line">docker run -it ubuntu</span><br></pre></td></tr></table></div></figure>

<p>更新apt（因为只有base镜像）</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>这一步我之前换不换源都会出错，反正就是更新失败，后来折腾了两三天，都没什么效果。最后把wifi换成热点就更新成功了。所以你如果更新失败，可以试着检查一下网络问题。</p>
<p>也不用怀疑版本问题，本人用Ubuntu 15和Ubuntu22都更新成功过。</p>
</blockquote>
<p>安装<code>jdk</code>：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install openjdk-8-jdk</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果apt更新失败，后面的也会失败</span></span><br></pre></td></tr></table></div></figure>

<p>退出容器，将其构建为新的镜像，使用commit将容器保存为新的镜像：</p>
<figure class="highlight dockerfile"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit 容器名称/ID 新的镜像名称</span><br></pre></td></tr></table></div></figure>

<p>此时再使用<code>docker images</code>就可以看到新构建的镜像了。</p>
<blockquote>
<p>但是这种构建方式Docker官方并不推荐。普通用户可以使用Dockerfile构建上述镜像</p>
</blockquote>
<p>创建名为<code>Dockerfile</code>的文件：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch Dockerfile</span><br></pre></td></tr></table></div></figure>

<p>我们需要在<code>Dockerfile</code>文件内部编写指令来告诉Docker需要构建镜像的相关信息</p>
<figure class="highlight dockerfile"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &lt;基础镜像&gt;</span><br></pre></td></tr></table></div></figure>

<p><code>FROM</code>指令选择当前镜像的基础镜像（必须以该指令开始）。如果不需要任何基础镜像，使用<code>scratch</code>表示从零开始基础构建。</p>
<p>在容器中运行命令安装Java环境</p>
<figure class="highlight dockerfile"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt install -y openjdk-8-jdk</span></span><br></pre></td></tr></table></div></figure>

<p>构建：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &lt;镜像名称&gt; &lt;构建目录&gt;</span><br></pre></td></tr></table></div></figure>

<p>执行后，Docker会在构建目录中寻找Dockerfile文件，然后开始依次执行Dockerfile中的指令：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/23/97bff6ac9d64700f.jpg"></p>
<p>每一个指令都会在镜像上创建一个新的层，<code>-t</code>指定要创建的目标镜像名，<code>.</code>是Dockerfile所在目录。</p>

        <h1 id="发布镜像"   >
          <a href="#发布镜像" class="heading-link"><i class="fas fa-link"></i></a><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h1>
      <p>我们可以将镜像上传到：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://hub.docker.com/repositories" >https://hub.docker.com/repositories</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>先在hub.docker.com上创建公共的镜像仓库，再将本地镜像上传，上传前可以将镜像名称修改规范：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag ubuntu-java-file:latest 用户名/仓库名称:版本</span><br></pre></td></tr></table></div></figure>

<p>然后本地上传：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push nagocoler/ubuntu-java:1.0</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>这里参考的青空の霞光的用户名nagocoler和仓库名ubuntu-java</p>
</blockquote>
<p>公共仓库是可以被搜索和下载的，搜索使用<code>search</code>命令即可：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search nagocoler/ubuntu-java</span><br></pre></td></tr></table></div></figure>

<p>再使用pull命令下载：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nagocoler/ubuntu-java:1.0</span><br></pre></td></tr></table></div></figure>




        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/zwhkpi/kq6rlg" >https://www.yuque.com/qingkongxiaguang/zwhkpi/kq6rlg</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/devops/docker/docker-03-basic2.html" >https://pdai.tech/md/devops/docker/docker-03-basic2.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/21/Docker/Docker(2)-%E9%95%9C%E5%83%8F%E5%9F%BA%E7%A1%80/">Docker(2)--镜像基础</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-21</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-21</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="hello-world"   >
          <a href="#hello-world" class="heading-link"><i class="fas fa-link"></i></a><a href="#hello-world" class="headerlink" title="hello-world"></a>hello-world</h1>
      <p>要使用那些容器，首先需要拉取镜像到本地仓库，然后再运行</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取hello-world</span></span><br><span class="line">docker pull hello-world:latest</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看本地仓库的镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在容器中运行hello-world实例</span></span><br><span class="line">docker run (--name=XXX) hello-world</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>拉取指定版本的镜像：<code>docker pull 名称:版本</code>，默认是最新版本。run命令hi自动给容器分配名称，也可以使用唯一名称指定。</p>
</blockquote>
<p>如果没有调整docker的镜像源，那么docker就是从<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://hub.docker.com/" >Docker Hub</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>拉取的镜像到本地仓库。也可直接使用<code>run</code>来运行实例，如果本地仓库没有这个实例，那么就会从远端拉取镜像到仓库中。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/21/6378a12818c5974f.jpg"></p>
<blockquote>
<p><code>docker images</code>的结果有一列是ID，如果希望删除一个镜像：<code>docker rmi -f  &lt;ID&gt;</code>。</p>
</blockquote>
<p>Docker允许在容器内运行应用程序：<code>docker run</code>。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run centos:latest /bin/echo &quot;Hello world&quot;</span><br></pre></td></tr></table></div></figure>

<p>如果本地仓库没有centos的镜像，那么就会先拉取centos镜像。看一下参数的含义：</p>
<ul>
<li><p><code>docker</code>: Docker 的二进制执行文件。</p>
</li>
<li><p><code>run</code>: 与前面的 docker 组合来运行一个容器。</p>
</li>
<li><p><code>ubuntu:latest</code> 指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。</p>
</li>
<li><p><code>/bin/echo &quot;Hello world&quot;</code>: 在启动的容器里执行的命令</p>
</li>
</ul>
<blockquote>
<p>吐槽：我这拉取centos镜像文件好慢。。。</p>
</blockquote>
<p>如果我们只是想创建容器而不是去运行</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create hello-world</span><br></pre></td></tr></table></div></figure>

<p>如果想要查看<strong>所有容器</strong>（不论是否运行）</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">linux的ps是查看进程</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不加-a就只能查看运行的容器</span></span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></div></figure>

<p><img src="https://s3.bmp.ovh/imgs/2022/09/21/7bcf577b1cbd289f.jpg"></p>
<p>想要停止或者删除容器，就需要使用ID或者NAMES来指定容器，关于容器的相关操作：</p>
<ul>
<li><p>删除容器：<code>docker rm &lt;容器名/ID&gt;</code>。</p>
</li>
<li><p>停止容器：<code>docker stop &lt;XXX&gt;</code>。</p>
</li>
<li><p>运行停止的容器：<code>docker start &lt;XXX&gt;</code>。因为有些容器是执行完后马上停止，而不是像服务器那样阻塞从而一直保持运行状态。</p>
</li>
<li><p>重启容器：<code>docker restart &lt;XXX&gt;</code>。</p>
</li>
<li><p>停止后自动删除：<code>docker run --rm &lt;XXX&gt;</code>。</p>
</li>
</ul>
<p>在指定ID时，可以不用将ID完整打出来，只要前面一部分能够<strong>唯一标识</strong>该容器即可。</p>
<blockquote>
<p>该部分通过hello-world的例子讲解了一些命令和容器操作</p>
</blockquote>

        <h1 id="镜像结构"   >
          <a href="#镜像结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#镜像结构" class="headerlink" title="镜像结构"></a>镜像结构</h1>
      <p>先回顾一下镜像，容器与仓库的关系，这是官网的图：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/21/8ef2d678187a6499.jpg"></p>
<p>可以看到，容器的建立（实例化）依赖于镜像，项目打包需要一个基本的操作系统环境，这样才能在操作系统中安装依赖，这种基本的系统镜像，叫做<strong>base镜像</strong>。一般base镜像就是各个Linux操作系统的发行版。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果你执行过上面的centos的hello world</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">就不需要再执行该语句</span></span><br><span class="line">docker pull centos</span><br></pre></td></tr></table></div></figure>

<p>这就是centos的base镜像，<strong>base镜像省去了内核</strong>，内存很小。<img src="https://s3.bmp.ovh/imgs/2022/09/21/2ccdcf9b038c620c.png"></p>

        <h2 id="base镜像机制"   >
          <a href="#base镜像机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#base镜像机制" class="headerlink" title="base镜像机制"></a>base镜像机制</h2>
      <p><strong>Linux操作系统</strong>有内核空间和用户空间组成，这里需要了解两个文件系统：</p>
<ul>
<li>bootfs包含BootLoader和Linux内核，在内核启动后，bootfs会自动卸载。</li>
<li>rootfs包含系统常见目录结构，包括<code>/dev</code>，<code>/bin</code>等以及一些基本的文件和命令。</li>
</ul>
<p><strong>base镜像底层会直接使用宿主主机的内核</strong>，而rootfs可以在不同容器中运行多种不同的版本，所以实际上base镜像只包含CentOS的rootfs。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">uname</span>查看内核版本</span></span><br><span class="line">uname -r</span><br></pre></td></tr></table></div></figure>

<p>因此，Docker能够同时模拟多种Linux操作系统环境。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动base镜像</span></span><br><span class="line">docker run -it centos</span><br></pre></td></tr></table></div></figure>

<p>参数<code>-it</code>进行启动，其中<code>-i</code>表示在容器上打开一个标准输入（STDIN）接口，<code>-t</code>表示分配一个伪tty设备，可以支持终端登录（理解为伪终端），一般这两个是一起使用，否则base容器启动后就自动停止了。</p>
<blockquote>
<p>两个合起来的意思就是会弹出一个可以标准输入的终端提示符。</p>
</blockquote>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/21/e0ad3e663ad0fd3e.jpg"></p>
<p>使用<code>exit</code>退出后（<strong>CTRL+D也可以</strong>），容器也会停止，再次启动时，<strong>需要加上<code>-i</code>参数才能输入进行交互，否则就是后台运行</strong>。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start -i &lt;容器ID&gt;</span><br></pre></td></tr></table></div></figure>




        <h2 id="安装镜像"   >
          <a href="#安装镜像" class="heading-link"><i class="fas fa-link"></i></a><a href="#安装镜像" class="headerlink" title="安装镜像"></a>安装镜像</h2>
      <p>前面提到为什么需要一个基本的操作系统，基于base镜像，我们可以在这基础上安装各种软件，使用分层结构，每安装一个软件，就在base镜像上叠加上去。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/21/2600c8683f6fa6f4.jpg"></p>
<p><strong>所有的镜像会叠起来组成一个统一的文件系统，如果不同层中存在相同位置的文件，那么上层的会覆盖掉下层的文件，最终我们看到的是一个叠加之后的文件系统。</strong>当需要修改容器中的文件时，实际上并不会对镜像进行直接修改，而是在最顶上的容器层（最上面一般称为容器层，下面都是镜像层）进行修改。</p>
<p>各个操作如下：</p>
<ul>
<li><p>文件读取：要读取一个文件，Docker会<strong>最上层往下</strong>依次寻找，找到后则打开文件。</p>
</li>
<li><p>文件创建和修改：创建新文件会直接添加到容器层中，修改文件会从上往下依次寻找各个镜像中的文件，如果找到，则将其复制到容器层，再进行修改。</p>
</li>
<li><p>删除文件：删除文件也会从上往下依次寻找各个镜像中的文件，一旦找到，并不会直接删除镜像中的文件，而是在容器层标记这个删除操作。</p>
</li>
</ul>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/devops/docker/docker-02-basic.html" >https://pdai.tech/md/devops/docker/docker-02-basic.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/zwhkpi/kq6rlg#a327ddf2" >https://www.yuque.com/qingkongxiaguang/zwhkpi/kq6rlg#a327ddf2</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/20/Docker/Docker(1)-%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8/">Docker(1)--容器技术入门</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-20</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-24</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="虚拟化技术"   >
          <a href="#虚拟化技术" class="heading-link"><i class="fas fa-link"></i></a><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h1>
      <p>Virtualization是一种资源管理技术，将计算机各种实体资源（服务器，内存，网络）予以抽象，打破实体结构间不可切割的障碍，使用户可以更好的方式利用资源。从而实现在同一主机上运行多个系统或应用。</p>
<p>软件虚拟化技术是利用软件技术，在现有的物理平台上实现对物理平台访问的截获和模拟。有些软件虚拟化技术需要依赖硬件支持，比如：VMware，KVM。</p>
<p>Docker就是软件虚拟化，软件虚拟化分为好几类，Docker实际是操作系统层虚拟化。<strong>操作系统级虚拟化也被称为容器化</strong>，它允许多个相互隔离的用户空间实例存在，这些用户空间实例也被<strong>容器</strong>。</p>
<blockquote>
<p>普通的进程可以看到计算机所有资源而容器只能看到分配给该容器的资源</p>
</blockquote>
<p>实现操作系统虚拟化需要用到<strong>Namespace</strong>及<strong>cgroups</strong>技术。</p>
<p>因为不是主要讲解虚拟化技术的底层实现，所以详细可以看这篇文章：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://my.oschina.net/kelvinxupt/blog/1602990" >操作系统级虚拟化概述</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p>

        <h2 id="Docker虚拟化"   >
          <a href="#Docker虚拟化" class="heading-link"><i class="fas fa-link"></i></a><a href="#Docker虚拟化" class="headerlink" title="Docker虚拟化"></a>Docker虚拟化</h2>
      <p>Docker是一个开源的应用容器引擎，它让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到安装了任何 Linux 发行版本的机器上。Docker是直接运行在宿主操作系统之上的一个容器（操作系统级别的虚拟化），<strong>所有容器用的都是宿主操作系统的内核</strong>。</p>
<p>Docker能快速搭建开发环境，并且每个容器相互隔离：我们只需要将这些环境打包成镜像，到需要在服务器上部署时，可以直接下载镜像实现一键部署。</p>

        <h2 id="Docker与虚拟机区别"   >
          <a href="#Docker与虚拟机区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#Docker与虚拟机区别" class="headerlink" title="Docker与虚拟机区别"></a>Docker与虚拟机区别</h2>
      <p><img src="https://s3.bmp.ovh/imgs/2022/09/20/204f57e058964113.jpg"></p>
<p><strong>虚拟机</strong></p>
<ul>
<li>基础设施（Infrastructure）：个人电脑，服务器，云主机。</li>
<li>主操作系统（Host Operating System）：基础设施上运行的MacOS，Windows或者某个Linux发行版。</li>
<li>虚拟机管理系统（Hypervisor）：利用Hypervisor，可以在主操作系统之上运行多个不同的从操作系统。类型1的Hypervisor有支持MacOS的HyperKit，支持Windows的Hyper-V以及支持Linux的KVM。类型2的Hypervisor有VirtualBox和VMWare。</li>
<li><strong>操作系统（Guest Operating System）</strong>：假设你需要运行3个相互隔离的应用，则需要使用Hypervisor启动3个从操作系统，也就是3个虚拟机。这些虚拟机都非常大，也许有700MB，这就意味着它们将占用2.1GB的磁盘空间。更糟糕的是，它们还会消耗很多CPU和内存。</li>
<li>各种依赖：每一个从操作系统都需要安装许多依赖。如果你的的应用需要连接PostgreSQL的话，则需要安装libpq-dev；如果你使用Ruby的话，应该需要安装gems；如果使用其他编程语言，比如Python或者Node.js，都会需要安装对应的依赖库。</li>
</ul>
<p><strong>Docker容器</strong></p>
<ul>
<li>主操作系统（Host Operating System）：所有主流的Linux发行版都可以运行Docker。对于MacOS和Windows，也有一些办法”运行”Docker。</li>
<li>Docker守护进程（Docker Daemon）：Docker守护进程取代了Hypervisor，它是运行在操作系统之上的后台进程，<strong>负责管理Docker容器</strong>。</li>
<li>各种依赖。对于Docker，<strong>应用的所有依赖都打包在Docker镜像中，Docker容器是基于Docker镜像创建的</strong>。</li>
<li>应用。应用的源代码与它的依赖都打包在Docker镜像中，不同的应用需要不同的Docker镜像。不同的应用运行在不同的Docker容器中，它们是相互隔离的。</li>
</ul>
<blockquote>
<p>Docker守护进程可以直接与主操作系统进行通信，为各个Docker容器分配资源；它还可以将容器与主操作系统隔离，并将各个容器互相隔离。</p>
</blockquote>

        <h1 id="Docker架构"   >
          <a href="#Docker架构" class="heading-link"><i class="fas fa-link"></i></a><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h1>
      <p>Docker是C&#x2F;S架构，通过远程API来管理和创建容器。</p>
<p>客户端：客户端通过命令行或者其他工具使用Docker SDK和Docker守护进程通信。</p>
<p>主机：物理或虚拟机器，用于执行Docker守护进程和容器。</p>
<p>其他的基本概念：</p>
<ul>
<li><p><strong>镜像（Image）</strong>：Docker 镜像（Image），就相当于是一个 root 文件系统。</p>
</li>
<li><p><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
</li>
<li><p><strong>仓库（Repository）</strong>：仓库可看着一个代码控制中心，用来保存镜像。</p>
</li>
</ul>

        <h1 id="Docker安装"   >
          <a href="#Docker安装" class="heading-link"><i class="fas fa-link"></i></a><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1>
      <blockquote>
<p>我使用的系统是Ubuntu 20.04.3版本</p>
</blockquote>
<p>先安装一些工具</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ca-certificates curl gnupg lsb-release</span><br></pre></td></tr></table></div></figure>

<p>再安装官方的GPG key：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/apt/keyrings</span><br><span class="line"></span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br></pre></td></tr></table></div></figure>

<p>将Docker的库添加到apt资源列表中：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></div></figure>

<p>更新apt：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></div></figure>

<p>安装Docker CE版本</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker-ce</span><br></pre></td></tr></table></div></figure>

<p>等待安装后，查看Docker版本</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker --version</span><br></pre></td></tr></table></div></figure>

<p>但是我们使用了sudo命令（因为当前用户使用权限可能不足），所以需要将当前用户加入到Docker组里面</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker &lt;用户名&gt;</span><br></pre></td></tr></table></div></figure>

<p>退出ssh终端，重新连接即可生效。</p>
<p>我们可以先看一下Docker这个组</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里把提示符部分也写出来是为了展示一下我的用户名</span></span><br><span class="line">cyan@cyan-virtual-machine:~$ cat /etc/group</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最后一排：docker:x:998:cyan</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我已经执行过usermod命令了，所以docker组有cyan这个用户</span></span><br></pre></td></tr></table></div></figure>

<p>关于详细的Linux组的知识，你可以参考这篇文章：<a href="https://cecilia.cool/2022/07/31/Shell/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/">Linux文件权限</a>。</p>
<blockquote>
<p>如果加入组后权限依然不够，执行：<code>newgrp docker</code>。newgrp命令是登入群组。</p>
</blockquote>
<p>前文提到Docker架构（C&#x2F;S），现在部署Nginx服务器</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d -p 80:80 nginx</span><br></pre></td></tr></table></div></figure>

<p>会从镜像仓库里面下载对应的镜像，下载完成后就在后台运行了</p>
<blockquote>
<p>在浏览器的url中输入虚拟机IP，就能看到Nginx启动了</p>
</blockquote>
<p>该命令流程：</p>
<ol>
<li>Docker客户端将操作发送给服务端，告诉服务端我们要运行nginx这个镜像。</li>
<li>Docker服务端先看看本地有没有这个镜像，发现没有。</li>
<li>接着只能从公共仓库Docker Hub去查找下载镜像了。</li>
<li>下载完成，镜像成功保存到本地。</li>
<li>Docker<strong>服务端加载Nginx镜像</strong>，启动容器开始正常运行。</li>
</ol>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/devops/docker/docker-01-docker-vm.html" >https://pdai.tech/md/devops/docker/docker-01-docker-vm.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/zwhkpi/kq6rlg" >https://www.yuque.com/qingkongxiaguang/zwhkpi/kq6rlg</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://my.oschina.net/kelvinxupt/blog/1602990" >https://my.oschina.net/kelvinxupt/blog/1602990</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/jie-fang/p/10279629.html" >https://www.cnblogs.com/jie-fang/p/10279629.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/19/%E4%BA%91%E8%AE%A1%E7%AE%97/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A/">云计算作业</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-19</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h1>
      <p>用MapReduce实现wordCount（单词计数）</p>
<blockquote>
<p>软件2004-20207127云计算作业</p>
</blockquote>

        <h1 id="相关类"   >
          <a href="#相关类" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h1>
      
        <h2 id="WordCountMapper"   >
          <a href="#WordCountMapper" class="heading-link"><i class="fas fa-link"></i></a><a href="#WordCountMapper" class="headerlink" title="WordCountMapper"></a>WordCountMapper</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCountMapper</span> <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;LongWritable, Text,Text, IntWritable&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        System.out.println(key);</span><br><span class="line">        String line=value.toString();</span><br><span class="line">        String[] words=line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String word : words)&#123;</span><br><span class="line">            context.write(<span class="keyword">new</span> <span class="title class_">Text</span>(word),<span class="keyword">new</span> <span class="title class_">IntWritable</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="WordCountReduce"   >
          <a href="#WordCountReduce" class="heading-link"><i class="fas fa-link"></i></a><a href="#WordCountReduce" class="headerlink" title="WordCountReduce"></a>WordCountReduce</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCountReduce</span> <span class="keyword">extends</span> <span class="title class_">Reducer</span>&lt;Text, IntWritable,Text,IntWritable&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> total=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(IntWritable value : values)&#123;</span><br><span class="line">            total+=value.get();</span><br><span class="line">        &#125;</span><br><span class="line">        context.write(key,<span class="keyword">new</span> <span class="title class_">IntWritable</span>(total));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="WordCountMain"   >
          <a href="#WordCountMain" class="heading-link"><i class="fas fa-link"></i></a><a href="#WordCountMain" class="headerlink" title="WordCountMain"></a>WordCountMain</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCountMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//1.建立连接</span></span><br><span class="line">        Configuration cfg=<span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">        Job job=Job.getInstance(cfg,<span class="string">&quot;wc&quot;</span>);</span><br><span class="line">        job.setJarByClass(WordCountMain.class);</span><br><span class="line">        <span class="comment">//2.指定mapper和reduce</span></span><br><span class="line">        job.setMapperClass(WordCountMapper.class);</span><br><span class="line">        job.setReducerClass(WordCountReduce.class);</span><br><span class="line">        <span class="comment">//指定mapper输出类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(IntWritable.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定reduce输出类型</span></span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(IntWritable.class);</span><br><span class="line">        <span class="comment">//指定输出路径</span></span><br><span class="line">        FileInputFormat.setInputPaths(job,<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;S:/test/data.txt&quot;</span>));</span><br><span class="line">        FileOutputFormat.setOutputPath(job,<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;S:/test/M&quot;</span>));</span><br><span class="line">        <span class="comment">//3.运行</span></span><br><span class="line">        <span class="type">boolean</span> result=job.waitForCompletion(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(result?<span class="string">&quot;成功&quot;</span>:<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">        System.exit(result?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="运行结果"   >
          <a href="#运行结果" class="heading-link"><i class="fas fa-link"></i></a><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1>
      <p><img src="https://s3.bmp.ovh/imgs/2022/09/19/fc49e140e301e8d5.jpg"></p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/logo.png" alt="avatar"></div><p class="sidebar-ov-author__text">You have lots more to work on</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">75</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">2</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">12</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh_tw" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Cyan</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.2.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.7.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.7.0"></script><script src="/js/stun-boot.js?v=2.7.0"></script><script src="/js/scroll.js?v=2.7.0"></script><script src="/js/header.js?v=2.7.0"></script><script src="/js/sidebar.js?v=2.7.0"></script></body></html>