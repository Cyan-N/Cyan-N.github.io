{
    "version": "https://jsonfeed.org/version/1",
    "title": "慕青の迷途 • All posts by \"jvm\" tag",
    "description": "时雨病重症患者！！！",
    "home_page_url": "https://cecilia.cool",
    "items": [
        {
            "id": "https://cecilia.cool/2022/10/14/Java/JVM/JVM(9)-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/",
            "url": "https://cecilia.cool/2022/10/14/Java/JVM/JVM(9)-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/",
            "title": "JVM(9)-垃圾收集器",
            "date_published": "2022-10-14T04:10:45.000Z",
            "content_html": "<h1 id=\"垃圾收集器\"><a class=\"anchor\" href=\"#垃圾收集器\">#</a> 垃圾收集器</h1>\n<blockquote>\n<p>主要是介绍不同收集器得优劣以及使用</p>\n</blockquote>\n<ul>\n<li>\n<p>单线程与多线程：单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程。</p>\n</li>\n<li>\n<p>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并形指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</p>\n</li>\n</ul>\n<h2 id=\"serial收集器\"><a class=\"anchor\" href=\"#serial收集器\">#</a> Serial 收集器</h2>\n<p><code>Serial</code>  翻译为串行，即以串行的方式执行。它是单线程的收集器，只会使用一个线程进行垃圾收集工作。在进行垃圾收集时，其他线程都要暂停等待。尽管缺点明显，但是从 JDK1.3.1 开始，Serial 收集器就是默认的垃圾收集器了（客户端模式）。</p>\n<p>优点：</p>\n<ul>\n<li>设计简单高效。</li>\n<li>在用户的桌面应用场景中，内存一般不大，可以在较短时间内完成垃圾收集，只要不频繁发生，使用串行回收器是可以接受的。</li>\n</ul>\n<blockquote>\n<p>客户端模式一般是一些桌面级图形化界面应用程序，使用内存较少。</p>\n</blockquote>\n<p>我们可以修改 JDK 当前模式为客户端模式，可以在 jvm.cfg 文件将内容修改为</p>\n<pre><code class=\"language-Plain\">-client KNOWN\n-server IGNORE\n</code></pre>\n<p>使用 <code>java -version</code>  查看当前模式。（下图还没有修改为客户端模式）</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/14/df6e14722988927f.jpg\" alt=\"\" /></p>\n<blockquote>\n<p>它是 Client 模式下的默认新生代收集器，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。</p>\n</blockquote>\n<h2 id=\"parnew收集器\"><a class=\"anchor\" href=\"#parnew收集器\">#</a> ParNew 收集器</h2>\n<p>是 Serial 收集器的多线程版本。</p>\n<p>是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。</p>\n<p>默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。</p>\n<h2 id=\"parallel-scavenge收集器\"><a class=\"anchor\" href=\"#parallel-scavenge收集器\">#</a> Parallel Scavenge 收集器</h2>\n<p>其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是<strong>达到一个可控制的吞吐量</strong>，它被称为 “吞吐量优先” 收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。</p>\n<ul>\n<li>停顿时间短适合用于与用户交互的程序，<strong>良好的响应速度提升用户体验</strong>。</li>\n<li>高吞吐量可以尽快完成程序运算任务，适合后台运算而不需要太多交互的任务。</li>\n</ul>\n<blockquote>\n<p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p>\n</blockquote>\n<p>还有个<strong> Parallel Old 收集器</strong>，是 Parallel Scavenge 老年代版本，在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p>\n<h2 id=\"serial-old收集器\"><a class=\"anchor\" href=\"#serial-old收集器\">#</a> Serial Old 收集器</h2>\n<p>Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。</p>\n<p>如果用在 Server 模式下，它有两大用途:</p>\n<ul>\n<li>在 JDK 1.5 以及之前版本 (Parallel Old 诞生以前) 中与 Parallel Scavenge 收集器搭配使用。</li>\n<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>\n</ul>\n<h2 id=\"cms收集器\"><a class=\"anchor\" href=\"#cms收集器\">#</a> CMS 收集器</h2>\n<blockquote>\n<p>CMS (Concurrent Mark Sweep)，Mark Sweep 指的是标记 - 清除算法。</p>\n</blockquote>\n<p>这款收集器是 HotSpot 虚拟机中第一款真正意义上的并发（注意这里的并发和之前的并行是有区别的，并发可以理解为同时运行用户线程和 GC 线程，而并行可以理解为多条 GC 线程同时工作）收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/14/17a1a966f2a69388.jpg\" alt=\"\" /></p>\n<p>整个流程分为四个阶段：</p>\n<ul>\n<li>初始标记（需要暂停用户线程）：这个阶段的主要任务仅仅只是标记出 GC Roots 能<strong>直接关联</strong>到的对象，速度比较快，不用担心会停顿太长时间。</li>\n</ul>\n<blockquote>\n<p>直接关联：虚拟机栈，本地方法栈，被锁的对象，静态引用（方法区），虚拟机内部使用的对象</p>\n</blockquote>\n<ul>\n<li>\n<p>并发标记：从 GC Roots 的直接关联对象开始<strong>遍历整个对象图</strong>的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</p>\n</li>\n<li>\n<p>重新标记（需要暂停用户线程）：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。这个时间会比初始标记时间长一丢丢。</p>\n</li>\n<li>\n<p>并发清除：最后就可以直接将所有标记好的无用对象进行删除，因为这些对象程序中也用不到了，所以可以与用户线程并发运行。</p>\n</li>\n</ul>\n<p>具有以下缺点:</p>\n<ul>\n<li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li>\n<li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指 ** 并发清除阶段（第四个阶段）** 由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li>\n<li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li>\n</ul>\n<h2 id=\"g1收集器\"><a class=\"anchor\" href=\"#g1收集器\">#</a> G1 收集器</h2>\n<p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1（Garbage First ） 可以直接对新生代和老年代一起回收。</p>\n<p>垃圾回收分为 <code>Minor GC</code> 、 <code>Major GC</code>  和 <code>Full GC</code> ，它们分别对应的是新生代，老年代和整个堆内存的垃圾回收，而 G1 收集器巧妙地绕过了这些约定，它将整个 Java 堆划分成 <code>2048</code>  个大小相同的独立 <code>Region</code>  块，每个 <code>Region块</code> 的大小根据堆空间的实际大小而定，整体被控制在 1MB 到 32MB 之间，且都为 2 的 N 次幂。所有的 <code>Region</code>  大小相同，且在 JVM 的整个生命周期内不会发生改变。</p>\n<p>每一个 <code>Region</code>  都可以根据需要，自由决定扮演哪个角色（Eden、Survivor 和老年代），收集器会根据对应的角色采用不同的回收策略。此外，G1 收集器还存在一个 Humongous 区域，它专门用于存放大对象（一般认为大小超过了 Region 容量一半的对象为大对象）这样，新生代、老年代在物理上，不再是一个连续的内存区域，而是到处分布的。</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/14/9472c91267ced332.jpg\" alt=\"\" /></p>\n<p>回收过程与 CMS 相似：</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/14/ec5b94383e100df0.jpg\" alt=\"\" /></p>\n<ul>\n<li>\n<p>初始标记（暂停用户线程）：仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的 Region 中分配新对象。</p>\n</li>\n<li>\n<p>并发标记：从 GC Root 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。</p>\n</li>\n<li>\n<p>最终标记（暂停用户线程）：对用户线程做一个短暂的暂停，用于处理并发标记阶段漏标的那部分对象。</p>\n</li>\n<li>\n<p>筛选回收：负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，<strong>可以自由选择任意多个 Region 构成回收集，然后把决定回收的那一部分 Region 的存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间</strong>。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多个收集器线程并行完成的。</p>\n</li>\n</ul>\n<h1 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h1>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueXVxdWUuY29tL3Fpbmdrb25neGlhZ3VhbmcvamF2YXNlL2hsYTdociMyNDY2Yzc5Mg==\">https://www.yuque.com/qingkongxiaguang/javase/hla7hr#2466c792</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wZGFpLnRlY2gvbWQvamF2YS9qdm0vamF2YS1qdm0tZ2MuaHRtbCMlRTUlOUUlODMlRTUlOUMlQkUlRTYlOTQlQjYlRTklOUIlODYlRTUlOTklQTg=\">https://pdai.tech/md/java/jvm/java-jvm-gc.html# 垃圾收集器</span></p>\n</blockquote>\n",
            "tags": [
                "JVM"
            ]
        },
        {
            "id": "https://cecilia.cool/2022/10/13/Java/JVM/JVM(8)-%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%B4%BB%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/",
            "url": "https://cecilia.cool/2022/10/13/Java/JVM/JVM(8)-%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%B4%BB%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/",
            "title": "JVM(8)--对象存活与垃圾回收",
            "date_published": "2022-10-13T08:20:56.000Z",
            "content_html": "<h1 id=\"对象存活算法\"><a class=\"anchor\" href=\"#对象存活算法\">#</a> 对象存活算法</h1>\n<blockquote>\n<p>尽量以简短精炼的语言讲解，唔，所见即所得。</p>\n</blockquote>\n<h2 id=\"引用计数算法\"><a class=\"anchor\" href=\"#引用计数算法\">#</a> 引用计数算法</h2>\n<p>给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p>\n<p>两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。</p>\n<p>正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ReferenceCountingGC</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Object</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token class-name\">ReferenceCountingGC</span> objectA <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReferenceCountingGC</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token class-name\">ReferenceCountingGC</span> objectB <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReferenceCountingGC</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        objectA<span class=\"token punctuation\">.</span>instance <span class=\"token operator\">=</span> objectB<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        objectB<span class=\"token punctuation\">.</span>instance <span class=\"token operator\">=</span> objectA<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"可达性分析算法\"><a class=\"anchor\" href=\"#可达性分析算法\">#</a> 可达性分析算法</h2>\n<p>通过 GC Roots 作为起始点进行搜索，能够达到的对象都是存活的，不可达的对象可被回收。</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/13/b793a432c31cfc5a.jpg\" alt=\"\" /></p>\n<p>GC Roots 一般包含：</p>\n<ul>\n<li><a href=\"https://cecilia.cool/2022/10/10/Java/JVM/JVM(5)-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89/#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88\">虚拟机栈</a>中引用的对象（每个线程都有一个虚拟机栈）。</li>\n<li><a href=\"https://cecilia.cool/2022/10/10/Java/JVM/JVM(5)-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89/#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88\">本地方法栈</a>中引用的对象（调用 native 方法）。</li>\n<li><a href=\"https://cecilia.cool/2022/10/11/Java/JVM/JVM(6)-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB/#%E6%96%B9%E6%B3%95%E5%8C%BA\">方法区</a>中类静态属性，常量引用的对象（方法区其实就是 heap 老年代后面那个，又叫元数据区，永久代）。</li>\n<li>被添加了锁的对象</li>\n<li>虚拟机内部需要用到的对象。</li>\n</ul>\n<p>一旦已经存在的根节点不满足存在的条件时，那么根节点与对象之间的连接将被断开。此时虽然对象 1 仍存在对其他对象的引用，但是由于其没有任何根节点引用，所以此对象即可被判定为不再使用。</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/13/1622fa539ace74ea.jpg\" alt=\"\" /></p>\n<h2 id=\"方法区回收\"><a class=\"anchor\" href=\"#方法区回收\">#</a> 方法区回收</h2>\n<blockquote>\n<p>方法区主要存放永久代对象，其回收率很低，因此在方法区主要是对常量池的回收和对类的卸载</p>\n</blockquote>\n<p>大量使用反射，动态代理，CGLib 等框架，这类频繁定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。</p>\n<p>类卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载：</p>\n<ul>\n<li>\n<p>该类所有实例都被回收</p>\n</li>\n<li>\n<p>加载该类的 <code>ClassLoader</code>  已经被回收</p>\n</li>\n<li>\n<p>该类对象的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</p>\n</li>\n</ul>\n<h2 id=\"finalize\"><a class=\"anchor\" href=\"#finalize\">#</a> finalize()</h2>\n<p><code>finalize()</code>  类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，<strong>因此最好不要使用</strong>。</p>\n<p>当一个对象可被回收时，如果需要执行该对象的 finalize () 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。<strong>自救只能进行一次</strong>，如果回收的对象之前调用了 finalize () 方法自救，后面回收时不会调用  <code>finalize()</code>  方法。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 该方法在 Object 类中</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">finalize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Throwable</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h1 id=\"引用类型\"><a class=\"anchor\" href=\"#引用类型\">#</a> 引用类型</h1>\n<p>这个在 <code>WeakHashMap</code>  中讲过，相关<a href=\"https://cecilia.cool/2022/10/04/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88(5)-WeakHashMap/\">链接</a>。</p>\n<h1 id=\"垃圾回收\"><a class=\"anchor\" href=\"#垃圾回收\">#</a> 垃圾回收</h1>\n<h2 id=\"标记-清除\"><a class=\"anchor\" href=\"#标记-清除\">#</a> 标记 - 清除</h2>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/14/6e2c2f6a36068e2f.jpg\" alt=\"\" /></p>\n<p>单纯清理掉未被标记的对象：标记和清除过程效率不高，但是会产生大量不连续的内存碎片。</p>\n<h2 id=\"标记-整理\"><a class=\"anchor\" href=\"#标记-整理\">#</a> 标记 - 整理</h2>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/14/e25babeccdf54b47.jpg\" alt=\"\" /></p>\n<p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>\n<h2 id=\"复制\"><a class=\"anchor\" href=\"#复制\">#</a> 复制</h2>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/14/ea3a84203595777f.jpg\" alt=\"\" /></p>\n<p>有没有想起堆区中的两个幸存者区，尽管这不是，这种复制的缺点是只是用了内存的一半，现在的 JVM 都采用这种收集算法回收新生代，而不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。</p>\n<p>HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 <strong>8:1</strong>，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，<strong>那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象</strong>（这就是空间分配担保机制）。</p>\n<p>先看一下垃圾收集类别：</p>\n<ul>\n<li>\n<p>Minor GC  -  次要垃圾回收，主要进行新生代区域的垃圾收集。</p>\n</li>\n<li>\n<ul>\n<li>触发条件：新生代的 Eden 区容量已满时。</li>\n</ul>\n</li>\n<li>\n<p>Major GC  -  主要垃圾回收，主要进行老年代的垃圾收集。</p>\n</li>\n<li>\n<p>Full GC    -   完全垃圾回收，对整个 Java 堆内存和方法区进行垃圾回收。</p>\n</li>\n<li>\n<ul>\n<li>触发条件 1：每次晋升到老年代的对象平均大小大于老年代剩余空间</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>触发条件 2：Minor GC 后存活的对象超过了老年代剩余空间</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>触发条件 3：永久代内存不足（JDK8 之前）</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>触发条件 4：手动调用 <code>System.gc()</code>  方法</li>\n</ul>\n</li>\n</ul>\n<p><strong>详细的空间分配担保</strong>：</p>\n<p>当新生代无法容纳更多的的对象时，可以把新生代中的对象移动到老年代中，这样新生代就腾出了空间来容纳更多的对象。</p>\n<p>如果老年代也装不下，首先会判断一下之前的每次垃圾回收进入老年代的平均大小是否小于当前老年代的剩余空间，如果小于，那么说明也许可以放得下（不过也仅仅是也许，依然有可能放不下，因为判断的实际上只是平均值，万一这一次突然非常大呢），否则，会先来一次 Full GC，进行一次大规模垃圾回收，来尝试腾出空间，再次判断老年代是否有空间存放，要是还是装不下，直接抛出 OOM 错误，摆烂。</p>\n<h2 id=\"分代收集\"><a class=\"anchor\" href=\"#分代收集\">#</a> 分代收集</h2>\n<p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p>\n<p>一般将堆分为新生代和老年代。</p>\n<ul>\n<li>新生代使用：复制算法</li>\n<li>老年代使用：标记 - 清除 或者 标记 - 整理 算法</li>\n</ul>\n<h1 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h1>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wZGFpLnRlY2gvbWQvamF2YS9qdm0vamF2YS1qdm0tZ2MuaHRtbA==\">https://pdai.tech/md/java/jvm/java-jvm-gc.html</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueXVxdWUuY29tL3Fpbmdrb25neGlhZ3VhbmcvamF2YXNlL2hsYTdociNjY2IxMGZlNA==\">https://www.yuque.com/qingkongxiaguang/javase/hla7hr#ccb10fe4</span></p>\n</blockquote>\n",
            "tags": [
                "JVM"
            ]
        },
        {
            "id": "https://cecilia.cool/2022/10/12/Java/JVM/JVM(7)-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/",
            "url": "https://cecilia.cool/2022/10/12/Java/JVM/JVM(7)-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/",
            "title": "JVM(7)--内存模型",
            "date_published": "2022-10-12T05:22:10.000Z",
            "content_html": "<h1 id=\"引入\"><a class=\"anchor\" href=\"#引入\">#</a> 引入</h1>\n<blockquote>\n<p>内存模型和内存结构不一样，通过本节从堆栈角度引入 JMM，为后续内容做铺垫。</p>\n</blockquote>\n<p>JMM 在线程栈和堆之间划分内存，如果你系统的学习过 Java，一定听过<strong>引用保存在栈中，实例化对象保存在堆中</strong>这样的话。从逻辑上说明 JMM：</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/12/542b995303607bcd.jpg\" alt=\"\" /></p>\n<p>由线程创建的局部变量对于创建它的线程以外的所有其他线程是不可见的。 即使两个线程正在执行完全相同的代码，两个线程仍将在每个自己的线程堆栈中创建该代码的局部变量。</p>\n<blockquote>\n<p>基本类型的局部变量完全存储在线程堆栈中，对其他线程不可见；但是 <code>new</code>  对象时，都存储在堆上，这个对象的成员变量与对象一起存储在堆上。</p>\n</blockquote>\n<h2 id=\"jmm与硬件内存结构关系\"><a class=\"anchor\" href=\"#jmm与硬件内存结构关系\">#</a> JMM 与硬件内存结构关系</h2>\n<blockquote>\n<p>其实该部分在 <code>J.U.C</code>  的 <code>volatile</code>  关键字讲过。</p>\n</blockquote>\n<p>先看内存结构图：</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/12/f8124fb203ff9b3a.jpg\" alt=\"\" /></p>\n<p><code>内存-&gt;cache-&gt;寄存器</code> ：有些结构是将 <code>cache</code>  也到了 CPU 里面。</p>\n<p>因为 JVM 也是一个运行在 CPU 的程序，所以堆内存和线程栈的数据可能在三个位置，就会导致可见性和同步性的问题：</p>\n<blockquote>\n<p>可见性：对象共享后，某一个线程做出修改，但是还没有刷新到主存中，就会导致另一个线程看不到修改。</p>\n<p>同步性：多个线程的修改，后一个线程可能会掩盖前一个线程的修改。</p>\n</blockquote>\n<p>这些都是并发讲过的，不多说了，前一个问题通过 <code>volatile</code>  解决，后一个问题通过上锁解决。</p>\n<p>关于第二个问题，同步块有个特性：同步块还保证在同步块内访问的所有变量都将从主存储器中读入，当线程退出同步块时，所有更新的变量将再次刷新回主存储器，无论变量是不是声明为 volatile。</p>\n<h1 id=\"内存模型\"><a class=\"anchor\" href=\"#内存模型\">#</a> 内存模型</h1>\n<blockquote>\n<p>接下来的内容与并发内容多有相似之处。总结于 Info 上的深入理解 Java 内存模型，作者程晓明。</p>\n</blockquote>\n<h2 id=\"基础\"><a class=\"anchor\" href=\"#基础\">#</a> 基础</h2>\n<p>线程之间通信机制有两种：共享内存和消息传递。前者很简单，后者的模型中，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</p>\n<p>Java 的并发采用的是共享内存模型，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p>\n<h3 id=\"jmm抽象\"><a class=\"anchor\" href=\"#jmm抽象\">#</a> JMM 抽象</h3>\n<p>在引入中就讲到 JMM，线程之间内存不共享。Java 中，所有实例，静态域，数组元素存储在堆内存中。我们常说的线程通信，其实就是通过主内存进行通信，因为每个线程都有副本，所以会出现可见性问题。</p>\n<p><strong>happens-before</strong>：这个概念用来阐述操作之间的内存可见性，如果 a 操作的结果需要对 b 操作可见，那么这两个操作必须存在 happens-before 关系。</p>\n<ul>\n<li>\n<p>程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</p>\n</li>\n<li>\n<p>监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</p>\n</li>\n<li>\n<p>volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。</p>\n</li>\n<li>\n<p>传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。</p>\n</li>\n</ul>\n<p>happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。</p>\n<blockquote>\n<p>因为内容完整性才写的这个，感觉都没什么好说的，知道有这么个概念即可。</p>\n</blockquote>\n<h2 id=\"重排序\"><a class=\"anchor\" href=\"#重排序\">#</a> 重排序</h2>\n<p><strong>数据依赖性</strong>：如果两个指令（操作）重排序会导致执行结果改变，就不允许重排序：写后读，读后写，写后写。</p>\n<blockquote>\n<p>编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p>\n</blockquote>\n<p><strong>as-if-serial</strong>：不管怎么重排序，（单线程）程序的执行结果不能被改变。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">double</span> pi <span class=\"token operator\">=</span> <span class=\"token number\">3.14</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//A</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">double</span> r   <span class=\"token operator\">=</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//B</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">double</span> area <span class=\"token operator\">=</span> pi <span class=\"token operator\">*</span> r <span class=\"token operator\">*</span> r<span class=\"token punctuation\">;</span> <span class=\"token comment\">//C</span></pre></td></tr></table></figure><p>三个操作数依赖关系：</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/12/fb20c093ac1b648f.jpg\" alt=\"\" /></p>\n<blockquote>\n<p>其实就是 A，B 可以随意交换执行顺序。其实在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的开发并行度。编译器和处理器遵从这一目标，从 happens- before 的定义我们可以看出，JMM 同样遵从这一目标。</p>\n</blockquote>\n<h1 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h1>\n<blockquote>\n<p>个人感觉：JMM 就是为了（多）线程指令正确执行而做出的努力。</p>\n</blockquote>\n<p>一般的处理器内存模型都符合这么一个规律：越是追求性能的处理器，内存模型设计会越弱，因为处理器希望内存模型对他们的束缚越少越好。毕竟为了保证并发环境下程序正确执行，会消耗大量资源。</p>\n<blockquote>\n<p>JMM 是一个语言级的内存模型，处理器内存模型是硬件级的内存模型</p>\n</blockquote>\n<p>不同处理器平台对于指令的重排序也不相同，JMM 通过插入内存屏障阻止这些不同处理器的不同重排序，向上屏蔽了处理器内存模型的差异，它在不同的处理器平台之上为 java 程序员呈现了一个一致的内存模型。</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/12/b09bbd238021753d.jpg\" alt=\"\" /></p>\n<h2 id=\"jmm的设计\"><a class=\"anchor\" href=\"#jmm的设计\">#</a> JMM 的设计</h2>\n<p>从 JMM 设计者的角度来说，在设计 JMM 时，需要考虑两个关键因素：</p>\n<ul>\n<li>程序员对内存模型的使用。程序员希望内存模型易于理解，易于编程。程序员希望基于一个强内存模型来编写代码。</li>\n<li>编译器和处理器对内存模型的实现。编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。编译器和处理器希望实现一个弱内存模型。</li>\n</ul>\n<blockquote>\n<p>一方面要为程序员提供足够强的内存可见性保证；另一方面，对编译器和处理器的限制要尽可能的放松。</p>\n</blockquote>\n<p>下面让我们看看 JSR-133 是如何实现这一目标的。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">double</span> pi  <span class=\"token operator\">=</span> <span class=\"token number\">3.14</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">//A</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">double</span> r   <span class=\"token operator\">=</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">//B</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">double</span> area <span class=\"token operator\">=</span> pi <span class=\"token operator\">*</span> r <span class=\"token operator\">*</span> r<span class=\"token punctuation\">;</span> <span class=\"token comment\">//C</span></pre></td></tr></table></figure><ul>\n<li>A happens- before B；</li>\n<li>B happens- before C；</li>\n<li>A happens- before C；</li>\n</ul>\n<p>happens- before 的定义会要求：A 操作执行的结果要对 B 可见，且 A 操作的执行顺序排在 B 操作之前。 但是从程序语义的角度来说，<strong>对 A 和 B 做重排序即不会改变程序的执行结果</strong>，也还能提高程序的执行性能（允许这种重排序减少了对编译器和处理器优化的束缚）。也就是说，上面这 3 个 happens- before 关系中，虽然 2 和 3 是必需要的，但 1 是不必要的。因此，JMM 把 happens- before <strong>要求禁止的重排序</strong>分为了下面两类：</p>\n<ul>\n<li>会改变程序执行结果的重排序。</li>\n<li>不会改变程序执行结果的重排序。</li>\n</ul>\n<blockquote>\n<p>这里说的 happens- before <strong>要求禁止的重排序</strong>就是 A happens-before B，也就是 A 的结果 B 必须可见（但是显然这不是必须的）。</p>\n</blockquote>\n<p>JMM 对这两种不同性质的重排序，采取了不同的策略：</p>\n<ul>\n<li>对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序。</li>\n<li>对于不会改变程序执行结果的重排序，JMM 对编译器和处理器不作要求（JMM 允许这种重排序）。</li>\n</ul>\n<blockquote>\n<p>第二种就是，JMM 放养了，随便编译器和处理器是否排序。</p>\n</blockquote>\n<h1 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h1>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wZGFpLnRlY2gvbWQvamF2YS9qdm0vamF2YS1qdm0tam1tLmh0bWw=\">https://pdai.tech/md/java/jvm/java-jvm-jmm.html</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaW5mb3EuY24vbWluaWJvb2svamF2YV9tZW1vcnlfbW9kZWw=\">https://www.infoq.cn/minibook/java_memory_model</span></p>\n</blockquote>\n",
            "tags": [
                "JVM"
            ]
        },
        {
            "id": "https://cecilia.cool/2022/10/11/Java/JVM/JVM(6)-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB/",
            "url": "https://cecilia.cool/2022/10/11/Java/JVM/JVM(6)-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB/",
            "title": "JVM(6)--内存结构之线程共享",
            "date_published": "2022-10-11T02:23:41.000Z",
            "content_html": "<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>关于内存结构的第二篇：包含堆内存，方法区。</p>\n<h1 id=\"堆内存\"><a class=\"anchor\" href=\"#堆内存\">#</a> 堆内存</h1>\n<blockquote>\n<p>Java 堆是 Java 虚拟机管理的内存中最大的一块，被所有线程共享。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。</p>\n</blockquote>\n<p>JVM 把堆内存逻辑上划分为三个区域（划分的唯一理由就是优化 GC 性能）:</p>\n<ul>\n<li>年轻代：新对象和没达到一定年龄的对象都在新生代。</li>\n<li>老年代：被长时间使用的对象，老年代的内存空间应该要比年轻代更大。</li>\n<li>元空间（JDK1.8 之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存。</li>\n</ul>\n<p>主流虚拟机都是可扩展的（通过  <code>-Xmx</code>  和  <code>-Xms</code>  控制），如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出  <code>OutOfMemoryError</code>  异常。</p>\n<h2 id=\"年轻代\"><a class=\"anchor\" href=\"#年轻代\">#</a> 年轻代</h2>\n<p>年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为 <strong>Minor GC</strong>。年轻一代被分为三个部分 —— 伊甸园（<strong>Eden Memory</strong>）和两个幸存区（<strong>Survivor Memory</strong>，被称为 from/to 或 s0/s1），默认比例是 <code>8:1:1</code></p>\n<ul>\n<li>大多数新创建的对象都位于 Eden 内存空间中，此时 JVM 会给对象定义一个对象年轻计数器。（ <code>-XX:MaxTenuringThreshold</code> ）。</li>\n<li>当 Eden 空间被对象填（<strong>空间不足</strong>）时，执行<strong> Minor GC</strong>，并将所有幸存者对象移动到一个幸存者空间中。</li>\n<li>Minor GC 检查幸存者对象，并将它们移动到<strong>另一个</strong>幸存者空间。所以每次，一个幸存者空间总是空的</li>\n<li>经过多次 GC 循环（每次 Minor GC 对象年龄 + 1）后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的年龄阈值来实现的，然后他们才有资格提升到老一代。</li>\n</ul>\n<blockquote>\n<p>对象超过了 <code>-XX:PetenureSizeThreshold</code> ，对象会<strong>直接被分配到老年代</strong>。默认是 15 次回收标记。</p>\n</blockquote>\n<h2 id=\"老年代\"><a class=\"anchor\" href=\"#老年代\">#</a> 老年代</h2>\n<p>旧的一代内存包含那些经过许多轮小型 GC 后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集称为 主 GC（Major GC），通常需要更长的时间。</p>\n<p><strong>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个 Survivor 区之间发生大量的内存拷贝</strong>。</p>\n<blockquote>\n<p>在老年代，如果内存不足，触发 Major GC，进行内存清理。之后发现依然无法进行对象的保存，就会产生 OOM 异常。</p>\n</blockquote>\n<h2 id=\"元空间\"><a class=\"anchor\" href=\"#元空间\">#</a> 元空间</h2>\n<p>不管是 JDK8 之前的永久代，还是 JDK8 及以后的元空间，都可以看作是 Java 虚拟机规范中方法区的实现。</p>\n<p>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开</p>\n<h2 id=\"设置堆内存大小和oom\"><a class=\"anchor\" href=\"#设置堆内存大小和oom\">#</a> 设置堆内存大小和 OOM</h2>\n<p>堆的大小可以在 JVM 启动时确定，通过 <code>-Xmx</code>  和 <code>-Xms</code>  设定：</p>\n<ul>\n<li><code>-Xms</code>  表示堆的起始内存，等价于 <code>-XX:InitialHeapSize</code> 。</li>\n<li><code>-Xmx</code>  表示堆的最大内存，等价于 <code>-XX:MaxHeapSize</code> 。</li>\n</ul>\n<p>如果堆的内存大小超过  <code>-Xmx</code>  设定的最大内存， 就会抛出  <code>OutOfMemoryError</code>  异常。</p>\n<p>通常会将  <code>-Xmx</code>  和  <code>-Xms</code>  两个参数配置为相同的值，其目的是为了能够在垃圾回收机制清理完堆区后不再需要重新分隔计算堆的大小，从而提高性能</p>\n<ul>\n<li>默认情况下，初始堆内存大小为：电脑内存大小 / 64</li>\n<li>默认情况下，最大堆内存大小为：电脑内存大小 / 4</li>\n</ul>\n<blockquote>\n<p>也可能出现偏差，导致下面代码的内存并不符合这种计算。</p>\n</blockquote>\n<p>可以通过代码获取到我们的设置值，当然也可以模拟 OOM：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token comment\">// 返回 JVM 堆大小</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">long</span> initalMemory <span class=\"token operator\">=</span> <span class=\"token class-name\">Runtime</span><span class=\"token punctuation\">.</span><span class=\"token function\">getRuntime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">totalMemory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">1024</span> <span class=\"token operator\">/</span><span class=\"token number\">1024</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token comment\">// 返回 JVM 堆的最大内存</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token keyword\">long</span> maxMemory <span class=\"token operator\">=</span> <span class=\"token class-name\">Runtime</span><span class=\"token punctuation\">.</span><span class=\"token function\">getRuntime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">maxMemory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">1024</span> <span class=\"token operator\">/</span><span class=\"token number\">1024</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"-Xms : \"</span><span class=\"token operator\">+</span>initalMemory <span class=\"token operator\">+</span> <span class=\"token string\">\"M\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"-Xmx : \"</span><span class=\"token operator\">+</span>maxMemory <span class=\"token operator\">+</span> <span class=\"token string\">\"M\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>  <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"系统内存大小：\"</span> <span class=\"token operator\">+</span> initalMemory <span class=\"token operator\">*</span> <span class=\"token number\">64</span> <span class=\"token operator\">/</span> <span class=\"token number\">1024</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"G\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"系统内存大小：\"</span> <span class=\"token operator\">+</span> maxMemory <span class=\"token operator\">*</span> <span class=\"token number\">4</span> <span class=\"token operator\">/</span> <span class=\"token number\">1024</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"G\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"查看jvm堆内存分配\"><a class=\"anchor\" href=\"#查看jvm堆内存分配\">#</a> 查看 JVM 堆内存分配</h2>\n<ol>\n<li>在默认不配置 JVM 堆内存大小的情况下，JVM 根据默认值来配置当前内存大小</li>\n<li>默认情况下新生代和老年代的比例是 1:2，可以通过  <code>–XX:NewRatio</code>  来配置\n<ul>\n<li>新生代中的 <strong>Eden</strong>:<strong>From Survivor</strong>:<strong>To Survivor</strong> 的比例是 <strong>8:1:1</strong>，可以通过  <code>-XX:SurvivorRatio</code>  来配置</li>\n</ul>\n</li>\n<li>若在 JDK 7 中开启了  <code>-XX:+UseAdaptiveSizePolicy</code> ，JVM 会动态调整 JVM 堆中各个区域的大小以及进入老年代的年龄。此时  <code>–XX:NewRatio</code>  和  <code>-XX:SurvivorRatio</code>   将会失效，而 JDK 8 是默认开启 <code>-XX:+UseAdaptiveSizePolicy</code> 。在 JDK 8 中，<strong>不要随意关闭</strong> <code>-XX:+UseAdaptiveSizePolicy</code> ，除非对堆内存的划分有明确的规划。</li>\n</ol>\n<blockquote>\n<p>所以记住了比例也是然并卵对吗？</p>\n</blockquote>\n<p>每次 GC 后都会重新计算 Eden、From Survivor、To Survivor 的大小</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">java</span> <span class=\"token parameter variable\">-XX:+PrintFlagsFinal</span> <span class=\"token parameter variable\">-version</span> <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> HeapSize</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    uintx ErgoHeapSizeLimit                         <span class=\"token operator\">=</span> <span class=\"token number\">0</span>                                   <span class=\"token punctuation\">&#123;</span>product<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    uintx HeapSizePerGCThread                       <span class=\"token operator\">=</span> <span class=\"token number\">87241520</span>                            <span class=\"token punctuation\">&#123;</span>product<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    uintx InitialHeapSize                          :<span class=\"token operator\">=</span> <span class=\"token number\">134217728</span>                           <span class=\"token punctuation\">&#123;</span>product<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    uintx LargePageHeapSizeThreshold                <span class=\"token operator\">=</span> <span class=\"token number\">134217728</span>                           <span class=\"token punctuation\">&#123;</span>product<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    uintx MaxHeapSize                              :<span class=\"token operator\">=</span> <span class=\"token number\">2147483648</span>                          <span class=\"token punctuation\">&#123;</span>product<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">java</span> version <span class=\"token string\">\"1.8.0_211\"</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>Java<span class=\"token punctuation\">(</span>TM<span class=\"token punctuation\">)</span> SE Runtime Environment <span class=\"token punctuation\">(</span>build <span class=\"token number\">1.8</span>.0_211-b12<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>Java HotSpot<span class=\"token punctuation\">(</span>TM<span class=\"token punctuation\">)</span> <span class=\"token number\">64</span>-Bit Server VM <span class=\"token punctuation\">(</span>build <span class=\"token number\">25.211</span>-b12, mixed mode<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h2 id=\"扩展逃逸分析\"><a class=\"anchor\" href=\"#扩展逃逸分析\">#</a> 扩展：逃逸分析</h2>\n<blockquote>\n<p>随着 JIT 编译期的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么 “绝对” 了。 ——《深入理解 Java 虚拟机》</p>\n</blockquote>\n<p><strong>逃逸分析 (Escape Analysis) 是目前 Java 虚拟机中比较前沿的优化技术</strong>。通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定<strong>是否要将这个对象分配到堆上</strong>。</p>\n<p>逃逸分析的基本行为就是分析对象动态作用域：</p>\n<ul>\n<li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li>\n<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中，称为方法逃逸。</li>\n</ul>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">StringBuffer</span> <span class=\"token function\">craeteStringBuffer</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> s1<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> s2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>   <span class=\"token class-name\">StringBuffer</span> sb <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringBuffer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>   sb<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>s1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>   sb<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>   <span class=\"token keyword\">return</span> sb<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">//sb 就可以被外部方法访问，即方法逃逸，如果还被外部线程访问了，就是线程逃逸。</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">// 如果不想 sb 逃逸出去，可以写成 sb.toString ()，当然方法返回类型改为 String</span></pre></td></tr></table></figure><p>使用逃逸分析，编译器可以对代码做优化：</p>\n<ul>\n<li><strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配（这个可以有，而且优化效果会非常明显）。</li>\n</ul>\n<p>JVM 通过逃逸分析确定该对象不会被外部访问。那就通过标量替换将该对象分解在栈上分配内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。</p>\n<ul>\n<li><strong>同步省略</strong>：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步</li>\n</ul>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">keep</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token class-name\">Object</span> keeper <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token keyword\">synchronized</span><span class=\"token punctuation\">(</span>keeper<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>keeper<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">// 当然，这种更考验开发人员写代码的水平，因为本来就不该给 keeper</span></pre></td></tr></table></figure><ul>\n<li><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而存储在 CPU 寄存器</li>\n</ul>\n<p>分离对象（标量替换）说直白点就是将对象拆分为标量。</p>\n<blockquote>\n<p><strong>标量</strong>（Scalar）是指一个无法再分解成更小的数据的数据，其他的就是聚合量。</p>\n</blockquote>\n<p>通过  <code>-XX:+EliminateAllocations</code>  可以开启标量替换， <code>-XX:+PrintEliminateAllocations</code>  查看标量替换情况。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>   <span class=\"token function\">alloc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">alloc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>   <span class=\"token class-name\">Point</span> point <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Point</span>（<span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span>）<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>   <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"point.x=\"</span><span class=\"token operator\">+</span>point<span class=\"token punctuation\">.</span>x<span class=\"token operator\">+</span><span class=\"token string\">\"; point.y=\"</span><span class=\"token operator\">+</span>point<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Point</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> x<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>point 对象并没有逃逸出  <code>alloc()</code>  方法，并且 point 对象是可以拆解成标量的。那么，JIT 就不会直接创建 Point 对象，而是直接使用两个标量 int x ，int y 来替代 Point 对象。</p>\n<p><strong>总结</strong>：</p>\n<p>** 虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。** 一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。关于逃逸分析的论文在 1999 年就已经发表了，但直到 JDK 1.6 才有实现，而且这项技术到如今也并不是十分成熟的。</p>\n<h1 id=\"方法区\"><a class=\"anchor\" href=\"#方法区\">#</a> 方法区</h1>\n<p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本 / 字段 / 方法 / 接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是  <code>String.intern()</code>  方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出  <code>OutOfMemoryErro</code> r 异常。</p>\n<h3 id=\"解惑\"><a class=\"anchor\" href=\"#解惑\">#</a> 解惑</h3>\n<p>你是否也有看不同的参考资料，有的内存结构图有方法区，有的又是永久代，元数据区，一脸懵逼的时候？</p>\n<ul>\n<li><strong>方法区（method area）只是 JVM 规范中定义的一个概念</strong>，用于存储类信息、常量池、静态变量、JIT 编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而<strong>永久代（PermGen）是 Hotspot 虚拟机特有的概念， Java8 的时候又被元空间</strong>取代了，永久代和元空间都可以理解为方法区的落地实现。</li>\n<li>永久代物理是堆的一部分，和新生代，老年代地址是连续的（受垃圾回收器管理），而元空间存在于本地内存（我们常说的堆外内存，不受垃圾回收器管理），这样就不受 JVM 限制了，也比较难发生 OOM（都会有溢出异常）。</li>\n<li>Java7 中我们通过 <code>-XX:PermSize</code>  和  <code>-xx:MaxPermSize</code>  来设置永久代参数，Java8 之后，随着永久代的取消，这些参数也就随之失效了，改为通过 <code>-XX:MetaspaceSize</code>  和  <code>-XX:MaxMetaspaceSize</code>  用来设置元空间参数。</li>\n<li>存储内容不同，元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中。</li>\n<li>如果方法区域中的内存不能用于满足分配请求，则 Java 虚拟机抛出  <code>OutOfMemoryError</code> 。</li>\n<li>JVM 规范说方法区在逻辑上是堆的一部分，但目前实际上是与 Java 堆分开的（Non-Heap）。</li>\n</ul>\n<p>所以对于方法区，Java8 之后的变化：</p>\n<ul>\n<li>移除了永久代（PermGen），替换为元空间（Metaspace）；</li>\n<li>永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；</li>\n<li>永久代中的 interned Strings 和 class static variables 转移到了 Java heap；</li>\n<li>永久代参数 （PermSize MaxPermSize） -&gt; 元空间参数（MetaspaceSize MaxMetaspaceSize）</li>\n</ul>\n<h3 id=\"方法区内部结构\"><a class=\"anchor\" href=\"#方法区内部结构\">#</a> 方法区内部结构</h3>\n<blockquote>\n<p>方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p>\n</blockquote>\n<h4 id=\"类型信息\"><a class=\"anchor\" href=\"#类型信息\">#</a> 类型信息</h4>\n<p>对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息</p>\n<ul>\n<li>这个类型的完整有效名称（全名 = 包名。类名）</li>\n<li>这个类型直接父类的完整有效名（对于 interface 或是 java.lang.Object，都没有父类）</li>\n<li>这个类型的修饰符（public，abstract，final 的某个子集）</li>\n<li>这个类型直接接口的一个有序列表</li>\n</ul>\n<h4 id=\"域信息\"><a class=\"anchor\" href=\"#域信息\">#</a> 域信息</h4>\n<ul>\n<li>JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序</li>\n<li>域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient 的某个子集）</li>\n</ul>\n<h4 id=\"方法信息\"><a class=\"anchor\" href=\"#方法信息\">#</a> 方法信息</h4>\n<p>JVM 必须保存所有方法的</p>\n<ul>\n<li>方法名称</li>\n<li>方法的返回类型</li>\n<li>方法参数的数量和类型</li>\n<li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract 的一个子集）</li>\n<li>方法的字符码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）</li>\n<li>异常表（abstract 和 native 方法除外）\n<ul>\n<li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"运行时常量池\"><a class=\"anchor\" href=\"#运行时常量池\">#</a> 运行时常量池</h3>\n<p>运行时常量池（Runtime Constant Pool）是方法区的一部分，在加载类和结构到虚拟机后，就会创建对应的运行时常量池。</p>\n<ul>\n<li>常量池表（Constant Pool Table）是 Class 文件的一部分，用于存储编译期生成的各种字面量和符号引用，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong>。</li>\n<li>JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</li>\n<li>运行时常量池中包含各种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。运行时常量池，相对于 Class 文件常量池的另一个重要特征是：<strong>动态性</strong>，Java 语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String 类的  <code>intern()</code>  方法就是这样的。</li>\n<li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛出 OutOfMemoryError 异常。</li>\n</ul>\n<h3 id=\"方法区的gc\"><a class=\"anchor\" href=\"#方法区的gc\">#</a> 方法区的 GC</h3>\n<p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再使用的类型</strong>。</p>\n<p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p>\n<ul>\n<li>类和接口的全限定名</li>\n<li>字段的名称和描述符</li>\n<li>方法的名称和描述符</li>\n</ul>\n<p>HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p>\n<p>判定一个类型是否属于 “不再被使用的类”，需要同时满足三个条件：</p>\n<ul>\n<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例</li>\n<li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常很难达成</li>\n<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>\n</ul>\n<p>Java 虚拟机被允许堆满足上述三个条件的无用类进行回收，这里说的仅仅是 “被允许”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot 虚拟机提供了  <code>-Xnoclassgc</code>  参数进行控制，还可以使用  <code>-verbose:class</code>  以及  <code>-XX:+TraceClassLoading</code>  、 <code>-XX:+TraceClassUnLoading</code>  查看类加载和卸载信息。</p>\n<p>在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>\n<h1 id=\"参考与感谢\"><a class=\"anchor\" href=\"#参考与感谢\">#</a> 参考与感谢</h1>\n<ul>\n<li>作者：海星</li>\n<li>来源于：JavaKeeper</li>\n</ul>\n<p>原作者参考内容如下</p>\n<p>算是一篇学习笔记，共勉，主要来源：</p>\n<p>《深入理解 Java 虚拟机 第三版》</p>\n<p>宋红康老师的 JVM 教程</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2luZGV4Lmh0bWw=\">https://docs.oracle.com/javase/specs/index.html</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2ljZmh3ZmZnL3AvOTM4MjY3Ny5odG1s\">https://www.cnblogs.com/wicfhwffg/p/9382677.html</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaG9sbGlzY2h1YW5nL3AvMTI1MDE5NTAuaHRtbA==\">https://www.cnblogs.com/hollischuang/p/12501950.html</span></p>\n",
            "tags": [
                "JVM"
            ]
        },
        {
            "id": "https://cecilia.cool/2022/10/10/Java/JVM/JVM(5)-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89/",
            "url": "https://cecilia.cool/2022/10/10/Java/JVM/JVM(5)-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89/",
            "title": "JVM(5)--内存结构之线程私有",
            "date_published": "2022-10-10T11:48:04.000Z",
            "content_html": "<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>JVM 内存结构主要分为 5 个：</p>\n<ul>\n<li>\n<p>线程私有：程序计数器，虚拟机栈，本地方法栈。</p>\n</li>\n<li>\n<p>线程共享：方法区，堆内存。</p>\n</li>\n</ul>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/10/db2c0ead0de42c67.jpg\" alt=\"\" /></p>\n<blockquote>\n<p>因为内容较多，所以分两篇讲完。</p>\n</blockquote>\n<h1 id=\"程序计数器\"><a class=\"anchor\" href=\"#程序计数器\">#</a> 程序计数器</h1>\n<p>程序计数寄存器（<strong>Program Counter Register</strong>），Register 的命名源于 CPU 的寄存器，寄存器存储指令相关的线程信息，CPU 只有把数据装载到寄存器才能够运行。</p>\n<p>这里，并非是广义上所指的物理寄存器，叫程序计数器（或 PC 计数器或指令计数器）会更加贴切，并且也不容易引起一些不必要的误会。<strong>JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟</strong>。</p>\n<blockquote>\n<p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的<strong>行号指示器</strong>。</p>\n</blockquote>\n<h2 id=\"作用\"><a class=\"anchor\" href=\"#作用\">#</a> 作用</h2>\n<p>PC 寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/10/8fd60a5f2a320f84.jpg\" alt=\"\" /></p>\n<p>通过两个问题来理解 PC 寄存器：</p>\n<ul>\n<li><strong>使用 PC 寄存器存储字节码指令地址有什么用呢？为什么使用 PC 寄存器记录当前线程的执行地址呢？</strong></li>\n</ul>\n<p>因为 CPU 需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM 的字节码解释器就需要通过改变 PC 寄存器的值来明确下一条应该执行什么样的字节码指令。</p>\n<ul>\n<li><strong>PC 寄存器为什么会被设定为线程私有的？</strong></li>\n</ul>\n<p>多线程在一个特定的时间段内只会执行其中某一个线程方法，CPU 会不停的做任务切换，这样必然会导致经常中断或恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为<strong>每个线程都分配了一个 PC 寄存器，每个线程都独立计算，不会互相影响</strong>。</p>\n<blockquote>\n<p>总结如下：</p>\n</blockquote>\n<ul>\n<li>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域</li>\n<li>在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致</li>\n<li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。如果当前线程正在执行的是 Java 方法，程序计数器记录的是 JVM 字节码指令地址，如果是执行 native 方法，则是未指定值 (undefined)</li>\n<li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</li>\n<li><strong>它是唯一一个在 JVM 规范中没有规定任何  <code>OutOfMemoryError</code>  情况的区域</strong></li>\n</ul>\n<h1 id=\"虚拟机栈\"><a class=\"anchor\" href=\"#虚拟机栈\">#</a> 虚拟机栈</h1>\n<p>每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧 (Stack Frame），对应着一次次 Java 方法调用，是线程私有的，生命周期和线程一致。</p>\n<blockquote>\n<p>方法调用会入栈，方法递归时，其实就是一个个方法不断入栈。如果一直递归无法结束，就会 <code>StackOverflowError</code> 。</p>\n</blockquote>\n<p><strong>栈中可能出现的异常</strong>：</p>\n<p>Java 虚拟机规范允许 <strong>Java 虚拟机栈的大小是动态的或者是固定不变的</strong></p>\n<ul>\n<li>如果采用<strong>固定大小</strong>的 Java 虚拟机栈，容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 <strong>StackOverflowError</strong> 异常</li>\n<li>如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个<strong> OutOfMemoryError</strong> 异常</li>\n</ul>\n<h2 id=\"存储单位\"><a class=\"anchor\" href=\"#存储单位\">#</a> 存储单位</h2>\n<ul>\n<li>\n<p>栈中的数据都是以<strong>栈帧（Stack Frame）的格式存在</strong></p>\n</li>\n<li>\n<p>在这个线程上正在执行的每个方法都各自有对应的一个栈帧</p>\n</li>\n<li>\n<p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</p>\n</li>\n</ul>\n<h2 id=\"运行原理\"><a class=\"anchor\" href=\"#运行原理\">#</a> 运行原理</h2>\n<ul>\n<li>\n<p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（<strong>栈顶栈帧</strong>）是有效的，这个栈帧被称为<strong>当前栈帧</strong>（Current Frame），与当前栈帧对应的方法就是<strong>当前方法</strong>（Current Method），定义这个方法的类就是<strong>当前类</strong>（Current Class）</p>\n</li>\n<li>\n<p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前栈帧</p>\n</li>\n<li>\n<p>Java 方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出</strong>。</p>\n</li>\n</ul>\n<h2 id=\"栈帧内部结构\"><a class=\"anchor\" href=\"#栈帧内部结构\">#</a> 栈帧内部结构</h2>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zMy5ibXAub3ZoL2ltZ3MvMjAyMi8xMC8xMC8yNWJhMzFhMGJlMDM0MzRmLmpwZw==\">https://s3.bmp.ovh/imgs/2022/10/10/25ba31a0be03434f.jpg</span>&quot;  /&gt;</p>\n<p>上图最右边即是栈帧的内部结构：</p>\n<ul>\n<li>动态链接：指向运行时常量池的方法引用。</li>\n<li>方法返回地址：正常退出或异常退出的地址。</li>\n</ul>\n<h3 id=\"局部变量表\"><a class=\"anchor\" href=\"#局部变量表\">#</a> 局部变量表</h3>\n<p><strong>局部变量表所需要的容量大小是编译期确定下来的</strong>，并保存在方法的 Code 属性的  <code>maximum local variables</code>  数据项中。在方法运行期间是不会改变局部变量表的大小的。</p>\n<blockquote>\n<p>局部变量不仅包括基本数据类型，还包括对象引用。</p>\n</blockquote>\n<p>局部变量表最基本的存储单元是 <code>Slot</code> -- 槽：</p>\n<ul>\n<li>在局部变量表中，32 位以内的类型只占用一个 Slot (包括 returnAddress 类型)，64 位的类型（long 和 double）占用两个连续的 Slot。</li>\n<li>byte、short、char 在存储前被转换为 int，boolean 也被转换为 int，0 表示 false，非 0 表示 true。</li>\n</ul>\n<blockquote>\n<p>所以有时候在方法里面想着节省空间，将 <code>int</code>  在允许的情况下换成 <code>byte</code>  啥的，其实并不节省空间。</p>\n</blockquote>\n<ul>\n<li>\n<p>每个 Slot 对应一个访问索引，范围从 0 到 Slot 最大数量。</p>\n</li>\n<li>\n<p>如果当前帧是由构造方法或实例方法创建的，那么该对象引用 this 将会存放在 index 为 0 的 Slot 处，其余的参数按照参数表顺序继续排列（这里就引出一个问题：静态方法中为什么不可以引用 this，就是因为 this 变量不存在于当前方法的局部变量表中）。</p>\n</li>\n<li>\n<p><strong>栈帧中的局部变量表中的槽位是可以重用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而<strong>达到节省资源的目的</strong>。</p>\n</li>\n<li>\n<p><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong>。</p>\n</li>\n</ul>\n<h3 id=\"操作数栈\"><a class=\"anchor\" href=\"#操作数栈\">#</a> 操作数栈</h3>\n<p><strong>在方法执行过程中，根据字节码指令，往操作数栈中写入数据或提取数据，即入栈（push）、出栈（pop）</strong>。</p>\n<blockquote>\n<p>对，就是操作数的一个数据结构。</p>\n</blockquote>\n<p>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如，执行复制、交换、求和等操作。</p>\n<h3 id=\"动态链接\"><a class=\"anchor\" href=\"#动态链接\">#</a> 动态链接</h3>\n<p>在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为<strong>符号引用</strong>（Symbolic Reference）保存在 Class 文件的常量池中。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/10/05c85fc5e1233e0a.jpg\" alt=\"\" /></p>\n<p><strong>方法调用</strong>：唯一任务著是确定被调用方法的版本（即调用哪一个方法），不涉及方法内部的具体运行过程。Class 文件的编译过程中不包括传统编译器中的连接步骤，一切<strong>方法调用</strong>在 Class 文件里面存储的都是<strong>符号引用</strong>，而不是方法在实际运行时内存布局中的入口地址（<strong>直接引用</strong>）。也就是需要在类加载阶段，甚至到运行期才能确定目标方法的直接引用。</p>\n<ul>\n<li>\n<p><strong>静态链接</strong>：当一个字节码文件被装载进 JVM 内部时，如果被调用的<strong>目标方法在编译期可知</strong>，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</p>\n</li>\n<li>\n<p><strong>动态链接</strong>：如果被调用的方法在编译期无法被确定下来，也就是说，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接</p>\n</li>\n</ul>\n<p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次</strong>。</p>\n<blockquote>\n<p>早期和晚期的区别在于<strong>被调用的目标方法如果在编译期可知，且运行期保持不变时</strong>，即可将这个方法与所属的类型进行绑定。这种方法也叫做非虚方法。</p>\n</blockquote>\n<h3 id=\"方法返回地址\"><a class=\"anchor\" href=\"#方法返回地址\">#</a> 方法返回地址</h3>\n<p>方法退出后都返回到<strong>该方法被调用的位置</strong>。方法正常退出时，调用者的 <strong>PC 计数器的值</strong>作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过<strong>异常表</strong>来确定的，栈帧中一般不会保存这部分信息。</p>\n<p>在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称<strong>异常完成出口</strong>。</p>\n<p>正常完成出口和异常完成出口的区别在于：<strong>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值</strong>。</p>\n<h1 id=\"本地方法栈\"><a class=\"anchor\" href=\"#本地方法栈\">#</a> 本地方法栈</h1>\n<p>一个 Native Method 就是一个 Java 调用非 Java 代码的接口。我们知道的 Unsafe 类就有很多本地方法。</p>\n<p>我们在开发程序时，有时会不可避免地使用本地方法。</p>\n<ul>\n<li>Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用。</li>\n<li>允许线程固定或者可动态扩展的内存大小（抛出异常机制和虚拟机栈一样）。</li>\n<li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区，它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量的内存。</li>\n<li><strong>在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一</strong>。</li>\n</ul>\n<blockquote>\n<p><strong>栈是运行时的单位，而堆是存储的单位</strong>。</p>\n<p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。</p>\n</blockquote>\n<h1 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h1>\n<p><strong>海星的 javakeeper 公众号</strong>整理的文章，写得好就直接用了。</p>\n",
            "tags": [
                "JVM"
            ]
        },
        {
            "id": "https://cecilia.cool/2022/10/10/Java/JVM/JVM(4)-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/",
            "url": "https://cecilia.cool/2022/10/10/Java/JVM/JVM(4)-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/",
            "title": "JVM(4)--类加载器",
            "date_published": "2022-10-10T02:58:09.000Z",
            "content_html": "<blockquote>\n<p>jvm 启动的时候，并不会一次性加载所有的 class 文件，而是根据需要去动态加载。ClassLoader 的具体作用就是将 class 文件加载到 jvm 虚拟机中去，程序就可以正确运行了。普通的<span class=\"exturl\" data-url=\"aHR0cDovL2xpYi5jc2RuLm5ldC9iYXNlL2phdmFzZQ==\"> Java</span> 开发者其实用到的不多，但对于某些框架开发者来说却非常常见。</p>\n</blockquote>\n<h1 id=\"使用\"><a class=\"anchor\" href=\"#使用\">#</a> 使用</h1>\n<blockquote>\n<p>看了很多文章，个人觉得先把如何使用类加载器 -- <code>ClassLoader</code>  弄明白，再来讲解原理效果好得多。</p>\n</blockquote>\n<p><code>class</code>  字节码文件，需要使用类加载器加载字节码，即在 java 中所有类都会通过加载器加载才能运行。下文提到的类似 <code>Bootstrap ClassLoader</code> ， <code>Extension ClassLoader</code>  等，都是 JDK 自带的，正是这些自带的类加载器，我们才能将源码的 class 文件加载字节码。</p>\n<h2 id=\"自定义classloader\"><a class=\"anchor\" href=\"#自定义classloader\">#</a> 自定义 ClassLoader</h2>\n<p>核心方法：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">loadClass</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> className<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 根据名字加载一个类</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">defineClass</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> b<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> off<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 将字节流定义为类</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">findClass</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 查找一个类</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">findLoaderClass</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 在已加载的类中，查找一个类</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">resolveClass</span><span class=\"token punctuation\">(</span>链接指定的<span class=\"token class-name\">Java</span>类<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>比如我们需要动态加载一些东西，或者从 C 盘某个特定的文件夹加载一个 class 文件，又或者从网络上下载 class 主内容然后再进行加载等。分三步搞定：</p>\n<ul>\n<li>编写一个类继承 <code>ClassLoader</code>  抽象类。</li>\n<li>重写 <code>findClass()</code>  方法。</li>\n<li>在 <code>findClass()</code>  方法中调用 <code>defineClass()</code>  方法即可实现自定义 <code>ClassLoader</code> 。</li>\n</ul>\n<p>我们先写一个类：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> test <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">method</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token string\">\"hello,world\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">// 编译得到 class 文件 -> 写程序将 class 文件转换为字节流</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">// InputStream fis = new FileInputStream(\"test.class\");</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">// byte[] bytes = IOUtils.readFully(fis, -1, false);</span></pre></td></tr></table></figure><p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/10/67d06fbed9be1513.jpg\" alt=\"\" /></p>\n<p>自定义加载器类：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> <span class=\"token constant\">JVM</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">sun<span class=\"token punctuation\">.</span>misc<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">IOUtils</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">FileInputStream</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">IOException</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">InputStream</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>reflect<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">InvocationTargetException</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>reflect<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Method</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ClassLoaderTest</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">ClassLoader</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">InputStream</span> fis<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> bytes<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">String</span> testClassname <span class=\"token operator\">=</span> <span class=\"token string\">\"JVM.Test\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    \t\t<span class=\"token class-name\">ClassNotFoundException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">InstantiationException</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>            <span class=\"token class-name\">IllegalAccessException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">NoSuchMethodException</span><span class=\"token punctuation\">,</span> </pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    \t\t<span class=\"token class-name\">InvocationTargetException</span> </pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        fis <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileInputStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"src/JVM/Test.class\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        bytes <span class=\"token operator\">=</span> <span class=\"token class-name\">IOUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">readFully</span><span class=\"token punctuation\">(</span>fis<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token comment\">// 创建加载器</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token class-name\">ClassLoaderTest</span> classloadertest <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ClassLoaderTest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token comment\">// 使用我们自定义的类去加载 testClassname</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        <span class=\"token class-name\">Class</span> aClass <span class=\"token operator\">=</span> classloadertest<span class=\"token punctuation\">.</span><span class=\"token function\">loadClass</span><span class=\"token punctuation\">(</span>testClassname<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        <span class=\"token comment\">// 反射创建 test 类对象</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        <span class=\"token class-name\">Object</span> o <span class=\"token operator\">=</span> aClass<span class=\"token punctuation\">.</span><span class=\"token function\">newInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>        <span class=\"token comment\">// 反射获取 method 方法</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>        <span class=\"token class-name\">Method</span> method <span class=\"token operator\">=</span> o<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getMethod</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"method\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>        <span class=\"token comment\">// 反射去调用执行 method 方法</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>        <span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span> method<span class=\"token punctuation\">.</span><span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>    <span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>    <span class=\"token keyword\">protected</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">findClass</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">ClassNotFoundException</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>        <span class=\"token comment\">// 只处理 JVM.Test 类</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>testClassname<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>            <span class=\"token comment\">// 将一个字节流定义为一个类。</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>            <span class=\"token comment\">// 其实这个名字可以随便取</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>            <span class=\"token keyword\">return</span> <span class=\"token function\">defineClass</span><span class=\"token punctuation\">(</span>testClassname<span class=\"token punctuation\">,</span> bytes<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> bytes<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">findClass</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/10/b6c86511a9b493e8.jpg\" alt=\"\" /></p>\n<h1 id=\"类加载器层次\"><a class=\"anchor\" href=\"#类加载器层次\">#</a> 类加载器层次</h1>\n<p>站在开发人员角度：</p>\n<ul>\n<li><code>Bootstrap ClassLoader</code> ：启动类加载器，无法被 Java 程序直接引用，负责加载存放在 JDK\\jre\\lib (JDK 代表 JDK 的安装目录，下同) 下，或被 - Xbootclasspath 参数指定的路径中的，并且能被虚拟机识别的类库 (如 rt.jar，所有的 java.* 开头的类均被 Bootstrap ClassLoader 加载)。</li>\n<li><code>Extension ClassLoader</code> ：扩展类加载器，负责加载 JDK\\jre\\lib\\ext 目录中，或者由 java.ext.dirs 系统变量指定的路径中的所有类库 (如 javax.* 开头的类)，开发者可以直接使用扩展类加载器。</li>\n<li><code>Application ClassLoader</code> ：负责加载用户类路径 (ClassPath) 所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>\n</ul>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zMy5ibXAub3ZoL2ltZ3MvMjAyMi8xMC8xMC83MTViMzllNmUyZjM0NTAwLmpwZw==\">https://s3.bmp.ovh/imgs/2022/10/10/715b39e6e2f34500.jpg</span>&quot; style=&quot;zoom:80%;&quot; /&gt;</p>\n<blockquote>\n<p>还可以加入自定义的类加载器，因为 JVM 自带的 ClassLoader 只能从本地文件系统加载标准的 <code>java.class</code>  文件。</p>\n</blockquote>\n<p>看一个小例子：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> <span class=\"token namespace\">com<span class=\"token punctuation\">.</span>pdai<span class=\"token punctuation\">.</span>jvm<span class=\"token punctuation\">.</span>classloader</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ClassLoaderTest</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>     <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token class-name\">ClassLoader</span> loader <span class=\"token operator\">=</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getContextClassLoader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>loader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>loader<span class=\"token punctuation\">.</span><span class=\"token function\">getParent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>loader<span class=\"token punctuation\">.</span><span class=\"token function\">getParent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getParent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\">// sun.misc.Launcher$AppClassLoader@64fef26a</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\">// sun.misc.Launcher$ExtClassLoader@1ddd40f3</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\">// null</span></pre></td></tr></table></figure><p>并没有获取到 <code>ExtClassLoader</code>  的父 Loader，原因是 <code>BootstrapLoader</code>  (引导类加载器) 是用 C 语言实现的，找不到一个确定的返回父 Loader 的方式，于是就返回 <code>null</code> 。</p>\n<h1 id=\"类的加载\"><a class=\"anchor\" href=\"#类的加载\">#</a> 类的加载</h1>\n<p>类加载有三种方式：</p>\n<ul>\n<li>启动应用时由 JVM 初始化加载</li>\n<li>通过 <code>Class.forName()</code>  方法动态加载</li>\n<li>通过 <code>Class.loader.loadClass()</code>  方法动态加载。</li>\n</ul>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> <span class=\"token namespace\">com</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">IOException</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">ClassNotFoundException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">IOException</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        </pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"使用loader.loadClass()：\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token class-name\">ClassLoader</span> loader <span class=\"token operator\">=</span> <span class=\"token class-name\">Main</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">.</span><span class=\"token function\">getClassLoader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        loader<span class=\"token punctuation\">.</span><span class=\"token function\">loadClass</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"com.Test\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t\t</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token comment\">// 默认执行初始化块</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"使用Class.forName()：\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token class-name\">Class</span><span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"com.Test\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token comment\">// 指定 ClassLoader，初始化不执行静态块</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"使用Class.forName(name,false,loader)：\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token class-name\">Class</span><span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"com.Test\"</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> loader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token keyword\">static</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"静态初始化块执行了！\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token comment\">// 输出结果：</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token comment\">// 使用 loader.loadClass ()：</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token comment\">// 使用 Class.forName ()：</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token comment\">// 静态初始化块执行了！</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre><span class=\"token comment\">// 使用 Class.forName (name,false,loader)：</span></pre></td></tr></table></figure><blockquote>\n<p><code>Class.forName()</code>  和 <code>ClassLoader.loadClass()</code>  区别？</p>\n</blockquote>\n<ul>\n<li>\n<p>Class.forName (): 将类的.class 文件加载到 jvm 中之外，还会对类进行解释，执行类中的 static 块；</p>\n</li>\n<li>\n<p><code>ClassLoader.loadClass()</code> ：只干一件事情，就是将.class 文件加载到 jvm 中，不会执行 static 中的内容，只有在 <code>newInstance</code>  才会去执行 static 块。</p>\n</li>\n<li>\n<p><code>Class.forName(name,initialize,loader)</code> ：可控制是否加载 <code>static</code>  块。</p>\n</li>\n</ul>\n<h1 id=\"jvm类加载机制\"><a class=\"anchor\" href=\"#jvm类加载机制\">#</a> JVM 类加载机制</h1>\n<p><strong>全盘负责</strong>，当一个类加载器负责加载某个 Class 时，该 Class 所依赖的和引用的其他 Class 也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p>\n<p><strong>父类委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p>\n<p><strong>缓存机制</strong>，缓存机制将会保证所有加载过的 Class 都会被缓存，当程序中需要使用某个 Class 时，类加载器先从缓存区寻找该 Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成 Class 对象，存入缓存区。这就是为什么修改了 Class 后，必须重启 JVM，程序的修改才会生效</p>\n<p><strong>双亲委派机制</strong> 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>\n<h2 id=\"双亲委派\"><a class=\"anchor\" href=\"#双亲委派\">#</a> 双亲委派</h2>\n<ol>\n<li>当 <code>AppClassLoader</code>  加载一个 class 时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器 <code>ExtClassLoader</code>  去完成。</li>\n<li>当 <code>ExtClassLoader</code>  加载一个 class 时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给 <code>BootStrapClassLoader</code>  去完成。</li>\n<li>如果 <code>BootStrapClassLoader</code>  加载失败 (例如在 <code>$JAVA_HOME/jre/lib</code>  里未查找到该 class)，会使用 <code>ExtClassLoader</code>  来尝试加载；</li>\n<li>若 <code>ExtClassLoader</code>  也加载失败，则会使用 <code>AppClassLoader</code>  来加载，如果 <code>AppClassLoader</code>  也加载失败，则会报出异常 <code>ClassNotFoundException</code> 。</li>\n</ol>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">loadClass</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span><span class=\"token keyword\">throws</span> <span class=\"token class-name\">ClassNotFoundException</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>            <span class=\"token keyword\">return</span> <span class=\"token function\">loadClass</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">protected</span> <span class=\"token keyword\">synchronized</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">loadClass</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> resolve<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    \t\t\t\t\t\t\t\t  <span class=\"token keyword\">throws</span> <span class=\"token class-name\">ClassNotFoundException</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">// 首先判断该类型是否已经被加载</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token class-name\">Class</span> c <span class=\"token operator\">=</span> <span class=\"token function\">findLoadedClass</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token comment\">// 如果没有被加载，就委托给父类加载或者委派给启动类加载器加载</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>parent <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>                <span class=\"token comment\">// 如果存在父类加载器，就委派给父类加载器加载</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>                c <span class=\"token operator\">=</span> parent<span class=\"token punctuation\">.</span><span class=\"token function\">loadClass</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>                <span class=\"token comment\">// 如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>                <span class=\"token comment\">//native Class findBootstrapClass(String name)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>                c <span class=\"token operator\">=</span> <span class=\"token function\">findBootstrapClass0</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassNotFoundException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>            <span class=\"token comment\">// 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>            c <span class=\"token operator\">=</span> <span class=\"token function\">findClass</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token function\">resolveClass</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token keyword\">return</span> c<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h1 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h1>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbmljZTBlMy9wLzEzNzE5OTAzLmh0bWwjMHgwMi0tY2xhc3Nsb2FkZXIlRTclQjElQkIlRTUlOEElQTAlRTglQkQlQkQlRTUlOTklQTg=\">Java 安全之 ClassLoader 类加载器</span>.</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueXVxdWUuY29tL3Fpbmdrb25neGlhZ3VhbmcvamF2YXNlL2tlb3BtZyM5OTk1ZmZjYw==\">https://www.yuque.com/qingkongxiaguang/javase/keopmg#9995ffcc</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wZGFpLnRlY2gvbWQvamF2YS9qdm0vamF2YS1qdm0tY2xhc3Nsb2FkLmh0bQ==\">https://pdai.tech/md/java/jvm/java-jvm-classload.htm</span></p>\n<p>一个小例子，可以看看：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZXNpb24uY29tL2FydGljbGUvMjE3ODMwODc5OC8=\">https://www.freesion.com/article/2178308798/</span></p>\n<p>三大类加载器的源码解读：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmJzbWF4LmNvbS9BL24yZDliTzB3ekQv\">https://www.bbsmax.com/A/n2d9bO0wzD/</span></p>\n</blockquote>\n",
            "tags": [
                "JVM"
            ]
        },
        {
            "id": "https://cecilia.cool/2022/10/09/Java/JVM/JVM(3)-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/",
            "url": "https://cecilia.cool/2022/10/09/Java/JVM/JVM(3)-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/",
            "title": "JVM(3)--类加载机制",
            "date_published": "2022-10-09T04:39:46.000Z",
            "content_html": "<h1 id=\"类的生命周期\"><a class=\"anchor\" href=\"#类的生命周期\">#</a> 类的生命周期</h1>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/09/167570c48203f9c9.jpg\" alt=\"\" /></p>\n<p><code>加载</code> 、 <code>验证</code> 、 <code>准备</code> 和 <code>初始化</code> 这四个阶段发生的顺序是确定的，而 <code>解析</code> 阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持 Java 语言的运行时绑定 (也成为动态绑定或晚期绑定)。</p>\n<blockquote>\n<p>这些阶段知识按顺序开始，并不是按顺序结束，这些阶段往往互相交叉混合进行，再一个阶段执行过程中调用或激活另一个阶段。</p>\n</blockquote>\n<h1 id=\"类的加载\"><a class=\"anchor\" href=\"#类的加载\">#</a> 类的加载</h1>\n<p>首先介绍几个概念：</p>\n<ul>\n<li>方法区：JVM 实例内部，类型信息被存储在方法区的内存逻辑区中。类型信息是由类加载时从类文件中提取出来的。方法区又叫做静态区，被所有线程共享，方法区包含所有 <code>class</code>  和 <code>static</code> 。静态<strong>常量</strong>存放在方法区的常量区中，这之后会讲解。</li>\n</ul>\n<p>加载阶段虚拟机需要完成：</p>\n<ul>\n<li>通过类的全限定名（从方法区）来获取其定义的二进制字节流。</li>\n<li>字节流代表的静态存储结构转化为方法区的运行时数据结构。</li>\n<li>在 Java 堆中生成代表这个类的 <code>java.lang.Class</code>  对象，作为对方法区中这些数据的访问入口。</li>\n</ul>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/09/842b5cd01faa5b42.jpg\" alt=\"\" /></p>\n<p>类加载器不需要等待某个类首次主动使用时在加载，JVM 允许预料某个类需要使用时主动加载。在<strong>预加载</strong>中遇到.class 文件缺失或存在错误，类加载器必须在程序<strong>首次主动使用</strong>该类时才会报错误 --LinkageError。</p>\n<h1 id=\"连接\"><a class=\"anchor\" href=\"#连接\">#</a> 连接</h1>\n<h2 id=\"验证\"><a class=\"anchor\" href=\"#验证\">#</a> 验证</h2>\n<p>确保被加载的类的正确性，也就是 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全。</p>\n<blockquote>\n<p>如果使用纯 Java 代码编写的类，编译出来的 class 文件是相对安全的。但是.class 文件并不只是由 Java 源码编译而来，哪怕用键盘输入 01 并将文件后缀改为.class 都可以，所以验证非常有必要。</p>\n</blockquote>\n<p>验证阶段的检验动作：</p>\n<ul>\n<li><strong>文件格式验证</strong>：验证字节流是否符合 Class 文件格式的规范。（魔数，主次版本，常量的 tag 标志等）</li>\n<li><strong>元数据验证</strong>：对字节码描述的信息进行语义分析。（该类是否继承不可继承的 final 类，是否覆盖父类的 final 字段等）</li>\n<li><strong>字节码验证</strong>：通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。</li>\n<li><strong>符号引用验证</strong>：确保解析动作能正确执行。</li>\n</ul>\n<blockquote>\n<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 <code>-Xverifynone</code>  参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>\n</blockquote>\n<h2 id=\"准备\"><a class=\"anchor\" href=\"#准备\">#</a> 准备</h2>\n<p>正式为类变量分配内存并设置类变量<strong>初始值</strong>的阶段，<strong>这些内存都将在方法区中分配</strong>。</p>\n<ul>\n<li>内存分配的仅包括静态变量，<strong>不包括</strong>实例变量。<strong>实例变量是在对象实例化时随着对象一块分配在 Java 堆中</strong>。</li>\n<li>初始值： <code>0,0L,null,false</code>  等。</li>\n</ul>\n<p>比如某个类由以下语句：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> value <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在准备阶段只会赋值 0，将 <code>value</code>  赋值为 3 的 <code>put static</code>  指令存放于 <code>&lt;clinit()&gt;</code>  方法中。所以初始化阶段才会赋值为 3。</p>\n<p><code>&lt;clinit&gt;</code>  方法是类加载的<strong>初始化</strong>过程中，编译器按语句在源文件中出现的顺序，依次自动收集类中的静态变量的赋值动作和静态代码块中的语句合并产生 <code>&lt;clinit&gt;</code>  方法。并且  <code>&lt;clinit&gt;()</code>  不需要显式调用父类（接口除外，接口不需要调用父接口的初始化方法，只有使用到父接口中的静态变量时才需要调用）的初始化方法  <code>&lt;clinit&gt;()</code> ，虚拟机会保证在子类的  <code>&lt;clinit&gt;()</code>  方法执行之前，父类的  <code>&lt;clinit&gt;()</code>  方法已经执行完毕。</p>\n<p>随便写个类：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> a <span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>编译后通过 <code>jclasslib</code>  插件查看：</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/09/f122fdb91f027a3f.jpg\" alt=\"\" /></p>\n<blockquote>\n<p>当 int 取值 -128~127 时，JVM 采用  <code>bipush</code>  指令将常量压入栈中。</p>\n</blockquote>\n<p>还需要注意几点：</p>\n<ul>\n<li>对于同时被 <code>static</code>  和 <code>final</code>  修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；只被 final 修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值。</li>\n</ul>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> tmp<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>此时编译会报错：<strong>java: 变量 tmp 未在默认构造器中初始化</strong>。</p>\n<p>必须在构造器中将 <code>final</code>  变量初始化：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token class-name\">Test</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>k <span class=\"token operator\">=</span> k<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><ul>\n<li>同时被 <code>static</code>  和 <code>final</code>  修饰的常量，类会为它生成 <code>ConstantValue</code>  属性，在准备阶段 JVM 就会根据 <code>ConstantValue</code>  的设置将变量赋值。</li>\n</ul>\n<h2 id=\"解析\"><a class=\"anchor\" href=\"#解析\">#</a> 解析</h2>\n<p>JVM 将常量池内的符号引用替换为直接引用的过程，解析动作主要针对 <code>类</code> 或 <code>接口</code> 、 <code>字段</code> 、 <code>类方法</code> 、 <code>接口方法</code> 、 <code>方法类型</code> 、 <code>方法句柄</code> 和 <code>调用点</code> 限定符 7 类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p>\n<p><code>直接引用</code> 就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>\n<h2 id=\"初始化\"><a class=\"anchor\" href=\"#初始化\">#</a> 初始化</h2>\n<p>初始化，为类的静态变量赋予正确的初始值，JVM 负责对类进行初始化，主要对类变量进行初始化。</p>\n<blockquote>\n<p>也就是 <code>&lt;clinit&gt;</code>  方法。</p>\n</blockquote>\n<p><strong>类初始化时机</strong>：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种:</p>\n<ul>\n<li>\n<p>创建类的实例，也就是 new 的方式</p>\n</li>\n<li>\n<p>访问某个类或接口的静态变量，或者对该静态变量赋值</p>\n</li>\n<li>\n<p>调用类的静态方法（也经常和第二点合并在一起）</p>\n</li>\n<li>\n<p>反射 (如 Class.forName (&quot;com.pdai.jvm.Test&quot;))</p>\n</li>\n<li>\n<p>初始化某个类的子类，则其父类也会被初始化</p>\n</li>\n<li>\n<p>Java 虚拟机启动时被标明为启动类的类 (Java Test)，直接使用 java.exe 命令来运行某个主类</p>\n</li>\n</ul>\n<p>只有这六种是主动使用，其他的都是被动使用，被动使用不会初始化。被动引用的例子可以看这篇<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5nbGlhbmd6aS9hcnRpY2xlL2RldGFpbHMvNTEzMTkwMzM=\">博客</span>。</p>\n<h3 id=\"注意\"><a class=\"anchor\" href=\"#注意\">#</a> 注意</h3>\n<p>关于访问类的静态变量，一定要注意这里写的是<strong>变量，变量，变量</strong>（重要的是强调三遍）。 <code>static final int a = 10;</code>  是<strong>常量，常量，常量</strong>。访问 <code>a</code>  不会让类被加载。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Test</span><span class=\"token punctuation\">.</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>写一下 <code>Test</code>  类：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">static</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"我被初始化了！\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token string\">\"都看到这里了，不给个三连+关注吗？\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>先编译一下，看一下 <code>Main.class</code>  的内容：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"都看到这里了，不给个三连+关注吗？\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>字节码文件中，将 <code>Test.str</code>  直接替换成了字符串，那么执行时和 <code>Test</code>  也就没有任何关系了，自然也不会实例化 <code>Test</code> 。</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/09/28f0a77b42aeafb5.jpg\" alt=\"\" /></p>\n<blockquote>\n<p>当 int 取值 -2147483648~2147483647 时，JVM 采用  <code>ldc</code>  指令将常量压入栈中。</p>\n</blockquote>\n<h2 id=\"卸载\"><a class=\"anchor\" href=\"#卸载\">#</a> 卸载</h2>\n<p>JVM 将结束生命周期的几种情况：</p>\n<ul>\n<li>执行了 System.exit () 方法</li>\n<li>程序正常执行结束</li>\n<li>程序在执行过程中遇到了异常或错误而异常终止</li>\n<li>由于操作系统出现错误而导致 Java 虚拟机进程终止</li>\n</ul>\n<h1 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h1>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5nbGlhbmd6aS9hcnRpY2xlL2RldGFpbHMvNTEzMTkwMzM=\">https://blog.csdn.net/zhangliangzi/article/details/51319033</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wZGFpLnRlY2gvbWQvamF2YS9qdm0vamF2YS1qdm0tY2xhc3Nsb2FkLmh0bWw=\">https://pdai.tech/md/java/jvm/java-jvm-classload.html</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueXVxdWUuY29tL3Fpbmdrb25neGlhZ3VhbmcvamF2YXNlL2tlb3BtZyNkZGFmYzg3Ng==\">https://www.yuque.com/qingkongxiaguang/javase/keopmg#ddafc876</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2FuZ2d1b25pbmcvcC82MTA5Mzc3Lmh0bWw=\">https://www.cnblogs.com/wangguoning/p/6109377.html</span></p>\n<p>《深入理解 Java 虚拟机》第三版</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY3p3YmlnL3AvMTExNTU1NTUuaHRtbA==\">https://www.cnblogs.com/czwbig/p/11155555.html</span></p>\n</blockquote>\n",
            "tags": [
                "JVM"
            ]
        },
        {
            "id": "https://cecilia.cool/2022/10/08/Java/JVM/JVM(2)-%E5%AD%97%E8%8A%82%E7%A0%81%E5%A2%9E%E5%BC%BA/",
            "url": "https://cecilia.cool/2022/10/08/Java/JVM/JVM(2)-%E5%AD%97%E8%8A%82%E7%A0%81%E5%A2%9E%E5%BC%BA/",
            "title": "JVM(2)--字节码增强",
            "date_published": "2022-10-08T04:56:20.000Z",
            "content_html": "<h1 id=\"jvm基础-字节码增强\"><a class=\"anchor\" href=\"#jvm基础-字节码增强\">#</a> JVM 基础 - 字节码增强</h1>\n<blockquote>\n<p>字节码增强技术就是一类对现有字节码进行修改或者动态生成全新字节码文件的技术。</p>\n</blockquote>\n<h2 id=\"asm\"><a class=\"anchor\" href=\"#asm\">#</a> ASM</h2>\n<p>ASM 可以直接生成 <code>.class</code>  字节码文件，也可以在类被加载入 JVM 之前动态修改类行为。ASM 框架是 JDK 内部自带的，最基本的就是通过 <code>ClassWriter</code>  对象编辑类的字节码文件。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token class-name\">ClassWriter</span> writer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ClassWriter</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassWriter</span><span class=\"token punctuation\">.</span><span class=\"token constant\">COMPUTE_MAXS</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><blockquote>\n<p>在学习 ASM 前，请先学习一下<a href=\"https://cecilia.cool/2022/10/08/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%AE%BF%E9%97%AE%E8%80%85/\">访问者模式</a>。</p>\n</blockquote>\n<p>字节码文件的结构是由 JVM 固定的，适合利用访问者模式对字节码文件进行修改。</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/08/b57b44956364c1b6.jpg\" alt=\"\" /></p>\n<h3 id=\"核心api\"><a class=\"anchor\" href=\"#核心api\">#</a> 核心 API</h3>\n<ul>\n<li>\n<p><code>ClassReader</code> ：用于读取已经编译好的.class 文件。</p>\n</li>\n<li>\n<p><code>ClassWriter</code> ：用于重新构建编译后的类，如修改类名、属性以及方法，也可以生成新的类的字节码文件。</p>\n</li>\n<li>\n<p>各种 <code>Visitor</code>  类：如上所述，CoreAPI 根据字节码从上到下依次处理，对于字节码文件中不同的区域有不同的 Visitor，比如用于访问方法的 <code>MethodVisitor</code> 、用于访问类变量的 <code>FieldVisitor</code> 、用于访问注解的 <code>AnnotationVisitor</code>  等。</p>\n</li>\n</ul>\n<blockquote>\n<p>API 文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29sLm9zY2hpbmEubmV0L2FwaWRvY3MvYXBpZG9jP2FwaT1hc20=\">https://tool.oschina.net/apidocs/apidoc?api=asm</span></p>\n</blockquote>\n<h2 id=\"方法名和描述符\"><a class=\"anchor\" href=\"#方法名和描述符\">#</a> 方法名和描述符</h2>\n<p>这里补充一下类文件中方法名和描述符的表示。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> m<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">inc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token keyword\">return</span> m <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>使用 <code>jclasslib</code>  插件查看一下：</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/08/d03410a93bae253c.jpg\" alt=\"\" /></p>\n<p>可以看到，方法名在字节码文件中被 <code>&lt;&gt;</code>  包围，描述符其实就是返回值和参数列表，也都被 <code>&lt;&gt;</code>  包围。 <code>&lt;()I&gt;</code>  表示：</p>\n<ul>\n<li>括号里的是参数，后面的是返回值。</li>\n<li><code>I</code>  表示 <code>int</code> ，也就是说，该方法返回 <code>int</code> ，如果是 <code>void</code> ，这里就会是 <code>V</code> 。</li>\n</ul>\n<p>这样我们就固定了方法的方法名和参数列表以及返回值。从图中可以看到， <code>inc</code>  方法上面还有个 <code>&lt;init&gt;</code>  方法，那就是构造方法。</p>\n<p>如果方法参数中加入了对象：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">inc</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> s<span class=\"token punctuation\">,</span><span class=\"token class-name\">Object</span> o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        <span class=\"token keyword\">return</span> m <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// 描述符：&lt;(Ljava/lang/String;Ljava/lang/Object;) I></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">inc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">return</span> m<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">// 描述符：&lt;([[C) I></span></pre></td></tr></table></figure><p><code>L</code>  开头表示是一个对象，参数之间要用 <code>;</code>  隔开。详细的读者可以自己写一些方法来看一下具体的效果。</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/08/5d052fc53aef3cb4.jpg\" alt=\"\" /></p>\n<h2 id=\"基本使用\"><a class=\"anchor\" href=\"#基本使用\">#</a> 基本使用</h2>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">ClassWriter</span> writer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ClassWriter</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassWriter</span><span class=\"token punctuation\">.</span><span class=\"token constant\">COMPUTE_MAXS</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>构造函数里的参数与操作数栈和局部临时变量表有关，不想琢磨，用 <code>COMPUTE_MAXS</code>  即可。</p>\n<p>首先指定一下类的基本信息：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token class-name\">ClassWriter</span> writer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ClassWriter</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassWriter</span><span class=\"token punctuation\">.</span><span class=\"token constant\">COMPUTE_MAXS</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token comment\">// 因为这里用到的常量比较多，所以说直接一次性静态导入：</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token comment\">// import static jdk.internal.org.objectweb.asm.Opcodes.*;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        writer<span class=\"token punctuation\">.</span><span class=\"token function\">visit</span><span class=\"token punctuation\">(</span><span class=\"token constant\">V1_8</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">ACC_PUBLIC</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"com/JVM/Main\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>                     <span class=\"token string\">\"java/lang/Object\"</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token comment\">// 第三个参数，需要根据自己的 Main 路径填写</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>设定的基本信息依次是：版本 --Java8，修饰符 -- <code>ACC_PUBLIC</code> ，类名 -- 要携带包名，标签 -- <code>null</code> ，父类 -- <code>Object</code> 。</p>\n<p>将其保存，然后写入到自己生成的字节码文件当中：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token class-name\">ClassWriter</span> writer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ClassWriter</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassWriter</span><span class=\"token punctuation\">.</span><span class=\"token constant\">COMPUTE_MAXS</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        writer<span class=\"token punctuation\">.</span><span class=\"token function\">visit</span><span class=\"token punctuation\">(</span><span class=\"token constant\">V1_8</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">ACC_PUBLIC</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"com/test/Main\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>                     <span class=\"token string\">\"java/lang/Object\"</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token comment\">// 调用 visitEnd 表示结束编辑</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        writer<span class=\"token punctuation\">.</span><span class=\"token function\">visitEnd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token keyword\">try</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">FileOutputStream</span> stream <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileOutputStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./Main.class\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            stream<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>writer<span class=\"token punctuation\">.</span><span class=\"token function\">toByteArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"11\"></td><td><pre>            <span class=\"token comment\">// 直接通过 ClassWriter 将字节码文件转换为 byte 数组，并保存到根目录下</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>结果为：</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/08/f0c63a80acdf6c29.jpg\" alt=\"\" /></p>\n<p>从 class 文件可知， <code>Main.class</code>  没有构造方法，所以可以添加一个</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 通过 visitMethod 方法可以添加一个新的方法</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// 放在 writer.visitEnd (); 前面即可</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>writer<span class=\"token punctuation\">.</span><span class=\"token function\">visitMethod</span><span class=\"token punctuation\">(</span><span class=\"token constant\">ACC_PUBLIC</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"&lt;init>\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"()V\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>再次编译，发现存在构造方法，之前讲了字节码文件中的方法名和描述符，读者可以自行修改描述符感受一下效果。</p>\n<p>但是 <code>Main</code>  继承了 <code>Object</code>  类，所以在子类构造方法中应该调用父类的构造方法。也就是说，沃恩需要在方法中添加父类构造方法调用指令：</p>\n<pre><code class=\"language-Plain\">public com.test.Main();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1             // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V\n         4: return\n      LineNumberTable:\n        line 11: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       5     0  this   Lcom/test/Main;\n</code></pre>\n<p>所以我们开始访问代码（ <code>visitCode()</code> )，也就是对方法进行详细 i 编辑：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 通过 MethodVisitor 接收返回值，进行进一步操作</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token class-name\">MethodVisitor</span> visitor <span class=\"token operator\">=</span> writer<span class=\"token punctuation\">.</span><span class=\"token function\">visitMethod</span><span class=\"token punctuation\">(</span><span class=\"token constant\">ACC_PUBLIC</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"&lt;init>\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"()V\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// 开始编辑代码</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>visitor<span class=\"token punctuation\">.</span><span class=\"token function\">visitCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">// Label 用于存储行号，当前代码写到哪行了，l1 得到的就是多少行</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token class-name\">Label</span> l1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Label</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">// 添加源代码行数对应表 (字节码中的 LineNumberTable)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>visitor<span class=\"token punctuation\">.</span><span class=\"token function\">visitListNumber</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">,</span>l1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\">// 不同类型的指令需要不同方法调用</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>visitor<span class=\"token punctuation\">.</span><span class=\"token function\">visitVarInsn</span><span class=\"token punctuation\">(</span><span class=\"token constant\">ALOAD</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>visitor<span class=\"token punctuation\">.</span><span class=\"token function\">visitMethodInsn</span><span class=\"token punctuation\">(</span><span class=\"token constant\">INVOKESPECIAL</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"java/lang/Object\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"&lt;init>\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"()V\"</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>visitor<span class=\"token punctuation\">.</span><span class=\"token function\">visitInsn</span><span class=\"token punctuation\">(</span><span class=\"token constant\">RETURN</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token class-name\">Label</span> l2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Label</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>visitor<span class=\"token punctuation\">.</span><span class=\"token function\">visitLabel</span><span class=\"token punctuation\">(</span>l2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token comment\">// 添加本地变量表 (字节码中的 LocalVariableTable)，这里是 this 关键字</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>visitor<span class=\"token punctuation\">.</span><span class=\"token function\">visiLocalVariable</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"this\"</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"Lcom/JVM/Main;\"</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>l1<span class=\"token punctuation\">,</span> l2<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token comment\">// 最后设定最大栈深度和本地变量数</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>visitor<span class=\"token punctuation\">.</span><span class=\"token function\">visitMaxs</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token comment\">// 结束编辑</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>visitor<span class=\"token punctuation\">.</span><span class=\"token function\">visitEnd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>至此构造方法编辑完成，可以看到是非常麻烦的一件事，其实哪怕只是完成一个</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>都是非常复杂的一件事：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 开始安排 main 方法</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token class-name\">MethodVisitor</span> v2 <span class=\"token operator\">=</span> writer<span class=\"token punctuation\">.</span><span class=\"token function\">visitMethod</span><span class=\"token punctuation\">(</span><span class=\"token constant\">ACC_PUBLIC</span> <span class=\"token operator\">|</span> <span class=\"token constant\">ACC_STATIC</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"main\"</span><span class=\"token punctuation\">,</span> </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>                                      <span class=\"token string\">\"([Ljava/lang/String;)V\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>v2<span class=\"token punctuation\">.</span><span class=\"token function\">visitCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// 记录起始行信息</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token class-name\">Label</span> l3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Label</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>v2<span class=\"token punctuation\">.</span><span class=\"token function\">visitLabel</span><span class=\"token punctuation\">(</span>l3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>v2<span class=\"token punctuation\">.</span><span class=\"token function\">visitLineNumber</span><span class=\"token punctuation\">(</span><span class=\"token number\">13</span><span class=\"token punctuation\">,</span> l3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">// 首先是 int a = 10 的操作，执行指令依次为：</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\">//bipush 10     将 10 推向操作数栈顶</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\">//istore_1      将操作数栈顶元素保存到 1 号本地变量 a 中</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>v2<span class=\"token punctuation\">.</span><span class=\"token function\">visitIntInsn</span><span class=\"token punctuation\">(</span><span class=\"token constant\">BIPUSH</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>v2<span class=\"token punctuation\">.</span><span class=\"token function\">visitVarInsn</span><span class=\"token punctuation\">(</span><span class=\"token constant\">ISTORE</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token class-name\">Label</span> l4 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Label</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>v2<span class=\"token punctuation\">.</span><span class=\"token function\">visitLabel</span><span class=\"token punctuation\">(</span>l4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token comment\">// 记录一下行信息</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>v2<span class=\"token punctuation\">.</span><span class=\"token function\">visitLineNumber</span><span class=\"token punctuation\">(</span><span class=\"token number\">14</span><span class=\"token punctuation\">,</span> l4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token comment\">// 这里是获取 System 类中的 out 静态变量（PrintStream 接口），用于打印</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>v2<span class=\"token punctuation\">.</span><span class=\"token function\">visitFieldInsn</span><span class=\"token punctuation\">(</span><span class=\"token constant\">GETSTATIC</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"java/lang/System\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"out\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Ljava/io/PrintStream;\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token comment\">// 把 a 的值取出来</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>v2<span class=\"token punctuation\">.</span><span class=\"token function\">visitVarInsn</span><span class=\"token punctuation\">(</span><span class=\"token constant\">ILOAD</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token comment\">// 调用接口中的抽象方法 println</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>v2<span class=\"token punctuation\">.</span><span class=\"token function\">visitMethodInsn</span><span class=\"token punctuation\">(</span><span class=\"token constant\">INVOKEVIRTUAL</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"java/io/PrintStream\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"println\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"(I)V\"</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token comment\">// 再次记录行信息</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token class-name\">Label</span> l6 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Label</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>v2<span class=\"token punctuation\">.</span><span class=\"token function\">visitLabel</span><span class=\"token punctuation\">(</span>l6<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>v2<span class=\"token punctuation\">.</span><span class=\"token function\">visitLineNumber</span><span class=\"token punctuation\">(</span><span class=\"token number\">15</span><span class=\"token punctuation\">,</span> l6<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>v2<span class=\"token punctuation\">.</span><span class=\"token function\">visitInsn</span><span class=\"token punctuation\">(</span><span class=\"token constant\">RETURN</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token class-name\">Label</span> l7 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Label</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>v2<span class=\"token punctuation\">.</span><span class=\"token function\">visitLabel</span><span class=\"token punctuation\">(</span>l7<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre></pre></td></tr><tr><td data-num=\"36\"></td><td><pre><span class=\"token comment\">// 最后是本地变量表中的各个变量</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>v2<span class=\"token punctuation\">.</span><span class=\"token function\">visitLocalVariable</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"args\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"[Ljava/lang/String;\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> l3<span class=\"token punctuation\">,</span> l7<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>v2<span class=\"token punctuation\">.</span><span class=\"token function\">visitLocalVariable</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"I\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> l4<span class=\"token punctuation\">,</span> l7<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>v2<span class=\"token punctuation\">.</span><span class=\"token function\">visitMaxs</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre><span class=\"token comment\">// 终于 OK 了</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>v2<span class=\"token punctuation\">.</span><span class=\"token function\">visitEnd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><blockquote>\n<p>写之前就需要先写好 Java 程序进行反编译，再照着字节码一行一行使用 <code>MathodVisitor</code>  编辑。</p>\n</blockquote>\n<h2 id=\"例子实现aop\"><a class=\"anchor\" href=\"#例子实现aop\">#</a> 例子：实现 AOP</h2>\n<blockquote>\n<p>AOP-- 面向切面编程，Spring 核心之一，如果你不了解 AOP，就暂时理解为，在一个执行流程（模块）中，加入一个切面，通过这个切面的方法可以被切面加入一些操作，如记录日志啥的。</p>\n</blockquote>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/08/972d8fa05bf61137.jpg\" alt=\"\" /></p>\n<p>我们希望通过 ASM 来实现 AOP：在方法调用前后增加逻辑（也叫做前置通知和后置通知）。</p>\n<p>具体代码实现感兴趣的读者可以参考：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9wZGFpLnRlY2gvbWQvamF2YS9qdm0vamF2YS1qdm0tY2xhc3MtZW5oYW5jZXIuaHRtbCMlRTUlQUQlOTclRTglOEElODIlRTclQTAlODElRTUlQTIlOUUlRTUlQkMlQkElRTYlOEElODAlRTYlOUMlQUY=\">直接利用 ASM 实现 AOP</span>。</p>\n<h1 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h1>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueXVxdWUuY29tL3Fpbmdrb25neGlhZ3VhbmcvamF2YXNlL2tlb3BtZw==\">https://www.yuque.com/qingkongxiaguang/javase/keopmg</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wZGFpLnRlY2gvbWQvamF2YS9qdm0vamF2YS1qdm0tY2xhc3MtZW5oYW5jZXIuaHRtbA==\">https://pdai.tech/md/java/jvm/java-jvm-class-enhancer.html</span></p>\n</blockquote>\n",
            "tags": [
                "JVM"
            ]
        },
        {
            "id": "https://cecilia.cool/2022/10/05/Java/JVM/JVM(1)-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/",
            "url": "https://cecilia.cool/2022/10/05/Java/JVM/JVM(1)-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/",
            "title": "JVM(1)--类文件结构",
            "date_published": "2022-10-05T15:29:47.000Z",
            "content_html": "<h1 id=\"类文件结构\"><a class=\"anchor\" href=\"#类文件结构\">#</a> 类文件结构</h1>\n<p>计算机是不能直接运行 java 代码的，必须要先运行 java 虚拟机，再由 java 虚拟机运行编译后的 java 代码。这个编译后的 java 代码，就是本文要介绍的 java 字节码。</p>\n<ul>\n<li>Java 代码间接翻译成字节码，储存字节码的文件再交由运行于不同平台上的 JVM 虚拟机去读取执行，从而实现一次编写，到处运行的目的。</li>\n<li>JVM 也不再只支持 Java，由此衍生出了许多基于 JVM 的编程语言，如 Groovy, Scala, Koltin 等等。</li>\n</ul>\n<blockquote>\n<p>许多开发语言支持将源代码编译为 <code>.class</code>  字节码文件格式，以便交给 JVM 运行</p>\n</blockquote>\n<h2 id=\"类文件信息\"><a class=\"anchor\" href=\"#类文件信息\">#</a> 类文件信息</h2>\n<p>先写一个例子：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> m<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">inc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token keyword\">return</span> m <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>编译生成 <code>Test.class</code>  文件。</p>\n<blockquote>\n<p>下载 WinHex 软件，以十六进制格式查看字节码文件（将编译好的 <code>class</code>  文件拖进去），每一位都是 4 个 bit</p>\n</blockquote>\n<p>呈现出来的是酱紫的：</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/06/227b1ae28c54688f.jpg\" alt=\"\" /></p>\n<p>但是 winHex 我这打开总是有些毛病，所以选择另一个工具（IEDA 插件）查看十六进制字节码：</p>\n<ul>\n<li>安装插件：Binary/hexadecimal editor。</li>\n<li>右键 class 文件，选择 Open As Binary。</li>\n</ul>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/06/995affe6c346a8aa.jpg\" alt=\"\" /></p>\n<p>有时直接查看 16 进制的结果不方便，为了能够方便查看字节码信息，需要安装另一个插件：</p>\n<ul>\n<li>安装插件：jclasslib Bytecode Viewer。</li>\n<li>选中要查看的 java 文件（不是 class 文件），点击 view（视图），再点击 <code>show Bytecode with jclasslib</code> 。</li>\n</ul>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/06/8f19ae55706ab1c2.jpg\" alt=\"\" /></p>\n<ul>\n<li>这样查看字节码文件中的常量池什么的就非常方便。</li>\n</ul>\n<p>对于类文件信息，需要知道的部分如下图：</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/05/868070b026d6842b.jpg\" alt=\"\" /></p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">ClassFile</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    u4             magic<span class=\"token punctuation\">;</span> <span class=\"token comment\">//Class 文件的标志</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    u2             minor_version<span class=\"token punctuation\">;</span><span class=\"token comment\">//Class 的小版本号</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    u2             major_version<span class=\"token punctuation\">;</span><span class=\"token comment\">//Class 的大版本号</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    u2             constant_pool_count<span class=\"token punctuation\">;</span><span class=\"token comment\">// 常量池的数量</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    cp_info        constant_pool<span class=\"token punctuation\">[</span>constant_pool_count<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 常量池</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    u2             access_flags<span class=\"token punctuation\">;</span><span class=\"token comment\">//Class 的访问标记</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    u2             this_class<span class=\"token punctuation\">;</span><span class=\"token comment\">// 当前类</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    u2             super_class<span class=\"token punctuation\">;</span><span class=\"token comment\">// 父类</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    u2             interfaces_count<span class=\"token punctuation\">;</span><span class=\"token comment\">// 接口</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    u2             interfaces<span class=\"token punctuation\">[</span>interfaces_count<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 一个类可以实现多个接口</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    u2             fields_count<span class=\"token punctuation\">;</span><span class=\"token comment\">//Class 文件的字段属性</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    field_info     fields<span class=\"token punctuation\">[</span>fields_count<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 一个类会可以有个字段</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    u2             methods_count<span class=\"token punctuation\">;</span><span class=\"token comment\">//Class 文件的方法数量</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    method_info    methods<span class=\"token punctuation\">[</span>methods_count<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 一个类可以有个多个方法</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    u2             attributes_count<span class=\"token punctuation\">;</span><span class=\"token comment\">// 此类的属性表中的属性数</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    attribute_info attributes<span class=\"token punctuation\">[</span>attributes_count<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 属性表集合</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"魔数与版本\"><a class=\"anchor\" href=\"#魔数与版本\">#</a> 魔数与版本</h3>\n<p>字节码文件前 4 个字节（32bit）组成了魔数，魔数机制检验该文件是否是 JVM 可以直接运行的字节码文件。字节码文件的魔数为：<strong>CAFFBABE</strong>。</p>\n<p>魔数后面的 4 个字节存储的是字节码文件的版本号，前两个是次要版本号（现在基本不用了），后两个是主要版本号，将 16 进制换算成 10 进制之后，得到的可以参照：52 代表 JDK8 编译的字节码文件（51 是 JDK7，53 是 JDK9）。</p>\n<h3 id=\"常量池\"><a class=\"anchor\" href=\"#常量池\">#</a> 常量池</h3>\n<p><code>Constant pool</code>  意为常量池，可以理解为 <code>Class</code>  文件中的资源仓库，是程序运行一些需要用到的常量数据，主要存放<strong>字面量</strong>和<strong>符号引用</strong>。字面量类似于 Java 中的常量概念，如文本字符串， <code>final</code>  常量等。</p>\n<p>符号引用属于编译原理的概念：</p>\n<ul>\n<li>类和接口的全限定名</li>\n<li>字段的名称和描述符</li>\n<li>方法的名称和描述符</li>\n</ul>\n<p>常量的数量不是确定的，所以在<strong>最开始的位置</strong>会存放常量池中<strong>常量的数量</strong>（是从 1 开始计算的，不是 0，比如 18，翻译为 10 进制就是 24，所以实际上有 23 个常量）。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>u2             constant_pool_count<span class=\"token punctuation\">;</span><span class=\"token comment\">// 常量池的数量</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>cp_info        constant_pool<span class=\"token punctuation\">[</span>constant_pool_count<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 常量池</span></pre></td></tr></table></figure><p>每一项常量池里面的数据都是一个表，都是以_info 结尾的（通过插件查看即可），有 14 种表。</p>\n<h3 id=\"访问标志\"><a class=\"anchor\" href=\"#访问标志\">#</a> 访问标志</h3>\n<p>两个字节，代表访问标志，用于识别一些类或者接口层次的访问信息，包括：Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/07/d412705d408b4988.jpg\" alt=\"\" /></p>\n<p>反编译一下 <code>Test.class</code>  文件查看访问标志：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># -p -private 显示所有类和成员</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># -v -verbose 输出附加信息</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>javap <span class=\"token parameter variable\">-verbose</span> <span class=\"token parameter variable\">-p</span> Test.class</pre></td></tr></table></figure><p>对于结果为：</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/07/175494f35c4a5e2e.jpg\" alt=\"\" /></p>\n<h3 id=\"类索引和接口索引集合\"><a class=\"anchor\" href=\"#类索引和接口索引集合\">#</a> 类索引和接口索引集合</h3>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>u2             this_class<span class=\"token punctuation\">;</span><span class=\"token comment\">// 当前类</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>u2             super_class<span class=\"token punctuation\">;</span><span class=\"token comment\">// 父类</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>u2             interfaces_count<span class=\"token punctuation\">;</span><span class=\"token comment\">// 接口</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>u2             interfaces<span class=\"token punctuation\">[</span>interfaces_count<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 一个类可以实现多个接口</span></pre></td></tr></table></figure><p>在访问标志的反编译图中也可以看到<strong>当前类索引</strong>，<strong>父类索引</strong>，<strong>接口索引</strong>。</p>\n<p><strong>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了  <code>java.lang.Object</code>  之外，所有的 java 类都有父类，因此除了  <code>java.lang.Object</code>  外，所有 Java 类的父类索引都不为 0。</strong></p>\n<p><strong>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 <code>implents</code>  (如果这个类本身是接口的话则是 <code>extends</code> ) 后的接口顺序从左到右排列在接口索引集合中。</strong></p>\n<h3 id=\"字段表集合\"><a class=\"anchor\" href=\"#字段表集合\">#</a> 字段表集合</h3>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>u2             fields_count<span class=\"token punctuation\">;</span><span class=\"token comment\">//Class 文件的字段的个数</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>field_info     fields<span class=\"token punctuation\">[</span>fields_count<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 一个类会可以有个字段</span></pre></td></tr></table></figure><p>用于描述接口或类中声明的变量。不包括方法内部的局部变量。</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/07/a82c68d88210068a.jpg\" alt=\"\" /></p>\n<ul>\n<li><strong>access_flags:</strong> 字段的作用域（ <code>public</code>  , <code>private</code> , <code>protected</code>  修饰符），是实例变量还是类变量（ <code>static</code>  修饰符）, 可否被序列化（transient 修饰符）, 可变性（final）, 可见性（volatile 修饰符，是否强制从主内存读写），各个修饰符都是布尔值，要么有某个修饰符，要么没有，适合使用标志位来表示。</li>\n<li><strong>name_index:</strong> 对<strong>常量池</strong>的引用，表示的字段的名称；</li>\n<li><strong>descriptor_index:</strong> 对常量池的引用，表示字段和方法的描述符；//</li>\n<li><strong>attributes_count:</strong> 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li>\n<li><strong>attributes[attributes_count]:</strong> 存放具体属性具体内容。</li>\n</ul>\n<h3 id=\"方法表集合\"><a class=\"anchor\" href=\"#方法表集合\">#</a> 方法表集合</h3>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>u2             methods_count<span class=\"token punctuation\">;</span><span class=\"token comment\">//Class 文件的方法的数量</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>method_info    methods<span class=\"token punctuation\">[</span>methods_count<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 一个类可以有个多个方法</span></pre></td></tr></table></figure><p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表（ <code>method_info</code> ）的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项（所以参照上图 <code>field_info</code> ）。</p>\n<p>得到的结果（这里只看方法那部分）：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token class-name\">Chapter1<span class=\"token punctuation\">.</span>Test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    descriptor<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token class-name\">V</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    flags<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0x0001</span><span class=\"token punctuation\">)</span> <span class=\"token constant\">ACC_PUBLIC</span>\t\t\t\t<span class=\"token comment\">// 这就是 access_flag 取值</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token class-name\">Code</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>      stack<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> locals<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> args_size<span class=\"token operator\">=</span><span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>         <span class=\"token number\">0</span><span class=\"token operator\">:</span> aload_0</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>         <span class=\"token number\">1</span><span class=\"token operator\">:</span> invokespecial #<span class=\"token number\">1</span>                <span class=\"token comment\">// Method java/lang/Object.\"&lt;init>\":()V</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>         <span class=\"token number\">4</span><span class=\"token operator\">:</span> <span class=\"token keyword\">return</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>         <span class=\"token number\">0</span><span class=\"token operator\">:</span> aload_0</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>         <span class=\"token number\">1</span><span class=\"token operator\">:</span> getfield      #<span class=\"token number\">2</span>                <span class=\"token comment\">// Field m:I</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>         <span class=\"token number\">4</span><span class=\"token operator\">:</span> iconst_1</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>         <span class=\"token number\">5</span><span class=\"token operator\">:</span> iadd</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>         <span class=\"token number\">6</span><span class=\"token operator\">:</span> ireturn</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>      <span class=\"token class-name\">LineNumberTable</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        line <span class=\"token number\">6</span><span class=\"token operator\">:</span> <span class=\"token number\">0</span></pre></td></tr></table></figure><p>其中 <code>access_flag</code>  取值为：</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2022/10/07/f8a119d3fd7bb199.jpg\" alt=\"\" /></p>\n<blockquote>\n<p>因为 <code>volatile</code>  修饰符和 <code>transient</code>  修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了 <code>synchronized</code> 、 <code>native</code> 、 <code>abstract</code>  等关键字修饰方法，所以也就多了这些关键字对应的标志。</p>\n</blockquote>\n<p>code 内的主要属性为:</p>\n<ul>\n<li><strong>stack</strong>： 最大操作数栈，JVM 运行时会根据这个值来分配栈帧 (Frame) 中的操作栈深度，此处为 1**（递归？）**</li>\n<li><strong>locals</strong>：局部变量所需的存储空间，单位为 Slot, Slot 是虚拟机为局部变量分配内存时所使用的最小单位，为 4 个字节大小。方法参数 (包括实例方法中的隐藏参数 this)，显示异常处理器的参数 (try catch 中的 catch 块所定义的异常)，方法体中定义的局部变量都需要使用<strong>局部变量表</strong>来存放。值得一提的是，locals 的大小并不一定等于所有局部变量所占的 Slot 之和，因为局部变量中的 Slot 是可以重用的。</li>\n<li><strong>args_size</strong>：方法参数的个数，这里是 1，因为每个实例方法都会有一个隐藏参数 this</li>\n<li><strong>attribute_info</strong>: 方法体内容，0,1,4 为字节码 &quot;行号&quot;，该段代码的意思是将第一个引用类型本地变量推送至栈顶，然后执行该类型的实例方法，也就是常量池存放的第一个变量，也就是注释里的 <code>java/lang/Object.&quot;&quot;:()V</code> , 然后执行返回语句，结束方法。</li>\n<li><strong>LineNumberTable</strong>：该属性的作用是描述源码行号与字节码行号 (字节码偏移量) 之间的对应关系。可以使用 -g:none 或 - g:lines 选项来取消或要求生成这项信息，如果选择不生成 LineNumberTable，当程序运行异常时将无法获取到发生异常的源码行号，也无法按照源码的行数来调试程序。</li>\n</ul>\n<p>有时还会出现这个：</p>\n<ul>\n<li><strong>LocalVariableTable</strong>：该属性的作用是描述帧栈中局部变量与源码中定义的变量之间的关系。可以使用 -g:none 或 -g:vars 来取消或生成这项信息，如果没有生成这项信息，那么当别人引用这个方法时，将无法获取到参数名称，取而代之的是 arg0, arg1 这样的占位符。 start 表示该局部变量在哪一行开始可见，length 表示可见行数，Slot 代表所在帧栈位置，Name 是变量名称，然后是类型签名。</li>\n</ul>\n<h3 id=\"属性表集合\"><a class=\"anchor\" href=\"#属性表集合\">#</a> 属性表集合</h3>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>u2             attributes_count<span class=\"token punctuation\">;</span><span class=\"token comment\">// 此类的属性表中的属性数</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>attribute_info attributes<span class=\"token punctuation\">[</span>attributes_count<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 属性表集合</span></pre></td></tr></table></figure><p>用于描述某些场景专有的信息。</p>\n<h1 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h1>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpnMk9UQTBOamswT0E9PSZhbXA7bWlkPTIyNDc0ODUyNTAmYW1wO2lkeD0yJmFtcDtzbj0zMzc5M2JjY2UzZjJmZjMxYjgzY2YyZjljMzJkZjE1MyZhbXA7Y2hrc209Y2VhMjQ4ODlmOWQ1YzE5ZmEzZTJiN2Q0ZjU5NzYyYjU5ZTZjZDllNWU2NTY0ZmU3M2M2OTkzYmQwNmUwOGJkZGQ0MGNjMGYzY2JhMCZhbXA7c2NlbmU9MCZhbXA7eHRyYWNrPTEmYW1wO2tleT00OWNkMWU1OTk5MGMzZDFmMjA3ODY1ZDMyNzU5ZjFmZjJhZTdmZGY2NzZmM2IwYTAyYmE0OTkwNmE1YWYzY2NkYmQ3M2U0M2JiZTMxNTE1ODY2Zjk3NDgzODhjNzhjYjllNDQwNmQ4ODBlYWYyZDUxYWZjZjMyMTY4ZjNhZDI3MTc2OWNjMWM5M2NiZmIwMTM1MDQ2MjEwYjQxZDdkMDM2JmFtcDthc2NlbmU9MSZhbXA7dWluPU1qTXhNRGs0TkRJMyZhbXA7ZGV2aWNldHlwZT1XaW5kb3dzKzcmYW1wO3ZlcnNpb249NjIwNjA3MzkmYW1wO2xhbmc9emhfQ04mYW1wO3Bhc3NfdGlja2V0PUowJTJCTG5yTmdFRm91SzRldEJud2cxSFVhYnNGdzdqaTVXMWZpU3ZldWc1NCUzRA==\">谈谈 Java 类文件结构</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2U3L2h0bWwvanZtcy00Lmh0bWw=\">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb29sc2hlbGwuY24vYXJ0aWNsZXMvOTIyOS5odG1s\">https://coolshell.cn/articles/9229.html</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1YW5sb3Vpcy9hcnRpY2xlL2RldGFpbHMvMzk5NjA4MTU=\">https://blog.csdn.net/luanlouis/article/details/39960815</span></p>\n<p>《实战 Java 虚拟机》</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wZGFpLnRlY2gvbWQvamF2YS9qdm0vamF2YS1qdm0tY2xhc3MuaHRtbA==\">https://pdai.tech/md/java/jvm/java-jvm-class.html</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueXVxdWUuY29tL3Fpbmdrb25neGlhZ3VhbmcvamF2YXNlL2tlb3BtZw==\">https://www.yuque.com/qingkongxiaguang/javase/keopmg</span></p>\n</blockquote>\n",
            "tags": [
                "JVM"
            ]
        }
    ]
}