{
    "version": "https://jsonfeed.org/version/1",
    "title": "慕青の迷途 • All posts by \"projects\" tag",
    "description": "时雨病重症患者",
    "home_page_url": "https://cecilia.cool",
    "items": [
        {
            "id": "https://cecilia.cool/2023/06/12/Project/cyan-log/",
            "url": "https://cecilia.cool/2023/06/12/Project/cyan-log/",
            "title": "cyan-log",
            "date_published": "2023-06-12T02:32:33.000Z",
            "content_html": "<h1 id=\"项目说明\"><a class=\"anchor\" href=\"#项目说明\">#</a> 项目说明</h1>\n<p>本项目以 <code>slf4j</code>  作为日志门面，对其进行提供日志实现，以 SPI 机制为基础，提供各种日志服务。本项目主要作为学习使用，了解现代主流的日志框架提供的功能以及如何开发一个简化的日志框架。因为鄙人对并发很感兴趣，所以 <code>cyan-log</code>  项目也主要是在并发方面花功夫，考虑将性能优化到极致，<strong>汇聚一点 登峰造极</strong>。</p>\n<h1 id=\"开源仓库\"><a class=\"anchor\" href=\"#开源仓库\">#</a> 开源仓库</h1>\n<p>暂时还没 push</p>\n<h1 id=\"cyan-log\"><a class=\"anchor\" href=\"#cyan-log\">#</a> cyan-log</h1>\n<h1 id=\"log4j2\"><a class=\"anchor\" href=\"#log4j2\">#</a> log4j2</h1>\n<p><strong>版本：2.19.0</strong></p>\n<h2 id=\"logger\"><a class=\"anchor\" href=\"#logger\">#</a> Logger</h2>\n<h3 id=\"asynclogger\"><a class=\"anchor\" href=\"#asynclogger\">#</a> AsyncLogger</h3>\n<p>参考链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9icnlhbnRjaGFuZy5naXRodWIuaW8vMjAxOS8wMS8xNS9sb2c0ajItYXN5bmNMb2dnZXIv\">https://bryantchang.github.io/2019/01/15/log4j2-asyncLogger/</span></p>\n<p>AsyncLogger 将日志事件传给了 disruptor 队列后，事件中封装了对应的 logger 和 config，消费者就会根据事件中的 config 来打印 logger，消费者的逻辑就和同步打印一样的。</p>\n<blockquote>\n<p>为什么有了 <code>AsyncAppender</code> ，还要 <code>AsyncLogger</code> ，这两个结合会如何，性能如何？请看该篇文章：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjQxNzc2MDEvZGlmZmVyZW5jZS1iZXR3ZWVuLWFzeW5jbG9nZ2VyLWFuZC1hc3luY2FwcGVuZGVyLWluLWxvZzRqMg==\">https://stackoverflow.com/questions/24177601/difference-between-asynclogger-and-asyncappender-in-log4j2</span></p>\n</blockquote>\n<h2 id=\"appender\"><a class=\"anchor\" href=\"#appender\">#</a> Appender</h2>\n<p><code>Appender</code>  是一个路由 LogEvent 的管道，他决定了日志要去哪以及怎么去。主要分为两种 <code>Appender</code> ：同步 <code>Appender</code>  和异步 <code>Appender</code> 。</p>\n<h3 id=\"asyncappender\"><a class=\"anchor\" href=\"#asyncappender\">#</a> AsyncAppender</h3>\n<blockquote>\n<p>建议看一下源码，该类本身代码量不多，给一个参考链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0Mjg1MzQzMA==\">https://segmentfault.com/a/1190000042853430</span></p>\n</blockquote>\n<p>日志记录需要进行磁盘 IO 操作，<strong>非常耗时</strong>，同时为了保证日志记录的并发安全，在写入日志时还经常要加锁，这些导致性能严重下降。</p>\n<p>先给出一个配置 demo 来演示异步 <code>Appender</code> ：</p>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token prolog\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Configuration</span> <span class=\"token attr-name\">status</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>INFO<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Appenders</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token comment\">&lt;!-- 配置两个正常的 Appender --></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Console</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>MyConsole<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">target</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>SYSTEM_OUT<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ThresholdFilter</span> <span class=\"token attr-name\">level</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>INFO<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">onMatch</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>ACCEPT<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">onMismatch</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>DENY<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>PatternLayout</span> <span class=\"token attr-name\">pattern</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>%msg%n<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Console</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>RollingFile</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>MyFile<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">fileName</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>mylog.log<span class=\"token punctuation\">\"</span></span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>                     <span class=\"token attr-name\">filePattern</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>mylog.log.%i<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ThresholdFilter</span> <span class=\"token attr-name\">level</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>INFO<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">onMatch</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>ACCEPT<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">onMismatch</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>DENY<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>PatternLayout</span> <span class=\"token attr-name\">pattern</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>%msg%n<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>SizeBasedTriggeringPolicy</span> <span class=\"token attr-name\">size</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>20M<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>RollingFile</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token comment\">&lt;!-- 让异步 Appender 引用正常 Appender --></span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Async</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>MyAsync<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>AppenderRef</span> <span class=\"token attr-name\">ref</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>MyConsole<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>AppenderRef</span> <span class=\"token attr-name\">ref</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>MyFile<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Async</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Appenders</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Loggers</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token comment\">&lt;!-- 让根日志打印器引用异步 Appender --></span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Root</span> <span class=\"token attr-name\">level</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>INFO<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Appender-ref</span> <span class=\"token attr-name\">ref</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>MyAsync<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Root</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Loggers</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Configuration</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><p><code>AsyncAppender</code>  类作为生产者，构建 <code>LogEvent</code>  放到阻塞队列中，同时内部有个属性为 <code>AsyncAppenderEventDispatcher dispatcher</code> ，该类继承了 <code>Log4jThread</code> ，其实就是<strong>消费者</strong>，该消费者最重要就是 <code>dispatch()</code>  方法，该方法就是将日志事件通过循环交给各个 <code>AppenderRef</code> 。另外两个方法就是：</p>\n<ul>\n<li><code>dispatchAll()</code> ：循环消费阻塞队列中的日志并打印</li>\n<li><code>dispatchRemaining()</code> ：线程如果被停止，则调用 dispatchRemaining () 保证阻塞队列中的日志全部被打印</li>\n</ul>\n<p><code>AsyncAppender</code>  的 <code>start()</code>  方法初始化 <code>AsyncAppenderEventDispatcher</code> ，并在最后就会调用 <code>dispatcher.start()</code> 。</p>\n<p><code>dispatchAll()</code>  方法会把 <code>logEvent</code>  交给 <code>AsyncAppender</code>  关联的 <code>Appender</code> 。上述例子中也就是将 <code>LogEvent</code>  发送到 <code>MyConsole</code>  和 <code>MyFile</code> ，然后进行日志打印（都在同一个线程，而不会分别让 <code>MyConsole</code>  和 <code>MyFIle</code>  各自一个线程）。</p>\n<p>下面就是整个异步打印的流程（<strong>图片来自上文引言中的链接</strong>）：</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2023/06/12/39af5621bd267702.jpg\" alt=\"\" /></p>\n<p>现在流程中的参与成员都知道了，并且我们也知道生产者何时将 <code>logEvent</code>  加入到队列中（当 Logger 产生日志时）消费者如何进行消费，下面列出几个重要的点：</p>\n<ul>\n<li><code>Appender</code>  使用 <code>WriterManager</code>  进行日志写入，后者内部使用的是 <code>Writer</code> ，为了保证并发安全， <code>WriterManager</code>  在写入方法上使用了 <code>synchronized</code>  关键字。（并发问题：多个 Logger 都使用了同一个 Appender，为了防止写入混乱，这是必要的上锁）。</li>\n<li>消费线程 <code>AsyncAppenderEventDispatcher</code>  何时启动又如何工作的？以 xml 配置为例， <code>Log4j2</code>  框架在首次获取 <code>Logger</code>  时，会初始化 <code>LoggerContext</code> ，而初始化 <code>LoggerContext</code>  时有一个步骤就是将 <code>Log4j2</code>  配置对象 <code>XmlConfiguration</code>  设置给 <code>LoggerContext</code>  并启动 <code>XmlConfiguration</code> ，这里看一下 <code>XmlConfiguration</code>  的 <code>start()</code>  方法</li>\n</ul>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">// ...</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token comment\">// 遍历配置文件中配置的 Appender 并启动</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> <span class=\"token class-name\">Appender</span> appender <span class=\"token operator\">:</span> appenders<span class=\"token punctuation\">.</span><span class=\"token function\">values</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        appender<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>alreadyStarted<span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        root<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token constant\">LOGGER</span><span class=\"token punctuation\">.</span><span class=\"token function\">debug</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Started configuration &#123;&#125; OK.\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><code>start()</code>  方法的最上层定义是 <code>LifeCycle</code>  接口，如此定义是因为不止 <code>Appender</code>  存在异步组件， <code>Logger</code> 、 <code>Filter</code>  等组件也存在异步，所以大家的异步组件本质上都实现了该接口。然后在 <code>config</code>  中启动。</p>\n<p>此时并发性能已经比较优秀了，但是我们可以看到有两个并发性能的瓶颈：</p>\n<ul>\n<li><code>logEvent</code>  的传递还是会在阻塞队列处停住，起码我们明显可以看出，一个并发安全的队列的并发性能是限制会限制日志写入</li>\n<li>一个队列分配一个线程来消费，本质上没有问题，但是后台线程在消费日志事件时还是会遇到锁竞争，因为后台线程 <code>dispatch</code>  会挨个将事件传给 <code>Appender</code> ，再抢锁（synchronized）进行日志打印。造成这种原因的其实是一个队列中的事件种类不一样，所以也就需要分发器（ <code>dispatch</code> ），而这个分发器又不是那么优秀（因为它不止需要分发，还需要打印）。</li>\n</ul>\n<blockquote>\n<p>dispatch 承担的功能：取出、分发、打印，取出和打印都会阻塞（取出是否阻塞要看选用哪种队列），如果打印阻塞时间太长，反而会导致队列中事件堆积。</p>\n</blockquote>\n<p><strong>问题一</strong>：log4j2 的异步日志是通过队列来处理的，关于队列，Log4j2 支持生成以下四种队列：</p>\n<ul>\n<li>\n<p><code>ArrayBlockingQueue</code> ：默认的队列，通过 java 原生的  <code>ArrayBlockingQueue</code>  实现。</p>\n</li>\n<li>\n<p><code>DisruptorBlockingQueue</code> ： <code>disruptor</code>  包实现的高性能队列，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0xNQVgtRXhjaGFuZ2UvZGlzcnVwdG9y\">开源地址</span>。</p>\n</li>\n<li>\n<p><code>JCToolsBlockingQueue</code> ： <code>JCTools</code>  实现的无锁队列。</p>\n</li>\n<li>\n<p><code>LinkedTransferQueue</code> ：通过 java7 以上原生支持的  <code>LinkedTransferQueue</code>  实现。</p>\n</li>\n</ul>\n<p><code>DisruptorBlockingQueue</code>  队列，它的特点为：<strong>无锁</strong>、<strong>环形空间</strong>。无锁就是 <code>CAS</code> 、环形队列使得空间循环利用，但是可能会覆盖，所以此时需要执行对应<strong>策略</strong>。</p>\n<p>关于该队列的细节介绍，之后会在数据结构与算法的 <code>tag</code>  中开一篇，现在我们只需要知道，这个队列确实能够高效的、并发安全的传输 LogEvent，也不会导致 <code>dispatch</code>  取出日志变得很慢。</p>\n<p><strong>问题二</strong>：这正是 cyan-log 需要解决的问题：</p>\n<ul>\n<li>\n<p>如何减少写入同一文件时锁的竞争：那就是只让一个线程写入文件，从开始到结束，都是它来写入</p>\n</li>\n<li>\n<p>如何只让一个线程来写入文件：多个 Logger 对于同一个文件的 <code>LogEvent</code> ，都放入通过一个队列中，然后写入线程只需要从队列中获取即可。</p>\n</li>\n<li>\n<p>如果某个文件的日志已经很久都没产生了，那么其写入线程就会一直阻塞，有点浪费，如何优化：不如使用线程池，阻塞队列提供了超时获取的方法，如果超时了就不再获取，那么线程可以复用，或者连续超时了很多次，这取决于你希望的策略。</p>\n</li>\n<li>\n<p>我们应该如何初始化这样一个线程：这里有个子问题，也就是我如何判断线程已经初始化了？</p>\n<p>正常思维是<strong>为每个文件（也就是日志去向）关联一个变量 A</strong>，当线程没有初始化（或者已经销毁复用）时，A 为 0，反之 A 为 1。A 涉及到原子修改，需要加锁或者 CAS，但是这并不会限制系统并发，因为这只是初始化阶段，初始化完毕就不会再执行（当然，复用还是会涉及到 A 的原子修改，还是那句话，这取决于你的策略，也就是是否要线程复用）。很遗憾，还是有点漏洞：</p>\n</li>\n</ul>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2023/06/12/b547dd40d12ae7e2.jpg\" alt=\"\" /></p>\n<p>可以看出这种使用一个变量 A 来保证并发安全，是有问题的，它会使得：队列中还有消息没有消费，但是线程池中已经没有线程来消费了。当然，如果后续又来了一个日志进入队列中，那么它又会初始化一个线程，队列中的日志自然可以消费。</p>\n<blockquote>\n<p>但是这是可以允许的吗？肯定不行，写一个程序，尤其是写一个健壮的程序，这才是关键。</p>\n</blockquote>\n<p>对于这种情况，我们可以后台单独开一个线程来检测是否有队列处于这样的情况，但是这无疑使得问题变得复杂，我们甚至无法知道线程该何时运行，运行多久。</p>\n<p>想一想，现在的情况是多个生产者，一个消费者，当消费者走到<strong>步骤 1</strong> 时，可能会有很多个生产者走到<strong>步骤 3</strong>，这是允许的，但不允许的是所有生产者都走到了<strong>步骤 3</strong>，不知道你们是否想到了解决办法，我的思路是使用读写锁来避免这种情况的出现。</p>\n<blockquote>\n<p>很遗憾，我们又无可避免的使用了锁，但是要保证并发安全，我们又无法不这么做，为了提升并发，我们采用的是读写锁，思考一下，这很合适，某种诡异的契合，不是吗？</p>\n</blockquote>\n<p>现‘在引入了读写锁，我们重新来看一下：</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2023/06/12/17fc6db496b7f586.jpg\" alt=\"\" /></p>\n<p>解释几点：</p>\n<ol>\n<li>生产者使用 <code>tryAcquire</code>  是因为如果没有获取到锁，就说明已经有线程在初始化线程池的线程了</li>\n<li>消费者使用 <code>tryAcquire</code>  是因为没拿到锁，说明存在读锁，也就说明有日志加入到队列中了，那么自己也就不需要销毁，重新消费即可。</li>\n<li>将日志加入队列的时机，是初始化前还是初始化后，其实没有太多影响，起码对于这个问题而言。注意，如果涉及到队列的抛弃策略，也就是队列可能会满，那么加入队列就应该在初始化前（因为没必要抢锁）。</li>\n</ol>\n<ul>\n<li>这里要考虑的问题就是线程初始化和线程复用这段时间是否会冲突，假设线程获取事件触发了超时（或许很多次），然后准备复用了，此时另外的线程恰好有对应的日志打过来</li>\n</ul>\n<h3 id=\"拒绝策略\"><a class=\"anchor\" href=\"#拒绝策略\">#</a> 拒绝策略</h3>\n<p>如果队列满了，会先判断 logger 是否在递归调用中，如果在，就在当前线程直接调用 appender 打印日志。不再，就会根据 <code>AsyncQueueFullPolicy</code>  来决定：</p>\n<ul>\n<li><code>DefaultAsyncQueueFullPolicy</code> ：如果该线程是后台线程，就在当前线程打印；反之就调用阻塞队列的 put 来阻塞当前线程加入日志。</li>\n<li><code>DiscardingAsyncQueueFullPolicy</code> ：继承了 <code>DefaultAsyncQueueFullPolicy</code> ，会先比较一下日志等级，如果在指定等级下的日志就会丢弃，高于指定等级的日志比较重要，就会调用 <code>DefaultAsyncQueueFullPolicy</code>  来处理日志。</li>\n</ul>\n<h1 id=\"disruptor队列\"><a class=\"anchor\" href=\"#disruptor队列\">#</a> disruptor 队列</h1>\n<p>高性能体现：CAS、解决伪共享。</p>\n<p>生产者和消费者共享一个环形内存，也就是 <code>RingBuffer</code> ：</p>\n<p><img data-src=\"https://s3.bmp.ovh/imgs/2023/08/19/edf0668db0b9c6a4.jpg\" alt=\"\" /></p>\n<p><code>Disruptor</code>  没有对生产者和消费者做定义，只是暴露了提交和取出的接口：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">RingBuffer</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">LogEvent</span><span class=\"token punctuation\">></span></span> ringBuffer<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 生产者 api</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">long</span> sequence <span class=\"token operator\">=</span> ringBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 无锁获取</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token class-name\">LogEvent</span> logEvent <span class=\"token operator\">=</span> ringBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>sequence<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">// 然后根据业务对 log 进行操作</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>ringBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">publish</span><span class=\"token punctuation\">(</span>sequence<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">// 消费者 api，需要实现 EventHandler&lt;T > 接口</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onEvent</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">LogEvent</span> logEvent<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> sequence<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> endOfBatch<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"获取到日志并消费\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"核心组件\"><a class=\"anchor\" href=\"#核心组件\">#</a> 核心组件</h2>\n<ul>\n<li><code>Disruptor</code>  对象：持有一个 <code>RingBuffer</code>  对象，一个线程池 <code>Executor</code>  对象以及一个 <code>ConsumerRepository</code>  对象，生产者生产的数据会存放在 <code>RingBuffer</code>  中的元素中，同时当向 <code>Disruptor</code>  注册事件处理器时 <code>Disruptor</code>  会基于注册的事件处理器创建消费者并添加到 <code>ConsumerRepository</code>  中。</li>\n<li><code>RingBuffer</code>  对象： <code>Disruptor</code>  框架中的核心对象，其持有一个 <code>Object</code>  数组用于存放元素以及一个 <code>Sequencer</code>  对象实现对生产者的同步控制。</li>\n<li><code>Sequencer</code>  对象：接口，有两个实现类分别为 <code>SingleProducerSequencer</code>  和 <code>MultiProducerSequencer</code> （默认），代表对单生产者和多生产者的同步控制（可以这么理解，定义的生产者 <code>TestEventProducer</code>  如果向 <code>RingBuffer</code>  生产元素，那么就会和其他生产者以及消费者产生并发冲突， <code>Sequencer</code>  就是用于控制并解决这个并发冲突的）。</li>\n<li><code>SequenceBarrier</code>  对象：其由 <code>Sequencer</code>  创建，并且会由消费者持有，主要用于消费者获取当前可以消费的元素的序号。</li>\n<li><code>EventProcessor</code>  对象：接口，表示消费者，当向 <code>Disruptor</code>  对象注册 <code>EventHandler</code>  对象时， <code>Disruptor</code>  会基于 <code>EventHandler</code>  创建一个 <code>BatchEventProcessor</code>  对象作为消费者，当向 <code>Disruptor</code>  注册 <code>WorkHandler</code>  对象时， <code>Disruptor</code>  会基于 <code>WorkHandler</code>  创建一个 <code>WorkProcessor</code>  对象作为消费者，本篇文章提及的消费者全部指 <code>BatchEventProcessor</code> 。</li>\n<li><code>Sequence</code>  对象：每个 <code>EventProcessor</code>  消费者会持有一个 <code>Sequence</code> ，同时 <code>SingleProducerSequencer</code>  持有一个 <code>Sequence</code> ， <code>MultiProducerSequencer</code>  持有两个 <code>Sequence</code> 。 <code>Sequence</code>  的使用者都是使用 <code>Sequence</code>  来维护自己的读 **/** 写序号。</li>\n</ul>\n<h3 id=\"消费者\"><a class=\"anchor\" href=\"#消费者\">#</a> 消费者</h3>\n<p>在消费时，会一直维护一个 <code>nextSequence</code> ，然后向 <code>sequenceBarrier</code>  获取当前实际可以消费到的元素的最大序号（ <code>waitFor</code>  方法）。</p>\n<p>这种机制可能导致消费者拿到的序号可能是别人已经消费了的事件，那么自己就会拿到一个还未填充数据的事件或者一个被生产者填充数据的事件。</p>\n<p>现在分析一下 <code>waitFor(nextSequence)</code>  方法：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">long</span> <span class=\"token function\">waitFor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> sequence<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        <span class=\"token keyword\">throws</span> <span class=\"token class-name\">AlertException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">InterruptedException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeoutException</span> </pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token function\">checkAlert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">// 调用等待策略的 waitFor () 方法得到一个可用序号</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">long</span> availableSequence <span class=\"token operator\">=</span> waitStrategy<span class=\"token punctuation\">.</span><span class=\"token function\">waitFor</span><span class=\"token punctuation\">(</span>sequence<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>                                                  cursorSequence<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>                                                  dependentSequence<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>                                                  <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token comment\">// 如果可用序号小于目标序号，则直接返回可用序号</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token comment\">// 说明当前最多只能消费到可用序号的元素</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>availableSequence <span class=\"token operator\">&lt;</span> sequence<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token keyword\">return</span> availableSequence<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token comment\">// 如果可用序号大于等于目标序号，则调用 Sequencer 来得到当前最大的已发布的序号</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token comment\">// 本示例中这里的 Sequencer 实际为 SingleProducerSequencer</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token comment\">// SingleProducerSequencer 的策略就是直接返回可用序号</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token keyword\">return</span> sequencer<span class=\"token punctuation\">.</span><span class=\"token function\">getHighestPublishedSequence</span><span class=\"token punctuation\">(</span>sequence<span class=\"token punctuation\">,</span> availableSequence<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token comment\">// SingleProducerSequencer#getHighestPublishedSequence</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">long</span> <span class=\"token function\">getHighestPublishedSequence</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> lowerBound<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> availableSequence<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token keyword\">return</span> availableSequence<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>等待策略中的 <code>waitFor</code>  方法， <code>WaitStrategy</code>  方法来决定它如何等待这个序号，以 <code>YieldingWaitStrategy</code>  为例，会循环 100 次获取可用序号，超过后每次循环未拿到就会调用 <code>Thread.yield</code> 。</p>\n<h3 id=\"生产者\"><a class=\"anchor\" href=\"#生产者\">#</a> 生产者</h3>\n<p><code>Disruptor</code>  的生产者生产元素的步骤可以概括如下。</p>\n<ol>\n<li>从 <code>RingBuffer</code>  中申请空间，即获取到一个可以设置数据的元素的序号；</li>\n<li>根据步骤 1 中获取到的索引将可以设置数据的元素从数组中获取出来；</li>\n<li>为步骤 2 中获取出来的元素设置数据；</li>\n<li>发布步骤 3 中的元素，即这个元素允许被消费者消费了。（两阶段提交）</li>\n</ol>\n<p>因为是环形结构，所以生产者也要防止追了（最慢）消费者的尾，如果检测到会发生追尾，那么就要自旋等待。</p>\n<p>生产者自然也可以批处理，因为它知道最慢的消费者走到哪了，也知道 RingBuffer 的大小。</p>\n<p>事实上，只有当 RingBuffer 的游标到达要提交的节点的前一个节点才会完成提交，假设 A 在 14 号位置已经进入提交函数，但是 B 在 13 号只是申请了序号，写入了数据，还没有提交，A 就需要自旋等待 B 提交了，游标走到 13 号，才会真正提交。</p>\n<h2 id=\"提高并发效率\"><a class=\"anchor\" href=\"#提高并发效率\">#</a> 提高并发效率</h2>\n<p>直接使用 CAS，是完全无锁的。我们自然知道，效率上：单线程操作 &gt; 单线程 CAS &gt; 单线程加锁。</p>\n<p>所以 disruptor 封装时还加上了策略配置，如果是单生产者（多）单消费者策略，生产者自然不需要 CAS，直接获得序号更快。根据生产者和消费者的数量，即有四种策略。默认是多生产者多消费者策略。</p>\n<p>更为重要的是，disruptor 是颁布序号给生产者和消费者，然后写入，消费元素时就能保证绝对线程安全，因为没有对应序号的线程不可能在这个位置竞争。那么就会有 RingBuffer 一次性有很多个线程在同时生产、消费，自然是很快的。</p>\n<p>而作者也提到，为什么队列无法胜任这个工作：因为队列只有两个指针。</p>\n<p>文档作者也提到，一个队列常常是单生产者和单消费者（至少我们应该尽力去做到），但是生产者和消费者的步调很难一致，所以缓冲常常就是满的队列（生产者比消费者快），或者是空的队列（消费者比生产者快）。</p>\n<h2 id=\"解决伪共享\"><a class=\"anchor\" href=\"#解决伪共享\">#</a> 解决伪共享</h2>\n<p>现代 64 位 CPU 的缓存行都是 64 字节，以 ArrayBlockingQueue 为例，他有头尾两个指针，int 情况下也就 8 字节，所以大概率是头尾指针在同一个缓存行，所以哪怕只有消费者消费了一个元素，导致尾指针更新，也会导致头指针失效，不得不从内存中重新获取。</p>\n<p>这就是伪共享 --false sharing。</p>\n<p>所以为了避免伪共享，就是用了字段填充：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">long</span> p1<span class=\"token punctuation\">,</span> p2<span class=\"token punctuation\">,</span> p3<span class=\"token punctuation\">,</span> p4<span class=\"token punctuation\">,</span> p5<span class=\"token punctuation\">,</span> p6<span class=\"token punctuation\">,</span> p7<span class=\"token punctuation\">;</span> <span class=\"token comment\">// cache line padding</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">long</span> cursor <span class=\"token operator\">=</span> <span class=\"token constant\">INITIAL_CURSOR_VALUE</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">long</span> p8<span class=\"token punctuation\">,</span> p9<span class=\"token punctuation\">,</span> p10<span class=\"token punctuation\">,</span> p11<span class=\"token punctuation\">,</span> p12<span class=\"token punctuation\">,</span> p13<span class=\"token punctuation\">,</span> p14<span class=\"token punctuation\">;</span> <span class=\"token comment\">// cache line padding</span></pre></td></tr></table></figure><h2 id=\"为什么使用环形缓冲\"><a class=\"anchor\" href=\"#为什么使用环形缓冲\">#</a> 为什么使用环形缓冲</h2>\n<p>RingBuffer 只维护了一个指向下一个可用位置的序号，这是为了<strong>提供可靠的消息传递</strong>。RingBuffer 需要将发送过的消息保存，如果外部服务发送 NAK 表示没有成功可以收到，就可以重新发送那一点到当前序号之间的所有消息。</p>\n",
            "tags": [
                "Projects"
            ]
        }
    ]
}