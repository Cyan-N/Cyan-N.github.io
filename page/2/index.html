<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.7.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.7.0" type="image/png" sizes="32x32"><meta name="description" content="我始终勇往直前，百折不回...">
<meta property="og:type" content="website">
<meta property="og:title" content="慕青的日记">
<meta property="og:url" content="https://cecilia.cool/page/2/index.html">
<meta property="og:site_name" content="慕青的日记">
<meta property="og:description" content="我始终勇往直前，百折不回...">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Cyan">
<meta name="twitter:card" content="summary"><title>慕青的日记 | Cyan</title><link ref="canonical" href="https://cecilia.cool/page/2/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.7.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">慕青的日记</div><div class="header-banner-info__subtitle">Cyan</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/08/Java/JVM/JVM(2)-%E5%AD%97%E8%8A%82%E7%A0%81%E5%A2%9E%E5%BC%BA/">JVM(2)--字节码增强</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-08</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-08</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="JVM基础-字节码增强"   >
          <a href="#JVM基础-字节码增强" class="heading-link"><i class="fas fa-link"></i></a><a href="#JVM基础-字节码增强" class="headerlink" title="JVM基础-字节码增强"></a>JVM基础-字节码增强</h1>
      <blockquote>
<p>字节码增强技术就是一类对现有字节码进行修改或者动态生成全新字节码文件的技术。</p>
</blockquote>

        <h2 id="ASM"   >
          <a href="#ASM" class="heading-link"><i class="fas fa-link"></i></a><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h2>
      <p>ASM可以直接生成<code>.class</code>字节码文件，也可以在类被加载入JVM之前动态修改类行为。ASM框架是JDK内部自带的，最基本的就是通过<code>ClassWriter</code>对象编辑类的字节码文件。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(ClassWriter.COMPUTE_MAXS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>在学习ASM前，请先学习一下<a href="https://cecilia.cool/2022/10/08/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%AE%BF%E9%97%AE%E8%80%85/">访问者模式</a>。</p>
</blockquote>
<p>字节码文件的结构是由JVM固定的，适合利用访问者模式对字节码文件进行修改。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/08/b57b44956364c1b6.jpg"></p>

        <h3 id="核心API"   >
          <a href="#核心API" class="heading-link"><i class="fas fa-link"></i></a><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h3>
      <ul>
<li><p><code>ClassReader</code>：用于读取已经编译好的.class文件。</p>
</li>
<li><p><code>ClassWriter</code>：用于重新构建编译后的类，如修改类名、属性以及方法，也可以生成新的类的字节码文件。</p>
</li>
<li><p>各种<code>Visitor</code>类：如上所述，CoreAPI根据字节码从上到下依次处理，对于字节码文件中不同的区域有不同的Visitor，比如用于访问方法的<code>MethodVisitor</code>、用于访问类变量的<code>FieldVisitor</code>、用于访问注解的<code>AnnotationVisitor</code>等。</p>
</li>
</ul>
<blockquote>
<p>API文档：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://tool.oschina.net/apidocs/apidoc?api=asm" >https://tool.oschina.net/apidocs/apidoc?api=asm</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>

        <h2 id="方法名和描述符"   >
          <a href="#方法名和描述符" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法名和描述符" class="headerlink" title="方法名和描述符"></a>方法名和描述符</h2>
      <p>这里补充一下类文件中方法名和描述符的表示。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>使用<code>jclasslib</code>插件查看一下：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/08/d03410a93bae253c.jpg"></p>
<p>可以看到，方法名在字节码文件中被<code>&lt;&gt;</code>包围，描述符其实就是返回值和参数列表，也都被<code>&lt;&gt;</code>包围。<code>&lt;()I&gt;</code>表示：</p>
<ul>
<li>括号里的是参数，后面的是返回值。</li>
<li><code>I</code>表示<code>int</code>，也就是说，该方法返回<code>int</code>，如果是<code>void</code>，这里就会是<code>V</code>。</li>
</ul>
<p>这样我们就固定了方法的方法名和参数列表以及返回值。从图中可以看到，<code>inc</code>方法上面还有个<code>&lt;init&gt;</code>方法，那就是构造方法。</p>
<p>如果方法参数中加入了对象：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">(String s,Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 描述符：&lt;(Ljava/lang/String;Ljava/lang/Object;)I&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">(<span class="type">char</span>[][] a)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 描述符：&lt;([[C)I&gt;</span></span><br></pre></td></tr></table></div></figure>

<p><code>L</code>开头表示是一个对象，参数之间要用<code>;</code>隔开。详细的读者可以自己写一些方法来看一下具体的效果。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/08/5d052fc53aef3cb4.jpg"></p>

        <h2 id="基本使用"   >
          <a href="#基本使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(ClassWriter.COMPUTE_MAXS);</span><br></pre></td></tr></table></div></figure>

<p>构造函数里的参数与操作数栈和局部临时变量表有关，不想琢磨，用<code>COMPUTE_MAXS</code>即可。</p>
<p>首先指定一下类的基本信息：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(ClassWriter.COMPUTE_MAXS);</span><br><span class="line">        <span class="comment">// 因为这里用到的常量比较多，所以说直接一次性静态导入：</span></span><br><span class="line">        <span class="comment">// import static jdk.internal.org.objectweb.asm.Opcodes.*;</span></span><br><span class="line">        writer.visit(V1_8, ACC_PUBLIC,<span class="string">&quot;com/JVM/Main&quot;</span>, <span class="literal">null</span>,</span><br><span class="line">                     <span class="string">&quot;java/lang/Object&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 第三个参数，需要根据自己的Main路径填写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>设定的基本信息依次是：版本–Java8，修饰符–<code>ACC_PUBLIC</code>，类名–要携带包名，标签–<code>null</code>，父类–<code>Object</code>。</p>
<p>将其保存，然后写入到自己生成的字节码文件当中：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(ClassWriter.COMPUTE_MAXS);</span><br><span class="line">        writer.visit(V1_8, ACC_PUBLIC,<span class="string">&quot;com/test/Main&quot;</span>, <span class="literal">null</span>,</span><br><span class="line">                     <span class="string">&quot;java/lang/Object&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//调用visitEnd表示结束编辑</span></span><br><span class="line">        writer.visitEnd();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>(<span class="type">FileOutputStream</span> <span class="variable">stream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./Main.class&quot;</span>))&#123;</span><br><span class="line">            stream.write(writer.toByteArray());  </span><br><span class="line">            <span class="comment">//直接通过ClassWriter将字节码文件转换为byte数组，并保存到根目录下</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>结果为：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/08/f0c63a80acdf6c29.jpg"></p>
<p>从class文件可知，<code>Main.class</code>没有构造方法，所以可以添加一个</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过visitMethod方法可以添加一个新的方法</span></span><br><span class="line"><span class="comment">// 放在writer.visitEnd();前面即可</span></span><br><span class="line">writer.visitMethod(ACC_PUBLIC, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></div></figure>

<p>再次编译，发现存在构造方法，之前讲了字节码文件中的方法名和描述符，读者可以自行修改描述符感受一下效果。</p>
<p>但是<code>Main</code>继承了<code>Object</code>类，所以在子类构造方法中应该调用父类的构造方法。也就是说，沃恩需要在方法中添加父类构造方法调用指令：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public com.test.Main();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1             // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 11: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/test/Main;</span><br></pre></td></tr></table></div></figure>

<p>所以我们开始访问代码（<code>visitCode()</code>)，也就是对方法进行详细i编辑：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过MethodVisitor接收返回值，进行进一步操作</span></span><br><span class="line"><span class="type">MethodVisitor</span> <span class="variable">visitor</span> <span class="operator">=</span> writer.visitMethod(ACC_PUBLIC, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始编辑代码</span></span><br><span class="line">visitor.visitCode();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Label用于存储行号，当前代码写到哪行了，l1得到的就是多少行</span></span><br><span class="line"><span class="type">Label</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加源代码行数对应表(字节码中的LineNumberTable)</span></span><br><span class="line">visitor.visitListNumber(<span class="number">11</span>,l1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同类型的指令需要不同方法调用</span></span><br><span class="line">visitor.visitVarInsn(ALOAD,<span class="number">0</span>);</span><br><span class="line">visitor.visitMethodInsn(INVOKESPECIAL, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">visitor.visitInsn(RETURN);</span><br><span class="line"></span><br><span class="line"><span class="type">Label</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">visitor.visitLabel(l2);</span><br><span class="line"><span class="comment">// 添加本地变量表(字节码中的LocalVariableTable)，这里是this关键字</span></span><br><span class="line">visitor.visiLocalVariable(<span class="string">&quot;this&quot;</span>,,<span class="string">&quot;Lcom/JVM/Main;&quot;</span>,<span class="literal">null</span>,l1, l2, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后设定最大栈深度和本地变量数</span></span><br><span class="line">visitor.visitMaxs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//结束编辑</span></span><br><span class="line">visitor.visitEnd();</span><br></pre></td></tr></table></div></figure>

<p>至此构造方法编辑完成，可以看到是非常麻烦的一件事，其实哪怕只是完成一个</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>都是非常复杂的一件事：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始安排main方法</span></span><br><span class="line"><span class="type">MethodVisitor</span> <span class="variable">v2</span> <span class="operator">=</span> writer.visitMethod(ACC_PUBLIC | ACC_STATIC, <span class="string">&quot;main&quot;</span>, </span><br><span class="line">                                      <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">v2.visitCode();</span><br><span class="line"><span class="comment">//记录起始行信息</span></span><br><span class="line"><span class="type">Label</span> <span class="variable">l3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">v2.visitLabel(l3);</span><br><span class="line">v2.visitLineNumber(<span class="number">13</span>, l3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先是int a = 10的操作，执行指令依次为：</span></span><br><span class="line"><span class="comment">// bipush 10     将10推向操作数栈顶</span></span><br><span class="line"><span class="comment">// istore_1      将操作数栈顶元素保存到1号本地变量a中</span></span><br><span class="line">v2.visitIntInsn(BIPUSH, <span class="number">10</span>);</span><br><span class="line">v2.visitVarInsn(ISTORE, <span class="number">1</span>);</span><br><span class="line"><span class="type">Label</span> <span class="variable">l4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">v2.visitLabel(l4);</span><br><span class="line"><span class="comment">//记录一下行信息</span></span><br><span class="line">v2.visitLineNumber(<span class="number">14</span>, l4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里是获取System类中的out静态变量（PrintStream接口），用于打印</span></span><br><span class="line">v2.visitFieldInsn(GETSTATIC, <span class="string">&quot;java/lang/System&quot;</span>, <span class="string">&quot;out&quot;</span>, <span class="string">&quot;Ljava/io/PrintStream;&quot;</span>);</span><br><span class="line"><span class="comment">//把a的值取出来</span></span><br><span class="line">v2.visitVarInsn(ILOAD, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//调用接口中的抽象方法println</span></span><br><span class="line">v2.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/io/PrintStream&quot;</span>, <span class="string">&quot;println&quot;</span>, <span class="string">&quot;(I)V&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//再次记录行信息</span></span><br><span class="line"><span class="type">Label</span> <span class="variable">l6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">v2.visitLabel(l6);</span><br><span class="line">v2.visitLineNumber(<span class="number">15</span>, l6);</span><br><span class="line"></span><br><span class="line">v2.visitInsn(RETURN);</span><br><span class="line"><span class="type">Label</span> <span class="variable">l7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">v2.visitLabel(l7);</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后是本地变量表中的各个变量</span></span><br><span class="line">v2.visitLocalVariable(<span class="string">&quot;args&quot;</span>, <span class="string">&quot;[Ljava/lang/String;&quot;</span>, <span class="literal">null</span>, l3, l7, <span class="number">0</span>);</span><br><span class="line">v2.visitLocalVariable(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="literal">null</span>, l4, l7, <span class="number">1</span>);</span><br><span class="line">v2.visitMaxs(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//终于OK了</span></span><br><span class="line">v2.visitEnd();</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>写之前就需要先写好Java程序进行反编译，再照着字节码一行一行使用<code>MathodVisitor</code>编辑。</p>
</blockquote>

        <h2 id="例子：实现AOP"   >
          <a href="#例子：实现AOP" class="heading-link"><i class="fas fa-link"></i></a><a href="#例子：实现AOP" class="headerlink" title="例子：实现AOP"></a>例子：实现AOP</h2>
      <blockquote>
<p>AOP–面向切面编程，Spring核心之一，如果你不了解AOP，就暂时理解为，在一个执行流程（模块）中，加入一个切面，通过这个切面的方法可以被切面加入一些操作，如记录日志啥的。</p>
</blockquote>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/08/972d8fa05bf61137.jpg"></p>
<p>我们希望通过ASM来实现AOP：在方法调用前后增加逻辑（也叫做前置通知和后置通知）。</p>
<p>具体代码实现感兴趣的读者可以参考：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/jvm/java-jvm-class-enhancer.html#%E5%AD%97%E8%8A%82%E7%A0%81%E5%A2%9E%E5%BC%BA%E6%8A%80%E6%9C%AF" >直接利用ASM实现AOP</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javase/keopmg" >https://www.yuque.com/qingkongxiaguang/javase/keopmg</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/jvm/java-jvm-class-enhancer.html" >https://pdai.tech/md/java/jvm/java-jvm-class-enhancer.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/05/Java/JVM/JVM(1)-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/">JVM(1)--类文件结构</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-07</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="类文件结构"   >
          <a href="#类文件结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1>
      <p>计算机是不能直接运行java代码的，必须要先运行java虚拟机，再由java虚拟机运行编译后的java代码。这个编译后的java代码，就是本文要介绍的java字节码。</p>
<ul>
<li>Java代码间接翻译成字节码，储存字节码的文件再交由运行于不同平台上的JVM虚拟机去读取执行，从而实现一次编写，到处运行的目的。</li>
<li>JVM也不再只支持Java，由此衍生出了许多基于JVM的编程语言，如Groovy, Scala, Koltin等等。</li>
</ul>
<blockquote>
<p>许多开发语言支持将源代码编译为<code>.class</code>字节码文件格式，以便交给JVM运行</p>
</blockquote>

        <h2 id="类文件信息"   >
          <a href="#类文件信息" class="heading-link"><i class="fas fa-link"></i></a><a href="#类文件信息" class="headerlink" title="类文件信息"></a>类文件信息</h2>
      <p>先写一个例子：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>编译生成<code>Test.class</code>文件。</p>
<blockquote>
<p>下载WinHex软件，以十六进制格式查看字节码文件（将编译好的<code>class</code>文件拖进去），每一位都是4个bit</p>
</blockquote>
<p>呈现出来的是酱紫的：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/06/227b1ae28c54688f.jpg"></p>
<p>但是winHex我这打开总是有些毛病，所以选择另一个工具（IEDA插件）查看十六进制字节码：</p>
<ul>
<li>安装插件：Binary&#x2F;hexadecimal editor。</li>
<li>右键class文件，选择Open As Binary。</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/06/995affe6c346a8aa.jpg"></p>
<p>有时直接查看16进制的结果不方便，为了能够方便查看字节码信息，需要安装另一个插件：</p>
<ul>
<li>安装插件：jclasslib Bytecode Viewer。</li>
<li>选中要查看的java文件（不是class文件），点击view（视图），再点击<code>show Bytecode with jclasslib</code>。</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/06/8f19ae55706ab1c2.jpg"></p>
<ul>
<li>这样查看字节码文件中的常量池什么的就非常方便。</li>
</ul>
<p>对于类文件信息，需要知道的部分如下图：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/05/868070b026d6842b.jpg"></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="魔数与版本"   >
          <a href="#魔数与版本" class="heading-link"><i class="fas fa-link"></i></a><a href="#魔数与版本" class="headerlink" title="魔数与版本"></a>魔数与版本</h3>
      <p>字节码文件前4个字节（32bit）组成了魔数，魔数机制检验该文件是否是JVM可以直接运行的字节码文件。字节码文件的魔数为：<strong>CAFFBABE</strong>。</p>
<p>魔数后面的4个字节存储的是字节码文件的版本号，前两个是次要版本号（现在基本不用了），后两个是主要版本号，将16进制换算成10进制之后，得到的可以参照：52代表JDK8编译的字节码文件（51是JDK7，53是JDK9）。</p>

        <h3 id="常量池"   >
          <a href="#常量池" class="heading-link"><i class="fas fa-link"></i></a><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3>
      <p><code>Constant pool</code>意为常量池，可以理解为<code>Class</code>文件中的资源仓库，是程序运行一些需要用到的常量数据，主要存放<strong>字面量</strong>和<strong>符号引用</strong>。字面量类似于Java中的常量概念，如文本字符串，<code>final</code>常量等。</p>
<p>符号引用属于编译原理的概念：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p>常量的数量不是确定的，所以在<strong>最开始的位置</strong>会存放常量池中<strong>常量的数量</strong>（是从1开始计算的，不是0，比如18，翻译为10进制就是24，所以实际上有23个常量）。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br></pre></td></tr></table></div></figure>

<p>每一项常量池里面的数据都是一个表，都是以_info结尾的（通过插件查看即可），有14种表。</p>

        <h3 id="访问标志"   >
          <a href="#访问标志" class="heading-link"><i class="fas fa-link"></i></a><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3>
      <p>两个字节，代表访问标志，用于识别一些类或者接口层次的访问信息，包括：Class是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/07/d412705d408b4988.jpg"></p>
<p>反编译一下<code>Test.class</code>文件查看访问标志：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p -private 显示所有类和成员</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-v -verbose 输出附加信息</span></span><br><span class="line">javap -verbose -p Test.class</span><br></pre></td></tr></table></div></figure>

<p>对于结果为：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/07/175494f35c4a5e2e.jpg"></p>

        <h3 id="类索引和接口索引集合"   >
          <a href="#类索引和接口索引集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#类索引和接口索引集合" class="headerlink" title="类索引和接口索引集合"></a>类索引和接口索引集合</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">u2             super_class;<span class="comment">//父类</span></span><br><span class="line">u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br></pre></td></tr></table></div></figure>

<p>在访问标志的反编译图中也可以看到<strong>当前类索引</strong>，<strong>父类索引</strong>，<strong>接口索引</strong>。</p>
<p><strong>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</strong></p>
<p><strong>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按<code>implents</code>(如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中。</strong></p>

        <h3 id="字段表集合"   >
          <a href="#字段表集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             fields_count;<span class="comment">//Class 文件的字段的个数</span></span><br><span class="line">field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段</span></span><br></pre></td></tr></table></div></figure>

<p>用于描述接口或类中声明的变量。不包括方法内部的局部变量。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/07/a82c68d88210068a.jpg"></p>
<ul>
<li><strong>access_flags:</strong> 字段的作用域（<code>public</code> ,<code>private</code>,<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写），各个修饰符都是布尔值，要么有某个修饰符，要么没有，适合使用标志位来表示。</li>
<li><strong>name_index:</strong> 对<strong>常量池</strong>的引用，表示的字段的名称；</li>
<li><strong>descriptor_index:</strong> 对常量池的引用，表示字段和方法的描述符；&#x2F;&#x2F;</li>
<li><strong>attributes_count:</strong> 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li>
<li><strong>attributes[attributes_count]:</strong> 存放具体属性具体内容。</li>
</ul>

        <h3 id="方法表集合"   >
          <a href="#方法表集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             methods_count;<span class="comment">//Class 文件的方法的数量</span></span><br><span class="line">method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br></pre></td></tr></table></div></figure>

<p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表（<code>method_info</code>）的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项（所以参照上图<code>field_info</code>）。</p>
<p>得到的结果（这里只看方法那部分）：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Chapter1.Test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC				<span class="comment">// 这就是access_flag取值</span></span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: getfield      #<span class="number">2</span>                <span class="comment">// Field m:I</span></span><br><span class="line">         <span class="number">4</span>: iconst_1</span><br><span class="line">         <span class="number">5</span>: iadd</span><br><span class="line">         <span class="number">6</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>其中<code>access_flag</code>取值为：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/07/f8a119d3fd7bb199.jpg"></p>
<blockquote>
<p>因为<code>volatile</code>修饰符和<code>transient</code>修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了<code>synchronized</code>、<code>native</code>、<code>abstract</code>等关键字修饰方法，所以也就多了这些关键字对应的标志。</p>
</blockquote>
<p>code内的主要属性为:</p>
<ul>
<li><strong>stack</strong>： 最大操作数栈，JVM运行时会根据这个值来分配栈帧(Frame)中的操作栈深度,此处为1<strong>（递归？）</strong></li>
<li><strong>locals</strong>：局部变量所需的存储空间，单位为Slot, Slot是虚拟机为局部变量分配内存时所使用的最小单位，为4个字节大小。方法参数(包括实例方法中的隐藏参数this)，显示异常处理器的参数(try catch中的catch块所定义的异常)，方法体中定义的局部变量都需要使用<strong>局部变量表</strong>来存放。值得一提的是，locals的大小并不一定等于所有局部变量所占的Slot之和，因为局部变量中的Slot是可以重用的。</li>
<li><strong>args_size</strong>：方法参数的个数，这里是1，因为每个实例方法都会有一个隐藏参数this</li>
<li><strong>attribute_info</strong>: 方法体内容，0,1,4为字节码”行号”，该段代码的意思是将第一个引用类型本地变量推送至栈顶，然后执行该类型的实例方法，也就是常量池存放的第一个变量，也就是注释里的<code>java/lang/Object.&quot;&quot;:()V</code>, 然后执行返回语句，结束方法。</li>
<li><strong>LineNumberTable</strong>：该属性的作用是描述源码行号与字节码行号(字节码偏移量)之间的对应关系。可以使用 -g:none 或-g:lines选项来取消或要求生成这项信息，如果选择不生成LineNumberTable，当程序运行异常时将无法获取到发生异常的源码行号，也无法按照源码的行数来调试程序。</li>
</ul>
<p>有时还会出现这个：</p>
<ul>
<li><strong>LocalVariableTable</strong>：该属性的作用是描述帧栈中局部变量与源码中定义的变量之间的关系。可以使用 -g:none 或 -g:vars来取消或生成这项信息，如果没有生成这项信息，那么当别人引用这个方法时，将无法获取到参数名称，取而代之的是arg0, arg1这样的占位符。 start 表示该局部变量在哪一行开始可见，length表示可见行数，Slot代表所在帧栈位置，Name是变量名称，然后是类型签名。</li>
</ul>

        <h3 id="属性表集合"   >
          <a href="#属性表集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br></pre></td></tr></table></div></figure>

<p>用于描述某些场景专有的信息。</p>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485250&idx=2&sn=33793bcce3f2ff31b83cf2f9c32df153&chksm=cea24889f9d5c19fa3e2b7d4f59762b59e6cd9e5e6564fe73c6993bd06e08bddd40cc0f3cba0&scene=0&xtrack=1&key=49cd1e59990c3d1f207865d32759f1ff2ae7fdf676f3b0a02ba49906a5af3ccdbd73e43bbe31515866f9748388c78cb9e4406d880eaf2d51afcf32168f3ad271769cc1c93cbfb0135046210b41d7d036&ascene=1&uin=MjMxMDk4NDI3&devicetype=Windows+7&version=62060739&lang=zh_CN&pass_ticket=J0+LnrNgEFouK4etBnwg1HUabsFw7ji5W1fiSveug54=" >谈谈Java类文件结构</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html" >https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://coolshell.cn/articles/9229.html" >https://coolshell.cn/articles/9229.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/luanlouis/article/details/39960815" >https://blog.csdn.net/luanlouis/article/details/39960815</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>《实战 Java 虚拟机》</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/jvm/java-jvm-class.html" >https://pdai.tech/md/java/jvm/java-jvm-class.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javase/keopmg" >https://www.yuque.com/qingkongxiaguang/javase/keopmg</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/04/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88(5)-WeakHashMap/">Java集合(5)--WeakHashMap</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-04</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="引用类型"   >
          <a href="#引用类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1>
      
        <h2 id="强引用"   >
          <a href="#强引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2>
      <p>最普遍的引用，如果一个对象<strong>具有</strong>强引用，GC绝不会回收。如果不使用，要弱化引用</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">o = <span class="literal">null</span>;<span class="comment">// help GC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">test方法内部有一个强引用，引用保存在栈中，new的对象保存在</span></span><br><span class="line"><span class="comment">堆中，当方法运行结束会退出方法栈，则引用内容的引用不存在，Object</span></span><br><span class="line"><span class="comment">就会被回收。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>如果o是全局变量，需要在不用对象时赋值为null。</p>
</blockquote>

        <h2 id="软引用"   >
          <a href="#软引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2>
      <p>一个对象只有软引用，在内存空间足够时，垃圾回收器不会回收它；当内存空间不足，就会回收这些对象的内存。</p>
<blockquote>
<p>软引用可以用于实现内存敏感的高速缓存。</p>
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弱引用</span></span><br><span class="line">SoftReference&lt;String&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(str);</span><br></pre></td></tr></table></div></figure>

<p>浏览器的后退按钮，后退时显示的网页应该是重新进行请求还是从缓存中取出的取决于具体的实现策略。如果将浏览的网页全部强引用存储到内存中，就会造成浪费甚至内存溢出。</p>
<p>此时使用软引用：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Browser</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Browser</span>();<span class="comment">// 页面浏览</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浏览后设为软引用</span></span><br><span class="line"><span class="type">SoftReference</span> <span class="variable">sr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SoftReference</span>(prev);</span><br><span class="line"><span class="keyword">if</span>(sr.get != <span class="literal">null</span>) &#123;</span><br><span class="line">    rev = (Browser) sr.get();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    prev = <span class="keyword">new</span> <span class="title class_">Broswer</span>();<span class="comment">// 内存吃紧，软引用对象回收</span></span><br><span class="line">    sr = <span class="keyword">new</span> <span class="title class_">SoftReference</span>(prev);<span class="comment">// 重新构建</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="弱引用"   >
          <a href="#弱引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2>
      <p>区别于软引用，只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">WeakReference&lt;String&gt; abcWeakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;String&gt;(str);</span><br><span class="line"></span><br><span class="line">str=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以恢复强引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">abc</span> <span class="operator">=</span> abcWeakRef.get();</span><br></pre></td></tr></table></div></figure>


        <h2 id="虚引用"   >
          <a href="#虚引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2>
      <p>虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p>
<p> 虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。</p>

        <h1 id="WeakHashMap"   >
          <a href="#WeakHashMap" class="heading-link"><i class="fas fa-link"></i></a><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h1>
      <p>先看一下<strong>引用队列</strong>：</p>
<ul>
<li>一般情况，一个对象被标记为垃圾（不代表回收了），会加入到引用队列。</li>
<li>对于虚引用来说，它指向的对象会只有被<strong>回收后</strong>才会加入到引用队列（其他是被标记），所以可以用作记录该引用指向的对象是否被回收。</li>
</ul>
<p><code>WeakHashMap</code>与<code>HashMap</code>没什么区别，只是引用采取的是弱引用的<code>key</code>存储，**GC回收的是<code>key</code>**。这种结构适合缓存处理。底层是因为<code>Entry</code>继承了<code>WeakReference</code>。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> </span><br><span class="line">    							<span class="title class_">WeakReference</span>&lt;Object&gt;</span><br><span class="line">                                <span class="keyword">implements</span></span><br><span class="line">                                <span class="title class_">Map</span>.Entry&lt;K,V&gt; </span><br><span class="line">&#123;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Entry(Object key, V value,</span><br><span class="line">          ReferenceQueue&lt;Object&gt; queue,</span><br><span class="line">          <span class="type">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(key, queue);</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.hash  = hash;</span><br><span class="line">        <span class="built_in">this</span>.next  = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>为了将<code>key</code>改写为弱引用，在<code>Entry</code>中又调用了一个<code>super(key, queue)</code>。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WeakReference构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">WeakReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; q)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(referent, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><code>WeakHashMap</code>除了<code>WeakReference</code>，还有<code>ReferenceQueue</code>重要。</p>
<blockquote>
<p>再次强调一下，<code>WeakHashMap</code>基于弱引用可以淘汰内部元素，同样的，<code>LinkedHashMap</code>也是具备淘汰机制的，只不过是通过阈值来限定节点个数的先进先出缓存。</p>
</blockquote>

        <h2 id="弱引用回收"   >
          <a href="#弱引用回收" class="heading-link"><i class="fas fa-link"></i></a><a href="#弱引用回收" class="headerlink" title="弱引用回收"></a>弱引用回收</h2>
      <p><code>Reference</code>类有一段静态代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Lock</span> &#123; &#125;;</span><br><span class="line"><span class="comment">// 有一个全局锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lock</span>();  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Reference</span> <span class="variable">pending</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">          </span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="type">ThreadGroup</span> <span class="variable">tg</span> <span class="operator">=</span> Thread.currentThread().getThreadGroup();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">ThreadGroup</span> <span class="variable">tgn</span> <span class="operator">=</span> tg;</span><br><span class="line">         tgn != <span class="literal">null</span>;</span><br><span class="line">         tg = tgn, tgn = tg.getParent());</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceHandler</span>(tg, <span class="string">&quot;Reference Handler&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 优先级最高</span></span><br><span class="line">    handler.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">    handler.setDaemon(<span class="literal">true</span>);</span><br><span class="line">    handler.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>假设<code>WeakHashMap</code>对象里面保存了很多对象引用：</p>
<ul>
<li>GC时，会创建一个CMST线程进行GC，该线程被创建的同时还会创建一个SLT线程并启动。</li>
<li>CMST开始GC时，会发送一个消息给SLT让他去获取Java层<code>Reference</code>对象的全局锁<code>lock</code>。</li>
<li>当GC完毕时，JVM会将WeakHashMap中所有被回收的对象所属的<code>WeakReference</code>容器对象放入到<code>Reference</code>的<code>pending</code>属性中（每次GC完毕后，<code>pending</code>属性基本上不会为null了）。</li>
<li>然后通知SLT释放并且<code>notify</code>全局锁<code>lock</code>，此时激活了<code>ReferenceHandler</code>线程的<code>run</code>方法，脱离wait状态开始运行。</li>
<li><code>Handler</code>线程会将pending中所有<code>WeakReference</code>对象移动到各自队列中（比如当前这个<code>WeakReference</code>属于某个<code>WeakHashMap</code>对象，那么它就会被放入相应的<code>ReferenceQueue</code>列队里面（该列队是链表结构））。</li>
</ul>
<p>最后看一下<code>ReferenceHandler</code>的源码，如何将<code>WeakRenference</code>压入队列：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReferenceHandler</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class="line">        <span class="built_in">super</span>(g, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Reference r;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pending != <span class="literal">null</span>) &#123;</span><br><span class="line">            r = pending;</span><br><span class="line">            <span class="type">Reference</span> <span class="variable">rn</span> <span class="operator">=</span> r.next;</span><br><span class="line">            pending = (rn == r) ? <span class="literal">null</span> : rn;</span><br><span class="line">            r.next = r;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException x) &#123; &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Fast path for cleaners</span></span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> Cleaner) &#123;</span><br><span class="line">            ((Cleaner)r).clean();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ReferenceQueue</span> <span class="variable">q</span> <span class="operator">=</span> r.queue;</span><br><span class="line">        <span class="keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;                 </span><br></pre></td></tr></table></div></figure>

<p>在调用<code>get()</code>，<code>replaceAll()</code>，<code>put()</code>，<code>remove()</code>等方法时（都需要获取<code>table</code>）,不是直接拿到<code>table</code>数组，而是通过<code>getTable()</code>方法先把数组中<code>key</code>为<code>null</code>的<code>Entry</code>删除掉在返回。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry&lt;K,V&gt;[] getTable() &#123;</span><br><span class="line">    <span class="comment">// 真正删除Entry的执行者 </span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>在<code>expungeStaleEntries()</code>方法中，存储被GC回收对象的<code>queue</code>会接收GC发送的回收消息，将queue（通过<code>synchronized</code>上锁）中的<code>key</code>对应的<code>value</code>赋值为<code>null</code>，即<code>help GC</code>。</p>
<blockquote>
<p><code>Entry</code>中保存了hash码，即使<code>key</code>被GC了，仍可以通过hash码来定位需要被删除的<code>Entry</code>。通过<code>Entry</code>的地址在冲突链表中定位（其实我觉得也可以判断<code>Entry.key == null</code>。</p>
</blockquote>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/phlive/p/6030446.html" >https://www.cnblogs.com/phlive/p/6030446.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.jianshu.com/p/2ba55345fd94" >https://www.jianshu.com/p/2ba55345fd94</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/shkstart/article/details/107019371?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-107019371-blog-106545340.pc_relevant_multi_platform_whitelistv4&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-107019371-blog-106545340.pc_relevant_multi_platform_whitelistv4&utm_relevant_index=3" >一文带你了解WeakHashMap</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>.</p>
<p>这篇讲得可以：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_33774883/article/details/89613271" >https://blog.csdn.net/weixin_33774883/article/details/89613271</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/03/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88(4)-TreeMap/">Java集合(4)-TreeMap</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-03</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-04</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h1>
      <p>首先，<code>TreeMap</code>与哈希没有任何关系，其次，哈希和Map也不是一回事，请不要先入为主。Map只是一个键值对的数据结构，哈希是将对象计算哈希码的一种算法。<code>TreeMap</code>只是通过红黑树将键值对存起来，一方面实现了二叉搜索树的排序性，另一方面维护了整棵树的平衡性，防止树退化为链表增大查询&#x2F;插入的时间复杂度。</p>

        <h1 id="排序方式"   >
          <a href="#排序方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#排序方式" class="headerlink" title="排序方式"></a>排序方式</h1>
      <p><code>TreeMap</code>对插入数据实现了排序，如果是自定义数据，要么该类实现<code>Comparable</code>接口，要么TreeMap在构造方法中传入<code>Comparator</code>接口。</p>

        <h2 id="Comparable"   >
          <a href="#Comparable" class="heading-link"><i class="fas fa-link"></i></a><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h2>
      <p>以<code>Student</code>类来说明，继承<code>Comparable</code>并重写<code>compareTo()</code>方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;<span class="comment">// 为了简单，就写一个id属性,并设为public方便获取</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id)</span> &#123;<span class="built_in">this</span>.id = id;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对比方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">        <span class="comment">// 按照id从小到大排序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.id - o.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>在<code>CompareTo()</code>中，是传入的对象和当前对象进行对比：</p>
<ul>
<li>如果对比大于0，降序排序。</li>
<li>如果对比小于0，升序。</li>
</ul>
<blockquote>
<p>其实记住当前对象-传入对象就是升序，反之则降序。</p>
</blockquote>

        <h2 id="Comparator"   >
          <a href="#Comparator" class="heading-link"><i class="fas fa-link"></i></a><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h2>
      <p>通过外部类的方式进行编写，对于<code>Comparator</code>接口的传入也可以用<code>Lambda</code>表达式</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1,Student o2)</span> &#123;</span><br><span class="line">        <span class="comment">// 第一个参数 - 第二个参数：升序</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(o1.id - o2.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以传入Lambda表达式</span></span><br><span class="line">Collections.sort(list,(Student o1,Student <span class="number">02</span>) -&gt; o1.id - o2.id);</span><br></pre></td></tr></table></div></figure>

<p>我们看一下<code>TreeMap</code>的部分属性和构造方法：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableMap</span>&lt;K,V&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传入一个Comparator接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">()</span> &#123;comparator = <span class="literal">null</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>如果没有传入<code>Comparator</code>接口实现，那么传入的<code>Key</code>必须实现<code>Comparable</code>。</p>
<blockquote>
<p><code>TreeMap</code>底层用红黑树，红黑树近似平衡，最长路径不超过最短路径的2倍。</p>
</blockquote>

        <h1 id="TreeMap"   >
          <a href="#TreeMap" class="heading-link"><i class="fas fa-link"></i></a><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h1>
      <p><code>TreeMap</code>的UML类图：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/03/a6778fc1ccf85111.jpg"></p>
<p>因为底层使用了红黑树，所以节点就是<code>Entry</code>，记录了左右节点和父节点指针，以及节点颜色。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> BLACK;</span><br><span class="line">	<span class="comment">// 构造方法，此处不写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>关于红黑树，详细的实现，也就是节点如何变色，如何左旋右旋来维持近似平衡，可以看《算法导论》，本文不会详细去讲，作者曾经也自己看着书写过红黑树，当成C++期末作业交上去了，但是过了两三天又忘了，这玩意吧，看个人兴趣吧，hhhhhh。</p>
</blockquote>

        <h2 id="put"   >
          <a href="#put" class="heading-link"><i class="fas fa-link"></i></a><a href="#put" class="headerlink" title="put()"></a>put()</h2>
      <p>直接给出<code>put</code>的执行流程：</p>
<ul>
<li>判断当前根节点为null，那么插入的第一个元素就是根节点。</li>
<li>如果存在根节点，判断插入元素在左侧还是右侧，如果对比为0，说明当前元素存在于<code>TreeMap</code>中，将其覆盖：<strong>在TreeMap中，不会存在重复元素</strong>。</li>
<li>找到插入位置，插入。</li>
<li>节点变色和旋转操作。</li>
</ul>
<blockquote>
<p>代码太长了，要看源码自己打开IDEA查看。从<code>put</code>流程也可知，时间复杂度为<em>logN</em>。</p>
</blockquote>

        <h2 id="get"   >
          <a href="#get" class="heading-link"><i class="fas fa-link"></i></a><a href="#get" class="headerlink" title="get()"></a>get()</h2>
      <p>也就是不断地对比，在红黑树中查找节点。</p>

        <h1 id="TreeSet"   >
          <a href="#TreeSet" class="heading-link"><i class="fas fa-link"></i></a><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h1>
      <p>这个就是对TreeMap进行了简单包装，不过多讲解</p>
<blockquote>
<p>额，其实关于<code>TreeMap</code>的详解应该是对红黑树的详解，但是我真的不想写，啊啊啊啊啊，以后有时间就单独写一篇博客解释一下红黑树，顺便放一个源码模板方便各位使用（等我想起了再说吧）。</p>
</blockquote>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_51192504/article/details/109775797" >https://blog.csdn.net/weixin_51192504/article/details/109775797</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/collection/java-map-TreeMap&amp;TreeSet.html" >https://pdai.tech/md/java/collection/java-map-TreeMap&amp;TreeSet.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/02/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88(3)-LinkedHashMap/">Java集合3-LinkedHashMap</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-02</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-02</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h1>
      <p><code>LinkedHashSet</code>也是用了适配器模式，对<code>LinkedHashMap</code>进行包装，所以本文主要分析<code>LinkedHashMap</code>。</p>
<p>从名字上可以看出容器是<em>Linked list</em>和<em>HashMap</em>的混合体，<strong>可以将<em>LinkedHashMap</em>看作采用<em>linked list</em>增强的<em>HashMap</em></strong>。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">HashMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><code>LinkedHashMap</code>是<code>HashMap</code>的直接子类，它的区别在于在<code>HashMap</code>的基础上采用双向链表将所有的数据节点都链接起来了，就是为了<strong>保证元素的迭代顺序和插入顺序相同</strong>。</p>
<p>还有个好处就是集合迭代时不需要遍历整个<code>table</code>，逮着双向链表的<code>header</code>遍历即可。</p>
<blockquote>
<p><code>LinkedHashMap</code>为了性能，是非同步的，多线程下需要手动同步</p>
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 也可以打包成同步的</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">m</span> <span class="operator">=</span> Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>(...));</span><br></pre></td></tr></table></div></figure>




        <h1 id="方法剖析"   >
          <a href="#方法剖析" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h1>
      <blockquote>
<p><code>get</code>方法和<code>HashMap</code>里的没什么区别，不多说。</p>
</blockquote>

        <h2 id="put"   >
          <a href="#put" class="heading-link"><i class="fas fa-link"></i></a><a href="#put" class="headerlink" title="put()"></a>put()</h2>
      <p>插入分为两部分：</p>
<ul>
<li>将元素插入<code>table</code>中，如果有哈希冲突，头插法插入到头部。</li>
<li>将元素插入双向链表中，链表尾部。</li>
</ul>
<p>其实就是在<code>HashMap</code>上加入链表的引用的修改。</p>
<p><code>LinkedHashMap</code>使用的节点是<code>Entrty</code>，该类继承了<code>HashMap</code>的<code>Node</code>类。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="remove"   >
          <a href="#remove" class="heading-link"><i class="fas fa-link"></i></a><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2>
      <p>删除也有两部分：</p>
<ul>
<li>将元素从<code>table</code>中删除。</li>
<li>将元素从双向链表中删除。</li>
</ul>

        <h1 id="经典用法"   >
          <a href="#经典用法" class="heading-link"><i class="fas fa-link"></i></a><a href="#经典用法" class="headerlink" title="经典用法"></a>经典用法</h1>
      <p>实现FIFO替换策略的缓存，<code>LinkedHashMap</code>有一个方法，作用是告诉Map删除最老的<code>Entry</code>，也就是最早插入Map的Entry。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>每次插入新元素时<code>LinkedHashMap</code>都会询问该函数是否要删除最老的元素，</p>
<blockquote>
<p><code>LinkedHashMap</code>并没有重写<code>put</code>方法，而是重写的<code>newNode</code>方法，因为<code>newNode</code>就是将要插入的键值对插放到新创建的节点中，在创建节点后马上将其加入到双向链表中即可。</p>
</blockquote>
<p>只要在子类中重载该方法，当元素个数超过一定数量时让<code>removeEldestEntry</code>返回<code>true</code>，就能实现一个固定大小的FIFO策略的缓存。其实我们写个子类继承<code>LinkedList</code>并重写一下<code>add</code>方法也是可以实现的，只是说，是哟个<code>LinkedHashMap</code>更加方便。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 一个固定大小的FIFO替换策略的缓存 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FIFOCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> cacheSize;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FIFOCache</span><span class="params">(<span class="type">int</span> cacheSize)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.cacheSize = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当Entry个数超过cacheSize时，删除最老的Entry</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> size() &gt; cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/collection/java-map-LinkedHashMap&amp;LinkedHashSet.html" >https://pdai.tech/md/java/collection/java-map-LinkedHashMap&amp;LinkedHashSet.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/u014203449/article/details/80194704" >https://blog.csdn.net/u014203449/article/details/80194704</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/02/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88(2)-HashMap/">Java集合(2)--HashMap</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-02</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-04</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h1>
      <p>关于这些集合的讲解，作者默认读者都知道该如何使用，所以不会从最基础的开始讲起，会直接跳过什么是映射关系，哈希值等概念的讲解。对于源码的解析也是最主要使用的那些方法。</p>

        <h1 id="一些概念"   >
          <a href="#一些概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h1>
      <ul>
<li>负载因子：集合容量都有上限，如果加入集合的数量超过一定允许值，集合就会扩容。负载因子就是衡量当前情况是否需要进行扩容的标准。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果数据占用率达到75%，就会扩容，扩容会重新计算哈希值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>红黑树：一种数据结构，在<code>HashMap</code>里面查询效率是<em>logN</em>，整棵树在插入数据时始终保持近似平衡（不是真的平衡）。JDK1.8后就用红黑树代替<code>HashMap</code>里面的长度超过8的冲突链表了。</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/02/760aca61cab61cfc.jpg"></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><code>TreeNode</code>就是为了实现红黑树而设计的内部类。</p>
<blockquote>
<p><code>HashMap</code>的初始容量是否应该设的比较大，在JDK1.7以前，HashMap用的是冲突链表，HashMap在迭代时，需要遍历整个数组和冲突链表。如果迭代频繁的话，就不宜将初始大小设的过大。</p>
</blockquote>
<ul>
<li><code>modCount</code>：集合只要可以使用迭代器，都需要<code>modCount</code>来记录修改次数。</li>
<li>实现<code>Map</code>接口：允许<code>key</code>和<code>value</code>都是<code>null</code>。</li>
</ul>

        <h1 id="核心方法"   >
          <a href="#核心方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h1>
      <p>有时会将Java7的方法拿出来和Java8作比较。</p>
<p>在Java7使用Entry代表数据节点，Java8使用Node，基本没有区别，都是<code>key</code>，<code>value</code>，<code>hash</code>，<code>next</code>四个属性。<code>Node</code>只能适用于链表，<code>TreeNode</code>用于红黑树。</p>

        <h2 id="put"   >
          <a href="#put" class="heading-link"><i class="fas fa-link"></i></a><a href="#put" class="headerlink" title="put()"></a>put()</h2>
      <blockquote>
<p><code>put</code>方法重点也是在于得到哈希值，然后就是处理一下<strong>扩容</strong>，<strong>哈希冲突</strong>，<strong>链表转化红黑树</strong>等问题。</p>
</blockquote>
<p>Java7是先扩容再插入值，Java8是先插入值再扩容。第一次<code>put</code>需要初始化一下<code>table</code>数组（从<code>null</code>初始化到默认容量16或者自定义容量），才能加入数据。</p>
<p>需要注意的是，如果两次使用<code>put</code>时，加入的<code>key</code>都是相同的，那么第二次的<code>value</code>应该覆盖第一次的，所以在<code>put</code>时也应该考虑到这一点，<strong>发生哈希冲突应该首先检查Key是不是相同的再进行下一步操作</strong>。</p>
<p>重点讲一下扩容操作：扩容时需要重新<code>hash</code>，并不是说要重新调用<code>hash</code>这个函数，<code>Node(TreeNode)</code>节点之前就保存了<code>hash</code>值的。</p>
<p>如果<code>hash</code>值超过了容量<code>cap</code>，需要取余操作，因为<code>cap</code>都是2的指数，所以<code>cap-1</code>（最大下标）的低位就全是1，取余操作就可以为：<code>hash &amp; (cap - 1)</code>。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/02/d1b17259fca6ec00.jpg"></p>
<p>所以一条冲突链表上的数据节点的哈希值并不一定都是相同的，可能是取余后才导致下标相同。所以在重新哈希的过程中，就需要对冲突链表拆分为两条链表，一条链表是哈希值本来就是当前下标，另一个是哈希值被取余了的（这条链表上也并不是哈希值都相同，只是取余后值都相同，5和7被2取余值也相同嘛）。</p>
<p>因为每次扩容都是容量乘2，所以后一条链表的新下标就是<code>i+cap</code>。</p>
<blockquote>
<p><code>i&lt;cap，(i+cap) % 2cap = i+cap</code>。</p>
</blockquote>

        <h2 id="get"   >
          <a href="#get" class="heading-link"><i class="fas fa-link"></i></a><a href="#get" class="headerlink" title="get()"></a>get()</h2>
      <blockquote>
<p><code>get</code>方法内部最重要的就是<code>hash()</code>得到其哈希值，然后再通过<code>equals()</code>找到对应的值。</p>
</blockquote>
<p>理解了<code>put</code>的机制和哈希值取余原理后，<code>get</code>分析就比较简单了。</p>
<ul>
<li><p>计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1)。</p>
</li>
<li><p>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步。</p>
</li>
<li><p>判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步。</p>
</li>
<li><p>遍历链表，直到找到相等(&#x3D;&#x3D;或equals)的 key。</p>
</li>
</ul>

        <h1 id="HashSet"   >
          <a href="#HashSet" class="heading-link"><i class="fas fa-link"></i></a><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1>
      <p><code>HashSet</code>使用了适配器模式，对<code>HashMap</code>进行了简单的包装，对<code>HashSet</code>的函数调用都会转换成合适的<code>HashMap</code>方法。这里提一下，不需要过多赘述。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashSet是对HashMap的简单包装</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;<span class="comment">//HashSet里面有一个HashMap</span></span><br><span class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;<span class="comment">//简单的方法转换</span></span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/collection/java-map-HashMap&amp;HashSet.html" >https://pdai.tech/md/java/collection/java-map-HashMap&amp;HashSet.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javase/syy4rz#b2b51e41" >https://www.yuque.com/qingkongxiaguang/javase/syy4rz#b2b51e41</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet%20and%20HashMap.md#get" >https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet%20and%20HashMap.md#get</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/01/Java/%E5%B9%B6%E5%8F%91/Java%E5%85%B3%E9%94%AE%E5%AD%97-volatile/">Java关键字volitale</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-01</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-01</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="volatile关键字"   >
          <a href="#volatile关键字" class="heading-link"><i class="fas fa-link"></i></a><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1>
      <p>并发存在的问题主要是可见性，原子性，有序性。原子性可以通过<code>synchronized</code>实现同步，可见性，有序性通过<code>volatile</code>解决。</p>
<p>可见性：CPU直接和内存交互太慢了，所以CPU直接和缓存交互。在多核CPU中，每个CPU各自有一个缓存，在A修改了某一变量时，可能来不及写入内存并让其他CPU读取，造成修改的不可见。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/01/14eaf6c457e413c7.jpg"></p>
<blockquote>
<p>缓存一致性协议就是为了解决一致性问题。</p>
</blockquote>
<p><code>volatile</code>可以保证可见性，当某一个线程修改了被<code>volatile</code>修饰的变量后，其他线程会马上更新这个变量。但是它依然不能解决原子性问题，就像那个最经典的多个线程<code>i++</code>一样，自增操作是被瓜分为了多个步骤完成的，虽然保证了可见性，但是只要手速够快，依然会出现两个线程同时写同一个值的问题（比如线程1刚刚将a的值更新为100，这时线程2可能也已经执行到更新a的值这条指令了，<strong>已经刹不住车了</strong>，所以依然会将a的值再更新为一次100）。</p>
<p>此处顺便介绍一下<strong>Java内存模型（JMM）</strong>：采用了类似的模型支持多线程</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/01/4d01a61364ae80bf.jpg"></p>
<ul>
<li>所有的变量全部存储在主内存。</li>
<li>每条线程有着自己的工作内存，线程对变量的所有操作，必须在工作内存中进行，不能直接操作主内存中的数据。</li>
<li>不同线程之间的工作内存相互隔离，如果需要在线程之间传递内容，只能通过主内存完成，无法直接访问对方的工作内存。</li>
</ul>
<p>有序性：为了优化程序，编译时会对指令进进行重排序，有可能暴露出未初始化的空内存出来。以双重检查的单例模式为例：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleInstance</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SignleInstance instance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SignleInstance <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//锁住这个类，无论哪个实例来执行这段代码都要拿到锁</span></span><br><span class="line">            <span class="keyword">synchronized</span>(SignleInstance.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">SingleInstance</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>对于<code>instance = new SingeInstance()</code>，正常的CPU指令为：</p>
<ol>
<li>分配内存空间</li>
<li>初始化对象</li>
<li>将instance引用指向内存空间</li>
</ol>
<p>但是重排序后可能执行顺序就是：</p>
<ol>
<li>分配内存空间</li>
<li>将instance引用指向内存空间</li>
<li>初始化对象</li>
</ol>
<p>如果线程在执行完2后中断，其他的线程再来执行<code>getInstance()</code>方法，就会拿到一个没有初始化的instance。</p>
<blockquote>
<p><code>volaitle</code>关键字可以产生内存屏障防止重排序。</p>
</blockquote>

        <h1 id="应用场景"   >
          <a href="#应用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1>
      <p>上面单例模式中为了解决重排序就可以使用<code>volatie</code>。</p>

        <h2 id="模式1：状态标志"   >
          <a href="#模式1：状态标志" class="heading-link"><i class="fas fa-link"></i></a><a href="#模式1：状态标志" class="headerlink" title="模式1：状态标志"></a>模式1：状态标志</h2>
      <p>用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> shutdownRequest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123; shutdownRequested = <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">while</span> (!shutdownRequested) &#123; </span><br><span class="line">        <span class="comment">// do stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="模式2：独立观察"   >
          <a href="#模式2：独立观察" class="heading-link"><i class="fas fa-link"></i></a><a href="#模式2：独立观察" class="headerlink" title="模式2：独立观察"></a>模式2：独立观察</h2>
      <p>安全使用 volatile 的另一种简单模式是定期 发布 观察结果供程序内部使用。例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> String lastUser;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">authenticate</span><span class="params">(String user, String password)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> passwordIsValid(user, password);</span><br><span class="line">        <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            activeUsers.add(u);</span><br><span class="line">            lastUser = user;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="模式3：volatile-bean模式"   >
          <a href="#模式3：volatile-bean模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#模式3：volatile-bean模式" class="headerlink" title="模式3：volatile bean模式"></a>模式3：volatile bean模式</h2>
      <p>在volatile bean模式中，JavaBean所有数据成员都是volatile类型，并且getter，setter方法必须非常普通—— 除了获取或设置相应的属性外，不能包含任何逻辑。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> age;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFirstName</span><span class="params">()</span> &#123; <span class="keyword">return</span> firstName; &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLastName</span><span class="params">()</span> &#123; <span class="keyword">return</span> lastName; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirstName</span><span class="params">(String firstName)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLastName</span><span class="params">(String lastName)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p>冰河《深入理解高并发编程》第一版</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/thread/java-thread-x-key-volatile.htm" >https://pdai.tech/md/java/thread/java-thread-x-key-volatile.htm</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/javase/vd60g5#21cd9456" >https://www.yuque.com/qingkongxiaguang/javase/vd60g5#21cd9456</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/10/01/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">网络协议</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-10-01</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-01</span></span></div></header><div class="post-body"><div class="post-excerpt"><blockquote>
<p>整个网络协议与工具线路参照pdai的<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/develop/protocol/dev-protocol-overview.html" >Java全栈知识体系</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>学习，前半部分关于计算机网络的知识，padi也是直接使用了博客园的博主<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://home.cnblogs.com/u/googny/" >桂城老托尼</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>关于《计算机网络第五版》（谢希仁）的<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/googny/p/3682280.html" >读书笔记</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，在学习期间，作者也会参考《计算机网络-自顶向下方法》进行内容补充。</p>
</blockquote>

        <h1 id="计算机网络基础"   >
          <a href="#计算机网络基础" class="heading-link"><i class="fas fa-link"></i></a><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h1>
      <blockquote>
<p>如果学计算机网络觉得看文字过于枯燥，可以看一下中科大的<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1JV411t7ow/?spm_id_from=333.337.search-card.all.click&vd_source=5acf5a7b23d28e7633e5a9b381c57c42" >郑烇老师</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>的计算机网络的课。</p>
</blockquote>

        <h2 id="因特网概述"   >
          <a href="#因特网概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#因特网概述" class="headerlink" title="因特网概述"></a>因特网概述</h2>
      <p>一个网络可能由光纤，路由器，计算机（包括服务器）等组成，本质上就是结点和链路的组成。而<strong>因特网则是把许多网络连接在一起</strong>。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/01/4851be18068b1041.jpg"></p>
<p>组成：</p>
<ul>
<li>边缘部分：由所有连接在因特网的主机组成，这些主机又叫做端系统(end system)。</li>
<li>核心部分：大量网络和连接这些网络的<strong>路由器</strong>组成，为边缘部分提供服务的。</li>
</ul>
<p>计算机通信方式：</p>
<ul>
<li>客户服务器方式–C&#x2F;S方式，一般是客户端发起通信，否则服务端不知道客户端IP。</li>
<li>对等方式–P2P方式（Peer-to-Peer），两个主机都运行了对等连接软件，可以平等，对等连接通信。</li>
</ul>
<p>因特网中的核心部分最复杂，起特殊作用的是路由器（Router），实现分组交换。比如某一主机现需要发送一段较长的数据，发送时就会将这段数据分为一个个的分组，加上首部（事实上，我们说一个分组时，已经认为其包含了首部）。首部包含了一些有用的信息，比如这个分组实际承载的数据多大，目标地址等。</p>
<p>分组交换网中的结点交换机根据收到的分组的首部中的地址信息，把分组转发到下一个结点交换机。用这样的存储转发方式，最后分组就能到达最终目的地。接收端收到分组后剥去首部还原成报文。最后，在接收端把收到的数据恢复成为原来的报文。</p>

        <h2 id="路由器"   >
          <a href="#路由器" class="heading-link"><i class="fas fa-link"></i></a><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2>
      <p>路由器处理分组过程：</p>
<ul>
<li>把收到的分组先放入缓存（暂时存储）；</li>
<li>查找转发表，找出到某个目的地址应从哪个端口转发；</li>
<li>把分组送到适当的端口转发出去。</li>
</ul>
<blockquote>
<p>请区分好路由器和主机的区别，尽管都是因特网的节点，但是它们是不一样的。</p>
</blockquote>
<p>分组交换也存在许多问题，比如许多节点在经过同一个路由器分组转发时，需要排队，会造成一定时延，分组的首部也造成一定开销。</p>
<blockquote>
<p>除了分组交换，还有电路交换，在发送信息前，双方必须建立一条连接，路径上的交换机都将为该连接维护状态，并且预留了带宽，数据能够以恒定速率发送。</p>
</blockquote>
<p>对比：</p>
<p>早期面向终端的计算机网络是<strong>以单个主机为中心的星形网</strong>，各终端通过通信线路共享昂贵的中心主机的硬件和软件资源。分组交换网则是以网络为中心，主机都处在网络的外围。</p>

        <h2 id="网络分类"   >
          <a href="#网络分类" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络分类" class="headerlink" title="网络分类"></a>网络分类</h2>
      <p>不同作用范围：</p>
<ul>
<li>广域网 WAN（Wide Area Network），手机端移动设备是通过蜂窝网提供商运营的基站来发送和接收分组。用于仅需位于基站的数万米范围。</li>
<li>局域网 LAN（Local Area Network)，个人热点就是局域网，称为wlan–无线局域网（Wireless），WiFi是基于IEEEE 802.11技术的无线LAN接入，用户必须在接入点几十米范围内。</li>
<li>城域网 MAN</li>
<li>个人区域网 PAN</li>
</ul>
<p>根据使用者也可以分为公用网和专用网。</p>
<blockquote>
<p>重点需要提的是接入网AN（Access），由ISP–Internet Service Provider提供，起到让用户域因特网连接的桥梁作用。每个ISP自身就是一个由多台分组交换机和多段通信链路组成的网络。</p>
</blockquote>
<p>分组交换机除了路由器和链路层交换机，后者通常用于接入网，路由器用于网络核心中。</p>

        <h2 id="相关术语"   >
          <a href="#相关术语" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2>
      <p><strong>带宽</strong>：数字信道所能传送的最<strong>高数据率</strong>，单位是<strong>比特每秒b&#x2F;s</strong>。</p>
<p><strong>吞吐量</strong>：单位时间内通过某个网络（信道，接口）的数据量。</p>
<p><strong>传输时延（发送时延 ）</strong>：  发送数据时，数据块从结点进入到传输媒体所需要的时间。从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间，<strong>发送时延&#x3D;数据块长度&#x2F;带宽</strong>。</p>
<p><strong>传播时延</strong>  电磁波在信道中需要传播一定的距离而花费的时间，<strong>传播时延&#x3D;信道长度&#x2F;信号在信道上的传播速率</strong>。</p>
<p>处理时延和排队时延比较简单，跟路由器有关。</p>

        <h2 id="体系结构"   >
          <a href="#体系结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2>
      <p>经常使用的TCP&#x2F;IP协议是四层体系结构：应用层，运输层，网际层，网络接口层。和ISO折中之后，采用一种五层协议的体系结构：应用层，运输层，网络层，数据链路层，物理层。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/01/cd33ff3621dde413.jpg"></p>
<blockquote>
<p>还有UDP，这种传输协议不能对数据做出任何保证，即使在传播过程中出现丢失，比特突变，都不会做任何弥补措施，一般用于实时媒体软件，比如直播（数据丢了就丢了，无所谓）。</p>
</blockquote>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/googny/p/3682280.html" >https://www.cnblogs.com/googny/p/3682280.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>《计算机网络自顶向下》第一章</p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/29/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88(1)-PriorityQueue/">Java集合(1)--PriorityQueue</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-29</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-29</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="其他集合"   >
          <a href="#其他集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#其他集合" class="headerlink" title="其他集合"></a>其他集合</h1>
      <p>因为像ArrayList，LinkedList之类的容器比较简单，此处不会过多解释，只会列出一些需要注意的点。</p>
<p><strong>ArrayList</strong>：</p>
<ul>
<li>ArrayList为了效率没有实现同步，有需求的情况下需要自己实现。</li>
<li>向ArrayList中加入元素（add）时，都会进行容量检查，扩容都会交给grow方法。</li>
<li><code>remove</code>函数中，删除中间某一个元素会导致后面的元素向前移动，需要将最后一个位置赋为null（为了让GC起作用）。</li>
<li><code>tirmToSize()</code>，将数组容量修改为当前元素个数大小；<code>indexOf()</code>与<code>lastIndexOf()</code><br>就是获取元素第一次&#x2F;最后一次出现的index。</li>
<li><code>modCount</code>是指集合创建以来修改的次数，他保证在迭代器循环中，如果出现集合的修改就停止迭代。</li>
</ul>
<p><strong>LinkedList</strong>：</p>
<ul>
<li>LinkedList可以考虑作为栈&#x2F;队列，Java官方不建议使用Stack。但是ArrayDeque是栈或者队列的<br>首选，性能更好。</li>
<li>LinkedList没有哑节点，当链表为空的时候first和last都指向null。</li>
</ul>
<p><strong>ArrayDeque</strong>：</p>
<ul>
<li><p><code>Deque</code>是”double ended queue”, 表示双向的队列，英文读作”deck”.。</p>
</li>
<li><p>ArrayDeque是非线程安全的，不允许加入null。</p>
</li>
</ul>

        <h1 id="PriorityQueue"   >
          <a href="#PriorityQueue" class="heading-link"><i class="fas fa-link"></i></a><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h1>
      <p>优先队列保证每次取出的元素都是队列中最小的（构造时可以传入比较器<code>Comparator</code>，所以想要每次取出都是最大的，只需要反过来即可）。</p>
<p>PriorityQueue不允许放入<code>null</code>元素，<strong>内部通过数组实现小根堆</strong>，小根堆抽象上可以理解为完全二叉树。</p>
<p>数组映射完全二叉树的算数关系为：</p>
<ul>
<li><code>leftNode = ParentNode*2 + 1</code> </li>
<li><code>rightNode = ParentNode*2 + 2</code> </li>
<li><code>ParentNode = (node - 1)/2</code></li>
</ul>
<blockquote>
<p><em>PriorityQueue</em>的<code>peek()</code>和<code>element</code>操作是常数时间，<code>add()</code>, <code>offer()</code>, 无参数的<code>remove()</code>以及<code>poll()</code>方法的时间复杂度都是*log(N)*。</p>
</blockquote>
<p><code>add()</code>和<code>remove()</code>失败后就会抛出异常，而<code>offer()</code>和<code>poll()</code>就是返回<code>false</code>。</p>

        <h2 id="小根堆解析"   >
          <a href="#小根堆解析" class="heading-link"><i class="fas fa-link"></i></a><a href="#小根堆解析" class="headerlink" title="小根堆解析"></a>小根堆解析</h2>
      <p>此处不讲解PriorityQueue源码，而是理解小根堆的维护流程</p>
<p><strong>加入节点</strong>：队列只允许从队尾加入元素，大致流程如下图。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/29/a2497ab926b94de8.jpg"></p>
<p>删除节点：</p>
<ul>
<li>优先队列出队操作会导致根节点被删除，此时需要将最后一个节点放到根节点的位置在进行下降调整。</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/29/0681d1a809288d78.jpg"></p>
<ul>
<li>如果是其他关于小根堆的删除，当删除节点是尾节点时，直接删除即可。</li>
<li>当节点在中间，我们就只看以该节点尾根节点的子树，将数组最后一个节点移到当前节点，再调整。</li>
</ul>

        <h1 id="小根堆代码"   >
          <a href="#小根堆代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#小根堆代码" class="headerlink" title="小根堆代码"></a>小根堆代码</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟小根堆的增加</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>[] minHeap ,<span class="type">int</span> size , <span class="type">int</span> val)</span> &#123;</span><br><span class="line">      <span class="comment">// 假设参数合法，数组不出现越界</span></span><br><span class="line">      <span class="keyword">if</span>(size == <span class="number">0</span>) &#123; minHeap[size++] = val;<span class="keyword">return</span>;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当前父节点,index是当前val位于的位置</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (size - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>,index = size;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(minHeap[p] &gt; val) &#123;</span><br><span class="line">          minHeap[index] = minHeap[p];</span><br><span class="line">          <span class="keyword">if</span>(p == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">          index = p;</span><br><span class="line">          p = (p-<span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      minHeap[p] = val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span>[] minHeap , <span class="type">int</span> size , <span class="type">int</span> index)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(size-<span class="number">1</span> == index) &#123;minHeap[size] = -<span class="number">1</span>;<span class="keyword">return</span>;&#125;<span class="comment">// 假设-1为null</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/** 小根堆是完全二叉树，左节点下标为奇数，右节点为偶数</span></span><br><span class="line"><span class="comment">          一直向下找右节点直到到达最后一层，在倒数第二层会出现</span></span><br><span class="line"><span class="comment">          1） 该层不存在右孩子</span></span><br><span class="line"><span class="comment">          2） 该层存在右孩子</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      minHeap[index] = minHeap[--size];</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>,r = l + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 权值大的节点向下沉</span></span><br><span class="line">      <span class="keyword">while</span>(l &lt; size &amp;&amp; r &lt; size) &#123;</span><br><span class="line">          <span class="keyword">if</span>(minHeap[l] &lt; minHeap[index]) &#123;</span><br><span class="line">              minHeap[index] = minHeap[l];</span><br><span class="line">              index = l;</span><br><span class="line">              l = (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;r = l + <span class="number">1</span>; </span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minHeap[r] &lt; minHeap[index]) &#123;</span><br><span class="line">              minHeap[index] = minHeap[r];</span><br><span class="line">              index = r;</span><br><span class="line">              l = (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;r = l + <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 如果当前节点小于左右子节点，则完成</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(l &lt; size &amp;&amp; minHeap[l] &lt; minHeap[index]) &#123;</span><br><span class="line">          minHeap[index] = minHeap[l];</span><br><span class="line">          minHeap[l] = -<span class="number">1</span>;</span><br><span class="line">      &#125; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://www.cnblogs.com/CarpenterLee/p/5488070.html" >http://www.cnblogs.com/CarpenterLee/p/5488070.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/collection/java-collection-PriorityQueue.html" >https://pdai.tech/md/java/collection/java-collection-PriorityQueue.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/09/28/Docker/Docker(7)-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/">Docker(7)--资源管理</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-28</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="容器控制操作"   >
          <a href="#容器控制操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#容器控制操作" class="headerlink" title="容器控制操作"></a>容器控制操作</h1>
      <blockquote>
<p>补充一些Docker的命令，对于这种单纯的命令查看，建议直接看菜鸟教程。</p>
</blockquote>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器，退出：ctrl+P，ctrl+Q；终止容器运行的程序：ctrl+C</span></span><br><span class="line">docker attach 容器ID/名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行命令，这里执行的是bash，并开启一个可输入终端</span></span><br><span class="line">docker exec -it 容器ID/名称 bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">（假设容器可以执行java），就相当于让容器执行java -version</span></span><br><span class="line">docker exec 容器ID/名称 java -version</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许容器处理善后再停止运行</span></span><br><span class="line">docker kill 容器ID/名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接强制停止容器</span></span><br><span class="line">docker stop 容器ID/名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动容器（一般是容器被stop之后）</span></span><br><span class="line">docker start 容器ID/名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启容器</span></span><br><span class="line">docker restart 容器ID/名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">暂停容器(unpause--取消暂停)</span></span><br><span class="line">docker pause 容器ID/名称</span><br></pre></td></tr></table></div></figure>




        <h1 id="物理资源管理"   >
          <a href="#物理资源管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#物理资源管理" class="headerlink" title="物理资源管理"></a>物理资源管理</h1>
      <ul>
<li>内存分配：</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -m 50M --memory-swap=100M nagocoler/springboot-test:1.0</span><br></pre></td></tr></table></div></figure>

<p><code>-m</code>对容器的物理内存的限制，<code>--memory-swap</code>对内存和交换分区总和的限制。默认都是-1，即没有任何限制。如果仅指定<code>-m</code>，那么交换内存的限制也为<code>-m</code>指定的参数。</p>
<ul>
<li>CPU进行限额：</li>
</ul>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line">docker run -c 1024 ubuntu</span><br><span class="line">docker run -c 512 ubuntu</span><br></pre></td></tr></table></div></figure>

<p>对CPU的分配只有多容器才生效，默认是1024，如果CPU不紧张，依然可以使用全部CPU资源。</p>
<blockquote>
<p>通过Ubuntu命令：<code>sudo apt install stress</code>在容器中下载压力测试工具来看一下进程分配权重对进程获得CPU资源的影响。</p>
</blockquote>
<p>还可以限制容器使用CPU：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --cpuset-cpus=1 ubuntu</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>选项后面的值不是CPU的数量，而是CPU的“编号”，即这个容器只用1这个CPU，所以指定两个CPU时也可以这样：<code>docker run -it --cpuset-cpus=0,1 ubuntu</code>。</p>
</blockquote>
<p>命令<code>--cpus</code>来限制使用CPU资源数（个数）：<code>docker run -it --cpus=1 ubuntu</code>。</p>

        <h1 id="容器监控"   >
          <a href="#容器监控" class="heading-link"><i class="fas fa-link"></i></a><a href="#容器监控" class="headerlink" title="容器监控"></a>容器监控</h1>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats</span><br></pre></td></tr></table></div></figure>

<p>可以实时对容器的各项状态进行监控，包括内存使用、CPU占用、网络I&#x2F;O、磁盘I&#x2F;O等信息。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/28/2e4f267ce01df490.jpg"></p>
<p><code>top</code>命令可以查看容器进程：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器ID/名称</span><br></pre></td></tr></table></div></figure>

<p>对于容器监管，也有页面版本的，官方<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://docs.portainer.io/start/install/server/docker/linux" >下载教程</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，此处不过多讲解。</p>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.yuque.com/qingkongxiaguang/zwhkpi/kq6rlg" >https://www.yuque.com/qingkongxiaguang/zwhkpi/kq6rlg</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-start-stop-restart-command.html" >https://www.runoob.com/docker/docker-start-stop-restart-command.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/3/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/logo.png" alt="avatar"></div><p class="sidebar-ov-author__text">You have lots more to work on</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">82</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">2</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">14</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh_tw" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Cyan</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.2.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.7.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.7.0"></script><script src="/js/stun-boot.js?v=2.7.0"></script><script src="/js/scroll.js?v=2.7.0"></script><script src="/js/header.js?v=2.7.0"></script><script src="/js/sidebar.js?v=2.7.0"></script></body></html>